// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ImagePolicy is the Schema for the imagepolicies API
 *
 * @schema ImagePolicy
 */
export class ImagePolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ImagePolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'image.toolkit.fluxcd.io/v1',
    kind: 'ImagePolicy',
  }

  /**
   * Renders a Kubernetes manifest for "ImagePolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ImagePolicyProps = {}): any {
    return {
      ...ImagePolicy.GVK,
      ...toJson_ImagePolicyProps(props),
    };
  }

  /**
   * Defines a "ImagePolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ImagePolicyProps = {}) {
    super(scope, id, {
      ...ImagePolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ImagePolicy.GVK,
      ...toJson_ImagePolicyProps(resolved),
    };
  }
}

/**
 * ImagePolicy is the Schema for the imagepolicies API
 *
 * @schema ImagePolicy
 */
export interface ImagePolicyProps {
  /**
   * @schema ImagePolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ImagePolicySpec defines the parameters for calculating the
   * ImagePolicy.
   *
   * @schema ImagePolicy#spec
   */
  readonly spec?: ImagePolicySpec;
}

/**
 * Converts an object of type 'ImagePolicyProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImagePolicyProps(obj: ImagePolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ImagePolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ImagePolicySpec defines the parameters for calculating the
 * ImagePolicy.
 *
 * @schema ImagePolicySpec
 */
export interface ImagePolicySpec {
  /**
   * DigestReflectionPolicy governs the setting of the `.status.latestRef.digest` field.
   *
   * Never: The digest field will always be set to the empty string.
   *
   * IfNotPresent: The digest field will be set to the digest of the elected
   * latest image if the field is empty and the image did not change.
   *
   * Always: The digest field will always be set to the digest of the elected
   * latest image.
   *
   * Default: Never.
   *
   * @schema ImagePolicySpec#digestReflectionPolicy
   */
  readonly digestReflectionPolicy?: ImagePolicySpecDigestReflectionPolicy;

  /**
   * FilterTags enables filtering for only a subset of tags based on a set of
   * rules. If no rules are provided, all the tags from the repository will be
   * ordered and compared.
   *
   * @schema ImagePolicySpec#filterTags
   */
  readonly filterTags?: ImagePolicySpecFilterTags;

  /**
   * ImageRepositoryRef points at the object specifying the image
   * being scanned
   *
   * @schema ImagePolicySpec#imageRepositoryRef
   */
  readonly imageRepositoryRef: ImagePolicySpecImageRepositoryRef;

  /**
   * Interval is the length of time to wait between
   * refreshing the digest of the latest tag when the
   * reflection policy is set to "Always".
   *
   * Defaults to 10m.
   *
   * @default 10m.
   * @schema ImagePolicySpec#interval
   */
  readonly interval?: string;

  /**
   * Policy gives the particulars of the policy to be followed in
   * selecting the most recent image
   *
   * @schema ImagePolicySpec#policy
   */
  readonly policy: ImagePolicySpecPolicy;

  /**
   * This flag tells the controller to suspend subsequent policy reconciliations.
   * It does not apply to already started reconciliations. Defaults to false.
   *
   * @default false.
   * @schema ImagePolicySpec#suspend
   */
  readonly suspend?: boolean;
}

/**
 * Converts an object of type 'ImagePolicySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImagePolicySpec(obj: ImagePolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'digestReflectionPolicy': obj.digestReflectionPolicy,
    'filterTags': toJson_ImagePolicySpecFilterTags(obj.filterTags),
    'imageRepositoryRef': toJson_ImagePolicySpecImageRepositoryRef(obj.imageRepositoryRef),
    'interval': obj.interval,
    'policy': toJson_ImagePolicySpecPolicy(obj.policy),
    'suspend': obj.suspend,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DigestReflectionPolicy governs the setting of the `.status.latestRef.digest` field.
 *
 * Never: The digest field will always be set to the empty string.
 *
 * IfNotPresent: The digest field will be set to the digest of the elected
 * latest image if the field is empty and the image did not change.
 *
 * Always: The digest field will always be set to the digest of the elected
 * latest image.
 *
 * Default: Never.
 *
 * @schema ImagePolicySpecDigestReflectionPolicy
 */
export enum ImagePolicySpecDigestReflectionPolicy {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
  /** Never */
  NEVER = "Never",
}

/**
 * FilterTags enables filtering for only a subset of tags based on a set of
 * rules. If no rules are provided, all the tags from the repository will be
 * ordered and compared.
 *
 * @schema ImagePolicySpecFilterTags
 */
export interface ImagePolicySpecFilterTags {
  /**
   * Extract allows a capture group to be extracted from the specified regular
   * expression pattern, useful before tag evaluation.
   *
   * @schema ImagePolicySpecFilterTags#extract
   */
  readonly extract?: string;

  /**
   * Pattern specifies a regular expression pattern used to filter for image
   * tags.
   *
   * @schema ImagePolicySpecFilterTags#pattern
   */
  readonly pattern?: string;
}

/**
 * Converts an object of type 'ImagePolicySpecFilterTags' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImagePolicySpecFilterTags(obj: ImagePolicySpecFilterTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extract': obj.extract,
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ImageRepositoryRef points at the object specifying the image
 * being scanned
 *
 * @schema ImagePolicySpecImageRepositoryRef
 */
export interface ImagePolicySpecImageRepositoryRef {
  /**
   * Name of the referent.
   *
   * @schema ImagePolicySpecImageRepositoryRef#name
   */
  readonly name: string;

  /**
   * Namespace of the referent, when not specified it acts as LocalObjectReference.
   *
   * @schema ImagePolicySpecImageRepositoryRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ImagePolicySpecImageRepositoryRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImagePolicySpecImageRepositoryRef(obj: ImagePolicySpecImageRepositoryRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policy gives the particulars of the policy to be followed in
 * selecting the most recent image
 *
 * @schema ImagePolicySpecPolicy
 */
export interface ImagePolicySpecPolicy {
  /**
   * Alphabetical set of rules to use for alphabetical ordering of the tags.
   *
   * @schema ImagePolicySpecPolicy#alphabetical
   */
  readonly alphabetical?: ImagePolicySpecPolicyAlphabetical;

  /**
   * Numerical set of rules to use for numerical ordering of the tags.
   *
   * @schema ImagePolicySpecPolicy#numerical
   */
  readonly numerical?: ImagePolicySpecPolicyNumerical;

  /**
   * SemVer gives a semantic version range to check against the tags
   * available.
   *
   * @schema ImagePolicySpecPolicy#semver
   */
  readonly semver?: ImagePolicySpecPolicySemver;
}

/**
 * Converts an object of type 'ImagePolicySpecPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImagePolicySpecPolicy(obj: ImagePolicySpecPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alphabetical': toJson_ImagePolicySpecPolicyAlphabetical(obj.alphabetical),
    'numerical': toJson_ImagePolicySpecPolicyNumerical(obj.numerical),
    'semver': toJson_ImagePolicySpecPolicySemver(obj.semver),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Alphabetical set of rules to use for alphabetical ordering of the tags.
 *
 * @schema ImagePolicySpecPolicyAlphabetical
 */
export interface ImagePolicySpecPolicyAlphabetical {
  /**
   * Order specifies the sorting order of the tags. Given the letters of the
   * alphabet as tags, ascending order would select Z, and descending order
   * would select A.
   *
   * @schema ImagePolicySpecPolicyAlphabetical#order
   */
  readonly order?: ImagePolicySpecPolicyAlphabeticalOrder;
}

/**
 * Converts an object of type 'ImagePolicySpecPolicyAlphabetical' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImagePolicySpecPolicyAlphabetical(obj: ImagePolicySpecPolicyAlphabetical | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'order': obj.order,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Numerical set of rules to use for numerical ordering of the tags.
 *
 * @schema ImagePolicySpecPolicyNumerical
 */
export interface ImagePolicySpecPolicyNumerical {
  /**
   * Order specifies the sorting order of the tags. Given the integer values
   * from 0 to 9 as tags, ascending order would select 9, and descending order
   * would select 0.
   *
   * @schema ImagePolicySpecPolicyNumerical#order
   */
  readonly order?: ImagePolicySpecPolicyNumericalOrder;
}

/**
 * Converts an object of type 'ImagePolicySpecPolicyNumerical' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImagePolicySpecPolicyNumerical(obj: ImagePolicySpecPolicyNumerical | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'order': obj.order,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SemVer gives a semantic version range to check against the tags
 * available.
 *
 * @schema ImagePolicySpecPolicySemver
 */
export interface ImagePolicySpecPolicySemver {
  /**
   * Range gives a semver range for the image tag; the highest
   * version within the range that's a tag yields the latest image.
   *
   * @schema ImagePolicySpecPolicySemver#range
   */
  readonly range: string;
}

/**
 * Converts an object of type 'ImagePolicySpecPolicySemver' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImagePolicySpecPolicySemver(obj: ImagePolicySpecPolicySemver | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'range': obj.range,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Order specifies the sorting order of the tags. Given the letters of the
 * alphabet as tags, ascending order would select Z, and descending order
 * would select A.
 *
 * @schema ImagePolicySpecPolicyAlphabeticalOrder
 */
export enum ImagePolicySpecPolicyAlphabeticalOrder {
  /** asc */
  ASC = "asc",
  /** desc */
  DESC = "desc",
}

/**
 * Order specifies the sorting order of the tags. Given the integer values
 * from 0 to 9 as tags, ascending order would select 9, and descending order
 * would select 0.
 *
 * @schema ImagePolicySpecPolicyNumericalOrder
 */
export enum ImagePolicySpecPolicyNumericalOrder {
  /** asc */
  ASC = "asc",
  /** desc */
  DESC = "desc",
}


/**
 * ImagePolicy is the Schema for the imagepolicies API
 *
 * @schema ImagePolicyV1Beta2
 */
export class ImagePolicyV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ImagePolicyV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'image.toolkit.fluxcd.io/v1beta2',
    kind: 'ImagePolicy',
  }

  /**
   * Renders a Kubernetes manifest for "ImagePolicyV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ImagePolicyV1Beta2Props = {}): any {
    return {
      ...ImagePolicyV1Beta2.GVK,
      ...toJson_ImagePolicyV1Beta2Props(props),
    };
  }

  /**
   * Defines a "ImagePolicyV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ImagePolicyV1Beta2Props = {}) {
    super(scope, id, {
      ...ImagePolicyV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ImagePolicyV1Beta2.GVK,
      ...toJson_ImagePolicyV1Beta2Props(resolved),
    };
  }
}

/**
 * ImagePolicy is the Schema for the imagepolicies API
 *
 * @schema ImagePolicyV1Beta2
 */
export interface ImagePolicyV1Beta2Props {
  /**
   * @schema ImagePolicyV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ImagePolicySpec defines the parameters for calculating the
   * ImagePolicy.
   *
   * @schema ImagePolicyV1Beta2#spec
   */
  readonly spec?: ImagePolicyV1Beta2Spec;
}

/**
 * Converts an object of type 'ImagePolicyV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImagePolicyV1Beta2Props(obj: ImagePolicyV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ImagePolicyV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ImagePolicySpec defines the parameters for calculating the
 * ImagePolicy.
 *
 * @schema ImagePolicyV1Beta2Spec
 */
export interface ImagePolicyV1Beta2Spec {
  /**
   * DigestReflectionPolicy governs the setting of the `.status.latestRef.digest` field.
   *
   * Never: The digest field will always be set to the empty string.
   *
   * IfNotPresent: The digest field will be set to the digest of the elected
   * latest image if the field is empty and the image did not change.
   *
   * Always: The digest field will always be set to the digest of the elected
   * latest image.
   *
   * Default: Never.
   *
   * @schema ImagePolicyV1Beta2Spec#digestReflectionPolicy
   */
  readonly digestReflectionPolicy?: ImagePolicyV1Beta2SpecDigestReflectionPolicy;

  /**
   * FilterTags enables filtering for only a subset of tags based on a set of
   * rules. If no rules are provided, all the tags from the repository will be
   * ordered and compared.
   *
   * @schema ImagePolicyV1Beta2Spec#filterTags
   */
  readonly filterTags?: ImagePolicyV1Beta2SpecFilterTags;

  /**
   * ImageRepositoryRef points at the object specifying the image
   * being scanned
   *
   * @schema ImagePolicyV1Beta2Spec#imageRepositoryRef
   */
  readonly imageRepositoryRef: ImagePolicyV1Beta2SpecImageRepositoryRef;

  /**
   * Interval is the length of time to wait between
   * refreshing the digest of the latest tag when the
   * reflection policy is set to "Always".
   *
   * Defaults to 10m.
   *
   * @default 10m.
   * @schema ImagePolicyV1Beta2Spec#interval
   */
  readonly interval?: string;

  /**
   * Policy gives the particulars of the policy to be followed in
   * selecting the most recent image
   *
   * @schema ImagePolicyV1Beta2Spec#policy
   */
  readonly policy: ImagePolicyV1Beta2SpecPolicy;

  /**
   * This flag tells the controller to suspend subsequent policy reconciliations.
   * It does not apply to already started reconciliations. Defaults to false.
   *
   * @default false.
   * @schema ImagePolicyV1Beta2Spec#suspend
   */
  readonly suspend?: boolean;
}

/**
 * Converts an object of type 'ImagePolicyV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImagePolicyV1Beta2Spec(obj: ImagePolicyV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'digestReflectionPolicy': obj.digestReflectionPolicy,
    'filterTags': toJson_ImagePolicyV1Beta2SpecFilterTags(obj.filterTags),
    'imageRepositoryRef': toJson_ImagePolicyV1Beta2SpecImageRepositoryRef(obj.imageRepositoryRef),
    'interval': obj.interval,
    'policy': toJson_ImagePolicyV1Beta2SpecPolicy(obj.policy),
    'suspend': obj.suspend,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DigestReflectionPolicy governs the setting of the `.status.latestRef.digest` field.
 *
 * Never: The digest field will always be set to the empty string.
 *
 * IfNotPresent: The digest field will be set to the digest of the elected
 * latest image if the field is empty and the image did not change.
 *
 * Always: The digest field will always be set to the digest of the elected
 * latest image.
 *
 * Default: Never.
 *
 * @schema ImagePolicyV1Beta2SpecDigestReflectionPolicy
 */
export enum ImagePolicyV1Beta2SpecDigestReflectionPolicy {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
  /** Never */
  NEVER = "Never",
}

/**
 * FilterTags enables filtering for only a subset of tags based on a set of
 * rules. If no rules are provided, all the tags from the repository will be
 * ordered and compared.
 *
 * @schema ImagePolicyV1Beta2SpecFilterTags
 */
export interface ImagePolicyV1Beta2SpecFilterTags {
  /**
   * Extract allows a capture group to be extracted from the specified regular
   * expression pattern, useful before tag evaluation.
   *
   * @schema ImagePolicyV1Beta2SpecFilterTags#extract
   */
  readonly extract?: string;

  /**
   * Pattern specifies a regular expression pattern used to filter for image
   * tags.
   *
   * @schema ImagePolicyV1Beta2SpecFilterTags#pattern
   */
  readonly pattern?: string;
}

/**
 * Converts an object of type 'ImagePolicyV1Beta2SpecFilterTags' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImagePolicyV1Beta2SpecFilterTags(obj: ImagePolicyV1Beta2SpecFilterTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extract': obj.extract,
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ImageRepositoryRef points at the object specifying the image
 * being scanned
 *
 * @schema ImagePolicyV1Beta2SpecImageRepositoryRef
 */
export interface ImagePolicyV1Beta2SpecImageRepositoryRef {
  /**
   * Name of the referent.
   *
   * @schema ImagePolicyV1Beta2SpecImageRepositoryRef#name
   */
  readonly name: string;

  /**
   * Namespace of the referent, when not specified it acts as LocalObjectReference.
   *
   * @schema ImagePolicyV1Beta2SpecImageRepositoryRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ImagePolicyV1Beta2SpecImageRepositoryRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImagePolicyV1Beta2SpecImageRepositoryRef(obj: ImagePolicyV1Beta2SpecImageRepositoryRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Policy gives the particulars of the policy to be followed in
 * selecting the most recent image
 *
 * @schema ImagePolicyV1Beta2SpecPolicy
 */
export interface ImagePolicyV1Beta2SpecPolicy {
  /**
   * Alphabetical set of rules to use for alphabetical ordering of the tags.
   *
   * @schema ImagePolicyV1Beta2SpecPolicy#alphabetical
   */
  readonly alphabetical?: ImagePolicyV1Beta2SpecPolicyAlphabetical;

  /**
   * Numerical set of rules to use for numerical ordering of the tags.
   *
   * @schema ImagePolicyV1Beta2SpecPolicy#numerical
   */
  readonly numerical?: ImagePolicyV1Beta2SpecPolicyNumerical;

  /**
   * SemVer gives a semantic version range to check against the tags
   * available.
   *
   * @schema ImagePolicyV1Beta2SpecPolicy#semver
   */
  readonly semver?: ImagePolicyV1Beta2SpecPolicySemver;
}

/**
 * Converts an object of type 'ImagePolicyV1Beta2SpecPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImagePolicyV1Beta2SpecPolicy(obj: ImagePolicyV1Beta2SpecPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alphabetical': toJson_ImagePolicyV1Beta2SpecPolicyAlphabetical(obj.alphabetical),
    'numerical': toJson_ImagePolicyV1Beta2SpecPolicyNumerical(obj.numerical),
    'semver': toJson_ImagePolicyV1Beta2SpecPolicySemver(obj.semver),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Alphabetical set of rules to use for alphabetical ordering of the tags.
 *
 * @schema ImagePolicyV1Beta2SpecPolicyAlphabetical
 */
export interface ImagePolicyV1Beta2SpecPolicyAlphabetical {
  /**
   * Order specifies the sorting order of the tags. Given the letters of the
   * alphabet as tags, ascending order would select Z, and descending order
   * would select A.
   *
   * @schema ImagePolicyV1Beta2SpecPolicyAlphabetical#order
   */
  readonly order?: ImagePolicyV1Beta2SpecPolicyAlphabeticalOrder;
}

/**
 * Converts an object of type 'ImagePolicyV1Beta2SpecPolicyAlphabetical' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImagePolicyV1Beta2SpecPolicyAlphabetical(obj: ImagePolicyV1Beta2SpecPolicyAlphabetical | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'order': obj.order,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Numerical set of rules to use for numerical ordering of the tags.
 *
 * @schema ImagePolicyV1Beta2SpecPolicyNumerical
 */
export interface ImagePolicyV1Beta2SpecPolicyNumerical {
  /**
   * Order specifies the sorting order of the tags. Given the integer values
   * from 0 to 9 as tags, ascending order would select 9, and descending order
   * would select 0.
   *
   * @schema ImagePolicyV1Beta2SpecPolicyNumerical#order
   */
  readonly order?: ImagePolicyV1Beta2SpecPolicyNumericalOrder;
}

/**
 * Converts an object of type 'ImagePolicyV1Beta2SpecPolicyNumerical' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImagePolicyV1Beta2SpecPolicyNumerical(obj: ImagePolicyV1Beta2SpecPolicyNumerical | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'order': obj.order,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SemVer gives a semantic version range to check against the tags
 * available.
 *
 * @schema ImagePolicyV1Beta2SpecPolicySemver
 */
export interface ImagePolicyV1Beta2SpecPolicySemver {
  /**
   * Range gives a semver range for the image tag; the highest
   * version within the range that's a tag yields the latest image.
   *
   * @schema ImagePolicyV1Beta2SpecPolicySemver#range
   */
  readonly range: string;
}

/**
 * Converts an object of type 'ImagePolicyV1Beta2SpecPolicySemver' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImagePolicyV1Beta2SpecPolicySemver(obj: ImagePolicyV1Beta2SpecPolicySemver | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'range': obj.range,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Order specifies the sorting order of the tags. Given the letters of the
 * alphabet as tags, ascending order would select Z, and descending order
 * would select A.
 *
 * @schema ImagePolicyV1Beta2SpecPolicyAlphabeticalOrder
 */
export enum ImagePolicyV1Beta2SpecPolicyAlphabeticalOrder {
  /** asc */
  ASC = "asc",
  /** desc */
  DESC = "desc",
}

/**
 * Order specifies the sorting order of the tags. Given the integer values
 * from 0 to 9 as tags, ascending order would select 9, and descending order
 * would select 0.
 *
 * @schema ImagePolicyV1Beta2SpecPolicyNumericalOrder
 */
export enum ImagePolicyV1Beta2SpecPolicyNumericalOrder {
  /** asc */
  ASC = "asc",
  /** desc */
  DESC = "desc",
}


/**
 * ImageRepository is the Schema for the imagerepositories API
 *
 * @schema ImageRepository
 */
export class ImageRepository extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ImageRepository"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'image.toolkit.fluxcd.io/v1',
    kind: 'ImageRepository',
  }

  /**
   * Renders a Kubernetes manifest for "ImageRepository".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ImageRepositoryProps = {}): any {
    return {
      ...ImageRepository.GVK,
      ...toJson_ImageRepositoryProps(props),
    };
  }

  /**
   * Defines a "ImageRepository" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ImageRepositoryProps = {}) {
    super(scope, id, {
      ...ImageRepository.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ImageRepository.GVK,
      ...toJson_ImageRepositoryProps(resolved),
    };
  }
}

/**
 * ImageRepository is the Schema for the imagerepositories API
 *
 * @schema ImageRepository
 */
export interface ImageRepositoryProps {
  /**
   * @schema ImageRepository#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ImageRepositorySpec defines the parameters for scanning an image
   * repository, e.g., `fluxcd/flux`.
   *
   * @schema ImageRepository#spec
   */
  readonly spec?: ImageRepositorySpec;
}

/**
 * Converts an object of type 'ImageRepositoryProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageRepositoryProps(obj: ImageRepositoryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ImageRepositorySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ImageRepositorySpec defines the parameters for scanning an image
 * repository, e.g., `fluxcd/flux`.
 *
 * @schema ImageRepositorySpec
 */
export interface ImageRepositorySpec {
  /**
   * AccessFrom defines an ACL for allowing cross-namespace references
   * to the ImageRepository object based on the caller's namespace labels.
   *
   * @schema ImageRepositorySpec#accessFrom
   */
  readonly accessFrom?: ImageRepositorySpecAccessFrom;

  /**
   * CertSecretRef can be given the name of a Secret containing
   * either or both of
   *
   * - a PEM-encoded client certificate (`tls.crt`) and private
   * key (`tls.key`);
   * - a PEM-encoded CA certificate (`ca.crt`)
   *
   * and whichever are supplied, will be used for connecting to the
   * registry. The client cert and key are useful if you are
   * authenticating with a certificate; the CA cert is useful if
   * you are using a self-signed server certificate. The Secret must
   * be of type `Opaque` or `kubernetes.io/tls`.
   *
   * Note: Support for the `caFile`, `certFile` and `keyFile` keys has
   * been deprecated.
   *
   * @schema ImageRepositorySpec#certSecretRef
   */
  readonly certSecretRef?: ImageRepositorySpecCertSecretRef;

  /**
   * ExclusionList is a list of regex strings used to exclude certain tags
   * from being stored in the database.
   *
   * @schema ImageRepositorySpec#exclusionList
   */
  readonly exclusionList?: string[];

  /**
   * Image is the name of the image repository
   *
   * @schema ImageRepositorySpec#image
   */
  readonly image: string;

  /**
   * Insecure allows connecting to a non-TLS HTTP container registry.
   *
   * @schema ImageRepositorySpec#insecure
   */
  readonly insecure?: boolean;

  /**
   * Interval is the length of time to wait between
   * scans of the image repository.
   *
   * @schema ImageRepositorySpec#interval
   */
  readonly interval: string;

  /**
   * The provider used for authentication, can be 'aws', 'azure', 'gcp' or 'generic'.
   * When not specified, defaults to 'generic'.
   *
   * @schema ImageRepositorySpec#provider
   */
  readonly provider?: ImageRepositorySpecProvider;

  /**
   * ProxySecretRef specifies the Secret containing the proxy configuration
   * to use while communicating with the container registry.
   *
   * @schema ImageRepositorySpec#proxySecretRef
   */
  readonly proxySecretRef?: ImageRepositorySpecProxySecretRef;

  /**
   * SecretRef can be given the name of a secret containing
   * credentials to use for the image registry. The secret should be
   * created with `kubectl create secret docker-registry`, or the
   * equivalent.
   *
   * @schema ImageRepositorySpec#secretRef
   */
  readonly secretRef?: ImageRepositorySpecSecretRef;

  /**
   * ServiceAccountName is the name of the Kubernetes ServiceAccount used to authenticate
   * the image pull if the service account has attached pull secrets.
   *
   * @schema ImageRepositorySpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * This flag tells the controller to suspend subsequent image scans.
   * It does not apply to already started scans. Defaults to false.
   *
   * @default false.
   * @schema ImageRepositorySpec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Timeout for image scanning.
   * Defaults to 'Interval' duration.
   *
   * @default Interval' duration.
   * @schema ImageRepositorySpec#timeout
   */
  readonly timeout?: string;
}

/**
 * Converts an object of type 'ImageRepositorySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageRepositorySpec(obj: ImageRepositorySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessFrom': toJson_ImageRepositorySpecAccessFrom(obj.accessFrom),
    'certSecretRef': toJson_ImageRepositorySpecCertSecretRef(obj.certSecretRef),
    'exclusionList': obj.exclusionList?.map(y => y),
    'image': obj.image,
    'insecure': obj.insecure,
    'interval': obj.interval,
    'provider': obj.provider,
    'proxySecretRef': toJson_ImageRepositorySpecProxySecretRef(obj.proxySecretRef),
    'secretRef': toJson_ImageRepositorySpecSecretRef(obj.secretRef),
    'serviceAccountName': obj.serviceAccountName,
    'suspend': obj.suspend,
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessFrom defines an ACL for allowing cross-namespace references
 * to the ImageRepository object based on the caller's namespace labels.
 *
 * @schema ImageRepositorySpecAccessFrom
 */
export interface ImageRepositorySpecAccessFrom {
  /**
   * NamespaceSelectors is the list of namespace selectors to which this ACL applies.
   * Items in this list are evaluated using a logical OR operation.
   *
   * @schema ImageRepositorySpecAccessFrom#namespaceSelectors
   */
  readonly namespaceSelectors: ImageRepositorySpecAccessFromNamespaceSelectors[];
}

/**
 * Converts an object of type 'ImageRepositorySpecAccessFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageRepositorySpecAccessFrom(obj: ImageRepositorySpecAccessFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_ImageRepositorySpecAccessFromNamespaceSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CertSecretRef can be given the name of a Secret containing
 * either or both of
 *
 * - a PEM-encoded client certificate (`tls.crt`) and private
 * key (`tls.key`);
 * - a PEM-encoded CA certificate (`ca.crt`)
 *
 * and whichever are supplied, will be used for connecting to the
 * registry. The client cert and key are useful if you are
 * authenticating with a certificate; the CA cert is useful if
 * you are using a self-signed server certificate. The Secret must
 * be of type `Opaque` or `kubernetes.io/tls`.
 *
 * Note: Support for the `caFile`, `certFile` and `keyFile` keys has
 * been deprecated.
 *
 * @schema ImageRepositorySpecCertSecretRef
 */
export interface ImageRepositorySpecCertSecretRef {
  /**
   * Name of the referent.
   *
   * @schema ImageRepositorySpecCertSecretRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ImageRepositorySpecCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageRepositorySpecCertSecretRef(obj: ImageRepositorySpecCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider used for authentication, can be 'aws', 'azure', 'gcp' or 'generic'.
 * When not specified, defaults to 'generic'.
 *
 * @schema ImageRepositorySpecProvider
 */
export enum ImageRepositorySpecProvider {
  /** generic */
  GENERIC = "generic",
  /** aws */
  AWS = "aws",
  /** azure */
  AZURE = "azure",
  /** gcp */
  GCP = "gcp",
}

/**
 * ProxySecretRef specifies the Secret containing the proxy configuration
 * to use while communicating with the container registry.
 *
 * @schema ImageRepositorySpecProxySecretRef
 */
export interface ImageRepositorySpecProxySecretRef {
  /**
   * Name of the referent.
   *
   * @schema ImageRepositorySpecProxySecretRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ImageRepositorySpecProxySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageRepositorySpecProxySecretRef(obj: ImageRepositorySpecProxySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef can be given the name of a secret containing
 * credentials to use for the image registry. The secret should be
 * created with `kubectl create secret docker-registry`, or the
 * equivalent.
 *
 * @schema ImageRepositorySpecSecretRef
 */
export interface ImageRepositorySpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema ImageRepositorySpecSecretRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ImageRepositorySpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageRepositorySpecSecretRef(obj: ImageRepositorySpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NamespaceSelector selects the namespaces to which this ACL applies.
 * An empty map of MatchLabels matches all namespaces in a cluster.
 *
 * @schema ImageRepositorySpecAccessFromNamespaceSelectors
 */
export interface ImageRepositorySpecAccessFromNamespaceSelectors {
  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ImageRepositorySpecAccessFromNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ImageRepositorySpecAccessFromNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageRepositorySpecAccessFromNamespaceSelectors(obj: ImageRepositorySpecAccessFromNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * ImageRepository is the Schema for the imagerepositories API
 *
 * @schema ImageRepositoryV1Beta2
 */
export class ImageRepositoryV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ImageRepositoryV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'image.toolkit.fluxcd.io/v1beta2',
    kind: 'ImageRepository',
  }

  /**
   * Renders a Kubernetes manifest for "ImageRepositoryV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ImageRepositoryV1Beta2Props = {}): any {
    return {
      ...ImageRepositoryV1Beta2.GVK,
      ...toJson_ImageRepositoryV1Beta2Props(props),
    };
  }

  /**
   * Defines a "ImageRepositoryV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ImageRepositoryV1Beta2Props = {}) {
    super(scope, id, {
      ...ImageRepositoryV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ImageRepositoryV1Beta2.GVK,
      ...toJson_ImageRepositoryV1Beta2Props(resolved),
    };
  }
}

/**
 * ImageRepository is the Schema for the imagerepositories API
 *
 * @schema ImageRepositoryV1Beta2
 */
export interface ImageRepositoryV1Beta2Props {
  /**
   * @schema ImageRepositoryV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ImageRepositorySpec defines the parameters for scanning an image
   * repository, e.g., `fluxcd/flux`.
   *
   * @schema ImageRepositoryV1Beta2#spec
   */
  readonly spec?: ImageRepositoryV1Beta2Spec;
}

/**
 * Converts an object of type 'ImageRepositoryV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageRepositoryV1Beta2Props(obj: ImageRepositoryV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ImageRepositoryV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ImageRepositorySpec defines the parameters for scanning an image
 * repository, e.g., `fluxcd/flux`.
 *
 * @schema ImageRepositoryV1Beta2Spec
 */
export interface ImageRepositoryV1Beta2Spec {
  /**
   * AccessFrom defines an ACL for allowing cross-namespace references
   * to the ImageRepository object based on the caller's namespace labels.
   *
   * @schema ImageRepositoryV1Beta2Spec#accessFrom
   */
  readonly accessFrom?: ImageRepositoryV1Beta2SpecAccessFrom;

  /**
   * CertSecretRef can be given the name of a Secret containing
   * either or both of
   *
   * - a PEM-encoded client certificate (`tls.crt`) and private
   * key (`tls.key`);
   * - a PEM-encoded CA certificate (`ca.crt`)
   *
   * and whichever are supplied, will be used for connecting to the
   * registry. The client cert and key are useful if you are
   * authenticating with a certificate; the CA cert is useful if
   * you are using a self-signed server certificate. The Secret must
   * be of type `Opaque` or `kubernetes.io/tls`.
   *
   * Note: Support for the `caFile`, `certFile` and `keyFile` keys has
   * been deprecated.
   *
   * @schema ImageRepositoryV1Beta2Spec#certSecretRef
   */
  readonly certSecretRef?: ImageRepositoryV1Beta2SpecCertSecretRef;

  /**
   * ExclusionList is a list of regex strings used to exclude certain tags
   * from being stored in the database.
   *
   * @schema ImageRepositoryV1Beta2Spec#exclusionList
   */
  readonly exclusionList?: string[];

  /**
   * Image is the name of the image repository
   *
   * @schema ImageRepositoryV1Beta2Spec#image
   */
  readonly image: string;

  /**
   * Insecure allows connecting to a non-TLS HTTP container registry.
   *
   * @schema ImageRepositoryV1Beta2Spec#insecure
   */
  readonly insecure?: boolean;

  /**
   * Interval is the length of time to wait between
   * scans of the image repository.
   *
   * @schema ImageRepositoryV1Beta2Spec#interval
   */
  readonly interval: string;

  /**
   * The provider used for authentication, can be 'aws', 'azure', 'gcp' or 'generic'.
   * When not specified, defaults to 'generic'.
   *
   * @schema ImageRepositoryV1Beta2Spec#provider
   */
  readonly provider?: ImageRepositoryV1Beta2SpecProvider;

  /**
   * ProxySecretRef specifies the Secret containing the proxy configuration
   * to use while communicating with the container registry.
   *
   * @schema ImageRepositoryV1Beta2Spec#proxySecretRef
   */
  readonly proxySecretRef?: ImageRepositoryV1Beta2SpecProxySecretRef;

  /**
   * SecretRef can be given the name of a secret containing
   * credentials to use for the image registry. The secret should be
   * created with `kubectl create secret docker-registry`, or the
   * equivalent.
   *
   * @schema ImageRepositoryV1Beta2Spec#secretRef
   */
  readonly secretRef?: ImageRepositoryV1Beta2SpecSecretRef;

  /**
   * ServiceAccountName is the name of the Kubernetes ServiceAccount used to authenticate
   * the image pull if the service account has attached pull secrets.
   *
   * @schema ImageRepositoryV1Beta2Spec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * This flag tells the controller to suspend subsequent image scans.
   * It does not apply to already started scans. Defaults to false.
   *
   * @default false.
   * @schema ImageRepositoryV1Beta2Spec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Timeout for image scanning.
   * Defaults to 'Interval' duration.
   *
   * @default Interval' duration.
   * @schema ImageRepositoryV1Beta2Spec#timeout
   */
  readonly timeout?: string;
}

/**
 * Converts an object of type 'ImageRepositoryV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageRepositoryV1Beta2Spec(obj: ImageRepositoryV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessFrom': toJson_ImageRepositoryV1Beta2SpecAccessFrom(obj.accessFrom),
    'certSecretRef': toJson_ImageRepositoryV1Beta2SpecCertSecretRef(obj.certSecretRef),
    'exclusionList': obj.exclusionList?.map(y => y),
    'image': obj.image,
    'insecure': obj.insecure,
    'interval': obj.interval,
    'provider': obj.provider,
    'proxySecretRef': toJson_ImageRepositoryV1Beta2SpecProxySecretRef(obj.proxySecretRef),
    'secretRef': toJson_ImageRepositoryV1Beta2SpecSecretRef(obj.secretRef),
    'serviceAccountName': obj.serviceAccountName,
    'suspend': obj.suspend,
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessFrom defines an ACL for allowing cross-namespace references
 * to the ImageRepository object based on the caller's namespace labels.
 *
 * @schema ImageRepositoryV1Beta2SpecAccessFrom
 */
export interface ImageRepositoryV1Beta2SpecAccessFrom {
  /**
   * NamespaceSelectors is the list of namespace selectors to which this ACL applies.
   * Items in this list are evaluated using a logical OR operation.
   *
   * @schema ImageRepositoryV1Beta2SpecAccessFrom#namespaceSelectors
   */
  readonly namespaceSelectors: ImageRepositoryV1Beta2SpecAccessFromNamespaceSelectors[];
}

/**
 * Converts an object of type 'ImageRepositoryV1Beta2SpecAccessFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageRepositoryV1Beta2SpecAccessFrom(obj: ImageRepositoryV1Beta2SpecAccessFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_ImageRepositoryV1Beta2SpecAccessFromNamespaceSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CertSecretRef can be given the name of a Secret containing
 * either or both of
 *
 * - a PEM-encoded client certificate (`tls.crt`) and private
 * key (`tls.key`);
 * - a PEM-encoded CA certificate (`ca.crt`)
 *
 * and whichever are supplied, will be used for connecting to the
 * registry. The client cert and key are useful if you are
 * authenticating with a certificate; the CA cert is useful if
 * you are using a self-signed server certificate. The Secret must
 * be of type `Opaque` or `kubernetes.io/tls`.
 *
 * Note: Support for the `caFile`, `certFile` and `keyFile` keys has
 * been deprecated.
 *
 * @schema ImageRepositoryV1Beta2SpecCertSecretRef
 */
export interface ImageRepositoryV1Beta2SpecCertSecretRef {
  /**
   * Name of the referent.
   *
   * @schema ImageRepositoryV1Beta2SpecCertSecretRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ImageRepositoryV1Beta2SpecCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageRepositoryV1Beta2SpecCertSecretRef(obj: ImageRepositoryV1Beta2SpecCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider used for authentication, can be 'aws', 'azure', 'gcp' or 'generic'.
 * When not specified, defaults to 'generic'.
 *
 * @schema ImageRepositoryV1Beta2SpecProvider
 */
export enum ImageRepositoryV1Beta2SpecProvider {
  /** generic */
  GENERIC = "generic",
  /** aws */
  AWS = "aws",
  /** azure */
  AZURE = "azure",
  /** gcp */
  GCP = "gcp",
}

/**
 * ProxySecretRef specifies the Secret containing the proxy configuration
 * to use while communicating with the container registry.
 *
 * @schema ImageRepositoryV1Beta2SpecProxySecretRef
 */
export interface ImageRepositoryV1Beta2SpecProxySecretRef {
  /**
   * Name of the referent.
   *
   * @schema ImageRepositoryV1Beta2SpecProxySecretRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ImageRepositoryV1Beta2SpecProxySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageRepositoryV1Beta2SpecProxySecretRef(obj: ImageRepositoryV1Beta2SpecProxySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef can be given the name of a secret containing
 * credentials to use for the image registry. The secret should be
 * created with `kubectl create secret docker-registry`, or the
 * equivalent.
 *
 * @schema ImageRepositoryV1Beta2SpecSecretRef
 */
export interface ImageRepositoryV1Beta2SpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema ImageRepositoryV1Beta2SpecSecretRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ImageRepositoryV1Beta2SpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageRepositoryV1Beta2SpecSecretRef(obj: ImageRepositoryV1Beta2SpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NamespaceSelector selects the namespaces to which this ACL applies.
 * An empty map of MatchLabels matches all namespaces in a cluster.
 *
 * @schema ImageRepositoryV1Beta2SpecAccessFromNamespaceSelectors
 */
export interface ImageRepositoryV1Beta2SpecAccessFromNamespaceSelectors {
  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ImageRepositoryV1Beta2SpecAccessFromNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ImageRepositoryV1Beta2SpecAccessFromNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageRepositoryV1Beta2SpecAccessFromNamespaceSelectors(obj: ImageRepositoryV1Beta2SpecAccessFromNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * ImageUpdateAutomation is the Schema for the imageupdateautomations API
 *
 * @schema ImageUpdateAutomation
 */
export class ImageUpdateAutomation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ImageUpdateAutomation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'image.toolkit.fluxcd.io/v1',
    kind: 'ImageUpdateAutomation',
  }

  /**
   * Renders a Kubernetes manifest for "ImageUpdateAutomation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ImageUpdateAutomationProps = {}): any {
    return {
      ...ImageUpdateAutomation.GVK,
      ...toJson_ImageUpdateAutomationProps(props),
    };
  }

  /**
   * Defines a "ImageUpdateAutomation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ImageUpdateAutomationProps = {}) {
    super(scope, id, {
      ...ImageUpdateAutomation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ImageUpdateAutomation.GVK,
      ...toJson_ImageUpdateAutomationProps(resolved),
    };
  }
}

/**
 * ImageUpdateAutomation is the Schema for the imageupdateautomations API
 *
 * @schema ImageUpdateAutomation
 */
export interface ImageUpdateAutomationProps {
  /**
   * @schema ImageUpdateAutomation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ImageUpdateAutomationSpec defines the desired state of ImageUpdateAutomation
   *
   * @schema ImageUpdateAutomation#spec
   */
  readonly spec?: ImageUpdateAutomationSpec;
}

/**
 * Converts an object of type 'ImageUpdateAutomationProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationProps(obj: ImageUpdateAutomationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ImageUpdateAutomationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ImageUpdateAutomationSpec defines the desired state of ImageUpdateAutomation
 *
 * @schema ImageUpdateAutomationSpec
 */
export interface ImageUpdateAutomationSpec {
  /**
   * GitSpec contains all the git-specific definitions. This is
   * technically optional, but in practice mandatory until there are
   * other kinds of source allowed.
   *
   * @schema ImageUpdateAutomationSpec#git
   */
  readonly git?: ImageUpdateAutomationSpecGit;

  /**
   * Interval gives an lower bound for how often the automation
   * run should be attempted.
   *
   * @schema ImageUpdateAutomationSpec#interval
   */
  readonly interval: string;

  /**
   * PolicySelector allows to filter applied policies based on labels.
   * By default includes all policies in namespace.
   *
   * @schema ImageUpdateAutomationSpec#policySelector
   */
  readonly policySelector?: ImageUpdateAutomationSpecPolicySelector;

  /**
   * SourceRef refers to the resource giving access details
   * to a git repository.
   *
   * @schema ImageUpdateAutomationSpec#sourceRef
   */
  readonly sourceRef: ImageUpdateAutomationSpecSourceRef;

  /**
   * Suspend tells the controller to not run this automation, until
   * it is unset (or set to false). Defaults to false.
   *
   * @default false.
   * @schema ImageUpdateAutomationSpec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Update gives the specification for how to update the files in
   * the repository. This can be left empty, to use the default
   * value.
   *
   * @schema ImageUpdateAutomationSpec#update
   */
  readonly update?: ImageUpdateAutomationSpecUpdate;
}

/**
 * Converts an object of type 'ImageUpdateAutomationSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationSpec(obj: ImageUpdateAutomationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'git': toJson_ImageUpdateAutomationSpecGit(obj.git),
    'interval': obj.interval,
    'policySelector': toJson_ImageUpdateAutomationSpecPolicySelector(obj.policySelector),
    'sourceRef': toJson_ImageUpdateAutomationSpecSourceRef(obj.sourceRef),
    'suspend': obj.suspend,
    'update': toJson_ImageUpdateAutomationSpecUpdate(obj.update),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GitSpec contains all the git-specific definitions. This is
 * technically optional, but in practice mandatory until there are
 * other kinds of source allowed.
 *
 * @schema ImageUpdateAutomationSpecGit
 */
export interface ImageUpdateAutomationSpecGit {
  /**
   * Checkout gives the parameters for cloning the git repository,
   * ready to make changes. If not present, the `spec.ref` field from the
   * referenced `GitRepository` or its default will be used.
   *
   * @schema ImageUpdateAutomationSpecGit#checkout
   */
  readonly checkout?: ImageUpdateAutomationSpecGitCheckout;

  /**
   * Commit specifies how to commit to the git repository.
   *
   * @schema ImageUpdateAutomationSpecGit#commit
   */
  readonly commit: ImageUpdateAutomationSpecGitCommit;

  /**
   * Push specifies how and where to push commits made by the
   * automation. If missing, commits are pushed (back) to
   * `.spec.checkout.branch` or its default.
   *
   * @schema ImageUpdateAutomationSpecGit#push
   */
  readonly push?: ImageUpdateAutomationSpecGitPush;
}

/**
 * Converts an object of type 'ImageUpdateAutomationSpecGit' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationSpecGit(obj: ImageUpdateAutomationSpecGit | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'checkout': toJson_ImageUpdateAutomationSpecGitCheckout(obj.checkout),
    'commit': toJson_ImageUpdateAutomationSpecGitCommit(obj.commit),
    'push': toJson_ImageUpdateAutomationSpecGitPush(obj.push),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PolicySelector allows to filter applied policies based on labels.
 * By default includes all policies in namespace.
 *
 * @schema ImageUpdateAutomationSpecPolicySelector
 */
export interface ImageUpdateAutomationSpecPolicySelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ImageUpdateAutomationSpecPolicySelector#matchExpressions
   */
  readonly matchExpressions?: ImageUpdateAutomationSpecPolicySelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ImageUpdateAutomationSpecPolicySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ImageUpdateAutomationSpecPolicySelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationSpecPolicySelector(obj: ImageUpdateAutomationSpecPolicySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ImageUpdateAutomationSpecPolicySelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SourceRef refers to the resource giving access details
 * to a git repository.
 *
 * @schema ImageUpdateAutomationSpecSourceRef
 */
export interface ImageUpdateAutomationSpecSourceRef {
  /**
   * API version of the referent.
   *
   * @schema ImageUpdateAutomationSpecSourceRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind of the referent.
   *
   * @schema ImageUpdateAutomationSpecSourceRef#kind
   */
  readonly kind: ImageUpdateAutomationSpecSourceRefKind;

  /**
   * Name of the referent.
   *
   * @schema ImageUpdateAutomationSpecSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace of the referent, defaults to the namespace of the Kubernetes resource object that contains the reference.
   *
   * @schema ImageUpdateAutomationSpecSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ImageUpdateAutomationSpecSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationSpecSourceRef(obj: ImageUpdateAutomationSpecSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Update gives the specification for how to update the files in
 * the repository. This can be left empty, to use the default
 * value.
 *
 * @schema ImageUpdateAutomationSpecUpdate
 */
export interface ImageUpdateAutomationSpecUpdate {
  /**
   * Path to the directory containing the manifests to be updated.
   * Defaults to 'None', which translates to the root path
   * of the GitRepositoryRef.
   *
   * @default None', which translates to the root path
   * @schema ImageUpdateAutomationSpecUpdate#path
   */
  readonly path?: string;

  /**
   * Strategy names the strategy to be used.
   *
   * @schema ImageUpdateAutomationSpecUpdate#strategy
   */
  readonly strategy?: ImageUpdateAutomationSpecUpdateStrategy;
}

/**
 * Converts an object of type 'ImageUpdateAutomationSpecUpdate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationSpecUpdate(obj: ImageUpdateAutomationSpecUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'strategy': obj.strategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Checkout gives the parameters for cloning the git repository,
 * ready to make changes. If not present, the `spec.ref` field from the
 * referenced `GitRepository` or its default will be used.
 *
 * @schema ImageUpdateAutomationSpecGitCheckout
 */
export interface ImageUpdateAutomationSpecGitCheckout {
  /**
   * Reference gives a branch, tag or commit to clone from the Git
   * repository.
   *
   * @schema ImageUpdateAutomationSpecGitCheckout#ref
   */
  readonly ref: ImageUpdateAutomationSpecGitCheckoutRef;
}

/**
 * Converts an object of type 'ImageUpdateAutomationSpecGitCheckout' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationSpecGitCheckout(obj: ImageUpdateAutomationSpecGitCheckout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ref': toJson_ImageUpdateAutomationSpecGitCheckoutRef(obj.ref),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Commit specifies how to commit to the git repository.
 *
 * @schema ImageUpdateAutomationSpecGitCommit
 */
export interface ImageUpdateAutomationSpecGitCommit {
  /**
   * Author gives the email and optionally the name to use as the
   * author of commits.
   *
   * @schema ImageUpdateAutomationSpecGitCommit#author
   */
  readonly author: ImageUpdateAutomationSpecGitCommitAuthor;

  /**
   * MessageTemplate provides a template for the commit message,
   * into which will be interpolated the details of the change made.
   * Note: The `Updated` template field has been removed. Use `Changed` instead.
   *
   * @schema ImageUpdateAutomationSpecGitCommit#messageTemplate
   */
  readonly messageTemplate?: string;

  /**
   * MessageTemplateValues provides additional values to be available to the
   * templating rendering.
   *
   * @schema ImageUpdateAutomationSpecGitCommit#messageTemplateValues
   */
  readonly messageTemplateValues?: { [key: string]: string };

  /**
   * SigningKey provides the option to sign commits with a GPG key
   *
   * @schema ImageUpdateAutomationSpecGitCommit#signingKey
   */
  readonly signingKey?: ImageUpdateAutomationSpecGitCommitSigningKey;
}

/**
 * Converts an object of type 'ImageUpdateAutomationSpecGitCommit' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationSpecGitCommit(obj: ImageUpdateAutomationSpecGitCommit | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'author': toJson_ImageUpdateAutomationSpecGitCommitAuthor(obj.author),
    'messageTemplate': obj.messageTemplate,
    'messageTemplateValues': ((obj.messageTemplateValues) === undefined) ? undefined : (Object.entries(obj.messageTemplateValues).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'signingKey': toJson_ImageUpdateAutomationSpecGitCommitSigningKey(obj.signingKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Push specifies how and where to push commits made by the
 * automation. If missing, commits are pushed (back) to
 * `.spec.checkout.branch` or its default.
 *
 * @schema ImageUpdateAutomationSpecGitPush
 */
export interface ImageUpdateAutomationSpecGitPush {
  /**
   * Branch specifies that commits should be pushed to the branch
   * named. The branch is created using `.spec.checkout.branch` as the
   * starting point, if it doesn't already exist.
   *
   * @schema ImageUpdateAutomationSpecGitPush#branch
   */
  readonly branch?: string;

  /**
   * Options specifies the push options that are sent to the Git
   * server when performing a push operation. For details, see:
   * https://git-scm.com/docs/git-push#Documentation/git-push.txt---push-optionltoptiongt
   *
   * @schema ImageUpdateAutomationSpecGitPush#options
   */
  readonly options?: { [key: string]: string };

  /**
   * Refspec specifies the Git Refspec to use for a push operation.
   * If both Branch and Refspec are provided, then the commit is pushed
   * to the branch and also using the specified refspec.
   * For more details about Git Refspecs, see:
   * https://git-scm.com/book/en/v2/Git-Internals-The-Refspec
   *
   * @schema ImageUpdateAutomationSpecGitPush#refspec
   */
  readonly refspec?: string;
}

/**
 * Converts an object of type 'ImageUpdateAutomationSpecGitPush' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationSpecGitPush(obj: ImageUpdateAutomationSpecGitPush | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branch': obj.branch,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'refspec': obj.refspec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ImageUpdateAutomationSpecPolicySelectorMatchExpressions
 */
export interface ImageUpdateAutomationSpecPolicySelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ImageUpdateAutomationSpecPolicySelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ImageUpdateAutomationSpecPolicySelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ImageUpdateAutomationSpecPolicySelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ImageUpdateAutomationSpecPolicySelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationSpecPolicySelectorMatchExpressions(obj: ImageUpdateAutomationSpecPolicySelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind of the referent.
 *
 * @schema ImageUpdateAutomationSpecSourceRefKind
 */
export enum ImageUpdateAutomationSpecSourceRefKind {
  /** GitRepository */
  GIT_REPOSITORY = "GitRepository",
}

/**
 * Strategy names the strategy to be used.
 *
 * @schema ImageUpdateAutomationSpecUpdateStrategy
 */
export enum ImageUpdateAutomationSpecUpdateStrategy {
  /** Setters */
  SETTERS = "Setters",
}

/**
 * Reference gives a branch, tag or commit to clone from the Git
 * repository.
 *
 * @schema ImageUpdateAutomationSpecGitCheckoutRef
 */
export interface ImageUpdateAutomationSpecGitCheckoutRef {
  /**
   * Branch to check out, defaults to 'master' if no other field is defined.
   *
   * @schema ImageUpdateAutomationSpecGitCheckoutRef#branch
   */
  readonly branch?: string;

  /**
   * Commit SHA to check out, takes precedence over all reference fields.
   *
   * This can be combined with Branch to shallow clone the branch, in which
   * the commit is expected to exist.
   *
   * @schema ImageUpdateAutomationSpecGitCheckoutRef#commit
   */
  readonly commit?: string;

  /**
   * Name of the reference to check out; takes precedence over Branch, Tag and SemVer.
   *
   * It must be a valid Git reference: https://git-scm.com/docs/git-check-ref-format#_description
   * Examples: "refs/heads/main", "refs/tags/v0.1.0", "refs/pull/420/head", "refs/merge-requests/1/head"
   *
   * @schema ImageUpdateAutomationSpecGitCheckoutRef#name
   */
  readonly name?: string;

  /**
   * SemVer tag expression to check out, takes precedence over Tag.
   *
   * @schema ImageUpdateAutomationSpecGitCheckoutRef#semver
   */
  readonly semver?: string;

  /**
   * Tag to check out, takes precedence over Branch.
   *
   * @schema ImageUpdateAutomationSpecGitCheckoutRef#tag
   */
  readonly tag?: string;
}

/**
 * Converts an object of type 'ImageUpdateAutomationSpecGitCheckoutRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationSpecGitCheckoutRef(obj: ImageUpdateAutomationSpecGitCheckoutRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branch': obj.branch,
    'commit': obj.commit,
    'name': obj.name,
    'semver': obj.semver,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Author gives the email and optionally the name to use as the
 * author of commits.
 *
 * @schema ImageUpdateAutomationSpecGitCommitAuthor
 */
export interface ImageUpdateAutomationSpecGitCommitAuthor {
  /**
   * Email gives the email to provide when making a commit.
   *
   * @schema ImageUpdateAutomationSpecGitCommitAuthor#email
   */
  readonly email: string;

  /**
   * Name gives the name to provide when making a commit.
   *
   * @schema ImageUpdateAutomationSpecGitCommitAuthor#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ImageUpdateAutomationSpecGitCommitAuthor' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationSpecGitCommitAuthor(obj: ImageUpdateAutomationSpecGitCommitAuthor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'email': obj.email,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SigningKey provides the option to sign commits with a GPG key
 *
 * @schema ImageUpdateAutomationSpecGitCommitSigningKey
 */
export interface ImageUpdateAutomationSpecGitCommitSigningKey {
  /**
   * SecretRef holds the name to a secret that contains a 'git.asc' key
   * corresponding to the ASCII Armored file containing the GPG signing
   * keypair as the value. It must be in the same namespace as the
   * ImageUpdateAutomation.
   *
   * @schema ImageUpdateAutomationSpecGitCommitSigningKey#secretRef
   */
  readonly secretRef: ImageUpdateAutomationSpecGitCommitSigningKeySecretRef;
}

/**
 * Converts an object of type 'ImageUpdateAutomationSpecGitCommitSigningKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationSpecGitCommitSigningKey(obj: ImageUpdateAutomationSpecGitCommitSigningKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ImageUpdateAutomationSpecGitCommitSigningKeySecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef holds the name to a secret that contains a 'git.asc' key
 * corresponding to the ASCII Armored file containing the GPG signing
 * keypair as the value. It must be in the same namespace as the
 * ImageUpdateAutomation.
 *
 * @schema ImageUpdateAutomationSpecGitCommitSigningKeySecretRef
 */
export interface ImageUpdateAutomationSpecGitCommitSigningKeySecretRef {
  /**
   * Name of the referent.
   *
   * @schema ImageUpdateAutomationSpecGitCommitSigningKeySecretRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ImageUpdateAutomationSpecGitCommitSigningKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationSpecGitCommitSigningKeySecretRef(obj: ImageUpdateAutomationSpecGitCommitSigningKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * ImageUpdateAutomation is the Schema for the imageupdateautomations API
 *
 * @schema ImageUpdateAutomationV1Beta2
 */
export class ImageUpdateAutomationV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ImageUpdateAutomationV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'image.toolkit.fluxcd.io/v1beta2',
    kind: 'ImageUpdateAutomation',
  }

  /**
   * Renders a Kubernetes manifest for "ImageUpdateAutomationV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ImageUpdateAutomationV1Beta2Props = {}): any {
    return {
      ...ImageUpdateAutomationV1Beta2.GVK,
      ...toJson_ImageUpdateAutomationV1Beta2Props(props),
    };
  }

  /**
   * Defines a "ImageUpdateAutomationV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ImageUpdateAutomationV1Beta2Props = {}) {
    super(scope, id, {
      ...ImageUpdateAutomationV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ImageUpdateAutomationV1Beta2.GVK,
      ...toJson_ImageUpdateAutomationV1Beta2Props(resolved),
    };
  }
}

/**
 * ImageUpdateAutomation is the Schema for the imageupdateautomations API
 *
 * @schema ImageUpdateAutomationV1Beta2
 */
export interface ImageUpdateAutomationV1Beta2Props {
  /**
   * @schema ImageUpdateAutomationV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ImageUpdateAutomationSpec defines the desired state of ImageUpdateAutomation
   *
   * @schema ImageUpdateAutomationV1Beta2#spec
   */
  readonly spec?: ImageUpdateAutomationV1Beta2Spec;
}

/**
 * Converts an object of type 'ImageUpdateAutomationV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationV1Beta2Props(obj: ImageUpdateAutomationV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ImageUpdateAutomationV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ImageUpdateAutomationSpec defines the desired state of ImageUpdateAutomation
 *
 * @schema ImageUpdateAutomationV1Beta2Spec
 */
export interface ImageUpdateAutomationV1Beta2Spec {
  /**
   * GitSpec contains all the git-specific definitions. This is
   * technically optional, but in practice mandatory until there are
   * other kinds of source allowed.
   *
   * @schema ImageUpdateAutomationV1Beta2Spec#git
   */
  readonly git?: ImageUpdateAutomationV1Beta2SpecGit;

  /**
   * Interval gives an lower bound for how often the automation
   * run should be attempted.
   *
   * @schema ImageUpdateAutomationV1Beta2Spec#interval
   */
  readonly interval: string;

  /**
   * PolicySelector allows to filter applied policies based on labels.
   * By default includes all policies in namespace.
   *
   * @schema ImageUpdateAutomationV1Beta2Spec#policySelector
   */
  readonly policySelector?: ImageUpdateAutomationV1Beta2SpecPolicySelector;

  /**
   * SourceRef refers to the resource giving access details
   * to a git repository.
   *
   * @schema ImageUpdateAutomationV1Beta2Spec#sourceRef
   */
  readonly sourceRef: ImageUpdateAutomationV1Beta2SpecSourceRef;

  /**
   * Suspend tells the controller to not run this automation, until
   * it is unset (or set to false). Defaults to false.
   *
   * @default false.
   * @schema ImageUpdateAutomationV1Beta2Spec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Update gives the specification for how to update the files in
   * the repository. This can be left empty, to use the default
   * value.
   *
   * @schema ImageUpdateAutomationV1Beta2Spec#update
   */
  readonly update?: ImageUpdateAutomationV1Beta2SpecUpdate;
}

/**
 * Converts an object of type 'ImageUpdateAutomationV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationV1Beta2Spec(obj: ImageUpdateAutomationV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'git': toJson_ImageUpdateAutomationV1Beta2SpecGit(obj.git),
    'interval': obj.interval,
    'policySelector': toJson_ImageUpdateAutomationV1Beta2SpecPolicySelector(obj.policySelector),
    'sourceRef': toJson_ImageUpdateAutomationV1Beta2SpecSourceRef(obj.sourceRef),
    'suspend': obj.suspend,
    'update': toJson_ImageUpdateAutomationV1Beta2SpecUpdate(obj.update),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GitSpec contains all the git-specific definitions. This is
 * technically optional, but in practice mandatory until there are
 * other kinds of source allowed.
 *
 * @schema ImageUpdateAutomationV1Beta2SpecGit
 */
export interface ImageUpdateAutomationV1Beta2SpecGit {
  /**
   * Checkout gives the parameters for cloning the git repository,
   * ready to make changes. If not present, the `spec.ref` field from the
   * referenced `GitRepository` or its default will be used.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecGit#checkout
   */
  readonly checkout?: ImageUpdateAutomationV1Beta2SpecGitCheckout;

  /**
   * Commit specifies how to commit to the git repository.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecGit#commit
   */
  readonly commit: ImageUpdateAutomationV1Beta2SpecGitCommit;

  /**
   * Push specifies how and where to push commits made by the
   * automation. If missing, commits are pushed (back) to
   * `.spec.checkout.branch` or its default.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecGit#push
   */
  readonly push?: ImageUpdateAutomationV1Beta2SpecGitPush;
}

/**
 * Converts an object of type 'ImageUpdateAutomationV1Beta2SpecGit' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationV1Beta2SpecGit(obj: ImageUpdateAutomationV1Beta2SpecGit | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'checkout': toJson_ImageUpdateAutomationV1Beta2SpecGitCheckout(obj.checkout),
    'commit': toJson_ImageUpdateAutomationV1Beta2SpecGitCommit(obj.commit),
    'push': toJson_ImageUpdateAutomationV1Beta2SpecGitPush(obj.push),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PolicySelector allows to filter applied policies based on labels.
 * By default includes all policies in namespace.
 *
 * @schema ImageUpdateAutomationV1Beta2SpecPolicySelector
 */
export interface ImageUpdateAutomationV1Beta2SpecPolicySelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecPolicySelector#matchExpressions
   */
  readonly matchExpressions?: ImageUpdateAutomationV1Beta2SpecPolicySelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecPolicySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ImageUpdateAutomationV1Beta2SpecPolicySelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationV1Beta2SpecPolicySelector(obj: ImageUpdateAutomationV1Beta2SpecPolicySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ImageUpdateAutomationV1Beta2SpecPolicySelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SourceRef refers to the resource giving access details
 * to a git repository.
 *
 * @schema ImageUpdateAutomationV1Beta2SpecSourceRef
 */
export interface ImageUpdateAutomationV1Beta2SpecSourceRef {
  /**
   * API version of the referent.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecSourceRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind of the referent.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecSourceRef#kind
   */
  readonly kind: ImageUpdateAutomationV1Beta2SpecSourceRefKind;

  /**
   * Name of the referent.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace of the referent, defaults to the namespace of the Kubernetes resource object that contains the reference.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ImageUpdateAutomationV1Beta2SpecSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationV1Beta2SpecSourceRef(obj: ImageUpdateAutomationV1Beta2SpecSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Update gives the specification for how to update the files in
 * the repository. This can be left empty, to use the default
 * value.
 *
 * @schema ImageUpdateAutomationV1Beta2SpecUpdate
 */
export interface ImageUpdateAutomationV1Beta2SpecUpdate {
  /**
   * Path to the directory containing the manifests to be updated.
   * Defaults to 'None', which translates to the root path
   * of the GitRepositoryRef.
   *
   * @default None', which translates to the root path
   * @schema ImageUpdateAutomationV1Beta2SpecUpdate#path
   */
  readonly path?: string;

  /**
   * Strategy names the strategy to be used.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecUpdate#strategy
   */
  readonly strategy?: ImageUpdateAutomationV1Beta2SpecUpdateStrategy;
}

/**
 * Converts an object of type 'ImageUpdateAutomationV1Beta2SpecUpdate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationV1Beta2SpecUpdate(obj: ImageUpdateAutomationV1Beta2SpecUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'strategy': obj.strategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Checkout gives the parameters for cloning the git repository,
 * ready to make changes. If not present, the `spec.ref` field from the
 * referenced `GitRepository` or its default will be used.
 *
 * @schema ImageUpdateAutomationV1Beta2SpecGitCheckout
 */
export interface ImageUpdateAutomationV1Beta2SpecGitCheckout {
  /**
   * Reference gives a branch, tag or commit to clone from the Git
   * repository.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecGitCheckout#ref
   */
  readonly ref: ImageUpdateAutomationV1Beta2SpecGitCheckoutRef;
}

/**
 * Converts an object of type 'ImageUpdateAutomationV1Beta2SpecGitCheckout' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationV1Beta2SpecGitCheckout(obj: ImageUpdateAutomationV1Beta2SpecGitCheckout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ref': toJson_ImageUpdateAutomationV1Beta2SpecGitCheckoutRef(obj.ref),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Commit specifies how to commit to the git repository.
 *
 * @schema ImageUpdateAutomationV1Beta2SpecGitCommit
 */
export interface ImageUpdateAutomationV1Beta2SpecGitCommit {
  /**
   * Author gives the email and optionally the name to use as the
   * author of commits.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecGitCommit#author
   */
  readonly author: ImageUpdateAutomationV1Beta2SpecGitCommitAuthor;

  /**
   * MessageTemplate provides a template for the commit message,
   * into which will be interpolated the details of the change made.
   * Note: The `Updated` template field has been removed. Use `Changed` instead.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecGitCommit#messageTemplate
   */
  readonly messageTemplate?: string;

  /**
   * MessageTemplateValues provides additional values to be available to the
   * templating rendering.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecGitCommit#messageTemplateValues
   */
  readonly messageTemplateValues?: { [key: string]: string };

  /**
   * SigningKey provides the option to sign commits with a GPG key
   *
   * @schema ImageUpdateAutomationV1Beta2SpecGitCommit#signingKey
   */
  readonly signingKey?: ImageUpdateAutomationV1Beta2SpecGitCommitSigningKey;
}

/**
 * Converts an object of type 'ImageUpdateAutomationV1Beta2SpecGitCommit' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationV1Beta2SpecGitCommit(obj: ImageUpdateAutomationV1Beta2SpecGitCommit | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'author': toJson_ImageUpdateAutomationV1Beta2SpecGitCommitAuthor(obj.author),
    'messageTemplate': obj.messageTemplate,
    'messageTemplateValues': ((obj.messageTemplateValues) === undefined) ? undefined : (Object.entries(obj.messageTemplateValues).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'signingKey': toJson_ImageUpdateAutomationV1Beta2SpecGitCommitSigningKey(obj.signingKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Push specifies how and where to push commits made by the
 * automation. If missing, commits are pushed (back) to
 * `.spec.checkout.branch` or its default.
 *
 * @schema ImageUpdateAutomationV1Beta2SpecGitPush
 */
export interface ImageUpdateAutomationV1Beta2SpecGitPush {
  /**
   * Branch specifies that commits should be pushed to the branch
   * named. The branch is created using `.spec.checkout.branch` as the
   * starting point, if it doesn't already exist.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecGitPush#branch
   */
  readonly branch?: string;

  /**
   * Options specifies the push options that are sent to the Git
   * server when performing a push operation. For details, see:
   * https://git-scm.com/docs/git-push#Documentation/git-push.txt---push-optionltoptiongt
   *
   * @schema ImageUpdateAutomationV1Beta2SpecGitPush#options
   */
  readonly options?: { [key: string]: string };

  /**
   * Refspec specifies the Git Refspec to use for a push operation.
   * If both Branch and Refspec are provided, then the commit is pushed
   * to the branch and also using the specified refspec.
   * For more details about Git Refspecs, see:
   * https://git-scm.com/book/en/v2/Git-Internals-The-Refspec
   *
   * @schema ImageUpdateAutomationV1Beta2SpecGitPush#refspec
   */
  readonly refspec?: string;
}

/**
 * Converts an object of type 'ImageUpdateAutomationV1Beta2SpecGitPush' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationV1Beta2SpecGitPush(obj: ImageUpdateAutomationV1Beta2SpecGitPush | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branch': obj.branch,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'refspec': obj.refspec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ImageUpdateAutomationV1Beta2SpecPolicySelectorMatchExpressions
 */
export interface ImageUpdateAutomationV1Beta2SpecPolicySelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecPolicySelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecPolicySelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecPolicySelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ImageUpdateAutomationV1Beta2SpecPolicySelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationV1Beta2SpecPolicySelectorMatchExpressions(obj: ImageUpdateAutomationV1Beta2SpecPolicySelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind of the referent.
 *
 * @schema ImageUpdateAutomationV1Beta2SpecSourceRefKind
 */
export enum ImageUpdateAutomationV1Beta2SpecSourceRefKind {
  /** GitRepository */
  GIT_REPOSITORY = "GitRepository",
}

/**
 * Strategy names the strategy to be used.
 *
 * @schema ImageUpdateAutomationV1Beta2SpecUpdateStrategy
 */
export enum ImageUpdateAutomationV1Beta2SpecUpdateStrategy {
  /** Setters */
  SETTERS = "Setters",
}

/**
 * Reference gives a branch, tag or commit to clone from the Git
 * repository.
 *
 * @schema ImageUpdateAutomationV1Beta2SpecGitCheckoutRef
 */
export interface ImageUpdateAutomationV1Beta2SpecGitCheckoutRef {
  /**
   * Branch to check out, defaults to 'master' if no other field is defined.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecGitCheckoutRef#branch
   */
  readonly branch?: string;

  /**
   * Commit SHA to check out, takes precedence over all reference fields.
   *
   * This can be combined with Branch to shallow clone the branch, in which
   * the commit is expected to exist.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecGitCheckoutRef#commit
   */
  readonly commit?: string;

  /**
   * Name of the reference to check out; takes precedence over Branch, Tag and SemVer.
   *
   * It must be a valid Git reference: https://git-scm.com/docs/git-check-ref-format#_description
   * Examples: "refs/heads/main", "refs/tags/v0.1.0", "refs/pull/420/head", "refs/merge-requests/1/head"
   *
   * @schema ImageUpdateAutomationV1Beta2SpecGitCheckoutRef#name
   */
  readonly name?: string;

  /**
   * SemVer tag expression to check out, takes precedence over Tag.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecGitCheckoutRef#semver
   */
  readonly semver?: string;

  /**
   * Tag to check out, takes precedence over Branch.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecGitCheckoutRef#tag
   */
  readonly tag?: string;
}

/**
 * Converts an object of type 'ImageUpdateAutomationV1Beta2SpecGitCheckoutRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationV1Beta2SpecGitCheckoutRef(obj: ImageUpdateAutomationV1Beta2SpecGitCheckoutRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branch': obj.branch,
    'commit': obj.commit,
    'name': obj.name,
    'semver': obj.semver,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Author gives the email and optionally the name to use as the
 * author of commits.
 *
 * @schema ImageUpdateAutomationV1Beta2SpecGitCommitAuthor
 */
export interface ImageUpdateAutomationV1Beta2SpecGitCommitAuthor {
  /**
   * Email gives the email to provide when making a commit.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecGitCommitAuthor#email
   */
  readonly email: string;

  /**
   * Name gives the name to provide when making a commit.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecGitCommitAuthor#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ImageUpdateAutomationV1Beta2SpecGitCommitAuthor' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationV1Beta2SpecGitCommitAuthor(obj: ImageUpdateAutomationV1Beta2SpecGitCommitAuthor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'email': obj.email,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SigningKey provides the option to sign commits with a GPG key
 *
 * @schema ImageUpdateAutomationV1Beta2SpecGitCommitSigningKey
 */
export interface ImageUpdateAutomationV1Beta2SpecGitCommitSigningKey {
  /**
   * SecretRef holds the name to a secret that contains a 'git.asc' key
   * corresponding to the ASCII Armored file containing the GPG signing
   * keypair as the value. It must be in the same namespace as the
   * ImageUpdateAutomation.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecGitCommitSigningKey#secretRef
   */
  readonly secretRef: ImageUpdateAutomationV1Beta2SpecGitCommitSigningKeySecretRef;
}

/**
 * Converts an object of type 'ImageUpdateAutomationV1Beta2SpecGitCommitSigningKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationV1Beta2SpecGitCommitSigningKey(obj: ImageUpdateAutomationV1Beta2SpecGitCommitSigningKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ImageUpdateAutomationV1Beta2SpecGitCommitSigningKeySecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef holds the name to a secret that contains a 'git.asc' key
 * corresponding to the ASCII Armored file containing the GPG signing
 * keypair as the value. It must be in the same namespace as the
 * ImageUpdateAutomation.
 *
 * @schema ImageUpdateAutomationV1Beta2SpecGitCommitSigningKeySecretRef
 */
export interface ImageUpdateAutomationV1Beta2SpecGitCommitSigningKeySecretRef {
  /**
   * Name of the referent.
   *
   * @schema ImageUpdateAutomationV1Beta2SpecGitCommitSigningKeySecretRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ImageUpdateAutomationV1Beta2SpecGitCommitSigningKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ImageUpdateAutomationV1Beta2SpecGitCommitSigningKeySecretRef(obj: ImageUpdateAutomationV1Beta2SpecGitCommitSigningKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

