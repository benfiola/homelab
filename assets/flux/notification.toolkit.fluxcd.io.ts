// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Alert is the Schema for the alerts API
 *
 * @schema Alert
 */
export class Alert extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Alert"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'notification.toolkit.fluxcd.io/v1beta2',
    kind: 'Alert',
  }

  /**
   * Renders a Kubernetes manifest for "Alert".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AlertProps = {}): any {
    return {
      ...Alert.GVK,
      ...toJson_AlertProps(props),
    };
  }

  /**
   * Defines a "Alert" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AlertProps = {}) {
    super(scope, id, {
      ...Alert.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Alert.GVK,
      ...toJson_AlertProps(resolved),
    };
  }
}

/**
 * Alert is the Schema for the alerts API
 *
 * @schema Alert
 */
export interface AlertProps {
  /**
   * @schema Alert#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AlertSpec defines an alerting rule for events involving a list of objects.
   *
   * @schema Alert#spec
   */
  readonly spec?: AlertSpec;
}

/**
 * Converts an object of type 'AlertProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AlertProps(obj: AlertProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AlertSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AlertSpec defines an alerting rule for events involving a list of objects.
 *
 * @schema AlertSpec
 */
export interface AlertSpec {
  /**
   * EventMetadata is an optional field for adding metadata to events dispatched by the
   * controller. This can be used for enhancing the context of the event. If a field
   * would override one already present on the original event as generated by the emitter,
   * then the override doesn't happen, i.e. the original value is preserved, and an info
   * log is printed.
   *
   * @schema AlertSpec#eventMetadata
   */
  readonly eventMetadata?: { [key: string]: string };

  /**
   * EventSeverity specifies how to filter events based on severity.
   * If set to 'info' no events will be filtered.
   *
   * @schema AlertSpec#eventSeverity
   */
  readonly eventSeverity?: AlertSpecEventSeverity;

  /**
   * EventSources specifies how to filter events based
   * on the involved object kind, name and namespace.
   *
   * @schema AlertSpec#eventSources
   */
  readonly eventSources: AlertSpecEventSources[];

  /**
   * ExclusionList specifies a list of Golang regular expressions
   * to be used for excluding messages.
   *
   * @schema AlertSpec#exclusionList
   */
  readonly exclusionList?: string[];

  /**
   * InclusionList specifies a list of Golang regular expressions
   * to be used for including messages.
   *
   * @schema AlertSpec#inclusionList
   */
  readonly inclusionList?: string[];

  /**
   * ProviderRef specifies which Provider this Alert should use.
   *
   * @schema AlertSpec#providerRef
   */
  readonly providerRef: AlertSpecProviderRef;

  /**
   * Summary holds a short description of the impact and affected cluster.
   *
   * @schema AlertSpec#summary
   */
  readonly summary?: string;

  /**
   * Suspend tells the controller to suspend subsequent
   * events handling for this Alert.
   *
   * @schema AlertSpec#suspend
   */
  readonly suspend?: boolean;
}

/**
 * Converts an object of type 'AlertSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AlertSpec(obj: AlertSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventMetadata': ((obj.eventMetadata) === undefined) ? undefined : (Object.entries(obj.eventMetadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'eventSeverity': obj.eventSeverity,
    'eventSources': obj.eventSources?.map(y => toJson_AlertSpecEventSources(y)),
    'exclusionList': obj.exclusionList?.map(y => y),
    'inclusionList': obj.inclusionList?.map(y => y),
    'providerRef': toJson_AlertSpecProviderRef(obj.providerRef),
    'summary': obj.summary,
    'suspend': obj.suspend,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EventSeverity specifies how to filter events based on severity.
 * If set to 'info' no events will be filtered.
 *
 * @schema AlertSpecEventSeverity
 */
export enum AlertSpecEventSeverity {
  /** info */
  INFO = "info",
  /** error */
  ERROR = "error",
}

/**
 * CrossNamespaceObjectReference contains enough information to let you locate the
 * typed referenced object at cluster level
 *
 * @schema AlertSpecEventSources
 */
export interface AlertSpecEventSources {
  /**
   * API version of the referent
   *
   * @schema AlertSpecEventSources#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind of the referent
   *
   * @schema AlertSpecEventSources#kind
   */
  readonly kind: AlertSpecEventSourcesKind;

  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   * MatchLabels requires the name to be set to `*`.
   *
   * @schema AlertSpecEventSources#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Name of the referent
   * If multiple resources are targeted `*` may be set.
   *
   * @schema AlertSpecEventSources#name
   */
  readonly name: string;

  /**
   * Namespace of the referent
   *
   * @schema AlertSpecEventSources#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'AlertSpecEventSources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AlertSpecEventSources(obj: AlertSpecEventSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProviderRef specifies which Provider this Alert should use.
 *
 * @schema AlertSpecProviderRef
 */
export interface AlertSpecProviderRef {
  /**
   * Name of the referent.
   *
   * @schema AlertSpecProviderRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AlertSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AlertSpecProviderRef(obj: AlertSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind of the referent
 *
 * @schema AlertSpecEventSourcesKind
 */
export enum AlertSpecEventSourcesKind {
  /** Bucket */
  BUCKET = "Bucket",
  /** GitRepository */
  GIT_REPOSITORY = "GitRepository",
  /** Kustomization */
  KUSTOMIZATION = "Kustomization",
  /** HelmRelease */
  HELM_RELEASE = "HelmRelease",
  /** HelmChart */
  HELM_CHART = "HelmChart",
  /** HelmRepository */
  HELM_REPOSITORY = "HelmRepository",
  /** ImageRepository */
  IMAGE_REPOSITORY = "ImageRepository",
  /** ImagePolicy */
  IMAGE_POLICY = "ImagePolicy",
  /** ImageUpdateAutomation */
  IMAGE_UPDATE_AUTOMATION = "ImageUpdateAutomation",
  /** OCIRepository */
  OCI_REPOSITORY = "OCIRepository",
}


/**
 * Alert is the Schema for the alerts API
 *
 * @schema AlertV1Beta3
 */
export class AlertV1Beta3 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AlertV1Beta3"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'notification.toolkit.fluxcd.io/v1beta3',
    kind: 'Alert',
  }

  /**
   * Renders a Kubernetes manifest for "AlertV1Beta3".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AlertV1Beta3Props = {}): any {
    return {
      ...AlertV1Beta3.GVK,
      ...toJson_AlertV1Beta3Props(props),
    };
  }

  /**
   * Defines a "AlertV1Beta3" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AlertV1Beta3Props = {}) {
    super(scope, id, {
      ...AlertV1Beta3.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...AlertV1Beta3.GVK,
      ...toJson_AlertV1Beta3Props(resolved),
    };
  }
}

/**
 * Alert is the Schema for the alerts API
 *
 * @schema AlertV1Beta3
 */
export interface AlertV1Beta3Props {
  /**
   * @schema AlertV1Beta3#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AlertSpec defines an alerting rule for events involving a list of objects.
   *
   * @schema AlertV1Beta3#spec
   */
  readonly spec?: AlertV1Beta3Spec;
}

/**
 * Converts an object of type 'AlertV1Beta3Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AlertV1Beta3Props(obj: AlertV1Beta3Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AlertV1Beta3Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AlertSpec defines an alerting rule for events involving a list of objects.
 *
 * @schema AlertV1Beta3Spec
 */
export interface AlertV1Beta3Spec {
  /**
   * EventMetadata is an optional field for adding metadata to events dispatched by the
   * controller. This can be used for enhancing the context of the event. If a field
   * would override one already present on the original event as generated by the emitter,
   * then the override doesn't happen, i.e. the original value is preserved, and an info
   * log is printed.
   *
   * @schema AlertV1Beta3Spec#eventMetadata
   */
  readonly eventMetadata?: { [key: string]: string };

  /**
   * EventSeverity specifies how to filter events based on severity.
   * If set to 'info' no events will be filtered.
   *
   * @schema AlertV1Beta3Spec#eventSeverity
   */
  readonly eventSeverity?: AlertV1Beta3SpecEventSeverity;

  /**
   * EventSources specifies how to filter events based
   * on the involved object kind, name and namespace.
   *
   * @schema AlertV1Beta3Spec#eventSources
   */
  readonly eventSources: AlertV1Beta3SpecEventSources[];

  /**
   * ExclusionList specifies a list of Golang regular expressions
   * to be used for excluding messages.
   *
   * @schema AlertV1Beta3Spec#exclusionList
   */
  readonly exclusionList?: string[];

  /**
   * InclusionList specifies a list of Golang regular expressions
   * to be used for including messages.
   *
   * @schema AlertV1Beta3Spec#inclusionList
   */
  readonly inclusionList?: string[];

  /**
   * ProviderRef specifies which Provider this Alert should use.
   *
   * @schema AlertV1Beta3Spec#providerRef
   */
  readonly providerRef: AlertV1Beta3SpecProviderRef;

  /**
   * Summary holds a short description of the impact and affected cluster.
   * Deprecated: Use EventMetadata instead.
   *
   * @schema AlertV1Beta3Spec#summary
   */
  readonly summary?: string;

  /**
   * Suspend tells the controller to suspend subsequent
   * events handling for this Alert.
   *
   * @schema AlertV1Beta3Spec#suspend
   */
  readonly suspend?: boolean;
}

/**
 * Converts an object of type 'AlertV1Beta3Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AlertV1Beta3Spec(obj: AlertV1Beta3Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventMetadata': ((obj.eventMetadata) === undefined) ? undefined : (Object.entries(obj.eventMetadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'eventSeverity': obj.eventSeverity,
    'eventSources': obj.eventSources?.map(y => toJson_AlertV1Beta3SpecEventSources(y)),
    'exclusionList': obj.exclusionList?.map(y => y),
    'inclusionList': obj.inclusionList?.map(y => y),
    'providerRef': toJson_AlertV1Beta3SpecProviderRef(obj.providerRef),
    'summary': obj.summary,
    'suspend': obj.suspend,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EventSeverity specifies how to filter events based on severity.
 * If set to 'info' no events will be filtered.
 *
 * @schema AlertV1Beta3SpecEventSeverity
 */
export enum AlertV1Beta3SpecEventSeverity {
  /** info */
  INFO = "info",
  /** error */
  ERROR = "error",
}

/**
 * CrossNamespaceObjectReference contains enough information to let you locate the
 * typed referenced object at cluster level
 *
 * @schema AlertV1Beta3SpecEventSources
 */
export interface AlertV1Beta3SpecEventSources {
  /**
   * API version of the referent
   *
   * @schema AlertV1Beta3SpecEventSources#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind of the referent
   *
   * @schema AlertV1Beta3SpecEventSources#kind
   */
  readonly kind: AlertV1Beta3SpecEventSourcesKind;

  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   * MatchLabels requires the name to be set to `*`.
   *
   * @schema AlertV1Beta3SpecEventSources#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Name of the referent
   * If multiple resources are targeted `*` may be set.
   *
   * @schema AlertV1Beta3SpecEventSources#name
   */
  readonly name: string;

  /**
   * Namespace of the referent
   *
   * @schema AlertV1Beta3SpecEventSources#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'AlertV1Beta3SpecEventSources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AlertV1Beta3SpecEventSources(obj: AlertV1Beta3SpecEventSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProviderRef specifies which Provider this Alert should use.
 *
 * @schema AlertV1Beta3SpecProviderRef
 */
export interface AlertV1Beta3SpecProviderRef {
  /**
   * Name of the referent.
   *
   * @schema AlertV1Beta3SpecProviderRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AlertV1Beta3SpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AlertV1Beta3SpecProviderRef(obj: AlertV1Beta3SpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind of the referent
 *
 * @schema AlertV1Beta3SpecEventSourcesKind
 */
export enum AlertV1Beta3SpecEventSourcesKind {
  /** Bucket */
  BUCKET = "Bucket",
  /** GitRepository */
  GIT_REPOSITORY = "GitRepository",
  /** Kustomization */
  KUSTOMIZATION = "Kustomization",
  /** HelmRelease */
  HELM_RELEASE = "HelmRelease",
  /** HelmChart */
  HELM_CHART = "HelmChart",
  /** HelmRepository */
  HELM_REPOSITORY = "HelmRepository",
  /** ImageRepository */
  IMAGE_REPOSITORY = "ImageRepository",
  /** ImagePolicy */
  IMAGE_POLICY = "ImagePolicy",
  /** ImageUpdateAutomation */
  IMAGE_UPDATE_AUTOMATION = "ImageUpdateAutomation",
  /** OCIRepository */
  OCI_REPOSITORY = "OCIRepository",
}


/**
 * Provider is the Schema for the providers API.
 *
 * @schema Provider
 */
export class Provider extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Provider"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'notification.toolkit.fluxcd.io/v1beta2',
    kind: 'Provider',
  }

  /**
   * Renders a Kubernetes manifest for "Provider".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProviderProps = {}): any {
    return {
      ...Provider.GVK,
      ...toJson_ProviderProps(props),
    };
  }

  /**
   * Defines a "Provider" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProviderProps = {}) {
    super(scope, id, {
      ...Provider.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Provider.GVK,
      ...toJson_ProviderProps(resolved),
    };
  }
}

/**
 * Provider is the Schema for the providers API.
 *
 * @schema Provider
 */
export interface ProviderProps {
  /**
   * @schema Provider#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProviderSpec defines the desired state of the Provider.
   *
   * @schema Provider#spec
   */
  readonly spec?: ProviderSpec;
}

/**
 * Converts an object of type 'ProviderProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProviderProps(obj: ProviderProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProviderSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProviderSpec defines the desired state of the Provider.
 *
 * @schema ProviderSpec
 */
export interface ProviderSpec {
  /**
   * Address specifies the endpoint, in a generic sense, to where alerts are sent.
   * What kind of endpoint depends on the specific Provider type being used.
   * For the generic Provider, for example, this is an HTTP/S address.
   * For other Provider types this could be a project ID or a namespace.
   *
   * @schema ProviderSpec#address
   */
  readonly address?: string;

  /**
   * CertSecretRef specifies the Secret containing
   * a PEM-encoded CA certificate (in the `ca.crt` key).
   *
   * Note: Support for the `caFile` key has
   * been deprecated.
   *
   * @schema ProviderSpec#certSecretRef
   */
  readonly certSecretRef?: ProviderSpecCertSecretRef;

  /**
   * Channel specifies the destination channel where events should be posted.
   *
   * @schema ProviderSpec#channel
   */
  readonly channel?: string;

  /**
   * Interval at which to reconcile the Provider with its Secret references.
   *
   * @schema ProviderSpec#interval
   */
  readonly interval?: string;

  /**
   * Proxy the HTTP/S address of the proxy server.
   *
   * @schema ProviderSpec#proxy
   */
  readonly proxy?: string;

  /**
   * SecretRef specifies the Secret containing the authentication
   * credentials for this Provider.
   *
   * @schema ProviderSpec#secretRef
   */
  readonly secretRef?: ProviderSpecSecretRef;

  /**
   * Suspend tells the controller to suspend subsequent
   * events handling for this Provider.
   *
   * @schema ProviderSpec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Timeout for sending alerts to the Provider.
   *
   * @schema ProviderSpec#timeout
   */
  readonly timeout?: string;

  /**
   * Type specifies which Provider implementation to use.
   *
   * @schema ProviderSpec#type
   */
  readonly type: ProviderSpecType;

  /**
   * Username specifies the name under which events are posted.
   *
   * @schema ProviderSpec#username
   */
  readonly username?: string;
}

/**
 * Converts an object of type 'ProviderSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProviderSpec(obj: ProviderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'certSecretRef': toJson_ProviderSpecCertSecretRef(obj.certSecretRef),
    'channel': obj.channel,
    'interval': obj.interval,
    'proxy': obj.proxy,
    'secretRef': toJson_ProviderSpecSecretRef(obj.secretRef),
    'suspend': obj.suspend,
    'timeout': obj.timeout,
    'type': obj.type,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CertSecretRef specifies the Secret containing
 * a PEM-encoded CA certificate (in the `ca.crt` key).
 *
 * Note: Support for the `caFile` key has
 * been deprecated.
 *
 * @schema ProviderSpecCertSecretRef
 */
export interface ProviderSpecCertSecretRef {
  /**
   * Name of the referent.
   *
   * @schema ProviderSpecCertSecretRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ProviderSpecCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProviderSpecCertSecretRef(obj: ProviderSpecCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef specifies the Secret containing the authentication
 * credentials for this Provider.
 *
 * @schema ProviderSpecSecretRef
 */
export interface ProviderSpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema ProviderSpecSecretRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ProviderSpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProviderSpecSecretRef(obj: ProviderSpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type specifies which Provider implementation to use.
 *
 * @schema ProviderSpecType
 */
export enum ProviderSpecType {
  /** slack */
  SLACK = "slack",
  /** discord */
  DISCORD = "discord",
  /** msteams */
  MSTEAMS = "msteams",
  /** rocket */
  ROCKET = "rocket",
  /** generic */
  GENERIC = "generic",
  /** generic-hmac */
  GENERIC_HYPHEN_HMAC = "generic-hmac",
  /** github */
  GITHUB = "github",
  /** gitlab */
  GITLAB = "gitlab",
  /** gitea */
  GITEA = "gitea",
  /** bitbucketserver */
  BITBUCKETSERVER = "bitbucketserver",
  /** bitbucket */
  BITBUCKET = "bitbucket",
  /** azuredevops */
  AZUREDEVOPS = "azuredevops",
  /** googlechat */
  GOOGLECHAT = "googlechat",
  /** googlepubsub */
  GOOGLEPUBSUB = "googlepubsub",
  /** webex */
  WEBEX = "webex",
  /** sentry */
  SENTRY = "sentry",
  /** azureeventhub */
  AZUREEVENTHUB = "azureeventhub",
  /** telegram */
  TELEGRAM = "telegram",
  /** lark */
  LARK = "lark",
  /** matrix */
  MATRIX = "matrix",
  /** opsgenie */
  OPSGENIE = "opsgenie",
  /** alertmanager */
  ALERTMANAGER = "alertmanager",
  /** grafana */
  GRAFANA = "grafana",
  /** githubdispatch */
  GITHUBDISPATCH = "githubdispatch",
  /** pagerduty */
  PAGERDUTY = "pagerduty",
  /** datadog */
  DATADOG = "datadog",
}


/**
 * Provider is the Schema for the providers API
 *
 * @schema ProviderV1Beta3
 */
export class ProviderV1Beta3 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProviderV1Beta3"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'notification.toolkit.fluxcd.io/v1beta3',
    kind: 'Provider',
  }

  /**
   * Renders a Kubernetes manifest for "ProviderV1Beta3".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProviderV1Beta3Props = {}): any {
    return {
      ...ProviderV1Beta3.GVK,
      ...toJson_ProviderV1Beta3Props(props),
    };
  }

  /**
   * Defines a "ProviderV1Beta3" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProviderV1Beta3Props = {}) {
    super(scope, id, {
      ...ProviderV1Beta3.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProviderV1Beta3.GVK,
      ...toJson_ProviderV1Beta3Props(resolved),
    };
  }
}

/**
 * Provider is the Schema for the providers API
 *
 * @schema ProviderV1Beta3
 */
export interface ProviderV1Beta3Props {
  /**
   * @schema ProviderV1Beta3#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProviderSpec defines the desired state of the Provider.
   *
   * @schema ProviderV1Beta3#spec
   */
  readonly spec?: ProviderV1Beta3Spec;
}

/**
 * Converts an object of type 'ProviderV1Beta3Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProviderV1Beta3Props(obj: ProviderV1Beta3Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProviderV1Beta3Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProviderSpec defines the desired state of the Provider.
 *
 * @schema ProviderV1Beta3Spec
 */
export interface ProviderV1Beta3Spec {
  /**
   * Address specifies the endpoint, in a generic sense, to where alerts are sent.
   * What kind of endpoint depends on the specific Provider type being used.
   * For the generic Provider, for example, this is an HTTP/S address.
   * For other Provider types this could be a project ID or a namespace.
   *
   * @schema ProviderV1Beta3Spec#address
   */
  readonly address?: string;

  /**
   * CertSecretRef specifies the Secret containing TLS certificates
   * for secure communication.
   *
   * Supported configurations:
   * - CA-only: Server authentication (provide ca.crt only)
   * - mTLS: Mutual authentication (provide ca.crt + tls.crt + tls.key)
   * - Client-only: Client authentication with system CA (provide tls.crt + tls.key only)
   *
   * Legacy keys "caFile", "certFile", "keyFile" are supported but deprecated. Use "ca.crt", "tls.crt", "tls.key" instead.
   *
   * @schema ProviderV1Beta3Spec#certSecretRef
   */
  readonly certSecretRef?: ProviderV1Beta3SpecCertSecretRef;

  /**
   * Channel specifies the destination channel where events should be posted.
   *
   * @schema ProviderV1Beta3Spec#channel
   */
  readonly channel?: string;

  /**
   * CommitStatusExpr is a CEL expression that evaluates to a string value
   * that can be used to generate a custom commit status message for use
   * with eligible Provider types (github, gitlab, gitea, bitbucketserver,
   * bitbucket, azuredevops). Supported variables are: event, provider,
   * and alert.
   *
   * @schema ProviderV1Beta3Spec#commitStatusExpr
   */
  readonly commitStatusExpr?: string;

  /**
   * Interval at which to reconcile the Provider with its Secret references.
   * Deprecated and not used in v1beta3.
   *
   * @schema ProviderV1Beta3Spec#interval
   */
  readonly interval?: string;

  /**
   * Proxy the HTTP/S address of the proxy server.
   * Deprecated: Use ProxySecretRef instead. Will be removed in v1.
   *
   * @schema ProviderV1Beta3Spec#proxy
   */
  readonly proxy?: string;

  /**
   * ProxySecretRef specifies the Secret containing the proxy configuration
   * for this Provider. The Secret should contain an 'address' key with the
   * HTTP/S address of the proxy server. Optional 'username' and 'password'
   * keys can be provided for proxy authentication.
   *
   * @schema ProviderV1Beta3Spec#proxySecretRef
   */
  readonly proxySecretRef?: ProviderV1Beta3SpecProxySecretRef;

  /**
   * SecretRef specifies the Secret containing the authentication
   * credentials for this Provider.
   *
   * @schema ProviderV1Beta3Spec#secretRef
   */
  readonly secretRef?: ProviderV1Beta3SpecSecretRef;

  /**
   * ServiceAccountName is the name of the Kubernetes ServiceAccount used to
   * authenticate with cloud provider services through workload identity.
   * This enables multi-tenant authentication without storing static credentials.
   *
   * Supported provider types: azureeventhub, azuredevops, googlepubsub
   *
   * When specified, the controller will:
   * 1. Create an OIDC token for the specified ServiceAccount
   * 2. Exchange it for cloud provider credentials via STS
   * 3. Use the obtained credentials for API authentication
   *
   * When unspecified, controller-level authentication is used (single-tenant).
   *
   * An error is thrown if static credentials are also defined in SecretRef.
   * This field requires the ObjectLevelWorkloadIdentity feature gate to be enabled.
   *
   * @schema ProviderV1Beta3Spec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * Suspend tells the controller to suspend subsequent
   * events handling for this Provider.
   *
   * @schema ProviderV1Beta3Spec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Timeout for sending alerts to the Provider.
   *
   * @schema ProviderV1Beta3Spec#timeout
   */
  readonly timeout?: string;

  /**
   * Type specifies which Provider implementation to use.
   *
   * @schema ProviderV1Beta3Spec#type
   */
  readonly type: ProviderV1Beta3SpecType;

  /**
   * Username specifies the name under which events are posted.
   *
   * @schema ProviderV1Beta3Spec#username
   */
  readonly username?: string;
}

/**
 * Converts an object of type 'ProviderV1Beta3Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProviderV1Beta3Spec(obj: ProviderV1Beta3Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'certSecretRef': toJson_ProviderV1Beta3SpecCertSecretRef(obj.certSecretRef),
    'channel': obj.channel,
    'commitStatusExpr': obj.commitStatusExpr,
    'interval': obj.interval,
    'proxy': obj.proxy,
    'proxySecretRef': toJson_ProviderV1Beta3SpecProxySecretRef(obj.proxySecretRef),
    'secretRef': toJson_ProviderV1Beta3SpecSecretRef(obj.secretRef),
    'serviceAccountName': obj.serviceAccountName,
    'suspend': obj.suspend,
    'timeout': obj.timeout,
    'type': obj.type,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CertSecretRef specifies the Secret containing TLS certificates
 * for secure communication.
 *
 * Supported configurations:
 * - CA-only: Server authentication (provide ca.crt only)
 * - mTLS: Mutual authentication (provide ca.crt + tls.crt + tls.key)
 * - Client-only: Client authentication with system CA (provide tls.crt + tls.key only)
 *
 * Legacy keys "caFile", "certFile", "keyFile" are supported but deprecated. Use "ca.crt", "tls.crt", "tls.key" instead.
 *
 * @schema ProviderV1Beta3SpecCertSecretRef
 */
export interface ProviderV1Beta3SpecCertSecretRef {
  /**
   * Name of the referent.
   *
   * @schema ProviderV1Beta3SpecCertSecretRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ProviderV1Beta3SpecCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProviderV1Beta3SpecCertSecretRef(obj: ProviderV1Beta3SpecCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProxySecretRef specifies the Secret containing the proxy configuration
 * for this Provider. The Secret should contain an 'address' key with the
 * HTTP/S address of the proxy server. Optional 'username' and 'password'
 * keys can be provided for proxy authentication.
 *
 * @schema ProviderV1Beta3SpecProxySecretRef
 */
export interface ProviderV1Beta3SpecProxySecretRef {
  /**
   * Name of the referent.
   *
   * @schema ProviderV1Beta3SpecProxySecretRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ProviderV1Beta3SpecProxySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProviderV1Beta3SpecProxySecretRef(obj: ProviderV1Beta3SpecProxySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef specifies the Secret containing the authentication
 * credentials for this Provider.
 *
 * @schema ProviderV1Beta3SpecSecretRef
 */
export interface ProviderV1Beta3SpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema ProviderV1Beta3SpecSecretRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ProviderV1Beta3SpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProviderV1Beta3SpecSecretRef(obj: ProviderV1Beta3SpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type specifies which Provider implementation to use.
 *
 * @schema ProviderV1Beta3SpecType
 */
export enum ProviderV1Beta3SpecType {
  /** slack */
  SLACK = "slack",
  /** discord */
  DISCORD = "discord",
  /** msteams */
  MSTEAMS = "msteams",
  /** rocket */
  ROCKET = "rocket",
  /** generic */
  GENERIC = "generic",
  /** generic-hmac */
  GENERIC_HYPHEN_HMAC = "generic-hmac",
  /** github */
  GITHUB = "github",
  /** gitlab */
  GITLAB = "gitlab",
  /** gitea */
  GITEA = "gitea",
  /** bitbucketserver */
  BITBUCKETSERVER = "bitbucketserver",
  /** bitbucket */
  BITBUCKET = "bitbucket",
  /** azuredevops */
  AZUREDEVOPS = "azuredevops",
  /** googlechat */
  GOOGLECHAT = "googlechat",
  /** googlepubsub */
  GOOGLEPUBSUB = "googlepubsub",
  /** webex */
  WEBEX = "webex",
  /** sentry */
  SENTRY = "sentry",
  /** azureeventhub */
  AZUREEVENTHUB = "azureeventhub",
  /** telegram */
  TELEGRAM = "telegram",
  /** lark */
  LARK = "lark",
  /** matrix */
  MATRIX = "matrix",
  /** opsgenie */
  OPSGENIE = "opsgenie",
  /** alertmanager */
  ALERTMANAGER = "alertmanager",
  /** grafana */
  GRAFANA = "grafana",
  /** githubdispatch */
  GITHUBDISPATCH = "githubdispatch",
  /** pagerduty */
  PAGERDUTY = "pagerduty",
  /** datadog */
  DATADOG = "datadog",
  /** nats */
  NATS = "nats",
  /** zulip */
  ZULIP = "zulip",
  /** otel */
  OTEL = "otel",
}


/**
 * Receiver is the Schema for the receivers API.
 *
 * @schema Receiver
 */
export class Receiver extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Receiver"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'notification.toolkit.fluxcd.io/v1',
    kind: 'Receiver',
  }

  /**
   * Renders a Kubernetes manifest for "Receiver".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReceiverProps = {}): any {
    return {
      ...Receiver.GVK,
      ...toJson_ReceiverProps(props),
    };
  }

  /**
   * Defines a "Receiver" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ReceiverProps = {}) {
    super(scope, id, {
      ...Receiver.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Receiver.GVK,
      ...toJson_ReceiverProps(resolved),
    };
  }
}

/**
 * Receiver is the Schema for the receivers API.
 *
 * @schema Receiver
 */
export interface ReceiverProps {
  /**
   * @schema Receiver#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ReceiverSpec defines the desired state of the Receiver.
   *
   * @schema Receiver#spec
   */
  readonly spec?: ReceiverSpec;
}

/**
 * Converts an object of type 'ReceiverProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ReceiverProps(obj: ReceiverProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ReceiverSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ReceiverSpec defines the desired state of the Receiver.
 *
 * @schema ReceiverSpec
 */
export interface ReceiverSpec {
  /**
   * Events specifies the list of event types to handle,
   * e.g. 'push' for GitHub or 'Push Hook' for GitLab.
   *
   * @schema ReceiverSpec#events
   */
  readonly events?: string[];

  /**
   * Interval at which to reconcile the Receiver with its Secret references.
   *
   * @schema ReceiverSpec#interval
   */
  readonly interval?: string;

  /**
   * ResourceFilter is a CEL expression expected to return a boolean that is
   * evaluated for each resource referenced in the Resources field when a
   * webhook is received. If the expression returns false then the controller
   * will not request a reconciliation for the resource.
   * When the expression is specified the controller will parse it and mark
   * the object as terminally failed if the expression is invalid or does not
   * return a boolean.
   *
   * @schema ReceiverSpec#resourceFilter
   */
  readonly resourceFilter?: string;

  /**
   * A list of resources to be notified about changes.
   *
   * @schema ReceiverSpec#resources
   */
  readonly resources: ReceiverSpecResources[];

  /**
   * SecretRef specifies the Secret containing the token used
   * to validate the payload authenticity.
   *
   * @schema ReceiverSpec#secretRef
   */
  readonly secretRef: ReceiverSpecSecretRef;

  /**
   * Suspend tells the controller to suspend subsequent
   * events handling for this receiver.
   *
   * @schema ReceiverSpec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Type of webhook sender, used to determine
   * the validation procedure and payload deserialization.
   *
   * @schema ReceiverSpec#type
   */
  readonly type: ReceiverSpecType;
}

/**
 * Converts an object of type 'ReceiverSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ReceiverSpec(obj: ReceiverSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'events': obj.events?.map(y => y),
    'interval': obj.interval,
    'resourceFilter': obj.resourceFilter,
    'resources': obj.resources?.map(y => toJson_ReceiverSpecResources(y)),
    'secretRef': toJson_ReceiverSpecSecretRef(obj.secretRef),
    'suspend': obj.suspend,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CrossNamespaceObjectReference contains enough information to let you locate the
 * typed referenced object at cluster level
 *
 * @schema ReceiverSpecResources
 */
export interface ReceiverSpecResources {
  /**
   * API version of the referent
   *
   * @schema ReceiverSpecResources#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind of the referent
   *
   * @schema ReceiverSpecResources#kind
   */
  readonly kind: ReceiverSpecResourcesKind;

  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   * MatchLabels requires the name to be set to `*`.
   *
   * @schema ReceiverSpecResources#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Name of the referent
   * If multiple resources are targeted `*` may be set.
   *
   * @schema ReceiverSpecResources#name
   */
  readonly name: string;

  /**
   * Namespace of the referent
   *
   * @schema ReceiverSpecResources#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ReceiverSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ReceiverSpecResources(obj: ReceiverSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef specifies the Secret containing the token used
 * to validate the payload authenticity.
 *
 * @schema ReceiverSpecSecretRef
 */
export interface ReceiverSpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema ReceiverSpecSecretRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ReceiverSpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ReceiverSpecSecretRef(obj: ReceiverSpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type of webhook sender, used to determine
 * the validation procedure and payload deserialization.
 *
 * @schema ReceiverSpecType
 */
export enum ReceiverSpecType {
  /** generic */
  GENERIC = "generic",
  /** generic-hmac */
  GENERIC_HYPHEN_HMAC = "generic-hmac",
  /** github */
  GITHUB = "github",
  /** gitlab */
  GITLAB = "gitlab",
  /** bitbucket */
  BITBUCKET = "bitbucket",
  /** harbor */
  HARBOR = "harbor",
  /** dockerhub */
  DOCKERHUB = "dockerhub",
  /** quay */
  QUAY = "quay",
  /** gcr */
  GCR = "gcr",
  /** nexus */
  NEXUS = "nexus",
  /** acr */
  ACR = "acr",
  /** cdevents */
  CDEVENTS = "cdevents",
}

/**
 * Kind of the referent
 *
 * @schema ReceiverSpecResourcesKind
 */
export enum ReceiverSpecResourcesKind {
  /** Bucket */
  BUCKET = "Bucket",
  /** GitRepository */
  GIT_REPOSITORY = "GitRepository",
  /** Kustomization */
  KUSTOMIZATION = "Kustomization",
  /** HelmRelease */
  HELM_RELEASE = "HelmRelease",
  /** HelmChart */
  HELM_CHART = "HelmChart",
  /** HelmRepository */
  HELM_REPOSITORY = "HelmRepository",
  /** ImageRepository */
  IMAGE_REPOSITORY = "ImageRepository",
  /** ImagePolicy */
  IMAGE_POLICY = "ImagePolicy",
  /** ImageUpdateAutomation */
  IMAGE_UPDATE_AUTOMATION = "ImageUpdateAutomation",
  /** OCIRepository */
  OCI_REPOSITORY = "OCIRepository",
}


/**
 * Receiver is the Schema for the receivers API.
 *
 * @schema ReceiverV1Beta2
 */
export class ReceiverV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ReceiverV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'notification.toolkit.fluxcd.io/v1beta2',
    kind: 'Receiver',
  }

  /**
   * Renders a Kubernetes manifest for "ReceiverV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReceiverV1Beta2Props = {}): any {
    return {
      ...ReceiverV1Beta2.GVK,
      ...toJson_ReceiverV1Beta2Props(props),
    };
  }

  /**
   * Defines a "ReceiverV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ReceiverV1Beta2Props = {}) {
    super(scope, id, {
      ...ReceiverV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ReceiverV1Beta2.GVK,
      ...toJson_ReceiverV1Beta2Props(resolved),
    };
  }
}

/**
 * Receiver is the Schema for the receivers API.
 *
 * @schema ReceiverV1Beta2
 */
export interface ReceiverV1Beta2Props {
  /**
   * @schema ReceiverV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ReceiverSpec defines the desired state of the Receiver.
   *
   * @schema ReceiverV1Beta2#spec
   */
  readonly spec?: ReceiverV1Beta2Spec;
}

/**
 * Converts an object of type 'ReceiverV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ReceiverV1Beta2Props(obj: ReceiverV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ReceiverV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ReceiverSpec defines the desired state of the Receiver.
 *
 * @schema ReceiverV1Beta2Spec
 */
export interface ReceiverV1Beta2Spec {
  /**
   * Events specifies the list of event types to handle,
   * e.g. 'push' for GitHub or 'Push Hook' for GitLab.
   *
   * @schema ReceiverV1Beta2Spec#events
   */
  readonly events?: string[];

  /**
   * Interval at which to reconcile the Receiver with its Secret references.
   *
   * @schema ReceiverV1Beta2Spec#interval
   */
  readonly interval?: string;

  /**
   * A list of resources to be notified about changes.
   *
   * @schema ReceiverV1Beta2Spec#resources
   */
  readonly resources: ReceiverV1Beta2SpecResources[];

  /**
   * SecretRef specifies the Secret containing the token used
   * to validate the payload authenticity.
   *
   * @schema ReceiverV1Beta2Spec#secretRef
   */
  readonly secretRef: ReceiverV1Beta2SpecSecretRef;

  /**
   * Suspend tells the controller to suspend subsequent
   * events handling for this receiver.
   *
   * @schema ReceiverV1Beta2Spec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Type of webhook sender, used to determine
   * the validation procedure and payload deserialization.
   *
   * @schema ReceiverV1Beta2Spec#type
   */
  readonly type: ReceiverV1Beta2SpecType;
}

/**
 * Converts an object of type 'ReceiverV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ReceiverV1Beta2Spec(obj: ReceiverV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'events': obj.events?.map(y => y),
    'interval': obj.interval,
    'resources': obj.resources?.map(y => toJson_ReceiverV1Beta2SpecResources(y)),
    'secretRef': toJson_ReceiverV1Beta2SpecSecretRef(obj.secretRef),
    'suspend': obj.suspend,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CrossNamespaceObjectReference contains enough information to let you locate the
 * typed referenced object at cluster level
 *
 * @schema ReceiverV1Beta2SpecResources
 */
export interface ReceiverV1Beta2SpecResources {
  /**
   * API version of the referent
   *
   * @schema ReceiverV1Beta2SpecResources#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind of the referent
   *
   * @schema ReceiverV1Beta2SpecResources#kind
   */
  readonly kind: ReceiverV1Beta2SpecResourcesKind;

  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   * MatchLabels requires the name to be set to `*`.
   *
   * @schema ReceiverV1Beta2SpecResources#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Name of the referent
   * If multiple resources are targeted `*` may be set.
   *
   * @schema ReceiverV1Beta2SpecResources#name
   */
  readonly name: string;

  /**
   * Namespace of the referent
   *
   * @schema ReceiverV1Beta2SpecResources#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ReceiverV1Beta2SpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ReceiverV1Beta2SpecResources(obj: ReceiverV1Beta2SpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef specifies the Secret containing the token used
 * to validate the payload authenticity.
 *
 * @schema ReceiverV1Beta2SpecSecretRef
 */
export interface ReceiverV1Beta2SpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema ReceiverV1Beta2SpecSecretRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ReceiverV1Beta2SpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ReceiverV1Beta2SpecSecretRef(obj: ReceiverV1Beta2SpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type of webhook sender, used to determine
 * the validation procedure and payload deserialization.
 *
 * @schema ReceiverV1Beta2SpecType
 */
export enum ReceiverV1Beta2SpecType {
  /** generic */
  GENERIC = "generic",
  /** generic-hmac */
  GENERIC_HYPHEN_HMAC = "generic-hmac",
  /** github */
  GITHUB = "github",
  /** gitlab */
  GITLAB = "gitlab",
  /** bitbucket */
  BITBUCKET = "bitbucket",
  /** harbor */
  HARBOR = "harbor",
  /** dockerhub */
  DOCKERHUB = "dockerhub",
  /** quay */
  QUAY = "quay",
  /** gcr */
  GCR = "gcr",
  /** nexus */
  NEXUS = "nexus",
  /** acr */
  ACR = "acr",
}

/**
 * Kind of the referent
 *
 * @schema ReceiverV1Beta2SpecResourcesKind
 */
export enum ReceiverV1Beta2SpecResourcesKind {
  /** Bucket */
  BUCKET = "Bucket",
  /** GitRepository */
  GIT_REPOSITORY = "GitRepository",
  /** Kustomization */
  KUSTOMIZATION = "Kustomization",
  /** HelmRelease */
  HELM_RELEASE = "HelmRelease",
  /** HelmChart */
  HELM_CHART = "HelmChart",
  /** HelmRepository */
  HELM_REPOSITORY = "HelmRepository",
  /** ImageRepository */
  IMAGE_REPOSITORY = "ImageRepository",
  /** ImagePolicy */
  IMAGE_POLICY = "ImagePolicy",
  /** ImageUpdateAutomation */
  IMAGE_UPDATE_AUTOMATION = "ImageUpdateAutomation",
  /** OCIRepository */
  OCI_REPOSITORY = "OCIRepository",
}

