// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * GarageAdminToken is the Schema for the garageadmintokens API
It manages admin API tokens for Garage clusters
 *
 * @schema GarageAdminToken
 */
export class GarageAdminToken extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GarageAdminToken"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'garage.rajsingh.info/v1alpha1',
    kind: 'GarageAdminToken',
  }

  /**
   * Renders a Kubernetes manifest for "GarageAdminToken".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GarageAdminTokenProps): any {
    return {
      ...GarageAdminToken.GVK,
      ...toJson_GarageAdminTokenProps(props),
    };
  }

  /**
   * Defines a "GarageAdminToken" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GarageAdminTokenProps) {
    super(scope, id, {
      ...GarageAdminToken.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...GarageAdminToken.GVK,
      ...toJson_GarageAdminTokenProps(resolved),
    };
  }
}

/**
 * GarageAdminToken is the Schema for the garageadmintokens API
 * It manages admin API tokens for Garage clusters
 *
 * @schema GarageAdminToken
 */
export interface GarageAdminTokenProps {
  /**
   * @schema GarageAdminToken#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GarageAdminTokenSpec defines the desired state of GarageAdminToken
   * Admin tokens are used to authenticate with the Garage Admin API.
   * They are separate from S3 access keys (GarageKey).
   *
   * Note: This operator uses file-based admin tokens (loaded via admin_token_file in TOML config).
   * File-based tokens always have full admin access. For scoped/restricted tokens, use Garage's
   * Admin API token management (CreateAdminToken, UpdateAdminToken) directly.
   *
   * @schema GarageAdminToken#spec
   */
  readonly spec: GarageAdminTokenSpec;
}

/**
 * Converts an object of type 'GarageAdminTokenProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageAdminTokenProps(obj: GarageAdminTokenProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GarageAdminTokenSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GarageAdminTokenSpec defines the desired state of GarageAdminToken
 * Admin tokens are used to authenticate with the Garage Admin API.
 * They are separate from S3 access keys (GarageKey).
 *
 * Note: This operator uses file-based admin tokens (loaded via admin_token_file in TOML config).
 * File-based tokens always have full admin access. For scoped/restricted tokens, use Garage's
 * Admin API token management (CreateAdminToken, UpdateAdminToken) directly.
 *
 * @schema GarageAdminTokenSpec
 */
export interface GarageAdminTokenSpec {
  /**
   * ClusterRef references the GarageCluster this token belongs to
   *
   * @schema GarageAdminTokenSpec#clusterRef
   */
  readonly clusterRef: GarageAdminTokenSpecClusterRef;

  /**
   * Expiration sets when this token expires (RFC 3339 format)
   * Note: Expiration is tracked by the operator but not enforced by Garage
   * for file-based tokens. Token rotation must be done manually.
   *
   * @schema GarageAdminTokenSpec#expiration
   */
  readonly expiration?: string;

  /**
   * Name is a friendly name for this admin token
   * If not set, metadata.name is used
   *
   * @schema GarageAdminTokenSpec#name
   */
  readonly name?: string;

  /**
   * NeverExpires sets the token to never expire
   * Mutually exclusive with Expiration
   *
   * @schema GarageAdminTokenSpec#neverExpires
   */
  readonly neverExpires?: boolean;

  /**
   * SecretTemplate configures how the secret containing the token is generated
   *
   * @schema GarageAdminTokenSpec#secretTemplate
   */
  readonly secretTemplate?: GarageAdminTokenSpecSecretTemplate;
}

/**
 * Converts an object of type 'GarageAdminTokenSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageAdminTokenSpec(obj: GarageAdminTokenSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterRef': toJson_GarageAdminTokenSpecClusterRef(obj.clusterRef),
    'expiration': obj.expiration,
    'name': obj.name,
    'neverExpires': obj.neverExpires,
    'secretTemplate': toJson_GarageAdminTokenSpecSecretTemplate(obj.secretTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterRef references the GarageCluster this token belongs to
 *
 * @schema GarageAdminTokenSpecClusterRef
 */
export interface GarageAdminTokenSpecClusterRef {
  /**
   * KubeConfigSecretRef references a secret containing kubeconfig for a remote cluster.
   * Only used for cross-cluster references in multi-cluster federation scenarios.
   *
   * @schema GarageAdminTokenSpecClusterRef#kubeConfigSecretRef
   */
  readonly kubeConfigSecretRef?: GarageAdminTokenSpecClusterRefKubeConfigSecretRef;

  /**
   * Name of the GarageCluster
   *
   * @schema GarageAdminTokenSpecClusterRef#name
   */
  readonly name: string;

  /**
   * Namespace of the GarageCluster (defaults to the same namespace as the referencing resource)
   *
   * @schema GarageAdminTokenSpecClusterRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'GarageAdminTokenSpecClusterRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageAdminTokenSpecClusterRef(obj: GarageAdminTokenSpecClusterRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kubeConfigSecretRef': toJson_GarageAdminTokenSpecClusterRefKubeConfigSecretRef(obj.kubeConfigSecretRef),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretTemplate configures how the secret containing the token is generated
 *
 * @schema GarageAdminTokenSpecSecretTemplate
 */
export interface GarageAdminTokenSpecSecretTemplate {
  /**
   * Annotations to add to the secret
   *
   * @schema GarageAdminTokenSpecSecretTemplate#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * EndpointKey is the key name for the admin endpoint
   *
   * @schema GarageAdminTokenSpecSecretTemplate#endpointKey
   */
  readonly endpointKey?: string;

  /**
   * IncludeEndpoint includes the admin API endpoint in the secret
   * Defaults to true if not specified
   *
   * @default true if not specified
   * @schema GarageAdminTokenSpecSecretTemplate#includeEndpoint
   */
  readonly includeEndpoint?: boolean;

  /**
   * Labels to add to the secret
   *
   * @schema GarageAdminTokenSpecSecretTemplate#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name is the name of the secret to create
   * Defaults to the GarageAdminToken name
   *
   * @default the GarageAdminToken name
   * @schema GarageAdminTokenSpecSecretTemplate#name
   */
  readonly name?: string;

  /**
   * Namespace is the namespace for the secret
   * Defaults to the GarageAdminToken namespace
   *
   * @default the GarageAdminToken namespace
   * @schema GarageAdminTokenSpecSecretTemplate#namespace
   */
  readonly namespace?: string;

  /**
   * TokenKey is the key name for the admin token in the secret
   *
   * @schema GarageAdminTokenSpecSecretTemplate#tokenKey
   */
  readonly tokenKey?: string;
}

/**
 * Converts an object of type 'GarageAdminTokenSpecSecretTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageAdminTokenSpecSecretTemplate(obj: GarageAdminTokenSpecSecretTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'endpointKey': obj.endpointKey,
    'includeEndpoint': obj.includeEndpoint,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
    'tokenKey': obj.tokenKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KubeConfigSecretRef references a secret containing kubeconfig for a remote cluster.
 * Only used for cross-cluster references in multi-cluster federation scenarios.
 *
 * @schema GarageAdminTokenSpecClusterRefKubeConfigSecretRef
 */
export interface GarageAdminTokenSpecClusterRefKubeConfigSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GarageAdminTokenSpecClusterRefKubeConfigSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema GarageAdminTokenSpecClusterRefKubeConfigSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GarageAdminTokenSpecClusterRefKubeConfigSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'GarageAdminTokenSpecClusterRefKubeConfigSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageAdminTokenSpecClusterRefKubeConfigSecretRef(obj: GarageAdminTokenSpecClusterRefKubeConfigSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * GarageBucket is the Schema for the garagebuckets API
 *
 * @schema GarageBucket
 */
export class GarageBucket extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GarageBucket"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'garage.rajsingh.info/v1alpha1',
    kind: 'GarageBucket',
  }

  /**
   * Renders a Kubernetes manifest for "GarageBucket".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GarageBucketProps): any {
    return {
      ...GarageBucket.GVK,
      ...toJson_GarageBucketProps(props),
    };
  }

  /**
   * Defines a "GarageBucket" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GarageBucketProps) {
    super(scope, id, {
      ...GarageBucket.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...GarageBucket.GVK,
      ...toJson_GarageBucketProps(resolved),
    };
  }
}

/**
 * GarageBucket is the Schema for the garagebuckets API
 *
 * @schema GarageBucket
 */
export interface GarageBucketProps {
  /**
   * @schema GarageBucket#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GarageBucketSpec defines the desired state of GarageBucket
   *
   * @schema GarageBucket#spec
   */
  readonly spec: GarageBucketSpec;
}

/**
 * Converts an object of type 'GarageBucketProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageBucketProps(obj: GarageBucketProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GarageBucketSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GarageBucketSpec defines the desired state of GarageBucket
 *
 * @schema GarageBucketSpec
 */
export interface GarageBucketSpec {
  /**
   * ClusterRef references the GarageCluster this bucket belongs to
   *
   * @schema GarageBucketSpec#clusterRef
   */
  readonly clusterRef: GarageBucketSpecClusterRef;

  /**
   * GlobalAlias is the global alias for this bucket (optional)
   * If not set, the bucket name from metadata.name is used
   *
   * @schema GarageBucketSpec#globalAlias
   */
  readonly globalAlias?: string;

  /**
   * KeyPermissions grants access to specific GarageKeys.
   *
   * Note: Permissions can be granted from either direction:
   * - Here (GarageBucket.keyPermissions): Grant keys access to this bucket
   * - On GarageKey (GarageKey.bucketPermissions): Grant the key access to buckets
   *
   * Both approaches are equivalent and result in the same Garage API calls.
   * Use whichever is more convenient for your workflow:
   * - Bucket-centric: Define all key access on the bucket
   * - Key-centric: Define all bucket access on the key
   *
   * If the same permission is defined in both places, they are merged (not conflicting).
   *
   * @schema GarageBucketSpec#keyPermissions
   */
  readonly keyPermissions?: GarageBucketSpecKeyPermissions[];

  /**
   * LocalAliases are per-key local aliases for this bucket
   *
   * @schema GarageBucketSpec#localAliases
   */
  readonly localAliases?: GarageBucketSpecLocalAliases[];

  /**
   * Quotas configures bucket quotas
   *
   * @schema GarageBucketSpec#quotas
   */
  readonly quotas?: GarageBucketSpecQuotas;

  /**
   * Website configures static website hosting for this bucket.
   * Note: Only indexDocument and errorDocument are supported via the Admin API.
   * For advanced features (routing rules, redirectAll), use S3 PutBucketWebsite API directly.
   *
   * @schema GarageBucketSpec#website
   */
  readonly website?: GarageBucketSpecWebsite;
}

/**
 * Converts an object of type 'GarageBucketSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageBucketSpec(obj: GarageBucketSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterRef': toJson_GarageBucketSpecClusterRef(obj.clusterRef),
    'globalAlias': obj.globalAlias,
    'keyPermissions': obj.keyPermissions?.map(y => toJson_GarageBucketSpecKeyPermissions(y)),
    'localAliases': obj.localAliases?.map(y => toJson_GarageBucketSpecLocalAliases(y)),
    'quotas': toJson_GarageBucketSpecQuotas(obj.quotas),
    'website': toJson_GarageBucketSpecWebsite(obj.website),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterRef references the GarageCluster this bucket belongs to
 *
 * @schema GarageBucketSpecClusterRef
 */
export interface GarageBucketSpecClusterRef {
  /**
   * KubeConfigSecretRef references a secret containing kubeconfig for a remote cluster.
   * Only used for cross-cluster references in multi-cluster federation scenarios.
   *
   * @schema GarageBucketSpecClusterRef#kubeConfigSecretRef
   */
  readonly kubeConfigSecretRef?: GarageBucketSpecClusterRefKubeConfigSecretRef;

  /**
   * Name of the GarageCluster
   *
   * @schema GarageBucketSpecClusterRef#name
   */
  readonly name: string;

  /**
   * Namespace of the GarageCluster (defaults to the same namespace as the referencing resource)
   *
   * @schema GarageBucketSpecClusterRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'GarageBucketSpecClusterRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageBucketSpecClusterRef(obj: GarageBucketSpecClusterRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kubeConfigSecretRef': toJson_GarageBucketSpecClusterRefKubeConfigSecretRef(obj.kubeConfigSecretRef),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KeyPermission grants access to a key
 *
 * @schema GarageBucketSpecKeyPermissions
 */
export interface GarageBucketSpecKeyPermissions {
  /**
   * KeyRef references the GarageKey by name
   *
   * @schema GarageBucketSpecKeyPermissions#keyRef
   */
  readonly keyRef: string;

  /**
   * Owner allows bucket owner operations
   *
   * @schema GarageBucketSpecKeyPermissions#owner
   */
  readonly owner?: boolean;

  /**
   * Read allows reading objects
   *
   * @schema GarageBucketSpecKeyPermissions#read
   */
  readonly read?: boolean;

  /**
   * Write allows writing objects
   *
   * @schema GarageBucketSpecKeyPermissions#write
   */
  readonly write?: boolean;
}

/**
 * Converts an object of type 'GarageBucketSpecKeyPermissions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageBucketSpecKeyPermissions(obj: GarageBucketSpecKeyPermissions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyRef': obj.keyRef,
    'owner': obj.owner,
    'read': obj.read,
    'write': obj.write,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalAlias represents a per-key local alias for a bucket
 *
 * @schema GarageBucketSpecLocalAliases
 */
export interface GarageBucketSpecLocalAliases {
  /**
   * Alias is the local alias name
   *
   * @schema GarageBucketSpecLocalAliases#alias
   */
  readonly alias: string;

  /**
   * KeyRef references the GarageKey
   *
   * @schema GarageBucketSpecLocalAliases#keyRef
   */
  readonly keyRef: string;
}

/**
 * Converts an object of type 'GarageBucketSpecLocalAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageBucketSpecLocalAliases(obj: GarageBucketSpecLocalAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alias': obj.alias,
    'keyRef': obj.keyRef,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Quotas configures bucket quotas
 *
 * @schema GarageBucketSpecQuotas
 */
export interface GarageBucketSpecQuotas {
  /**
   * MaxObjects is the maximum number of objects
   *
   * @schema GarageBucketSpecQuotas#maxObjects
   */
  readonly maxObjects?: number;

  /**
   * MaxSize is the maximum bucket size in bytes
   *
   * @schema GarageBucketSpecQuotas#maxSize
   */
  readonly maxSize?: GarageBucketSpecQuotasMaxSize;
}

/**
 * Converts an object of type 'GarageBucketSpecQuotas' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageBucketSpecQuotas(obj: GarageBucketSpecQuotas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxObjects': obj.maxObjects,
    'maxSize': obj.maxSize?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Website configures static website hosting for this bucket.
 * Note: Only indexDocument and errorDocument are supported via the Admin API.
 * For advanced features (routing rules, redirectAll), use S3 PutBucketWebsite API directly.
 *
 * @schema GarageBucketSpecWebsite
 */
export interface GarageBucketSpecWebsite {
  /**
   * Enabled enables static website hosting
   *
   * @schema GarageBucketSpecWebsite#enabled
   */
  readonly enabled?: boolean;

  /**
   * ErrorDocument is the error document to serve for 404s
   *
   * @schema GarageBucketSpecWebsite#errorDocument
   */
  readonly errorDocument?: string;

  /**
   * IndexDocument is the default index document (default: index.html)
   *
   * @schema GarageBucketSpecWebsite#indexDocument
   */
  readonly indexDocument?: string;
}

/**
 * Converts an object of type 'GarageBucketSpecWebsite' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageBucketSpecWebsite(obj: GarageBucketSpecWebsite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'errorDocument': obj.errorDocument,
    'indexDocument': obj.indexDocument,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KubeConfigSecretRef references a secret containing kubeconfig for a remote cluster.
 * Only used for cross-cluster references in multi-cluster federation scenarios.
 *
 * @schema GarageBucketSpecClusterRefKubeConfigSecretRef
 */
export interface GarageBucketSpecClusterRefKubeConfigSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GarageBucketSpecClusterRefKubeConfigSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema GarageBucketSpecClusterRefKubeConfigSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GarageBucketSpecClusterRefKubeConfigSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'GarageBucketSpecClusterRefKubeConfigSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageBucketSpecClusterRefKubeConfigSecretRef(obj: GarageBucketSpecClusterRefKubeConfigSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MaxSize is the maximum bucket size in bytes
 *
 * @schema GarageBucketSpecQuotasMaxSize
 */
export class GarageBucketSpecQuotasMaxSize {
  public static fromNumber(value: number): GarageBucketSpecQuotasMaxSize {
    return new GarageBucketSpecQuotasMaxSize(value);
  }
  public static fromString(value: string): GarageBucketSpecQuotasMaxSize {
    return new GarageBucketSpecQuotasMaxSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}


/**
 * GarageCluster is the Schema for the garageclusters API
 *
 * @schema GarageCluster
 */
export class GarageCluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GarageCluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'garage.rajsingh.info/v1alpha1',
    kind: 'GarageCluster',
  }

  /**
   * Renders a Kubernetes manifest for "GarageCluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GarageClusterProps): any {
    return {
      ...GarageCluster.GVK,
      ...toJson_GarageClusterProps(props),
    };
  }

  /**
   * Defines a "GarageCluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GarageClusterProps) {
    super(scope, id, {
      ...GarageCluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...GarageCluster.GVK,
      ...toJson_GarageClusterProps(resolved),
    };
  }
}

/**
 * GarageCluster is the Schema for the garageclusters API
 *
 * @schema GarageCluster
 */
export interface GarageClusterProps {
  /**
   * @schema GarageCluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GarageClusterSpec defines the desired state of GarageCluster
   *
   * @schema GarageCluster#spec
   */
  readonly spec: GarageClusterSpec;
}

/**
 * Converts an object of type 'GarageClusterProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterProps(obj: GarageClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GarageClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GarageClusterSpec defines the desired state of GarageCluster
 *
 * @schema GarageClusterSpec
 */
export interface GarageClusterSpec {
  /**
   * Admin configures the admin API endpoint and metrics
   *
   * @schema GarageClusterSpec#admin
   */
  readonly admin?: GarageClusterSpecAdmin;

  /**
   * Affinity for pod scheduling
   *
   * @schema GarageClusterSpec#affinity
   */
  readonly affinity?: GarageClusterSpecAffinity;

  /**
   * Blocks configures block storage settings
   *
   * @schema GarageClusterSpec#blocks
   */
  readonly blocks?: GarageClusterSpecBlocks;

  /**
   * CapacityReservePercent reserves a percentage of PVC capacity for overhead.
   * Only used when LayoutPolicy is "Auto".
   * For example, setting this to 10 will report 90% of PVC size as node capacity.
   * This is useful to reserve headroom for filesystem overhead, snapshots, or growth.
   * Default: 0 (use full PVC size as capacity)
   *
   * @schema GarageClusterSpec#capacityReservePercent
   */
  readonly capacityReservePercent?: number;

  /**
   * ConnectTo specifies the storage cluster this gateway cluster connects to.
   * Required when gateway=true. The gateway cluster will:
   * - Use the same RPC secret as the storage cluster
   * - Connect to the storage cluster's nodes
   * - Register its pods as gateway nodes in the storage cluster's layout
   *
   * @schema GarageClusterSpec#connectTo
   */
  readonly connectTo?: GarageClusterSpecConnectTo;

  /**
   * ContainerSecurityContext for Garage containers
   *
   * @schema GarageClusterSpec#containerSecurityContext
   */
  readonly containerSecurityContext?: GarageClusterSpecContainerSecurityContext;

  /**
   * Database configures the metadata database engine
   *
   * @schema GarageClusterSpec#database
   */
  readonly database?: GarageClusterSpecDatabase;

  /**
   * DefaultNodeTags are tags applied to all auto-managed nodes.
   * Only used when LayoutPolicy is "Auto".
   * For per-node tags, use LayoutPolicy "Manual" with GarageNode resources.
   *
   * @schema GarageClusterSpec#defaultNodeTags
   */
  readonly defaultNodeTags?: string[];

  /**
   * Discovery configures peer discovery mechanisms
   *
   * @schema GarageClusterSpec#discovery
   */
  readonly discovery?: GarageClusterSpecDiscovery;

  /**
   * Gateway marks this cluster as a gateway-only cluster.
   * Gateway clusters don't store data - they only handle API requests.
   * When true:
   * - Creates a StatefulSet with metadata PVC only (for node identity persistence)
   * - Data storage uses EmptyDir (gateways don't store blocks)
   * - Pods are registered as gateway nodes in the layout (capacity=null)
   * - Must specify connectTo to reference a storage cluster
   *
   * @schema GarageClusterSpec#gateway
   */
  readonly gateway?: boolean;

  /**
   * Image specifies the Garage container image to use.
   * Takes precedence over imageRepository if both are set.
   *
   * @schema GarageClusterSpec#image
   */
  readonly image?: string;

  /**
   * ImagePullPolicy specifies the image pull policy
   *
   * @schema GarageClusterSpec#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * ImagePullSecrets specifies secrets for pulling images from private registries
   *
   * @schema GarageClusterSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: GarageClusterSpecImagePullSecrets[];

  /**
   * ImageRepository overrides just the repository portion of the default Garage image,
   * preserving the default tag for automatic version upgrades.
   * For example, setting this to "my-mirror/garage" with the default tag v2.2.0
   * produces "my-mirror/garage:v2.2.0".
   * Ignored if image is set.
   *
   * @schema GarageClusterSpec#imageRepository
   */
  readonly imageRepository?: string;

  /**
   * K2VAPI configures the K2V (key-value) API endpoint
   *
   * @schema GarageClusterSpec#k2vApi
   */
  readonly k2VApi?: GarageClusterSpecK2VApi;

  /**
   * LayoutManagement controls how the cluster layout is managed
   *
   * @schema GarageClusterSpec#layoutManagement
   */
  readonly layoutManagement?: GarageClusterSpecLayoutManagement;

  /**
   * LayoutPolicy controls whether node layouts are automatically managed or manually configured.
   * - "Auto": The controller automatically assigns all local pods to the layout using the
   * cluster's zone and derives capacity from data PVC size. No GarageNode resources needed.
   * - "Manual": You must create GarageNode resources for each node you want in the layout.
   * Use this for fine-grained control over zones, capacities, or external nodes.
   *
   * @schema GarageClusterSpec#layoutPolicy
   */
  readonly layoutPolicy?: GarageClusterSpecLayoutPolicy;

  /**
   * Logging configures logging behavior for Garage nodes
   *
   * @schema GarageClusterSpec#logging
   */
  readonly logging?: GarageClusterSpecLogging;

  /**
   * Network configures RPC and API networking
   *
   * @schema GarageClusterSpec#network
   */
  readonly network?: GarageClusterSpecNetwork;

  /**
   * NodeSelector for pod scheduling
   *
   * @schema GarageClusterSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * PodAnnotations to add to Garage pods
   *
   * @schema GarageClusterSpec#podAnnotations
   */
  readonly podAnnotations?: { [key: string]: string };

  /**
   * PodDisruptionBudget configures the PodDisruptionBudget for the cluster
   *
   * @schema GarageClusterSpec#podDisruptionBudget
   */
  readonly podDisruptionBudget?: GarageClusterSpecPodDisruptionBudget;

  /**
   * PodLabels to add to Garage pods
   *
   * @schema GarageClusterSpec#podLabels
   */
  readonly podLabels?: { [key: string]: string };

  /**
   * PriorityClassName for Garage pods
   *
   * @schema GarageClusterSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * PublicEndpoint configures how remote clusters reach this cluster's nodes
   * Required for multi-cluster federation
   *
   * @schema GarageClusterSpec#publicEndpoint
   */
  readonly publicEndpoint?: GarageClusterSpecPublicEndpoint;

  /**
   * RemoteClusters are Garage clusters in other Kubernetes clusters
   * The operator will auto-discover nodes and coordinate layout
   *
   * @schema GarageClusterSpec#remoteClusters
   */
  readonly remoteClusters?: GarageClusterSpecRemoteClusters[];

  /**
   * Replicas is the number of Garage nodes to deploy in this cluster
   *
   * @schema GarageClusterSpec#replicas
   */
  readonly replicas: number;

  /**
   * Replication configures data replication settings
   *
   * @schema GarageClusterSpec#replication
   */
  readonly replication: GarageClusterSpecReplication;

  /**
   * Resources specifies compute resources for Garage pods
   *
   * @schema GarageClusterSpec#resources
   */
  readonly resources?: GarageClusterSpecResources;

  /**
   * S3API configures the S3-compatible API endpoint
   *
   * @schema GarageClusterSpec#s3Api
   */
  readonly s3Api?: GarageClusterSpecS3Api;

  /**
   * Security configures security-related settings
   *
   * @schema GarageClusterSpec#security
   */
  readonly security?: GarageClusterSpecSecurity;

  /**
   * SecurityContext for Garage pods
   *
   * @schema GarageClusterSpec#securityContext
   */
  readonly securityContext?: GarageClusterSpecSecurityContext;

  /**
   * ServiceAccountName for Garage pods
   *
   * @schema GarageClusterSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * ServiceAnnotations to add to Garage services
   *
   * @schema GarageClusterSpec#serviceAnnotations
   */
  readonly serviceAnnotations?: { [key: string]: string };

  /**
   * Storage configures storage settings for metadata and data.
   * Optional - sensible defaults are provided:
   * - Storage clusters: 10Gi metadata, 100Gi data
   * - Gateway clusters: 1Gi metadata only (data uses EmptyDir)
   *
   * @schema GarageClusterSpec#storage
   */
  readonly storage?: GarageClusterSpecStorage;

  /**
   * Tolerations for pod scheduling
   *
   * @schema GarageClusterSpec#tolerations
   */
  readonly tolerations?: GarageClusterSpecTolerations[];

  /**
   * TopologySpreadConstraints for pod scheduling
   *
   * @schema GarageClusterSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: GarageClusterSpecTopologySpreadConstraints[];

  /**
   * WebAPI configures the static website hosting endpoint
   *
   * @schema GarageClusterSpec#webApi
   */
  readonly webApi?: GarageClusterSpecWebApi;

  /**
   * Zone is the zone name for all nodes in this cluster.
   * Used for fault tolerance - Garage distributes replicas across zones.
   * Required for multi-cluster federation.
   *
   * Examples: "us-east-1", "rack-a", "dc1", "zone-a"
   *
   * @schema GarageClusterSpec#zone
   */
  readonly zone?: string;
}

/**
 * Converts an object of type 'GarageClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpec(obj: GarageClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'admin': toJson_GarageClusterSpecAdmin(obj.admin),
    'affinity': toJson_GarageClusterSpecAffinity(obj.affinity),
    'blocks': toJson_GarageClusterSpecBlocks(obj.blocks),
    'capacityReservePercent': obj.capacityReservePercent,
    'connectTo': toJson_GarageClusterSpecConnectTo(obj.connectTo),
    'containerSecurityContext': toJson_GarageClusterSpecContainerSecurityContext(obj.containerSecurityContext),
    'database': toJson_GarageClusterSpecDatabase(obj.database),
    'defaultNodeTags': obj.defaultNodeTags?.map(y => y),
    'discovery': toJson_GarageClusterSpecDiscovery(obj.discovery),
    'gateway': obj.gateway,
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_GarageClusterSpecImagePullSecrets(y)),
    'imageRepository': obj.imageRepository,
    'k2vApi': toJson_GarageClusterSpecK2VApi(obj.k2VApi),
    'layoutManagement': toJson_GarageClusterSpecLayoutManagement(obj.layoutManagement),
    'layoutPolicy': obj.layoutPolicy,
    'logging': toJson_GarageClusterSpecLogging(obj.logging),
    'network': toJson_GarageClusterSpecNetwork(obj.network),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'podAnnotations': ((obj.podAnnotations) === undefined) ? undefined : (Object.entries(obj.podAnnotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'podDisruptionBudget': toJson_GarageClusterSpecPodDisruptionBudget(obj.podDisruptionBudget),
    'podLabels': ((obj.podLabels) === undefined) ? undefined : (Object.entries(obj.podLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'priorityClassName': obj.priorityClassName,
    'publicEndpoint': toJson_GarageClusterSpecPublicEndpoint(obj.publicEndpoint),
    'remoteClusters': obj.remoteClusters?.map(y => toJson_GarageClusterSpecRemoteClusters(y)),
    'replicas': obj.replicas,
    'replication': toJson_GarageClusterSpecReplication(obj.replication),
    'resources': toJson_GarageClusterSpecResources(obj.resources),
    's3Api': toJson_GarageClusterSpecS3Api(obj.s3Api),
    'security': toJson_GarageClusterSpecSecurity(obj.security),
    'securityContext': toJson_GarageClusterSpecSecurityContext(obj.securityContext),
    'serviceAccountName': obj.serviceAccountName,
    'serviceAnnotations': ((obj.serviceAnnotations) === undefined) ? undefined : (Object.entries(obj.serviceAnnotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'storage': toJson_GarageClusterSpecStorage(obj.storage),
    'tolerations': obj.tolerations?.map(y => toJson_GarageClusterSpecTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_GarageClusterSpecTopologySpreadConstraints(y)),
    'webApi': toJson_GarageClusterSpecWebApi(obj.webApi),
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Admin configures the admin API endpoint and metrics
 *
 * @schema GarageClusterSpecAdmin
 */
export interface GarageClusterSpecAdmin {
  /**
   * AdminTokenSecretRef references a secret containing the admin API token
   *
   * @schema GarageClusterSpecAdmin#adminTokenSecretRef
   */
  readonly adminTokenSecretRef?: GarageClusterSpecAdminAdminTokenSecretRef;

  /**
   * BindAddress is a custom bind address for the Admin API.
   * Can be a TCP address or Unix socket path (e.g., "unix:///run/garage/admin.sock").
   * If set, this overrides BindPort.
   *
   * @schema GarageClusterSpecAdmin#bindAddress
   */
  readonly bindAddress?: string;

  /**
   * BindPort is the port to bind for admin API
   *
   * @schema GarageClusterSpecAdmin#bindPort
   */
  readonly bindPort?: number;

  /**
   * Enabled enables the admin API
   *
   * @schema GarageClusterSpecAdmin#enabled
   */
  readonly enabled?: boolean;

  /**
   * MetricsRequireToken requires authentication for /metrics endpoint
   *
   * @schema GarageClusterSpecAdmin#metricsRequireToken
   */
  readonly metricsRequireToken?: boolean;

  /**
   * MetricsTokenSecretRef references a secret containing the metrics token
   *
   * @schema GarageClusterSpecAdmin#metricsTokenSecretRef
   */
  readonly metricsTokenSecretRef?: GarageClusterSpecAdminMetricsTokenSecretRef;

  /**
   * TraceSink is the OpenTelemetry collector address for tracing
   * Example: "http://localhost:4317"
   *
   * @schema GarageClusterSpecAdmin#traceSink
   */
  readonly traceSink?: string;
}

/**
 * Converts an object of type 'GarageClusterSpecAdmin' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAdmin(obj: GarageClusterSpecAdmin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'adminTokenSecretRef': toJson_GarageClusterSpecAdminAdminTokenSecretRef(obj.adminTokenSecretRef),
    'bindAddress': obj.bindAddress,
    'bindPort': obj.bindPort,
    'enabled': obj.enabled,
    'metricsRequireToken': obj.metricsRequireToken,
    'metricsTokenSecretRef': toJson_GarageClusterSpecAdminMetricsTokenSecretRef(obj.metricsTokenSecretRef),
    'traceSink': obj.traceSink,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Affinity for pod scheduling
 *
 * @schema GarageClusterSpecAffinity
 */
export interface GarageClusterSpecAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema GarageClusterSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: GarageClusterSpecAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema GarageClusterSpecAffinity#podAffinity
   */
  readonly podAffinity?: GarageClusterSpecAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema GarageClusterSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: GarageClusterSpecAffinityPodAntiAffinity;
}

/**
 * Converts an object of type 'GarageClusterSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinity(obj: GarageClusterSpecAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_GarageClusterSpecAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_GarageClusterSpecAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_GarageClusterSpecAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Blocks configures block storage settings
 *
 * @schema GarageClusterSpecBlocks
 */
export interface GarageClusterSpecBlocks {
  /**
   * CompressionLevel is the zstd compression level
   * 1-19: standard, 20-22: ultra, -1 to -99: fast, "none": disabled
   *
   * @schema GarageClusterSpecBlocks#compressionLevel
   */
  readonly compressionLevel?: string;

  /**
   * DisableScrub disables automatic monthly data directory scrub
   *
   * @schema GarageClusterSpecBlocks#disableScrub
   */
  readonly disableScrub?: boolean;

  /**
   * MaxConcurrentReads is the maximum simultaneous block file reads
   *
   * @schema GarageClusterSpecBlocks#maxConcurrentReads
   */
  readonly maxConcurrentReads?: number;

  /**
   * MaxConcurrentWritesPerRequest is the maximum parallel block writes per PUT request.
   * Higher values improve throughput but increase memory usage.
   * Default: 3. Recommended: 10-30 for NVMe, 3-10 for HDD.
   * Added in Garage v2.2.0.
   *
   * @schema GarageClusterSpecBlocks#maxConcurrentWritesPerRequest
   */
  readonly maxConcurrentWritesPerRequest?: number;

  /**
   * RAMBufferMax is the maximum RAM for buffering blocks
   *
   * @schema GarageClusterSpecBlocks#ramBufferMax
   */
  readonly ramBufferMax?: GarageClusterSpecBlocksRamBufferMax;

  /**
   * Size is the size of data blocks (default: 1M)
   *
   * @schema GarageClusterSpecBlocks#size
   */
  readonly size?: GarageClusterSpecBlocksSize;

  /**
   * UseLocalTZ runs lifecycle worker at midnight in local timezone
   *
   * @schema GarageClusterSpecBlocks#useLocalTZ
   */
  readonly useLocalTz?: boolean;
}

/**
 * Converts an object of type 'GarageClusterSpecBlocks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecBlocks(obj: GarageClusterSpecBlocks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'compressionLevel': obj.compressionLevel,
    'disableScrub': obj.disableScrub,
    'maxConcurrentReads': obj.maxConcurrentReads,
    'maxConcurrentWritesPerRequest': obj.maxConcurrentWritesPerRequest,
    'ramBufferMax': obj.ramBufferMax?.value,
    'size': obj.size?.value,
    'useLocalTZ': obj.useLocalTz,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConnectTo specifies the storage cluster this gateway cluster connects to.
 * Required when gateway=true. The gateway cluster will:
 * - Use the same RPC secret as the storage cluster
 * - Connect to the storage cluster's nodes
 * - Register its pods as gateway nodes in the storage cluster's layout
 *
 * @schema GarageClusterSpecConnectTo
 */
export interface GarageClusterSpecConnectTo {
  /**
   * AdminAPIEndpoint is the admin API endpoint for discovering nodes and registering gateways
   * Required if clusterRef is not in the same namespace
   * Example: "http://garage-storage.other-namespace:3903"
   *
   * @schema GarageClusterSpecConnectTo#adminApiEndpoint
   */
  readonly adminApiEndpoint?: string;

  /**
   * AdminTokenSecretRef references the admin token for the storage cluster
   * If clusterRef is specified and in same namespace, uses that cluster's token
   *
   * @schema GarageClusterSpecConnectTo#adminTokenSecretRef
   */
  readonly adminTokenSecretRef?: GarageClusterSpecConnectToAdminTokenSecretRef;

  /**
   * BootstrapPeers are the initial peers to connect to (for external storage clusters)
   * Format: "<node_public_key>@<ip_or_hostname>:<port>"
   *
   * @schema GarageClusterSpecConnectTo#bootstrapPeers
   */
  readonly bootstrapPeers?: string[];

  /**
   * ClusterRef references a GarageCluster in the same namespace
   * The gateway will use this cluster's RPC secret and connect to its nodes
   *
   * @schema GarageClusterSpecConnectTo#clusterRef
   */
  readonly clusterRef?: GarageClusterSpecConnectToClusterRef;

  /**
   * RPCSecretRef references a shared RPC secret (for cross-namespace or external clusters)
   * If clusterRef is specified, this is ignored (uses the referenced cluster's secret)
   *
   * @schema GarageClusterSpecConnectTo#rpcSecretRef
   */
  readonly rpcSecretRef?: GarageClusterSpecConnectToRpcSecretRef;
}

/**
 * Converts an object of type 'GarageClusterSpecConnectTo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecConnectTo(obj: GarageClusterSpecConnectTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'adminApiEndpoint': obj.adminApiEndpoint,
    'adminTokenSecretRef': toJson_GarageClusterSpecConnectToAdminTokenSecretRef(obj.adminTokenSecretRef),
    'bootstrapPeers': obj.bootstrapPeers?.map(y => y),
    'clusterRef': toJson_GarageClusterSpecConnectToClusterRef(obj.clusterRef),
    'rpcSecretRef': toJson_GarageClusterSpecConnectToRpcSecretRef(obj.rpcSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerSecurityContext for Garage containers
 *
 * @schema GarageClusterSpecContainerSecurityContext
 */
export interface GarageClusterSpecContainerSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GarageClusterSpecContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * appArmorProfile is the AppArmor options to use by this container. If set, this profile
   * overrides the pod's appArmorProfile.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GarageClusterSpecContainerSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: GarageClusterSpecContainerSecurityContextAppArmorProfile;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema GarageClusterSpecContainerSecurityContext#capabilities
   */
  readonly capabilities?: GarageClusterSpecContainerSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema GarageClusterSpecContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default value is Default which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GarageClusterSpecContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema GarageClusterSpecContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GarageClusterSpecContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema GarageClusterSpecContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema GarageClusterSpecContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GarageClusterSpecContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: GarageClusterSpecContainerSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GarageClusterSpecContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: GarageClusterSpecContainerSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema GarageClusterSpecContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: GarageClusterSpecContainerSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'GarageClusterSpecContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecContainerSecurityContext(obj: GarageClusterSpecContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'appArmorProfile': toJson_GarageClusterSpecContainerSecurityContextAppArmorProfile(obj.appArmorProfile),
    'capabilities': toJson_GarageClusterSpecContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_GarageClusterSpecContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_GarageClusterSpecContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_GarageClusterSpecContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Database configures the metadata database engine
 *
 * @schema GarageClusterSpecDatabase
 */
export interface GarageClusterSpecDatabase {
  /**
   * Engine specifies the database engine to use
   *
   * @schema GarageClusterSpecDatabase#engine
   */
  readonly engine?: GarageClusterSpecDatabaseEngine;

  /**
   * FjallBlockCacheSize is the block cache size for Fjall
   *
   * @schema GarageClusterSpecDatabase#fjallBlockCacheSize
   */
  readonly fjallBlockCacheSize?: GarageClusterSpecDatabaseFjallBlockCacheSize;

  /**
   * LMDBMapSize is the virtual memory region size for LMDB
   *
   * @schema GarageClusterSpecDatabase#lmdbMapSize
   */
  readonly lmdbMapSize?: GarageClusterSpecDatabaseLmdbMapSize;
}

/**
 * Converts an object of type 'GarageClusterSpecDatabase' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecDatabase(obj: GarageClusterSpecDatabase | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'engine': obj.engine,
    'fjallBlockCacheSize': obj.fjallBlockCacheSize?.value,
    'lmdbMapSize': obj.lmdbMapSize?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Discovery configures peer discovery mechanisms
 *
 * @schema GarageClusterSpecDiscovery
 */
export interface GarageClusterSpecDiscovery {
  /**
   * Consul configures Consul-based peer discovery
   *
   * @schema GarageClusterSpecDiscovery#consul
   */
  readonly consul?: GarageClusterSpecDiscoveryConsul;

  /**
   * Kubernetes configures Kubernetes-based peer discovery
   *
   * @schema GarageClusterSpecDiscovery#kubernetes
   */
  readonly kubernetes?: GarageClusterSpecDiscoveryKubernetes;
}

/**
 * Converts an object of type 'GarageClusterSpecDiscovery' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecDiscovery(obj: GarageClusterSpecDiscovery | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consul': toJson_GarageClusterSpecDiscoveryConsul(obj.consul),
    'kubernetes': toJson_GarageClusterSpecDiscoveryKubernetes(obj.kubernetes),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema GarageClusterSpecImagePullSecrets
 */
export interface GarageClusterSpecImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema GarageClusterSpecImagePullSecrets#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'GarageClusterSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecImagePullSecrets(obj: GarageClusterSpecImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * K2VAPI configures the K2V (key-value) API endpoint
 *
 * @schema GarageClusterSpecK2VApi
 */
export interface GarageClusterSpecK2VApi {
  /**
   * BindAddress is a custom bind address for the K2V API.
   * Can be a TCP address or Unix socket path (e.g., "unix:///run/garage/k2v.sock").
   * If set, this overrides BindPort.
   *
   * @schema GarageClusterSpecK2VApi#bindAddress
   */
  readonly bindAddress?: string;

  /**
   * BindPort is the port to bind for K2V API
   *
   * @schema GarageClusterSpecK2VApi#bindPort
   */
  readonly bindPort?: number;

  /**
   * Enabled enables the K2V API
   *
   * @schema GarageClusterSpecK2VApi#enabled
   */
  readonly enabled?: boolean;
}

/**
 * Converts an object of type 'GarageClusterSpecK2VApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecK2VApi(obj: GarageClusterSpecK2VApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bindAddress': obj.bindAddress,
    'bindPort': obj.bindPort,
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LayoutManagement controls how the cluster layout is managed
 *
 * @schema GarageClusterSpecLayoutManagement
 */
export interface GarageClusterSpecLayoutManagement {
  /**
   * AutoApply automatically applies staged layout changes
   *
   * @schema GarageClusterSpecLayoutManagement#autoApply
   */
  readonly autoApply?: boolean;

  /**
   * MinNodesHealthy is the minimum healthy nodes required before applying layout changes
   *
   * @schema GarageClusterSpecLayoutManagement#minNodesHealthy
   */
  readonly minNodesHealthy?: number;
}

/**
 * Converts an object of type 'GarageClusterSpecLayoutManagement' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecLayoutManagement(obj: GarageClusterSpecLayoutManagement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoApply': obj.autoApply,
    'minNodesHealthy': obj.minNodesHealthy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LayoutPolicy controls whether node layouts are automatically managed or manually configured.
 * - "Auto": The controller automatically assigns all local pods to the layout using the
 * cluster's zone and derives capacity from data PVC size. No GarageNode resources needed.
 * - "Manual": You must create GarageNode resources for each node you want in the layout.
 * Use this for fine-grained control over zones, capacities, or external nodes.
 *
 * @schema GarageClusterSpecLayoutPolicy
 */
export enum GarageClusterSpecLayoutPolicy {
  /** Auto */
  AUTO = "Auto",
  /** Manual */
  MANUAL = "Manual",
}

/**
 * Logging configures logging behavior for Garage nodes
 *
 * @schema GarageClusterSpecLogging
 */
export interface GarageClusterSpecLogging {
  /**
   * Journald enables logging to systemd journald (requires Garage built with journald feature)
   *
   * @schema GarageClusterSpecLogging#journald
   */
  readonly journald?: boolean;

  /**
   * Level sets the log level using RUST_LOG format.
   *
   * Examples:
   * - "info": Default info level for all components
   * - "debug": Debug level for all components
   * - "garage=debug": Debug only for garage module
   * - "garage=debug,netapp=info": Fine-grained per-component levels
   * - "garage=trace,netapp=debug,rusoto=warn": Multiple components
   *
   * See https://docs.rs/env_logger for full syntax.
   *
   * @schema GarageClusterSpecLogging#level
   */
  readonly level?: string;

  /**
   * Syslog enables logging to syslog (requires Garage built with syslog feature)
   *
   * @schema GarageClusterSpecLogging#syslog
   */
  readonly syslog?: boolean;
}

/**
 * Converts an object of type 'GarageClusterSpecLogging' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecLogging(obj: GarageClusterSpecLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'journald': obj.journald,
    'level': obj.level,
    'syslog': obj.syslog,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Network configures RPC and API networking
 *
 * @schema GarageClusterSpecNetwork
 */
export interface GarageClusterSpecNetwork {
  /**
   * BootstrapPeers lists initial peers for cluster formation.
   *
   * Format: "<node_public_key>@<ip_or_hostname>:<port>"
   *
   * Example:
   * - "563e1ac825ee3323aa441e72c26d1030d6d4414aeb3dd25287c531e7fc2bc95d@10.0.0.1:3901"
   * - "ec79480e0ce52ae26fd00c9da684e4fa56f77571b9b8560382f859930e63571d@garage-2.example.com:3901"
   *
   * @schema GarageClusterSpecNetwork#bootstrapPeers
   */
  readonly bootstrapPeers?: string[];

  /**
   * RPCBindAddress is a custom bind address for the RPC server.
   * Can be a TCP address (e.g., "0.0.0.0:3901", "[::]:3901").
   * If set, this overrides RPCBindPort.
   *
   * @schema GarageClusterSpecNetwork#rpcBindAddress
   */
  readonly rpcBindAddress?: string;

  /**
   * RPCBindOutgoing pre-binds outgoing sockets to same IP
   *
   * @schema GarageClusterSpecNetwork#rpcBindOutgoing
   */
  readonly rpcBindOutgoing?: boolean;

  /**
   * RPCBindPort is the port for inter-cluster RPC
   *
   * @schema GarageClusterSpecNetwork#rpcBindPort
   */
  readonly rpcBindPort?: number;

  /**
   * RPCPingTimeoutMs sets the RPC ping timeout in milliseconds
   *
   * @schema GarageClusterSpecNetwork#rpcPingTimeoutMs
   */
  readonly rpcPingTimeoutMs?: number;

  /**
   * RPCPublicAddr is the external address for other nodes to contact this node
   *
   * @schema GarageClusterSpecNetwork#rpcPublicAddr
   */
  readonly rpcPublicAddr?: string;

  /**
   * RPCPublicAddrSubnet filters autodiscovered IPs to specific subnet
   *
   * @schema GarageClusterSpecNetwork#rpcPublicAddrSubnet
   */
  readonly rpcPublicAddrSubnet?: string;

  /**
   * RPCSecret is a reference to a secret containing the RPC secret
   * The secret must have a key 'rpc-secret' with a 32-byte hex-encoded value
   *
   * @schema GarageClusterSpecNetwork#rpcSecretRef
   */
  readonly rpcSecretRef?: GarageClusterSpecNetworkRpcSecretRef;

  /**
   * RPCTimeoutMs sets the RPC call timeout in milliseconds
   *
   * @schema GarageClusterSpecNetwork#rpcTimeoutMs
   */
  readonly rpcTimeoutMs?: number;

  /**
   * Service configures the Kubernetes Service for the cluster
   *
   * @schema GarageClusterSpecNetwork#service
   */
  readonly service?: GarageClusterSpecNetworkService;
}

/**
 * Converts an object of type 'GarageClusterSpecNetwork' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecNetwork(obj: GarageClusterSpecNetwork | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bootstrapPeers': obj.bootstrapPeers?.map(y => y),
    'rpcBindAddress': obj.rpcBindAddress,
    'rpcBindOutgoing': obj.rpcBindOutgoing,
    'rpcBindPort': obj.rpcBindPort,
    'rpcPingTimeoutMs': obj.rpcPingTimeoutMs,
    'rpcPublicAddr': obj.rpcPublicAddr,
    'rpcPublicAddrSubnet': obj.rpcPublicAddrSubnet,
    'rpcSecretRef': toJson_GarageClusterSpecNetworkRpcSecretRef(obj.rpcSecretRef),
    'rpcTimeoutMs': obj.rpcTimeoutMs,
    'service': toJson_GarageClusterSpecNetworkService(obj.service),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDisruptionBudget configures the PodDisruptionBudget for the cluster
 *
 * @schema GarageClusterSpecPodDisruptionBudget
 */
export interface GarageClusterSpecPodDisruptionBudget {
  /**
   * Enabled enables PodDisruptionBudget creation
   *
   * @schema GarageClusterSpecPodDisruptionBudget#enabled
   */
  readonly enabled?: boolean;

  /**
   * MaxUnavailable specifies the maximum number of pods that can be unavailable
   * Can be an absolute number (e.g., 1) or a percentage (e.g., "25%")
   * Mutually exclusive with MinAvailable
   *
   * @schema GarageClusterSpecPodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: string;

  /**
   * MinAvailable specifies the minimum number of pods that must be available
   * Can be an absolute number (e.g., 2) or a percentage (e.g., "50%")
   * Mutually exclusive with MaxUnavailable
   *
   * @schema GarageClusterSpecPodDisruptionBudget#minAvailable
   */
  readonly minAvailable?: string;
}

/**
 * Converts an object of type 'GarageClusterSpecPodDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecPodDisruptionBudget(obj: GarageClusterSpecPodDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'maxUnavailable': obj.maxUnavailable,
    'minAvailable': obj.minAvailable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PublicEndpoint configures how remote clusters reach this cluster's nodes
 * Required for multi-cluster federation
 *
 * @schema GarageClusterSpecPublicEndpoint
 */
export interface GarageClusterSpecPublicEndpoint {
  /**
   * ExternalIP configuration
   *
   * @schema GarageClusterSpecPublicEndpoint#externalIP
   */
  readonly externalIp?: GarageClusterSpecPublicEndpointExternalIp;

  /**
   * LoadBalancer configuration
   *
   * @schema GarageClusterSpecPublicEndpoint#loadBalancer
   */
  readonly loadBalancer?: GarageClusterSpecPublicEndpointLoadBalancer;

  /**
   * NodePort configuration
   *
   * @schema GarageClusterSpecPublicEndpoint#nodePort
   */
  readonly nodePort?: GarageClusterSpecPublicEndpointNodePort;

  /**
   * Type specifies how nodes are exposed
   *
   * @schema GarageClusterSpecPublicEndpoint#type
   */
  readonly type: GarageClusterSpecPublicEndpointType;
}

/**
 * Converts an object of type 'GarageClusterSpecPublicEndpoint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecPublicEndpoint(obj: GarageClusterSpecPublicEndpoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalIP': toJson_GarageClusterSpecPublicEndpointExternalIp(obj.externalIp),
    'loadBalancer': toJson_GarageClusterSpecPublicEndpointLoadBalancer(obj.loadBalancer),
    'nodePort': toJson_GarageClusterSpecPublicEndpointNodePort(obj.nodePort),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RemoteClusterConfig defines a Garage cluster in another Kubernetes cluster
 *
 * @schema GarageClusterSpecRemoteClusters
 */
export interface GarageClusterSpecRemoteClusters {
  /**
   * Connection defines how to connect to this remote cluster
   *
   * @schema GarageClusterSpecRemoteClusters#connection
   */
  readonly connection: GarageClusterSpecRemoteClustersConnection;

  /**
   * DefaultCapacity is the default storage capacity to assign to remote nodes
   * that don't yet have a role in the layout. If not specified, defaults to 100Gi.
   * Set to "0" to add nodes as gateway-only (no storage).
   *
   * @schema GarageClusterSpecRemoteClusters#defaultCapacity
   */
  readonly defaultCapacity?: GarageClusterSpecRemoteClustersDefaultCapacity;

  /**
   * Name is a friendly name for this remote cluster
   *
   * @schema GarageClusterSpecRemoteClusters#name
   */
  readonly name: string;

  /**
   * Zone is the zone name for nodes in this remote cluster
   *
   * @schema GarageClusterSpecRemoteClusters#zone
   */
  readonly zone: string;
}

/**
 * Converts an object of type 'GarageClusterSpecRemoteClusters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecRemoteClusters(obj: GarageClusterSpecRemoteClusters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connection': toJson_GarageClusterSpecRemoteClustersConnection(obj.connection),
    'defaultCapacity': obj.defaultCapacity?.value,
    'name': obj.name,
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Replication configures data replication settings
 *
 * @schema GarageClusterSpecReplication
 */
export interface GarageClusterSpecReplication {
  /**
   * ConsistencyMode controls quorum behavior for read/write operations.
   *
   * Values:
   * - "consistent" (default): Require quorum for both reads and writes.
   * Safest option, ensures strong consistency.
   * - "degraded": Allow reads from single node when quorum unavailable.
   * May return stale data during network partitions.
   * - "dangerous": Allow reads AND writes without quorum.
   * WARNING: May lose data during failures!
   *
   * @schema GarageClusterSpecReplication#consistencyMode
   */
  readonly consistencyMode?: GarageClusterSpecReplicationConsistencyMode;

  /**
   * Factor is the replication factor (1, 2, 3, 5, 7, etc.)
   * Must be the same on all nodes in the cluster
   *
   * @schema GarageClusterSpecReplication#factor
   */
  readonly factor: number;

  /**
   * ZoneRedundancy controls how data is distributed across zones.
   *
   * Values:
   * - "Maximum": Maximize redundancy by placing replicas in as many zones as possible
   * - "AtLeast(n)": Require replicas to be in at least n different zones
   *
   * The value n must not exceed the replication factor.
   *
   * Examples:
   * - "Maximum" (default): Best effort zone distribution
   * - "AtLeast(1)": No zone constraint (all replicas can be in one zone)
   * - "AtLeast(2)": Survives 1 zone failure (requires 2+ zones)
   * - "AtLeast(3)": Survives 2 zone failures (requires 3+ zones)
   *
   * @schema GarageClusterSpecReplication#zoneRedundancy
   */
  readonly zoneRedundancy?: string;
}

/**
 * Converts an object of type 'GarageClusterSpecReplication' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecReplication(obj: GarageClusterSpecReplication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistencyMode': obj.consistencyMode,
    'factor': obj.factor,
    'zoneRedundancy': obj.zoneRedundancy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources specifies compute resources for Garage pods
 *
 * @schema GarageClusterSpecResources
 */
export interface GarageClusterSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This field depends on the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema GarageClusterSpecResources#claims
   */
  readonly claims?: GarageClusterSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema GarageClusterSpecResources#limits
   */
  readonly limits?: { [key: string]: GarageClusterSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema GarageClusterSpecResources#requests
   */
  readonly requests?: { [key: string]: GarageClusterSpecResourcesRequests };
}

/**
 * Converts an object of type 'GarageClusterSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecResources(obj: GarageClusterSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_GarageClusterSpecResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * S3API configures the S3-compatible API endpoint
 *
 * @schema GarageClusterSpecS3Api
 */
export interface GarageClusterSpecS3Api {
  /**
   * BindAddress is a custom bind address for the S3 API.
   * Can be a TCP address (e.g., "0.0.0.0:3900", "[::]:3900") or
   * a Unix socket path (e.g., "unix:///run/garage/s3.sock").
   * If set, this overrides BindPort.
   *
   * @schema GarageClusterSpecS3Api#bindAddress
   */
  readonly bindAddress?: string;

  /**
   * BindPort is the port to bind for S3 API
   *
   * @schema GarageClusterSpecS3Api#bindPort
   */
  readonly bindPort?: number;

  /**
   * Region is the AWS S3 region name to use
   *
   * @schema GarageClusterSpecS3Api#region
   */
  readonly region: string;

  /**
   * RootDomain is the root domain suffix for vhost-style S3 access.
   * When set, buckets can be accessed via <bucket-name>.<root-domain>.
   *
   * Examples:
   * - ".s3.garage.tld" -> Access bucket "mybucket" at "mybucket.s3.garage.tld"
   * - ".s3.example.com" -> Access bucket "data" at "data.s3.example.com"
   *
   * Note: Include the leading dot.
   *
   * @schema GarageClusterSpecS3Api#rootDomain
   */
  readonly rootDomain?: string;
}

/**
 * Converts an object of type 'GarageClusterSpecS3Api' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecS3Api(obj: GarageClusterSpecS3Api | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bindAddress': obj.bindAddress,
    'bindPort': obj.bindPort,
    'region': obj.region,
    'rootDomain': obj.rootDomain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Security configures security-related settings
 *
 * @schema GarageClusterSpecSecurity
 */
export interface GarageClusterSpecSecurity {
  /**
   * AllowPunycode allows punycode in bucket names
   *
   * @schema GarageClusterSpecSecurity#allowPunycode
   */
  readonly allowPunycode?: boolean;

  /**
   * AllowWorldReadableSecrets bypasses permission check for secret files
   *
   * @schema GarageClusterSpecSecurity#allowWorldReadableSecrets
   */
  readonly allowWorldReadableSecrets?: boolean;

  /**
   * TLS configures TLS settings
   *
   * @schema GarageClusterSpecSecurity#tls
   */
  readonly tls?: GarageClusterSpecSecurityTls;
}

/**
 * Converts an object of type 'GarageClusterSpecSecurity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecSecurity(obj: GarageClusterSpecSecurity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPunycode': obj.allowPunycode,
    'allowWorldReadableSecrets': obj.allowWorldReadableSecrets,
    'tls': toJson_GarageClusterSpecSecurityTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecurityContext for Garage pods
 *
 * @schema GarageClusterSpecSecurityContext
 */
export interface GarageClusterSpecSecurityContext {
  /**
   * appArmorProfile is the AppArmor options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GarageClusterSpecSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: GarageClusterSpecSecurityContextAppArmorProfile;

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GarageClusterSpecSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GarageClusterSpecSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GarageClusterSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema GarageClusterSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema GarageClusterSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
   * It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
   * Valid values are "MountOption" and "Recursive".
   *
   * "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
   * This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.
   *
   * "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
   * This requires all Pods that share the same volume to use the same SELinux label.
   * It is not possible to share the same volume among privileged and unprivileged Pods.
   * Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
   * whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
   * CSIDriver instance. Other volumes are always re-labelled recursively.
   * "MountOption" value is allowed only when SELinuxMount feature gate is enabled.
   *
   * If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
   * If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
   * and "Recursive" for all other volumes.
   *
   * This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.
   *
   * All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GarageClusterSpecSecurityContext#seLinuxChangePolicy
   */
  readonly seLinuxChangePolicy?: string;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GarageClusterSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: GarageClusterSpecSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GarageClusterSpecSecurityContext#seccompProfile
   */
  readonly seccompProfile?: GarageClusterSpecSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in
   * addition to the container's primary GID and fsGroup (if specified).  If
   * the SupplementalGroupsPolicy feature is enabled, the
   * supplementalGroupsPolicy field determines whether these are in addition
   * to or instead of any group memberships defined in the container image.
   * If unspecified, no additional groups are added, though group memberships
   * defined in the container image may still be used, depending on the
   * supplementalGroupsPolicy field.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GarageClusterSpecSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Defines how supplemental groups of the first container processes are calculated.
   * Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
   * (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
   * and the container runtime must implement support for this feature.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GarageClusterSpecSecurityContext#supplementalGroupsPolicy
   */
  readonly supplementalGroupsPolicy?: string;

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema GarageClusterSpecSecurityContext#sysctls
   */
  readonly sysctls?: GarageClusterSpecSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema GarageClusterSpecSecurityContext#windowsOptions
   */
  readonly windowsOptions?: GarageClusterSpecSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'GarageClusterSpecSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecSecurityContext(obj: GarageClusterSpecSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appArmorProfile': toJson_GarageClusterSpecSecurityContextAppArmorProfile(obj.appArmorProfile),
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxChangePolicy': obj.seLinuxChangePolicy,
    'seLinuxOptions': toJson_GarageClusterSpecSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_GarageClusterSpecSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'supplementalGroupsPolicy': obj.supplementalGroupsPolicy,
    'sysctls': obj.sysctls?.map(y => toJson_GarageClusterSpecSecurityContextSysctls(y)),
    'windowsOptions': toJson_GarageClusterSpecSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Storage configures storage settings for metadata and data.
 * Optional - sensible defaults are provided:
 * - Storage clusters: 10Gi metadata, 100Gi data
 * - Gateway clusters: 1Gi metadata only (data uses EmptyDir)
 *
 * @schema GarageClusterSpecStorage
 */
export interface GarageClusterSpecStorage {
  /**
   * Data configures data block storage
   *
   * @schema GarageClusterSpecStorage#data
   */
  readonly data?: GarageClusterSpecStorageData;

  /**
   * DataFsync enables fsync for data block writes
   *
   * @schema GarageClusterSpecStorage#dataFsync
   */
  readonly dataFsync?: boolean;

  /**
   * Metadata configures metadata storage
   *
   * @schema GarageClusterSpecStorage#metadata
   */
  readonly metadata?: GarageClusterSpecStorageMetadata;

  /**
   * MetadataAutoSnapshotInterval enables automatic metadata snapshots
   * Format: "6h", "1d", etc.
   *
   * @schema GarageClusterSpecStorage#metadataAutoSnapshotInterval
   */
  readonly metadataAutoSnapshotInterval?: string;

  /**
   * MetadataFsync enables fsync for metadata transactions
   *
   * @schema GarageClusterSpecStorage#metadataFsync
   */
  readonly metadataFsync?: boolean;

  /**
   * MetadataSnapshotsDir specifies directory for metadata snapshots
   *
   * @schema GarageClusterSpecStorage#metadataSnapshotsDir
   */
  readonly metadataSnapshotsDir?: string;

  /**
   * PVCRetentionPolicy controls whether PVCs are deleted when the StatefulSet is deleted or scaled down.
   * Requires Kubernetes 1.23+. If not specified, defaults to Retain for both policies.
   *
   * @schema GarageClusterSpecStorage#pvcRetentionPolicy
   */
  readonly pvcRetentionPolicy?: GarageClusterSpecStoragePvcRetentionPolicy;
}

/**
 * Converts an object of type 'GarageClusterSpecStorage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecStorage(obj: GarageClusterSpecStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': toJson_GarageClusterSpecStorageData(obj.data),
    'dataFsync': obj.dataFsync,
    'metadata': toJson_GarageClusterSpecStorageMetadata(obj.metadata),
    'metadataAutoSnapshotInterval': obj.metadataAutoSnapshotInterval,
    'metadataFsync': obj.metadataFsync,
    'metadataSnapshotsDir': obj.metadataSnapshotsDir,
    'pvcRetentionPolicy': toJson_GarageClusterSpecStoragePvcRetentionPolicy(obj.pvcRetentionPolicy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema GarageClusterSpecTolerations
 */
export interface GarageClusterSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema GarageClusterSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema GarageClusterSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists, Equal, Lt, and Gt. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   * Lt and Gt perform numeric comparisons (requires feature gate TaintTolerationComparisonOperators).
   *
   * @default Equal.
   * @schema GarageClusterSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema GarageClusterSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema GarageClusterSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'GarageClusterSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecTolerations(obj: GarageClusterSpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema GarageClusterSpecTopologySpreadConstraints
 */
export interface GarageClusterSpecTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema GarageClusterSpecTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: GarageClusterSpecTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are ANDed with labelSelector
   * to select the group of existing pods over which spreading will be calculated
   * for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * MatchLabelKeys cannot be set when LabelSelector isn't set.
   * Keys that don't exist in the incoming pod labels will
   * be ignored. A null or empty list means only match against labelSelector.
   *
   * This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema GarageClusterSpecTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   * The global minimum is the minimum number of matching pods in an eligible domain
   * or zero if the number of eligible domains is less than MinDomains.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 2/2/1:
   * In this case, the global minimum is 1.
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |   P   |
   * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
   * scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
   * violate MaxSkew(1).
   * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
   * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
   * to topologies that satisfy it.
   * It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema GarageClusterSpecTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   * And when the number of eligible domains with matching topology keys equals or greater than minDomains,
   * this value has no effect on scheduling.
   * As a result, when the number of eligible domains is less than minDomains,
   * scheduler won't schedule more than maxSkew Pods to those domains.
   * If value is nil, the constraint behaves as if MinDomains is equal to 1.
   * Valid values are integers greater than 0.
   * When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
   *
   * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
   * labelSelector spread as 2/2/2:
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |  P P  |
   * The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
   * In this situation, new pod with the same labelSelector cannot be scheduled,
   * because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
   * it will violate MaxSkew.
   *
   * @schema GarageClusterSpecTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
   *
   * If this value is nil, the behavior is equivalent to the Honor policy.
   *
   * @schema GarageClusterSpecTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   * If this value is nil, the behavior is equivalent to the Ignore policy.
   *
   * @schema GarageClusterSpecTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   * We define a domain as a particular instance of a topology.
   * Also, we define an eligible domain as a domain whose nodes meet the requirements of
   * nodeAffinityPolicy and nodeTaintsPolicy.
   * e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
   * And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
   * It's a required field.
   *
   * @schema GarageClusterSpecTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
   * but giving higher precedence to topologies that would help reduce the
   * skew.
   * A constraint is considered "Unsatisfiable" for an incoming pod
   * if and only if every possible node assignment for that pod would violate
   * "MaxSkew" on some topology.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 3/1/1:
   * | zone1 | zone2 | zone3 |
   * | P P P |   P   |   P   |
   * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
   * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
   * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
   * won't make it *more* imbalanced.
   * It's a required field.
   *
   * @schema GarageClusterSpecTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;
}

/**
 * Converts an object of type 'GarageClusterSpecTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecTopologySpreadConstraints(obj: GarageClusterSpecTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_GarageClusterSpecTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WebAPI configures the static website hosting endpoint
 *
 * @schema GarageClusterSpecWebApi
 */
export interface GarageClusterSpecWebApi {
  /**
   * AddHostToMetrics adds the domain name to metrics labels for per-domain tracking.
   *
   * @schema GarageClusterSpecWebApi#addHostToMetrics
   */
  readonly addHostToMetrics?: boolean;

  /**
   * BindAddress is a custom bind address for the Web API.
   * Can be a TCP address or Unix socket path (e.g., "unix:///run/garage/web.sock").
   * If set, this overrides BindPort.
   *
   * @schema GarageClusterSpecWebApi#bindAddress
   */
  readonly bindAddress?: string;

  /**
   * BindPort is the port to bind for web serving
   *
   * @schema GarageClusterSpecWebApi#bindPort
   */
  readonly bindPort?: number;

  /**
   * Enabled enables static website hosting
   *
   * @schema GarageClusterSpecWebApi#enabled
   */
  readonly enabled?: boolean;

  /**
   * RootDomain is the root domain suffix for bucket website access.
   * When set, bucket websites are accessible via <bucket-name>.<root-domain>.
   *
   * Examples:
   * - ".web.garage.tld" -> Access bucket "site" website at "site.web.garage.tld"
   * - ".sites.example.com" -> Access bucket "blog" at "blog.sites.example.com"
   *
   * Note: Include the leading dot.
   *
   * @schema GarageClusterSpecWebApi#rootDomain
   */
  readonly rootDomain?: string;
}

/**
 * Converts an object of type 'GarageClusterSpecWebApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecWebApi(obj: GarageClusterSpecWebApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addHostToMetrics': obj.addHostToMetrics,
    'bindAddress': obj.bindAddress,
    'bindPort': obj.bindPort,
    'enabled': obj.enabled,
    'rootDomain': obj.rootDomain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AdminTokenSecretRef references a secret containing the admin API token
 *
 * @schema GarageClusterSpecAdminAdminTokenSecretRef
 */
export interface GarageClusterSpecAdminAdminTokenSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GarageClusterSpecAdminAdminTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema GarageClusterSpecAdminAdminTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GarageClusterSpecAdminAdminTokenSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'GarageClusterSpecAdminAdminTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAdminAdminTokenSecretRef(obj: GarageClusterSpecAdminAdminTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MetricsTokenSecretRef references a secret containing the metrics token
 *
 * @schema GarageClusterSpecAdminMetricsTokenSecretRef
 */
export interface GarageClusterSpecAdminMetricsTokenSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GarageClusterSpecAdminMetricsTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema GarageClusterSpecAdminMetricsTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GarageClusterSpecAdminMetricsTokenSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'GarageClusterSpecAdminMetricsTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAdminMetricsTokenSecretRef(obj: GarageClusterSpecAdminMetricsTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema GarageClusterSpecAffinityNodeAffinity
 */
export interface GarageClusterSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema GarageClusterSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema GarageClusterSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityNodeAffinity(obj: GarageClusterSpecAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema GarageClusterSpecAffinityPodAffinity
 */
export interface GarageClusterSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema GarageClusterSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema GarageClusterSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityPodAffinity(obj: GarageClusterSpecAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema GarageClusterSpecAffinityPodAntiAffinity
 */
export interface GarageClusterSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and subtracting
   * "weight" from the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityPodAntiAffinity(obj: GarageClusterSpecAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RAMBufferMax is the maximum RAM for buffering blocks
 *
 * @schema GarageClusterSpecBlocksRamBufferMax
 */
export class GarageClusterSpecBlocksRamBufferMax {
  public static fromNumber(value: number): GarageClusterSpecBlocksRamBufferMax {
    return new GarageClusterSpecBlocksRamBufferMax(value);
  }
  public static fromString(value: string): GarageClusterSpecBlocksRamBufferMax {
    return new GarageClusterSpecBlocksRamBufferMax(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Size is the size of data blocks (default: 1M)
 *
 * @schema GarageClusterSpecBlocksSize
 */
export class GarageClusterSpecBlocksSize {
  public static fromNumber(value: number): GarageClusterSpecBlocksSize {
    return new GarageClusterSpecBlocksSize(value);
  }
  public static fromString(value: string): GarageClusterSpecBlocksSize {
    return new GarageClusterSpecBlocksSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * AdminTokenSecretRef references the admin token for the storage cluster
 * If clusterRef is specified and in same namespace, uses that cluster's token
 *
 * @schema GarageClusterSpecConnectToAdminTokenSecretRef
 */
export interface GarageClusterSpecConnectToAdminTokenSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GarageClusterSpecConnectToAdminTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema GarageClusterSpecConnectToAdminTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GarageClusterSpecConnectToAdminTokenSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'GarageClusterSpecConnectToAdminTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecConnectToAdminTokenSecretRef(obj: GarageClusterSpecConnectToAdminTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterRef references a GarageCluster in the same namespace
 * The gateway will use this cluster's RPC secret and connect to its nodes
 *
 * @schema GarageClusterSpecConnectToClusterRef
 */
export interface GarageClusterSpecConnectToClusterRef {
  /**
   * KubeConfigSecretRef references a secret containing kubeconfig for a remote cluster.
   * Only used for cross-cluster references in multi-cluster federation scenarios.
   *
   * @schema GarageClusterSpecConnectToClusterRef#kubeConfigSecretRef
   */
  readonly kubeConfigSecretRef?: GarageClusterSpecConnectToClusterRefKubeConfigSecretRef;

  /**
   * Name of the GarageCluster
   *
   * @schema GarageClusterSpecConnectToClusterRef#name
   */
  readonly name: string;

  /**
   * Namespace of the GarageCluster (defaults to the same namespace as the referencing resource)
   *
   * @schema GarageClusterSpecConnectToClusterRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'GarageClusterSpecConnectToClusterRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecConnectToClusterRef(obj: GarageClusterSpecConnectToClusterRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kubeConfigSecretRef': toJson_GarageClusterSpecConnectToClusterRefKubeConfigSecretRef(obj.kubeConfigSecretRef),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RPCSecretRef references a shared RPC secret (for cross-namespace or external clusters)
 * If clusterRef is specified, this is ignored (uses the referenced cluster's secret)
 *
 * @schema GarageClusterSpecConnectToRpcSecretRef
 */
export interface GarageClusterSpecConnectToRpcSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GarageClusterSpecConnectToRpcSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema GarageClusterSpecConnectToRpcSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GarageClusterSpecConnectToRpcSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'GarageClusterSpecConnectToRpcSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecConnectToRpcSecretRef(obj: GarageClusterSpecConnectToRpcSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * appArmorProfile is the AppArmor options to use by this container. If set, this profile
 * overrides the pod's appArmorProfile.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema GarageClusterSpecContainerSecurityContextAppArmorProfile
 */
export interface GarageClusterSpecContainerSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema GarageClusterSpecContainerSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema GarageClusterSpecContainerSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'GarageClusterSpecContainerSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecContainerSecurityContextAppArmorProfile(obj: GarageClusterSpecContainerSecurityContextAppArmorProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema GarageClusterSpecContainerSecurityContextCapabilities
 */
export interface GarageClusterSpecContainerSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema GarageClusterSpecContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema GarageClusterSpecContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'GarageClusterSpecContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecContainerSecurityContextCapabilities(obj: GarageClusterSpecContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema GarageClusterSpecContainerSecurityContextSeLinuxOptions
 */
export interface GarageClusterSpecContainerSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema GarageClusterSpecContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema GarageClusterSpecContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema GarageClusterSpecContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema GarageClusterSpecContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'GarageClusterSpecContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecContainerSecurityContextSeLinuxOptions(obj: GarageClusterSpecContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema GarageClusterSpecContainerSecurityContextSeccompProfile
 */
export interface GarageClusterSpecContainerSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema GarageClusterSpecContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema GarageClusterSpecContainerSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'GarageClusterSpecContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecContainerSecurityContextSeccompProfile(obj: GarageClusterSpecContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema GarageClusterSpecContainerSecurityContextWindowsOptions
 */
export interface GarageClusterSpecContainerSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema GarageClusterSpecContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema GarageClusterSpecContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema GarageClusterSpecContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema GarageClusterSpecContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'GarageClusterSpecContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecContainerSecurityContextWindowsOptions(obj: GarageClusterSpecContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Engine specifies the database engine to use
 *
 * @schema GarageClusterSpecDatabaseEngine
 */
export enum GarageClusterSpecDatabaseEngine {
  /** lmdb */
  LMDB = "lmdb",
  /** sqlite */
  SQLITE = "sqlite",
  /** fjall */
  FJALL = "fjall",
}

/**
 * FjallBlockCacheSize is the block cache size for Fjall
 *
 * @schema GarageClusterSpecDatabaseFjallBlockCacheSize
 */
export class GarageClusterSpecDatabaseFjallBlockCacheSize {
  public static fromNumber(value: number): GarageClusterSpecDatabaseFjallBlockCacheSize {
    return new GarageClusterSpecDatabaseFjallBlockCacheSize(value);
  }
  public static fromString(value: string): GarageClusterSpecDatabaseFjallBlockCacheSize {
    return new GarageClusterSpecDatabaseFjallBlockCacheSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * LMDBMapSize is the virtual memory region size for LMDB
 *
 * @schema GarageClusterSpecDatabaseLmdbMapSize
 */
export class GarageClusterSpecDatabaseLmdbMapSize {
  public static fromNumber(value: number): GarageClusterSpecDatabaseLmdbMapSize {
    return new GarageClusterSpecDatabaseLmdbMapSize(value);
  }
  public static fromString(value: string): GarageClusterSpecDatabaseLmdbMapSize {
    return new GarageClusterSpecDatabaseLmdbMapSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Consul configures Consul-based peer discovery
 *
 * @schema GarageClusterSpecDiscoveryConsul
 */
export interface GarageClusterSpecDiscoveryConsul {
  /**
   * API specifies the service registration API ("catalog" or "agent")
   *
   * @schema GarageClusterSpecDiscoveryConsul#api
   */
  readonly api?: GarageClusterSpecDiscoveryConsulApi;

  /**
   * CACert is the CA certificate for TLS connection
   *
   * @schema GarageClusterSpecDiscoveryConsul#caCert
   */
  readonly caCert?: string;

  /**
   * CACertSecretRef references a secret containing the CA certificate
   *
   * @schema GarageClusterSpecDiscoveryConsul#caCertSecretRef
   */
  readonly caCertSecretRef?: GarageClusterSpecDiscoveryConsulCaCertSecretRef;

  /**
   * ClientCertSecretRef references a secret containing client TLS cert
   *
   * @schema GarageClusterSpecDiscoveryConsul#clientCertSecretRef
   */
  readonly clientCertSecretRef?: GarageClusterSpecDiscoveryConsulClientCertSecretRef;

  /**
   * ClientKeySecretRef references a secret containing client TLS key
   *
   * @schema GarageClusterSpecDiscoveryConsul#clientKeySecretRef
   */
  readonly clientKeySecretRef?: GarageClusterSpecDiscoveryConsulClientKeySecretRef;

  /**
   * Datacenters for WAN federation
   *
   * @schema GarageClusterSpecDiscoveryConsul#datacenters
   */
  readonly datacenters?: string[];

  /**
   * Enabled enables Consul-based discovery
   *
   * @schema GarageClusterSpecDiscoveryConsul#enabled
   */
  readonly enabled?: boolean;

  /**
   * HTTPAddr is the full HTTP(S) address of Consul server
   *
   * @schema GarageClusterSpecDiscoveryConsul#httpAddr
   */
  readonly httpAddr?: string;

  /**
   * Meta is service metadata key-value pairs
   *
   * @schema GarageClusterSpecDiscoveryConsul#meta
   */
  readonly meta?: { [key: string]: string };

  /**
   * ServiceName for Garage RPC port registration
   *
   * @schema GarageClusterSpecDiscoveryConsul#serviceName
   */
  readonly serviceName?: string;

  /**
   * Tags are additional service tags
   *
   * @schema GarageClusterSpecDiscoveryConsul#tags
   */
  readonly tags?: string[];

  /**
   * TLSSkipVerify skips TLS hostname verification
   *
   * @schema GarageClusterSpecDiscoveryConsul#tlsSkipVerify
   */
  readonly tlsSkipVerify?: boolean;

  /**
   * TokenSecretRef references a secret containing the bearer token
   *
   * @schema GarageClusterSpecDiscoveryConsul#tokenSecretRef
   */
  readonly tokenSecretRef?: GarageClusterSpecDiscoveryConsulTokenSecretRef;
}

/**
 * Converts an object of type 'GarageClusterSpecDiscoveryConsul' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecDiscoveryConsul(obj: GarageClusterSpecDiscoveryConsul | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'api': obj.api,
    'caCert': obj.caCert,
    'caCertSecretRef': toJson_GarageClusterSpecDiscoveryConsulCaCertSecretRef(obj.caCertSecretRef),
    'clientCertSecretRef': toJson_GarageClusterSpecDiscoveryConsulClientCertSecretRef(obj.clientCertSecretRef),
    'clientKeySecretRef': toJson_GarageClusterSpecDiscoveryConsulClientKeySecretRef(obj.clientKeySecretRef),
    'datacenters': obj.datacenters?.map(y => y),
    'enabled': obj.enabled,
    'httpAddr': obj.httpAddr,
    'meta': ((obj.meta) === undefined) ? undefined : (Object.entries(obj.meta).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'serviceName': obj.serviceName,
    'tags': obj.tags?.map(y => y),
    'tlsSkipVerify': obj.tlsSkipVerify,
    'tokenSecretRef': toJson_GarageClusterSpecDiscoveryConsulTokenSecretRef(obj.tokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubernetes configures Kubernetes-based peer discovery
 *
 * @schema GarageClusterSpecDiscoveryKubernetes
 */
export interface GarageClusterSpecDiscoveryKubernetes {
  /**
   * Enabled enables Kubernetes-based discovery
   *
   * @schema GarageClusterSpecDiscoveryKubernetes#enabled
   */
  readonly enabled?: boolean;

  /**
   * Namespace for Garage custom resources
   *
   * @schema GarageClusterSpecDiscoveryKubernetes#namespace
   */
  readonly namespace?: string;

  /**
   * ServiceName label to filter custom resources
   *
   * @schema GarageClusterSpecDiscoveryKubernetes#serviceName
   */
  readonly serviceName?: string;

  /**
   * SkipCRD skips automatic CRD creation/patching
   *
   * @schema GarageClusterSpecDiscoveryKubernetes#skipCRD
   */
  readonly skipCrd?: boolean;
}

/**
 * Converts an object of type 'GarageClusterSpecDiscoveryKubernetes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecDiscoveryKubernetes(obj: GarageClusterSpecDiscoveryKubernetes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'namespace': obj.namespace,
    'serviceName': obj.serviceName,
    'skipCRD': obj.skipCrd,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RPCSecret is a reference to a secret containing the RPC secret
 * The secret must have a key 'rpc-secret' with a 32-byte hex-encoded value
 *
 * @schema GarageClusterSpecNetworkRpcSecretRef
 */
export interface GarageClusterSpecNetworkRpcSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GarageClusterSpecNetworkRpcSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema GarageClusterSpecNetworkRpcSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GarageClusterSpecNetworkRpcSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'GarageClusterSpecNetworkRpcSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecNetworkRpcSecretRef(obj: GarageClusterSpecNetworkRpcSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Service configures the Kubernetes Service for the cluster
 *
 * @schema GarageClusterSpecNetworkService
 */
export interface GarageClusterSpecNetworkService {
  /**
   * Annotations for the service
   *
   * @schema GarageClusterSpecNetworkService#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * ExternalTrafficPolicy for LoadBalancer/NodePort
   *
   * @schema GarageClusterSpecNetworkService#externalTrafficPolicy
   */
  readonly externalTrafficPolicy?: string;

  /**
   * LoadBalancerIP for LoadBalancer type
   *
   * @schema GarageClusterSpecNetworkService#loadBalancerIP
   */
  readonly loadBalancerIp?: string;

  /**
   * LoadBalancerSourceRanges for LoadBalancer type
   *
   * @schema GarageClusterSpecNetworkService#loadBalancerSourceRanges
   */
  readonly loadBalancerSourceRanges?: string[];

  /**
   * Type of service
   *
   * @schema GarageClusterSpecNetworkService#type
   */
  readonly type?: GarageClusterSpecNetworkServiceType;
}

/**
 * Converts an object of type 'GarageClusterSpecNetworkService' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecNetworkService(obj: GarageClusterSpecNetworkService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'externalTrafficPolicy': obj.externalTrafficPolicy,
    'loadBalancerIP': obj.loadBalancerIp,
    'loadBalancerSourceRanges': obj.loadBalancerSourceRanges?.map(y => y),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExternalIP configuration
 *
 * @schema GarageClusterSpecPublicEndpointExternalIp
 */
export interface GarageClusterSpecPublicEndpointExternalIp {
  /**
   * AddressTemplate uses go template to generate addresses from pod info
   * Example: "garage-{{.Index}}.example.com"
   *
   * @schema GarageClusterSpecPublicEndpointExternalIp#addressTemplate
   */
  readonly addressTemplate?: string;

  /**
   * Addresses maps pod names to external IPs
   *
   * @schema GarageClusterSpecPublicEndpointExternalIp#addresses
   */
  readonly addresses?: { [key: string]: string };
}

/**
 * Converts an object of type 'GarageClusterSpecPublicEndpointExternalIp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecPublicEndpointExternalIp(obj: GarageClusterSpecPublicEndpointExternalIp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressTemplate': obj.addressTemplate,
    'addresses': ((obj.addresses) === undefined) ? undefined : (Object.entries(obj.addresses).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LoadBalancer configuration
 *
 * @schema GarageClusterSpecPublicEndpointLoadBalancer
 */
export interface GarageClusterSpecPublicEndpointLoadBalancer {
  /**
   * Annotations for the LoadBalancer service
   *
   * @schema GarageClusterSpecPublicEndpointLoadBalancer#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * PerNode creates a separate LoadBalancer per node (more expensive but ensures direct routing)
   *
   * @schema GarageClusterSpecPublicEndpointLoadBalancer#perNode
   */
  readonly perNode?: boolean;
}

/**
 * Converts an object of type 'GarageClusterSpecPublicEndpointLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecPublicEndpointLoadBalancer(obj: GarageClusterSpecPublicEndpointLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'perNode': obj.perNode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NodePort configuration
 *
 * @schema GarageClusterSpecPublicEndpointNodePort
 */
export interface GarageClusterSpecPublicEndpointNodePort {
  /**
   * BasePort is the starting NodePort (each node gets BasePort + index)
   *
   * @schema GarageClusterSpecPublicEndpointNodePort#basePort
   */
  readonly basePort?: number;

  /**
   * ExternalAddresses are the external IPs/hostnames of the Kubernetes nodes
   *
   * @schema GarageClusterSpecPublicEndpointNodePort#externalAddresses
   */
  readonly externalAddresses: string[];
}

/**
 * Converts an object of type 'GarageClusterSpecPublicEndpointNodePort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecPublicEndpointNodePort(obj: GarageClusterSpecPublicEndpointNodePort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basePort': obj.basePort,
    'externalAddresses': obj.externalAddresses?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type specifies how nodes are exposed
 *
 * @schema GarageClusterSpecPublicEndpointType
 */
export enum GarageClusterSpecPublicEndpointType {
  /** LoadBalancer */
  LOAD_BALANCER = "LoadBalancer",
  /** NodePort */
  NODE_PORT = "NodePort",
  /** ExternalIP */
  EXTERNAL_IP = "ExternalIP",
  /** Headless */
  HEADLESS = "Headless",
}

/**
 * Connection defines how to connect to this remote cluster
 *
 * @schema GarageClusterSpecRemoteClustersConnection
 */
export interface GarageClusterSpecRemoteClustersConnection {
  /**
   * AdminAPIEndpoint is the admin API endpoint of the remote cluster
   * This should be a reachable HTTP/HTTPS URL (e.g., via Tailscale, LoadBalancer, or port-forward)
   * Example: "http://garage-remote.tailscale:3903"
   *
   * @schema GarageClusterSpecRemoteClustersConnection#adminApiEndpoint
   */
  readonly adminApiEndpoint: string;

  /**
   * AdminTokenSecretRef references the admin token for the remote cluster's API
   * If not specified, uses the local cluster's admin token (for shared-token setups)
   *
   * @schema GarageClusterSpecRemoteClustersConnection#adminTokenSecretRef
   */
  readonly adminTokenSecretRef?: GarageClusterSpecRemoteClustersConnectionAdminTokenSecretRef;
}

/**
 * Converts an object of type 'GarageClusterSpecRemoteClustersConnection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecRemoteClustersConnection(obj: GarageClusterSpecRemoteClustersConnection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'adminApiEndpoint': obj.adminApiEndpoint,
    'adminTokenSecretRef': toJson_GarageClusterSpecRemoteClustersConnectionAdminTokenSecretRef(obj.adminTokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DefaultCapacity is the default storage capacity to assign to remote nodes
 * that don't yet have a role in the layout. If not specified, defaults to 100Gi.
 * Set to "0" to add nodes as gateway-only (no storage).
 *
 * @schema GarageClusterSpecRemoteClustersDefaultCapacity
 */
export class GarageClusterSpecRemoteClustersDefaultCapacity {
  public static fromNumber(value: number): GarageClusterSpecRemoteClustersDefaultCapacity {
    return new GarageClusterSpecRemoteClustersDefaultCapacity(value);
  }
  public static fromString(value: string): GarageClusterSpecRemoteClustersDefaultCapacity {
    return new GarageClusterSpecRemoteClustersDefaultCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ConsistencyMode controls quorum behavior for read/write operations.
 *
 * Values:
 * - "consistent" (default): Require quorum for both reads and writes.
 * Safest option, ensures strong consistency.
 * - "degraded": Allow reads from single node when quorum unavailable.
 * May return stale data during network partitions.
 * - "dangerous": Allow reads AND writes without quorum.
 * WARNING: May lose data during failures!
 *
 * @schema GarageClusterSpecReplicationConsistencyMode
 */
export enum GarageClusterSpecReplicationConsistencyMode {
  /** consistent */
  CONSISTENT = "consistent",
  /** degraded */
  DEGRADED = "degraded",
  /** dangerous */
  DANGEROUS = "dangerous",
}

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema GarageClusterSpecResourcesClaims
 */
export interface GarageClusterSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema GarageClusterSpecResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema GarageClusterSpecResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'GarageClusterSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecResourcesClaims(obj: GarageClusterSpecResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema GarageClusterSpecResourcesLimits
 */
export class GarageClusterSpecResourcesLimits {
  public static fromNumber(value: number): GarageClusterSpecResourcesLimits {
    return new GarageClusterSpecResourcesLimits(value);
  }
  public static fromString(value: string): GarageClusterSpecResourcesLimits {
    return new GarageClusterSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema GarageClusterSpecResourcesRequests
 */
export class GarageClusterSpecResourcesRequests {
  public static fromNumber(value: number): GarageClusterSpecResourcesRequests {
    return new GarageClusterSpecResourcesRequests(value);
  }
  public static fromString(value: string): GarageClusterSpecResourcesRequests {
    return new GarageClusterSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * TLS configures TLS settings
 *
 * @schema GarageClusterSpecSecurityTls
 */
export interface GarageClusterSpecSecurityTls {
  /**
   * CASecretRef references a secret containing the CA certificate for verifying peer nodes
   *
   * @schema GarageClusterSpecSecurityTls#caSecretRef
   */
  readonly caSecretRef?: GarageClusterSpecSecurityTlsCaSecretRef;

  /**
   * CertSecretRef references a secret containing the TLS certificate for RPC
   *
   * @schema GarageClusterSpecSecurityTls#certSecretRef
   */
  readonly certSecretRef?: GarageClusterSpecSecurityTlsCertSecretRef;

  /**
   * Enabled enables TLS for inter-node RPC communication.
   * NOTE: This does NOT enable TLS for S3/Admin APIs - use a service mesh or load balancer for that.
   *
   * @schema GarageClusterSpecSecurityTls#enabled
   */
  readonly enabled?: boolean;

  /**
   * KeySecretRef references a secret containing the TLS private key for RPC
   *
   * @schema GarageClusterSpecSecurityTls#keySecretRef
   */
  readonly keySecretRef?: GarageClusterSpecSecurityTlsKeySecretRef;
}

/**
 * Converts an object of type 'GarageClusterSpecSecurityTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecSecurityTls(obj: GarageClusterSpecSecurityTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caSecretRef': toJson_GarageClusterSpecSecurityTlsCaSecretRef(obj.caSecretRef),
    'certSecretRef': toJson_GarageClusterSpecSecurityTlsCertSecretRef(obj.certSecretRef),
    'enabled': obj.enabled,
    'keySecretRef': toJson_GarageClusterSpecSecurityTlsKeySecretRef(obj.keySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * appArmorProfile is the AppArmor options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema GarageClusterSpecSecurityContextAppArmorProfile
 */
export interface GarageClusterSpecSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema GarageClusterSpecSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema GarageClusterSpecSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'GarageClusterSpecSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecSecurityContextAppArmorProfile(obj: GarageClusterSpecSecurityContextAppArmorProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema GarageClusterSpecSecurityContextSeLinuxOptions
 */
export interface GarageClusterSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema GarageClusterSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema GarageClusterSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema GarageClusterSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema GarageClusterSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'GarageClusterSpecSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecSecurityContextSeLinuxOptions(obj: GarageClusterSpecSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema GarageClusterSpecSecurityContextSeccompProfile
 */
export interface GarageClusterSpecSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema GarageClusterSpecSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema GarageClusterSpecSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'GarageClusterSpecSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecSecurityContextSeccompProfile(obj: GarageClusterSpecSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema GarageClusterSpecSecurityContextSysctls
 */
export interface GarageClusterSpecSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema GarageClusterSpecSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema GarageClusterSpecSecurityContextSysctls#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'GarageClusterSpecSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecSecurityContextSysctls(obj: GarageClusterSpecSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema GarageClusterSpecSecurityContextWindowsOptions
 */
export interface GarageClusterSpecSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema GarageClusterSpecSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema GarageClusterSpecSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema GarageClusterSpecSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema GarageClusterSpecSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'GarageClusterSpecSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecSecurityContextWindowsOptions(obj: GarageClusterSpecSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Data configures data block storage
 *
 * @schema GarageClusterSpecStorageData
 */
export interface GarageClusterSpecStorageData {
  /**
   * Paths specifies multiple data directories with capacities
   * For advanced multi-disk configurations. Only valid when Type=PersistentVolumeClaim.
   *
   * @schema GarageClusterSpecStorageData#paths
   */
  readonly paths?: GarageClusterSpecStorageDataPaths[];

  /**
   * Size of the data volume. For PVC: storage request. For EmptyDir: sizeLimit (optional).
   *
   * @schema GarageClusterSpecStorageData#size
   */
  readonly size?: GarageClusterSpecStorageDataSize;

  /**
   * StorageClassName for the data PVC. Only valid when Type=PersistentVolumeClaim.
   *
   * @schema GarageClusterSpecStorageData#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * Type specifies the volume type: PersistentVolumeClaim (default) or EmptyDir.
   * When EmptyDir, data is lost on pod restart - only use for testing.
   *
   * @schema GarageClusterSpecStorageData#type
   */
  readonly type?: GarageClusterSpecStorageDataType;
}

/**
 * Converts an object of type 'GarageClusterSpecStorageData' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecStorageData(obj: GarageClusterSpecStorageData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'paths': obj.paths?.map(y => toJson_GarageClusterSpecStorageDataPaths(y)),
    'size': obj.size?.value,
    'storageClassName': obj.storageClassName,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metadata configures metadata storage
 *
 * @schema GarageClusterSpecStorageMetadata
 */
export interface GarageClusterSpecStorageMetadata {
  /**
   * AccessModes for the PVC. Only valid when Type=PersistentVolumeClaim.
   *
   * @schema GarageClusterSpecStorageMetadata#accessModes
   */
  readonly accessModes?: string[];

  /**
   * Selector to select PVs. Only valid when Type=PersistentVolumeClaim.
   *
   * @schema GarageClusterSpecStorageMetadata#selector
   */
  readonly selector?: GarageClusterSpecStorageMetadataSelector;

  /**
   * Size of the volume.
   * - For PVC: storage request (defaults to 10Gi for metadata if not specified)
   * - For EmptyDir: optional sizeLimit (if omitted, uses available node resources)
   *
   * @schema GarageClusterSpecStorageMetadata#size
   */
  readonly size?: GarageClusterSpecStorageMetadataSize;

  /**
   * StorageClassName for the PVC. Only valid when Type=PersistentVolumeClaim.
   *
   * @schema GarageClusterSpecStorageMetadata#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * Type specifies the volume type: PersistentVolumeClaim (default) or EmptyDir.
   * When EmptyDir, data is lost on pod restart - only use for testing.
   *
   * @schema GarageClusterSpecStorageMetadata#type
   */
  readonly type?: GarageClusterSpecStorageMetadataType;

  /**
   * VolumeClaimTemplateSpec allows full customization of the PVC.
   * Only valid when Type=PersistentVolumeClaim.
   *
   * @schema GarageClusterSpecStorageMetadata#volumeClaimTemplateSpec
   */
  readonly volumeClaimTemplateSpec?: GarageClusterSpecStorageMetadataVolumeClaimTemplateSpec;
}

/**
 * Converts an object of type 'GarageClusterSpecStorageMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecStorageMetadata(obj: GarageClusterSpecStorageMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'selector': toJson_GarageClusterSpecStorageMetadataSelector(obj.selector),
    'size': obj.size?.value,
    'storageClassName': obj.storageClassName,
    'type': obj.type,
    'volumeClaimTemplateSpec': toJson_GarageClusterSpecStorageMetadataVolumeClaimTemplateSpec(obj.volumeClaimTemplateSpec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PVCRetentionPolicy controls whether PVCs are deleted when the StatefulSet is deleted or scaled down.
 * Requires Kubernetes 1.23+. If not specified, defaults to Retain for both policies.
 *
 * @schema GarageClusterSpecStoragePvcRetentionPolicy
 */
export interface GarageClusterSpecStoragePvcRetentionPolicy {
  /**
   * WhenDeleted specifies what happens to PVCs when the StatefulSet is deleted.
   * - "Retain" (default): PVCs are kept for manual cleanup or data recovery
   * - "Delete": PVCs are automatically deleted with the StatefulSet
   *
   * @schema GarageClusterSpecStoragePvcRetentionPolicy#whenDeleted
   */
  readonly whenDeleted?: GarageClusterSpecStoragePvcRetentionPolicyWhenDeleted;

  /**
   * WhenScaled specifies what happens to PVCs when the StatefulSet is scaled down.
   * - "Retain" (default): PVCs are kept when scaling down (allows scale back up)
   * - "Delete": PVCs for removed replicas are deleted
   *
   * @schema GarageClusterSpecStoragePvcRetentionPolicy#whenScaled
   */
  readonly whenScaled?: GarageClusterSpecStoragePvcRetentionPolicyWhenScaled;
}

/**
 * Converts an object of type 'GarageClusterSpecStoragePvcRetentionPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecStoragePvcRetentionPolicy(obj: GarageClusterSpecStoragePvcRetentionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'whenDeleted': obj.whenDeleted,
    'whenScaled': obj.whenScaled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema GarageClusterSpecTopologySpreadConstraintsLabelSelector
 */
export interface GarageClusterSpecTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GarageClusterSpecTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: GarageClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GarageClusterSpecTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'GarageClusterSpecTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecTopologySpreadConstraintsLabelSelector(obj: GarageClusterSpecTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KubeConfigSecretRef references a secret containing kubeconfig for a remote cluster.
 * Only used for cross-cluster references in multi-cluster federation scenarios.
 *
 * @schema GarageClusterSpecConnectToClusterRefKubeConfigSecretRef
 */
export interface GarageClusterSpecConnectToClusterRefKubeConfigSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GarageClusterSpecConnectToClusterRefKubeConfigSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema GarageClusterSpecConnectToClusterRefKubeConfigSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GarageClusterSpecConnectToClusterRefKubeConfigSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'GarageClusterSpecConnectToClusterRefKubeConfigSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecConnectToClusterRefKubeConfigSecretRef(obj: GarageClusterSpecConnectToClusterRefKubeConfigSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * API specifies the service registration API ("catalog" or "agent")
 *
 * @schema GarageClusterSpecDiscoveryConsulApi
 */
export enum GarageClusterSpecDiscoveryConsulApi {
  /** catalog */
  CATALOG = "catalog",
  /** agent */
  AGENT = "agent",
}

/**
 * CACertSecretRef references a secret containing the CA certificate
 *
 * @schema GarageClusterSpecDiscoveryConsulCaCertSecretRef
 */
export interface GarageClusterSpecDiscoveryConsulCaCertSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GarageClusterSpecDiscoveryConsulCaCertSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema GarageClusterSpecDiscoveryConsulCaCertSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GarageClusterSpecDiscoveryConsulCaCertSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'GarageClusterSpecDiscoveryConsulCaCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecDiscoveryConsulCaCertSecretRef(obj: GarageClusterSpecDiscoveryConsulCaCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientCertSecretRef references a secret containing client TLS cert
 *
 * @schema GarageClusterSpecDiscoveryConsulClientCertSecretRef
 */
export interface GarageClusterSpecDiscoveryConsulClientCertSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GarageClusterSpecDiscoveryConsulClientCertSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema GarageClusterSpecDiscoveryConsulClientCertSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GarageClusterSpecDiscoveryConsulClientCertSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'GarageClusterSpecDiscoveryConsulClientCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecDiscoveryConsulClientCertSecretRef(obj: GarageClusterSpecDiscoveryConsulClientCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientKeySecretRef references a secret containing client TLS key
 *
 * @schema GarageClusterSpecDiscoveryConsulClientKeySecretRef
 */
export interface GarageClusterSpecDiscoveryConsulClientKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GarageClusterSpecDiscoveryConsulClientKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema GarageClusterSpecDiscoveryConsulClientKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GarageClusterSpecDiscoveryConsulClientKeySecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'GarageClusterSpecDiscoveryConsulClientKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecDiscoveryConsulClientKeySecretRef(obj: GarageClusterSpecDiscoveryConsulClientKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TokenSecretRef references a secret containing the bearer token
 *
 * @schema GarageClusterSpecDiscoveryConsulTokenSecretRef
 */
export interface GarageClusterSpecDiscoveryConsulTokenSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GarageClusterSpecDiscoveryConsulTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema GarageClusterSpecDiscoveryConsulTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GarageClusterSpecDiscoveryConsulTokenSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'GarageClusterSpecDiscoveryConsulTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecDiscoveryConsulTokenSecretRef(obj: GarageClusterSpecDiscoveryConsulTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type of service
 *
 * @schema GarageClusterSpecNetworkServiceType
 */
export enum GarageClusterSpecNetworkServiceType {
  /** ClusterIP */
  CLUSTER_IP = "ClusterIP",
  /** NodePort */
  NODE_PORT = "NodePort",
  /** LoadBalancer */
  LOAD_BALANCER = "LoadBalancer",
}

/**
 * AdminTokenSecretRef references the admin token for the remote cluster's API
 * If not specified, uses the local cluster's admin token (for shared-token setups)
 *
 * @schema GarageClusterSpecRemoteClustersConnectionAdminTokenSecretRef
 */
export interface GarageClusterSpecRemoteClustersConnectionAdminTokenSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GarageClusterSpecRemoteClustersConnectionAdminTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema GarageClusterSpecRemoteClustersConnectionAdminTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GarageClusterSpecRemoteClustersConnectionAdminTokenSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'GarageClusterSpecRemoteClustersConnectionAdminTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecRemoteClustersConnectionAdminTokenSecretRef(obj: GarageClusterSpecRemoteClustersConnectionAdminTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CASecretRef references a secret containing the CA certificate for verifying peer nodes
 *
 * @schema GarageClusterSpecSecurityTlsCaSecretRef
 */
export interface GarageClusterSpecSecurityTlsCaSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GarageClusterSpecSecurityTlsCaSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema GarageClusterSpecSecurityTlsCaSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GarageClusterSpecSecurityTlsCaSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'GarageClusterSpecSecurityTlsCaSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecSecurityTlsCaSecretRef(obj: GarageClusterSpecSecurityTlsCaSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CertSecretRef references a secret containing the TLS certificate for RPC
 *
 * @schema GarageClusterSpecSecurityTlsCertSecretRef
 */
export interface GarageClusterSpecSecurityTlsCertSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GarageClusterSpecSecurityTlsCertSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema GarageClusterSpecSecurityTlsCertSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GarageClusterSpecSecurityTlsCertSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'GarageClusterSpecSecurityTlsCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecSecurityTlsCertSecretRef(obj: GarageClusterSpecSecurityTlsCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KeySecretRef references a secret containing the TLS private key for RPC
 *
 * @schema GarageClusterSpecSecurityTlsKeySecretRef
 */
export interface GarageClusterSpecSecurityTlsKeySecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GarageClusterSpecSecurityTlsKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema GarageClusterSpecSecurityTlsKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GarageClusterSpecSecurityTlsKeySecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'GarageClusterSpecSecurityTlsKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecSecurityTlsKeySecretRef(obj: GarageClusterSpecSecurityTlsKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DataPath specifies a data directory with capacity
 *
 * @schema GarageClusterSpecStorageDataPaths
 */
export interface GarageClusterSpecStorageDataPaths {
  /**
   * Capacity of the drive (required unless readOnly)
   *
   * @schema GarageClusterSpecStorageDataPaths#capacity
   */
  readonly capacity?: GarageClusterSpecStorageDataPathsCapacity;

  /**
   * Path to the data directory
   *
   * @schema GarageClusterSpecStorageDataPaths#path
   */
  readonly path: string;

  /**
   * ReadOnly marks directory as legacy read-only for migrations
   *
   * @schema GarageClusterSpecStorageDataPaths#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Volume configuration if using PVC
   *
   * @schema GarageClusterSpecStorageDataPaths#volume
   */
  readonly volume?: GarageClusterSpecStorageDataPathsVolume;
}

/**
 * Converts an object of type 'GarageClusterSpecStorageDataPaths' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecStorageDataPaths(obj: GarageClusterSpecStorageDataPaths | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capacity': obj.capacity?.value,
    'path': obj.path,
    'readOnly': obj.readOnly,
    'volume': toJson_GarageClusterSpecStorageDataPathsVolume(obj.volume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Size of the data volume. For PVC: storage request. For EmptyDir: sizeLimit (optional).
 *
 * @schema GarageClusterSpecStorageDataSize
 */
export class GarageClusterSpecStorageDataSize {
  public static fromNumber(value: number): GarageClusterSpecStorageDataSize {
    return new GarageClusterSpecStorageDataSize(value);
  }
  public static fromString(value: string): GarageClusterSpecStorageDataSize {
    return new GarageClusterSpecStorageDataSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Type specifies the volume type: PersistentVolumeClaim (default) or EmptyDir.
 * When EmptyDir, data is lost on pod restart - only use for testing.
 *
 * @schema GarageClusterSpecStorageDataType
 */
export enum GarageClusterSpecStorageDataType {
  /** PersistentVolumeClaim */
  PERSISTENT_VOLUME_CLAIM = "PersistentVolumeClaim",
  /** EmptyDir */
  EMPTY_DIR = "EmptyDir",
}

/**
 * Selector to select PVs. Only valid when Type=PersistentVolumeClaim.
 *
 * @schema GarageClusterSpecStorageMetadataSelector
 */
export interface GarageClusterSpecStorageMetadataSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GarageClusterSpecStorageMetadataSelector#matchExpressions
   */
  readonly matchExpressions?: GarageClusterSpecStorageMetadataSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GarageClusterSpecStorageMetadataSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'GarageClusterSpecStorageMetadataSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecStorageMetadataSelector(obj: GarageClusterSpecStorageMetadataSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageClusterSpecStorageMetadataSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Size of the volume.
 * - For PVC: storage request (defaults to 10Gi for metadata if not specified)
 * - For EmptyDir: optional sizeLimit (if omitted, uses available node resources)
 *
 * @schema GarageClusterSpecStorageMetadataSize
 */
export class GarageClusterSpecStorageMetadataSize {
  public static fromNumber(value: number): GarageClusterSpecStorageMetadataSize {
    return new GarageClusterSpecStorageMetadataSize(value);
  }
  public static fromString(value: string): GarageClusterSpecStorageMetadataSize {
    return new GarageClusterSpecStorageMetadataSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Type specifies the volume type: PersistentVolumeClaim (default) or EmptyDir.
 * When EmptyDir, data is lost on pod restart - only use for testing.
 *
 * @schema GarageClusterSpecStorageMetadataType
 */
export enum GarageClusterSpecStorageMetadataType {
  /** PersistentVolumeClaim */
  PERSISTENT_VOLUME_CLAIM = "PersistentVolumeClaim",
  /** EmptyDir */
  EMPTY_DIR = "EmptyDir",
}

/**
 * VolumeClaimTemplateSpec allows full customization of the PVC.
 * Only valid when Type=PersistentVolumeClaim.
 *
 * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpec
 */
export interface GarageClusterSpecStorageMetadataVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * Users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpec#resources
   */
  readonly resources?: GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpec#selector
   */
  readonly selector?: GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string or nil value indicates that no
   * VolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,
   * this field can be reset to its previous value (including nil) to cancel the modification.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   *
   * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'GarageClusterSpecStorageMetadataVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecStorageMetadataVolumeClaimTemplateSpec(obj: GarageClusterSpecStorageMetadataVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WhenDeleted specifies what happens to PVCs when the StatefulSet is deleted.
 * - "Retain" (default): PVCs are kept for manual cleanup or data recovery
 * - "Delete": PVCs are automatically deleted with the StatefulSet
 *
 * @schema GarageClusterSpecStoragePvcRetentionPolicyWhenDeleted
 */
export enum GarageClusterSpecStoragePvcRetentionPolicyWhenDeleted {
  /** Retain */
  RETAIN = "Retain",
  /** Delete */
  DELETE = "Delete",
}

/**
 * WhenScaled specifies what happens to PVCs when the StatefulSet is scaled down.
 * - "Retain" (default): PVCs are kept when scaling down (allows scale back up)
 * - "Delete": PVCs for removed replicas are deleted
 *
 * @schema GarageClusterSpecStoragePvcRetentionPolicyWhenScaled
 */
export enum GarageClusterSpecStoragePvcRetentionPolicyWhenScaled {
  /** Retain */
  RETAIN = "Retain",
  /** Delete */
  DELETE = "Delete",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema GarageClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface GarageClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GarageClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GarageClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema GarageClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: GarageClusterSpecTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Capacity of the drive (required unless readOnly)
 *
 * @schema GarageClusterSpecStorageDataPathsCapacity
 */
export class GarageClusterSpecStorageDataPathsCapacity {
  public static fromNumber(value: number): GarageClusterSpecStorageDataPathsCapacity {
    return new GarageClusterSpecStorageDataPathsCapacity(value);
  }
  public static fromString(value: string): GarageClusterSpecStorageDataPathsCapacity {
    return new GarageClusterSpecStorageDataPathsCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Volume configuration if using PVC
 *
 * @schema GarageClusterSpecStorageDataPathsVolume
 */
export interface GarageClusterSpecStorageDataPathsVolume {
  /**
   * AccessModes for the PVC. Only valid when Type=PersistentVolumeClaim.
   *
   * @schema GarageClusterSpecStorageDataPathsVolume#accessModes
   */
  readonly accessModes?: string[];

  /**
   * Selector to select PVs. Only valid when Type=PersistentVolumeClaim.
   *
   * @schema GarageClusterSpecStorageDataPathsVolume#selector
   */
  readonly selector?: GarageClusterSpecStorageDataPathsVolumeSelector;

  /**
   * Size of the volume.
   * - For PVC: storage request (defaults to 10Gi for metadata if not specified)
   * - For EmptyDir: optional sizeLimit (if omitted, uses available node resources)
   *
   * @schema GarageClusterSpecStorageDataPathsVolume#size
   */
  readonly size?: GarageClusterSpecStorageDataPathsVolumeSize;

  /**
   * StorageClassName for the PVC. Only valid when Type=PersistentVolumeClaim.
   *
   * @schema GarageClusterSpecStorageDataPathsVolume#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * Type specifies the volume type: PersistentVolumeClaim (default) or EmptyDir.
   * When EmptyDir, data is lost on pod restart - only use for testing.
   *
   * @schema GarageClusterSpecStorageDataPathsVolume#type
   */
  readonly type?: GarageClusterSpecStorageDataPathsVolumeType;

  /**
   * VolumeClaimTemplateSpec allows full customization of the PVC.
   * Only valid when Type=PersistentVolumeClaim.
   *
   * @schema GarageClusterSpecStorageDataPathsVolume#volumeClaimTemplateSpec
   */
  readonly volumeClaimTemplateSpec?: GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpec;
}

/**
 * Converts an object of type 'GarageClusterSpecStorageDataPathsVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecStorageDataPathsVolume(obj: GarageClusterSpecStorageDataPathsVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'selector': toJson_GarageClusterSpecStorageDataPathsVolumeSelector(obj.selector),
    'size': obj.size?.value,
    'storageClassName': obj.storageClassName,
    'type': obj.type,
    'volumeClaimTemplateSpec': toJson_GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpec(obj.volumeClaimTemplateSpec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema GarageClusterSpecStorageMetadataSelectorMatchExpressions
 */
export interface GarageClusterSpecStorageMetadataSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GarageClusterSpecStorageMetadataSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GarageClusterSpecStorageMetadataSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema GarageClusterSpecStorageMetadataSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageClusterSpecStorageMetadataSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecStorageMetadataSelectorMatchExpressions(obj: GarageClusterSpecStorageMetadataSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecDataSource
 */
export interface GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecDataSource(obj: GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecDataSourceRef
 */
export interface GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecDataSourceRef(obj: GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * Users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecResources
 */
export interface GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecResourcesRequests };
}

/**
 * Converts an object of type 'GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecResources(obj: GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecSelector
 */
export interface GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecSelector(obj: GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: GarageClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: GarageClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: GarageClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: GarageClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector to select PVs. Only valid when Type=PersistentVolumeClaim.
 *
 * @schema GarageClusterSpecStorageDataPathsVolumeSelector
 */
export interface GarageClusterSpecStorageDataPathsVolumeSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeSelector#matchExpressions
   */
  readonly matchExpressions?: GarageClusterSpecStorageDataPathsVolumeSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'GarageClusterSpecStorageDataPathsVolumeSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecStorageDataPathsVolumeSelector(obj: GarageClusterSpecStorageDataPathsVolumeSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageClusterSpecStorageDataPathsVolumeSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Size of the volume.
 * - For PVC: storage request (defaults to 10Gi for metadata if not specified)
 * - For EmptyDir: optional sizeLimit (if omitted, uses available node resources)
 *
 * @schema GarageClusterSpecStorageDataPathsVolumeSize
 */
export class GarageClusterSpecStorageDataPathsVolumeSize {
  public static fromNumber(value: number): GarageClusterSpecStorageDataPathsVolumeSize {
    return new GarageClusterSpecStorageDataPathsVolumeSize(value);
  }
  public static fromString(value: string): GarageClusterSpecStorageDataPathsVolumeSize {
    return new GarageClusterSpecStorageDataPathsVolumeSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Type specifies the volume type: PersistentVolumeClaim (default) or EmptyDir.
 * When EmptyDir, data is lost on pod restart - only use for testing.
 *
 * @schema GarageClusterSpecStorageDataPathsVolumeType
 */
export enum GarageClusterSpecStorageDataPathsVolumeType {
  /** PersistentVolumeClaim */
  PERSISTENT_VOLUME_CLAIM = "PersistentVolumeClaim",
  /** EmptyDir */
  EMPTY_DIR = "EmptyDir",
}

/**
 * VolumeClaimTemplateSpec allows full customization of the PVC.
 * Only valid when Type=PersistentVolumeClaim.
 *
 * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpec
 */
export interface GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * Users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpec#resources
   */
  readonly resources?: GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpec#selector
   */
  readonly selector?: GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string or nil value indicates that no
   * VolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,
   * this field can be reset to its previous value (including nil) to cancel the modification.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpec(obj: GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecResourcesLimits
 */
export class GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecResourcesLimits {
    return new GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecResourcesLimits {
    return new GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecResourcesRequests
 */
export class GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecResourcesRequests {
    return new GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecResourcesRequests {
    return new GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecSelectorMatchExpressions(obj: GarageClusterSpecStorageMetadataVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: GarageClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: GarageClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema GarageClusterSpecStorageDataPathsVolumeSelectorMatchExpressions
 */
export interface GarageClusterSpecStorageDataPathsVolumeSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageClusterSpecStorageDataPathsVolumeSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecStorageDataPathsVolumeSelectorMatchExpressions(obj: GarageClusterSpecStorageDataPathsVolumeSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecDataSource
 */
export interface GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecDataSource(obj: GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecDataSourceRef
 */
export interface GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecDataSourceRef(obj: GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * Users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecResources
 */
export interface GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecResourcesRequests };
}

/**
 * Converts an object of type 'GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecResources(obj: GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecSelector
 */
export interface GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecSelector(obj: GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecResourcesLimits
 */
export class GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecResourcesLimits {
    return new GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecResourcesLimits {
    return new GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecResourcesRequests
 */
export class GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecResourcesRequests {
    return new GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecResourcesRequests {
    return new GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecSelectorMatchExpressions(obj: GarageClusterSpecStorageDataPathsVolumeVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * GarageKey is the Schema for the garagekeys API
 *
 * @schema GarageKey
 */
export class GarageKey extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GarageKey"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'garage.rajsingh.info/v1alpha1',
    kind: 'GarageKey',
  }

  /**
   * Renders a Kubernetes manifest for "GarageKey".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GarageKeyProps): any {
    return {
      ...GarageKey.GVK,
      ...toJson_GarageKeyProps(props),
    };
  }

  /**
   * Defines a "GarageKey" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GarageKeyProps) {
    super(scope, id, {
      ...GarageKey.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...GarageKey.GVK,
      ...toJson_GarageKeyProps(resolved),
    };
  }
}

/**
 * GarageKey is the Schema for the garagekeys API
 *
 * @schema GarageKey
 */
export interface GarageKeyProps {
  /**
   * @schema GarageKey#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GarageKeySpec defines the desired state of GarageKey
   *
   * @schema GarageKey#spec
   */
  readonly spec: GarageKeySpec;
}

/**
 * Converts an object of type 'GarageKeyProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageKeyProps(obj: GarageKeyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GarageKeySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GarageKeySpec defines the desired state of GarageKey
 *
 * @schema GarageKeySpec
 */
export interface GarageKeySpec {
  /**
   * AllBuckets grants this key access to ALL buckets in the cluster.
   * Useful for admin tools, monitoring, or systems that need cluster-wide access.
   * Uses deny-then-allow to enforce exact permissions: flags set false are actively
   * revoked, not just ignored. Per-bucket permissions (bucketPermissions) run after
   * and override additively on top.
   *
   * The key must be in the same namespace as the GarageBucket resources for
   * bidirectional reconciliation (bucket controller also applies these permissions
   * when new buckets are created).
   *
   * Note: ListBuckets returns ALL Garage buckets, including those not managed by
   * the operator. Cluster-wide permissions will be applied to those buckets as well.
   *
   * @schema GarageKeySpec#allBuckets
   */
  readonly allBuckets?: GarageKeySpecAllBuckets;

  /**
   * BucketPermissions grants this key access to buckets.
   *
   * Note: Permissions can be granted from either direction:
   * - Here (GarageKey.bucketPermissions): Grant this key access to buckets
   * - On GarageBucket (GarageBucket.keyPermissions): Grant keys access to the bucket
   *
   * Both approaches are equivalent and result in the same Garage API calls.
   * Use whichever is more convenient for your workflow:
   * - Key-centric: Define all bucket access on the key
   * - Bucket-centric: Define all key access on the bucket
   *
   * If the same permission is defined in both places, they are merged (not conflicting).
   *
   * @schema GarageKeySpec#bucketPermissions
   */
  readonly bucketPermissions?: GarageKeySpecBucketPermissions[];

  /**
   * ClusterRef references the GarageCluster this key belongs to
   *
   * @schema GarageKeySpec#clusterRef
   */
  readonly clusterRef: GarageKeySpecClusterRef;

  /**
   * Expiration sets when this key expires (RFC 3339 format)
   * Example: "2025-12-31T23:59:59Z"
   * Mutually exclusive with NeverExpires
   *
   * @schema GarageKeySpec#expiration
   */
  readonly expiration?: string;

  /**
   * ImportKey imports an existing key instead of generating new credentials
   *
   * @schema GarageKeySpec#importKey
   */
  readonly importKey?: GarageKeySpecImportKey;

  /**
   * Name is a friendly name for this access key
   * If not set, metadata.name is used
   *
   * @schema GarageKeySpec#name
   */
  readonly name?: string;

  /**
   * NeverExpires sets the key to never expire
   * Mutually exclusive with Expiration
   *
   * @schema GarageKeySpec#neverExpires
   */
  readonly neverExpires?: boolean;

  /**
   * Permissions configures key-level permissions
   * Note: For admin API access, use admin tokens configured in GarageCluster
   *
   * @schema GarageKeySpec#permissions
   */
  readonly permissions?: GarageKeySpecPermissions;

  /**
   * SecretTemplate configures how the secret is generated
   *
   * @schema GarageKeySpec#secretTemplate
   */
  readonly secretTemplate?: GarageKeySpecSecretTemplate;
}

/**
 * Converts an object of type 'GarageKeySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageKeySpec(obj: GarageKeySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allBuckets': toJson_GarageKeySpecAllBuckets(obj.allBuckets),
    'bucketPermissions': obj.bucketPermissions?.map(y => toJson_GarageKeySpecBucketPermissions(y)),
    'clusterRef': toJson_GarageKeySpecClusterRef(obj.clusterRef),
    'expiration': obj.expiration,
    'importKey': toJson_GarageKeySpecImportKey(obj.importKey),
    'name': obj.name,
    'neverExpires': obj.neverExpires,
    'permissions': toJson_GarageKeySpecPermissions(obj.permissions),
    'secretTemplate': toJson_GarageKeySpecSecretTemplate(obj.secretTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AllBuckets grants this key access to ALL buckets in the cluster.
 * Useful for admin tools, monitoring, or systems that need cluster-wide access.
 * Uses deny-then-allow to enforce exact permissions: flags set false are actively
 * revoked, not just ignored. Per-bucket permissions (bucketPermissions) run after
 * and override additively on top.
 *
 * The key must be in the same namespace as the GarageBucket resources for
 * bidirectional reconciliation (bucket controller also applies these permissions
 * when new buckets are created).
 *
 * Note: ListBuckets returns ALL Garage buckets, including those not managed by
 * the operator. Cluster-wide permissions will be applied to those buckets as well.
 *
 * @schema GarageKeySpecAllBuckets
 */
export interface GarageKeySpecAllBuckets {
  /**
   * Owner allows bucket owner operations on all buckets
   *
   * @schema GarageKeySpecAllBuckets#owner
   */
  readonly owner?: boolean;

  /**
   * Read allows reading objects from all buckets
   *
   * @schema GarageKeySpecAllBuckets#read
   */
  readonly read?: boolean;

  /**
   * Write allows writing objects to all buckets
   *
   * @schema GarageKeySpecAllBuckets#write
   */
  readonly write?: boolean;
}

/**
 * Converts an object of type 'GarageKeySpecAllBuckets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageKeySpecAllBuckets(obj: GarageKeySpecAllBuckets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'owner': obj.owner,
    'read': obj.read,
    'write': obj.write,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BucketPermission grants access to a bucket
 *
 * @schema GarageKeySpecBucketPermissions
 */
export interface GarageKeySpecBucketPermissions {
  /**
   * BucketID references the bucket by its Garage ID
   *
   * @schema GarageKeySpecBucketPermissions#bucketId
   */
  readonly bucketId?: string;

  /**
   * BucketRef references the GarageBucket by name
   *
   * @schema GarageKeySpecBucketPermissions#bucketRef
   */
  readonly bucketRef?: string;

  /**
   * GlobalAlias references the bucket by global alias
   *
   * @schema GarageKeySpecBucketPermissions#globalAlias
   */
  readonly globalAlias?: string;

  /**
   * Owner allows bucket owner operations (delete bucket, configure website, etc.)
   *
   * @schema GarageKeySpecBucketPermissions#owner
   */
  readonly owner?: boolean;

  /**
   * Read allows reading objects from the bucket
   *
   * @schema GarageKeySpecBucketPermissions#read
   */
  readonly read?: boolean;

  /**
   * Write allows writing objects to the bucket
   *
   * @schema GarageKeySpecBucketPermissions#write
   */
  readonly write?: boolean;
}

/**
 * Converts an object of type 'GarageKeySpecBucketPermissions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageKeySpecBucketPermissions(obj: GarageKeySpecBucketPermissions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketId': obj.bucketId,
    'bucketRef': obj.bucketRef,
    'globalAlias': obj.globalAlias,
    'owner': obj.owner,
    'read': obj.read,
    'write': obj.write,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterRef references the GarageCluster this key belongs to
 *
 * @schema GarageKeySpecClusterRef
 */
export interface GarageKeySpecClusterRef {
  /**
   * KubeConfigSecretRef references a secret containing kubeconfig for a remote cluster.
   * Only used for cross-cluster references in multi-cluster federation scenarios.
   *
   * @schema GarageKeySpecClusterRef#kubeConfigSecretRef
   */
  readonly kubeConfigSecretRef?: GarageKeySpecClusterRefKubeConfigSecretRef;

  /**
   * Name of the GarageCluster
   *
   * @schema GarageKeySpecClusterRef#name
   */
  readonly name: string;

  /**
   * Namespace of the GarageCluster (defaults to the same namespace as the referencing resource)
   *
   * @schema GarageKeySpecClusterRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'GarageKeySpecClusterRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageKeySpecClusterRef(obj: GarageKeySpecClusterRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kubeConfigSecretRef': toJson_GarageKeySpecClusterRefKubeConfigSecretRef(obj.kubeConfigSecretRef),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ImportKey imports an existing key instead of generating new credentials
 *
 * @schema GarageKeySpecImportKey
 */
export interface GarageKeySpecImportKey {
  /**
   * AccessKeyID is the existing access key ID
   *
   * @schema GarageKeySpecImportKey#accessKeyId
   */
  readonly accessKeyId?: string;

  /**
   * SecretAccessKey is the existing secret access key
   *
   * @schema GarageKeySpecImportKey#secretAccessKey
   */
  readonly secretAccessKey?: string;

  /**
   * SecretRef references a secret containing the credentials
   * Secret should have keys: access-key-id, secret-access-key
   *
   * @schema GarageKeySpecImportKey#secretRef
   */
  readonly secretRef?: GarageKeySpecImportKeySecretRef;
}

/**
 * Converts an object of type 'GarageKeySpecImportKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageKeySpecImportKey(obj: GarageKeySpecImportKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyId': obj.accessKeyId,
    'secretAccessKey': obj.secretAccessKey,
    'secretRef': toJson_GarageKeySpecImportKeySecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Permissions configures key-level permissions
 * Note: For admin API access, use admin tokens configured in GarageCluster
 *
 * @schema GarageKeySpecPermissions
 */
export interface GarageKeySpecPermissions {
  /**
   * CreateBucket allows this key to create new buckets via the S3 CreateBucket API
   *
   * @schema GarageKeySpecPermissions#createBucket
   */
  readonly createBucket?: boolean;
}

/**
 * Converts an object of type 'GarageKeySpecPermissions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageKeySpecPermissions(obj: GarageKeySpecPermissions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'createBucket': obj.createBucket,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretTemplate configures how the secret is generated
 *
 * @schema GarageKeySpecSecretTemplate
 */
export interface GarageKeySpecSecretTemplate {
  /**
   * AccessKeyIDKey is the key name for the access key ID
   *
   * @schema GarageKeySpecSecretTemplate#accessKeyIdKey
   */
  readonly accessKeyIdKey?: string;

  /**
   * AdditionalData includes additional key-value pairs in the secret
   *
   * @schema GarageKeySpecSecretTemplate#additionalData
   */
  readonly additionalData?: { [key: string]: string };

  /**
   * Annotations to add to the secret
   *
   * @schema GarageKeySpecSecretTemplate#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * EndpointKey is the key name for the S3 endpoint (includes http:// scheme)
   *
   * @schema GarageKeySpecSecretTemplate#endpointKey
   */
  readonly endpointKey?: string;

  /**
   * HostKey is the key name for the S3 host (without scheme, e.g., "host:port")
   *
   * @schema GarageKeySpecSecretTemplate#hostKey
   */
  readonly hostKey?: string;

  /**
   * IncludeEndpoint includes the S3 endpoint in the secret
   * Defaults to true if not specified
   *
   * @default true if not specified
   * @schema GarageKeySpecSecretTemplate#includeEndpoint
   */
  readonly includeEndpoint?: boolean;

  /**
   * IncludeRegion includes the S3 region in the secret
   * Defaults to true if not specified
   *
   * @default true if not specified
   * @schema GarageKeySpecSecretTemplate#includeRegion
   */
  readonly includeRegion?: boolean;

  /**
   * Labels to add to the secret
   *
   * @schema GarageKeySpecSecretTemplate#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name is the name of the secret to create
   * Defaults to the GarageKey name
   *
   * @default the GarageKey name
   * @schema GarageKeySpecSecretTemplate#name
   */
  readonly name?: string;

  /**
   * Namespace is the namespace for the secret
   * Defaults to the GarageKey namespace
   *
   * @default the GarageKey namespace
   * @schema GarageKeySpecSecretTemplate#namespace
   */
  readonly namespace?: string;

  /**
   * RegionKey is the key name for the S3 region
   *
   * @schema GarageKeySpecSecretTemplate#regionKey
   */
  readonly regionKey?: string;

  /**
   * SchemeKey is the key name for the endpoint scheme (http or https)
   *
   * @schema GarageKeySpecSecretTemplate#schemeKey
   */
  readonly schemeKey?: string;

  /**
   * SecretAccessKeyKey is the key name for the secret access key
   *
   * @schema GarageKeySpecSecretTemplate#secretAccessKeyKey
   */
  readonly secretAccessKeyKey?: string;

  /**
   * Type is the secret type
   *
   * @schema GarageKeySpecSecretTemplate#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'GarageKeySpecSecretTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageKeySpecSecretTemplate(obj: GarageKeySpecSecretTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIdKey': obj.accessKeyIdKey,
    'additionalData': ((obj.additionalData) === undefined) ? undefined : (Object.entries(obj.additionalData).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'endpointKey': obj.endpointKey,
    'hostKey': obj.hostKey,
    'includeEndpoint': obj.includeEndpoint,
    'includeRegion': obj.includeRegion,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
    'regionKey': obj.regionKey,
    'schemeKey': obj.schemeKey,
    'secretAccessKeyKey': obj.secretAccessKeyKey,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KubeConfigSecretRef references a secret containing kubeconfig for a remote cluster.
 * Only used for cross-cluster references in multi-cluster federation scenarios.
 *
 * @schema GarageKeySpecClusterRefKubeConfigSecretRef
 */
export interface GarageKeySpecClusterRefKubeConfigSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GarageKeySpecClusterRefKubeConfigSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema GarageKeySpecClusterRefKubeConfigSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GarageKeySpecClusterRefKubeConfigSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'GarageKeySpecClusterRefKubeConfigSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageKeySpecClusterRefKubeConfigSecretRef(obj: GarageKeySpecClusterRefKubeConfigSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a secret containing the credentials
 * Secret should have keys: access-key-id, secret-access-key
 *
 * @schema GarageKeySpecImportKeySecretRef
 */
export interface GarageKeySpecImportKeySecretRef {
  /**
   * name is unique within a namespace to reference a secret resource.
   *
   * @schema GarageKeySpecImportKeySecretRef#name
   */
  readonly name?: string;

  /**
   * namespace defines the space within which the secret name must be unique.
   *
   * @schema GarageKeySpecImportKeySecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'GarageKeySpecImportKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageKeySpecImportKeySecretRef(obj: GarageKeySpecImportKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * GarageNode is the Schema for the garagenodes API
 *
 * @schema GarageNode
 */
export class GarageNode extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GarageNode"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'garage.rajsingh.info/v1alpha1',
    kind: 'GarageNode',
  }

  /**
   * Renders a Kubernetes manifest for "GarageNode".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GarageNodeProps): any {
    return {
      ...GarageNode.GVK,
      ...toJson_GarageNodeProps(props),
    };
  }

  /**
   * Defines a "GarageNode" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GarageNodeProps) {
    super(scope, id, {
      ...GarageNode.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...GarageNode.GVK,
      ...toJson_GarageNodeProps(resolved),
    };
  }
}

/**
 * GarageNode is the Schema for the garagenodes API
 *
 * @schema GarageNode
 */
export interface GarageNodeProps {
  /**
   * @schema GarageNode#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GarageNodeSpec defines the desired state of GarageNode.
   *
   * GarageNode represents a node in the Garage cluster. When the parent GarageCluster
   * has layoutPolicy: Manual, each GarageNode creates its own StatefulSet (replica 1)
   * with independent storage configuration.
   *
   * Use GarageNode when you need:
   * - Heterogeneous storage (different storage classes per node)
   * - Per-node resource configuration
   * - Fine-grained zone/capacity control
   * - External nodes (VMs, other K8s clusters)
   *
   * Pod configuration (resources, nodeSelector, tolerations, etc.) is inherited from
   * the parent GarageCluster and can be overridden per-node.
   *
   * @schema GarageNode#spec
   */
  readonly spec: GarageNodeSpec;
}

/**
 * Converts an object of type 'GarageNodeProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeProps(obj: GarageNodeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GarageNodeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GarageNodeSpec defines the desired state of GarageNode.
 *
 * GarageNode represents a node in the Garage cluster. When the parent GarageCluster
 * has layoutPolicy: Manual, each GarageNode creates its own StatefulSet (replica 1)
 * with independent storage configuration.
 *
 * Use GarageNode when you need:
 * - Heterogeneous storage (different storage classes per node)
 * - Per-node resource configuration
 * - Fine-grained zone/capacity control
 * - External nodes (VMs, other K8s clusters)
 *
 * Pod configuration (resources, nodeSelector, tolerations, etc.) is inherited from
 * the parent GarageCluster and can be overridden per-node.
 *
 * @schema GarageNodeSpec
 */
export interface GarageNodeSpec {
  /**
   * Affinity overrides pod affinity rules.
   * If not specified, inherits from GarageCluster.
   *
   * @schema GarageNodeSpec#affinity
   */
  readonly affinity?: GarageNodeSpecAffinity;

  /**
   * Capacity is the storage capacity to report to Garage for this node.
   * Required unless Gateway is true.
   *
   * @schema GarageNodeSpec#capacity
   */
  readonly capacity?: GarageNodeSpecCapacity;

  /**
   * ClusterRef references the GarageCluster this node belongs to.
   * The GarageNode inherits configuration from this cluster.
   *
   * @schema GarageNodeSpec#clusterRef
   */
  readonly clusterRef: GarageNodeSpecClusterRef;

  /**
   * External marks this node as an external node (not managed by this operator).
   * When set, no StatefulSet is created - the node is assumed to exist externally.
   *
   * @schema GarageNodeSpec#external
   */
  readonly external?: GarageNodeSpecExternal;

  /**
   * Gateway marks this node as a gateway-only node (no storage).
   * Gateway nodes handle API requests but don't store data blocks.
   *
   * @schema GarageNodeSpec#gateway
   */
  readonly gateway?: boolean;

  /**
   * Image overrides the Garage container image.
   * If not specified, inherits from GarageCluster.
   *
   * @schema GarageNodeSpec#image
   */
  readonly image?: string;

  /**
   * ImageRepository overrides just the repository portion of the Garage image.
   * If not specified, inherits from GarageCluster.
   * Ignored if image is set.
   *
   * @schema GarageNodeSpec#imageRepository
   */
  readonly imageRepository?: string;

  /**
   * NodeID is the public key of the Garage node.
   * If not specified, the operator will auto-discover from the pod.
   *
   * @schema GarageNodeSpec#nodeId
   */
  readonly nodeId?: string;

  /**
   * NodeSelector overrides node selection constraints.
   * If not specified, inherits from GarageCluster.
   *
   * @schema GarageNodeSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * PodAnnotations are additional annotations to add to this node's pod.
   * Merged with annotations from GarageCluster (node-specific takes precedence).
   *
   * @schema GarageNodeSpec#podAnnotations
   */
  readonly podAnnotations?: { [key: string]: string };

  /**
   * PodLabels are additional labels to add to this node's pod.
   * Merged with labels from GarageCluster (node-specific takes precedence).
   *
   * @schema GarageNodeSpec#podLabels
   */
  readonly podLabels?: { [key: string]: string };

  /**
   * PriorityClassName overrides the priority class for this node's pod.
   * If not specified, inherits from GarageCluster.
   *
   * @schema GarageNodeSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * Resources overrides compute resources for the Garage container.
   * If not specified, inherits from GarageCluster.
   *
   * @schema GarageNodeSpec#resources
   */
  readonly resources?: GarageNodeSpecResources;

  /**
   * Storage configures storage volumes for this node's StatefulSet.
   * Required when not using External.
   *
   * @schema GarageNodeSpec#storage
   */
  readonly storage?: GarageNodeSpecStorage;

  /**
   * Tags are custom tags for this node in the Garage layout.
   *
   * @schema GarageNodeSpec#tags
   */
  readonly tags?: string[];

  /**
   * Tolerations overrides pod tolerations.
   * If not specified, inherits from GarageCluster.
   *
   * @schema GarageNodeSpec#tolerations
   */
  readonly tolerations?: GarageNodeSpecTolerations[];

  /**
   * Zone is the zone assignment for this node.
   * Used for data placement and fault tolerance.
   *
   * @schema GarageNodeSpec#zone
   */
  readonly zone: string;
}

/**
 * Converts an object of type 'GarageNodeSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpec(obj: GarageNodeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': toJson_GarageNodeSpecAffinity(obj.affinity),
    'capacity': obj.capacity?.value,
    'clusterRef': toJson_GarageNodeSpecClusterRef(obj.clusterRef),
    'external': toJson_GarageNodeSpecExternal(obj.external),
    'gateway': obj.gateway,
    'image': obj.image,
    'imageRepository': obj.imageRepository,
    'nodeId': obj.nodeId,
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'podAnnotations': ((obj.podAnnotations) === undefined) ? undefined : (Object.entries(obj.podAnnotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'podLabels': ((obj.podLabels) === undefined) ? undefined : (Object.entries(obj.podLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'priorityClassName': obj.priorityClassName,
    'resources': toJson_GarageNodeSpecResources(obj.resources),
    'storage': toJson_GarageNodeSpecStorage(obj.storage),
    'tags': obj.tags?.map(y => y),
    'tolerations': obj.tolerations?.map(y => toJson_GarageNodeSpecTolerations(y)),
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Affinity overrides pod affinity rules.
 * If not specified, inherits from GarageCluster.
 *
 * @schema GarageNodeSpecAffinity
 */
export interface GarageNodeSpecAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema GarageNodeSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: GarageNodeSpecAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema GarageNodeSpecAffinity#podAffinity
   */
  readonly podAffinity?: GarageNodeSpecAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema GarageNodeSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: GarageNodeSpecAffinityPodAntiAffinity;
}

/**
 * Converts an object of type 'GarageNodeSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinity(obj: GarageNodeSpecAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_GarageNodeSpecAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_GarageNodeSpecAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_GarageNodeSpecAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Capacity is the storage capacity to report to Garage for this node.
 * Required unless Gateway is true.
 *
 * @schema GarageNodeSpecCapacity
 */
export class GarageNodeSpecCapacity {
  public static fromNumber(value: number): GarageNodeSpecCapacity {
    return new GarageNodeSpecCapacity(value);
  }
  public static fromString(value: string): GarageNodeSpecCapacity {
    return new GarageNodeSpecCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ClusterRef references the GarageCluster this node belongs to.
 * The GarageNode inherits configuration from this cluster.
 *
 * @schema GarageNodeSpecClusterRef
 */
export interface GarageNodeSpecClusterRef {
  /**
   * KubeConfigSecretRef references a secret containing kubeconfig for a remote cluster.
   * Only used for cross-cluster references in multi-cluster federation scenarios.
   *
   * @schema GarageNodeSpecClusterRef#kubeConfigSecretRef
   */
  readonly kubeConfigSecretRef?: GarageNodeSpecClusterRefKubeConfigSecretRef;

  /**
   * Name of the GarageCluster
   *
   * @schema GarageNodeSpecClusterRef#name
   */
  readonly name: string;

  /**
   * Namespace of the GarageCluster (defaults to the same namespace as the referencing resource)
   *
   * @schema GarageNodeSpecClusterRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'GarageNodeSpecClusterRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecClusterRef(obj: GarageNodeSpecClusterRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kubeConfigSecretRef': toJson_GarageNodeSpecClusterRefKubeConfigSecretRef(obj.kubeConfigSecretRef),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * External marks this node as an external node (not managed by this operator).
 * When set, no StatefulSet is created - the node is assumed to exist externally.
 *
 * @schema GarageNodeSpecExternal
 */
export interface GarageNodeSpecExternal {
  /**
   * Address is the IP or hostname of the external node
   *
   * @schema GarageNodeSpecExternal#address
   */
  readonly address: string;

  /**
   * Port is the RPC port of the external node
   *
   * @schema GarageNodeSpecExternal#port
   */
  readonly port?: number;

  /**
   * RemoteClusterRef references a GarageCluster in another namespace/cluster
   *
   * @schema GarageNodeSpecExternal#remoteClusterRef
   */
  readonly remoteClusterRef?: GarageNodeSpecExternalRemoteClusterRef;
}

/**
 * Converts an object of type 'GarageNodeSpecExternal' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecExternal(obj: GarageNodeSpecExternal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
    'remoteClusterRef': toJson_GarageNodeSpecExternalRemoteClusterRef(obj.remoteClusterRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources overrides compute resources for the Garage container.
 * If not specified, inherits from GarageCluster.
 *
 * @schema GarageNodeSpecResources
 */
export interface GarageNodeSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This field depends on the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema GarageNodeSpecResources#claims
   */
  readonly claims?: GarageNodeSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema GarageNodeSpecResources#limits
   */
  readonly limits?: { [key: string]: GarageNodeSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema GarageNodeSpecResources#requests
   */
  readonly requests?: { [key: string]: GarageNodeSpecResourcesRequests };
}

/**
 * Converts an object of type 'GarageNodeSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecResources(obj: GarageNodeSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_GarageNodeSpecResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Storage configures storage volumes for this node's StatefulSet.
 * Required when not using External.
 *
 * @schema GarageNodeSpecStorage
 */
export interface GarageNodeSpecStorage {
  /**
   * Data volume configuration for block storage.
   * Ignored if the node is a gateway (Gateway: true).
   *
   * @schema GarageNodeSpecStorage#data
   */
  readonly data?: GarageNodeSpecStorageData;

  /**
   * Metadata volume configuration for node identity and cluster state.
   * Required for all nodes (storage and gateway).
   *
   * @schema GarageNodeSpecStorage#metadata
   */
  readonly metadata?: GarageNodeSpecStorageMetadata;
}

/**
 * Converts an object of type 'GarageNodeSpecStorage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecStorage(obj: GarageNodeSpecStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': toJson_GarageNodeSpecStorageData(obj.data),
    'metadata': toJson_GarageNodeSpecStorageMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema GarageNodeSpecTolerations
 */
export interface GarageNodeSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema GarageNodeSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema GarageNodeSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists, Equal, Lt, and Gt. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   * Lt and Gt perform numeric comparisons (requires feature gate TaintTolerationComparisonOperators).
   *
   * @default Equal.
   * @schema GarageNodeSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema GarageNodeSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema GarageNodeSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'GarageNodeSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecTolerations(obj: GarageNodeSpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema GarageNodeSpecAffinityNodeAffinity
 */
export interface GarageNodeSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema GarageNodeSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema GarageNodeSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityNodeAffinity(obj: GarageNodeSpecAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema GarageNodeSpecAffinityPodAffinity
 */
export interface GarageNodeSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema GarageNodeSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema GarageNodeSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityPodAffinity(obj: GarageNodeSpecAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema GarageNodeSpecAffinityPodAntiAffinity
 */
export interface GarageNodeSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and subtracting
   * "weight" from the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityPodAntiAffinity(obj: GarageNodeSpecAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KubeConfigSecretRef references a secret containing kubeconfig for a remote cluster.
 * Only used for cross-cluster references in multi-cluster federation scenarios.
 *
 * @schema GarageNodeSpecClusterRefKubeConfigSecretRef
 */
export interface GarageNodeSpecClusterRefKubeConfigSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GarageNodeSpecClusterRefKubeConfigSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema GarageNodeSpecClusterRefKubeConfigSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GarageNodeSpecClusterRefKubeConfigSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'GarageNodeSpecClusterRefKubeConfigSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecClusterRefKubeConfigSecretRef(obj: GarageNodeSpecClusterRefKubeConfigSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RemoteClusterRef references a GarageCluster in another namespace/cluster
 *
 * @schema GarageNodeSpecExternalRemoteClusterRef
 */
export interface GarageNodeSpecExternalRemoteClusterRef {
  /**
   * KubeConfigSecretRef references a secret containing kubeconfig for a remote cluster.
   * Only used for cross-cluster references in multi-cluster federation scenarios.
   *
   * @schema GarageNodeSpecExternalRemoteClusterRef#kubeConfigSecretRef
   */
  readonly kubeConfigSecretRef?: GarageNodeSpecExternalRemoteClusterRefKubeConfigSecretRef;

  /**
   * Name of the GarageCluster
   *
   * @schema GarageNodeSpecExternalRemoteClusterRef#name
   */
  readonly name: string;

  /**
   * Namespace of the GarageCluster (defaults to the same namespace as the referencing resource)
   *
   * @schema GarageNodeSpecExternalRemoteClusterRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'GarageNodeSpecExternalRemoteClusterRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecExternalRemoteClusterRef(obj: GarageNodeSpecExternalRemoteClusterRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kubeConfigSecretRef': toJson_GarageNodeSpecExternalRemoteClusterRefKubeConfigSecretRef(obj.kubeConfigSecretRef),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema GarageNodeSpecResourcesClaims
 */
export interface GarageNodeSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema GarageNodeSpecResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema GarageNodeSpecResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'GarageNodeSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecResourcesClaims(obj: GarageNodeSpecResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema GarageNodeSpecResourcesLimits
 */
export class GarageNodeSpecResourcesLimits {
  public static fromNumber(value: number): GarageNodeSpecResourcesLimits {
    return new GarageNodeSpecResourcesLimits(value);
  }
  public static fromString(value: string): GarageNodeSpecResourcesLimits {
    return new GarageNodeSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema GarageNodeSpecResourcesRequests
 */
export class GarageNodeSpecResourcesRequests {
  public static fromNumber(value: number): GarageNodeSpecResourcesRequests {
    return new GarageNodeSpecResourcesRequests(value);
  }
  public static fromString(value: string): GarageNodeSpecResourcesRequests {
    return new GarageNodeSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Data volume configuration for block storage.
 * Ignored if the node is a gateway (Gateway: true).
 *
 * @schema GarageNodeSpecStorageData
 */
export interface GarageNodeSpecStorageData {
  /**
   * ExistingClaim references a pre-existing PVC by name.
   * The PVC must exist in the same namespace as the GarageCluster.
   * Mutually exclusive with Size.
   *
   * @schema GarageNodeSpecStorageData#existingClaim
   */
  readonly existingClaim?: string;

  /**
   * Size for a dynamically provisioned PVC.
   * The operator will create a PVC with this size if it doesn't exist.
   * Mutually exclusive with ExistingClaim.
   *
   * @schema GarageNodeSpecStorageData#size
   */
  readonly size?: GarageNodeSpecStorageDataSize;

  /**
   * StorageClassName for dynamically provisioned PVC.
   * Only used when Size is specified.
   * If not specified, the cluster's default storage class is used.
   *
   * @schema GarageNodeSpecStorageData#storageClassName
   */
  readonly storageClassName?: string;
}

/**
 * Converts an object of type 'GarageNodeSpecStorageData' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecStorageData(obj: GarageNodeSpecStorageData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'existingClaim': obj.existingClaim,
    'size': obj.size?.value,
    'storageClassName': obj.storageClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metadata volume configuration for node identity and cluster state.
 * Required for all nodes (storage and gateway).
 *
 * @schema GarageNodeSpecStorageMetadata
 */
export interface GarageNodeSpecStorageMetadata {
  /**
   * ExistingClaim references a pre-existing PVC by name.
   * The PVC must exist in the same namespace as the GarageCluster.
   * Mutually exclusive with Size.
   *
   * @schema GarageNodeSpecStorageMetadata#existingClaim
   */
  readonly existingClaim?: string;

  /**
   * Size for a dynamically provisioned PVC.
   * The operator will create a PVC with this size if it doesn't exist.
   * Mutually exclusive with ExistingClaim.
   *
   * @schema GarageNodeSpecStorageMetadata#size
   */
  readonly size?: GarageNodeSpecStorageMetadataSize;

  /**
   * StorageClassName for dynamically provisioned PVC.
   * Only used when Size is specified.
   * If not specified, the cluster's default storage class is used.
   *
   * @schema GarageNodeSpecStorageMetadata#storageClassName
   */
  readonly storageClassName?: string;
}

/**
 * Converts an object of type 'GarageNodeSpecStorageMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecStorageMetadata(obj: GarageNodeSpecStorageMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'existingClaim': obj.existingClaim,
    'size': obj.size?.value,
    'storageClassName': obj.storageClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KubeConfigSecretRef references a secret containing kubeconfig for a remote cluster.
 * Only used for cross-cluster references in multi-cluster federation scenarios.
 *
 * @schema GarageNodeSpecExternalRemoteClusterRefKubeConfigSecretRef
 */
export interface GarageNodeSpecExternalRemoteClusterRefKubeConfigSecretRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema GarageNodeSpecExternalRemoteClusterRefKubeConfigSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema GarageNodeSpecExternalRemoteClusterRefKubeConfigSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema GarageNodeSpecExternalRemoteClusterRefKubeConfigSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'GarageNodeSpecExternalRemoteClusterRefKubeConfigSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecExternalRemoteClusterRefKubeConfigSecretRef(obj: GarageNodeSpecExternalRemoteClusterRefKubeConfigSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Size for a dynamically provisioned PVC.
 * The operator will create a PVC with this size if it doesn't exist.
 * Mutually exclusive with ExistingClaim.
 *
 * @schema GarageNodeSpecStorageDataSize
 */
export class GarageNodeSpecStorageDataSize {
  public static fromNumber(value: number): GarageNodeSpecStorageDataSize {
    return new GarageNodeSpecStorageDataSize(value);
  }
  public static fromString(value: string): GarageNodeSpecStorageDataSize {
    return new GarageNodeSpecStorageDataSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Size for a dynamically provisioned PVC.
 * The operator will create a PVC with this size if it doesn't exist.
 * Mutually exclusive with ExistingClaim.
 *
 * @schema GarageNodeSpecStorageMetadataSize
 */
export class GarageNodeSpecStorageMetadataSize {
  public static fromNumber(value: number): GarageNodeSpecStorageMetadataSize {
    return new GarageNodeSpecStorageMetadataSize(value);
  }
  public static fromString(value: string): GarageNodeSpecStorageMetadataSize {
    return new GarageNodeSpecStorageMetadataSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: GarageNodeSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: GarageNodeSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: GarageNodeSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: GarageNodeSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: GarageNodeSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: GarageNodeSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

