// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Backend allows the user to configure the endpoints of a backend and
the behavior of the connection from Envoy Proxy to the backend.
 *
 * @schema Backend
 */
export class Backend extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Backend"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'gateway.envoyproxy.io/v1alpha1',
    kind: 'Backend',
  }

  /**
   * Renders a Kubernetes manifest for "Backend".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackendProps): any {
    return {
      ...Backend.GVK,
      ...toJson_BackendProps(props),
    };
  }

  /**
   * Defines a "Backend" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackendProps) {
    super(scope, id, {
      ...Backend.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Backend.GVK,
      ...toJson_BackendProps(resolved),
    };
  }
}

/**
 * Backend allows the user to configure the endpoints of a backend and
 * the behavior of the connection from Envoy Proxy to the backend.
 *
 * @schema Backend
 */
export interface BackendProps {
  /**
   * @schema Backend#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec defines the desired state of Backend.
   *
   * @schema Backend#spec
   */
  readonly spec: BackendSpec;
}

/**
 * Converts an object of type 'BackendProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendProps(obj: BackendProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BackendSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec defines the desired state of Backend.
 *
 * @schema BackendSpec
 */
export interface BackendSpec {
  /**
   * AppProtocols defines the application protocols to be supported when connecting to the backend.
   *
   * @schema BackendSpec#appProtocols
   */
  readonly appProtocols?: BackendSpecAppProtocols[];

  /**
   * Endpoints defines the endpoints to be used when connecting to the backend.
   *
   * @schema BackendSpec#endpoints
   */
  readonly endpoints?: BackendSpecEndpoints[];

  /**
   * Fallback indicates whether the backend is designated as a fallback.
   * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
   * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
   * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
   * the health of the active backends falls below 72%.
   *
   * @schema BackendSpec#fallback
   */
  readonly fallback?: boolean;

  /**
   * TLS defines the TLS settings for the backend.
   * If TLS is specified here and a BackendTLSPolicy is also configured for the backend, the final TLS settings will
   * be a merge of both configurations. In case of overlapping fields, the values defined in the BackendTLSPolicy will
   * take precedence.
   *
   * @schema BackendSpec#tls
   */
  readonly tls?: BackendSpecTls;

  /**
   * Type defines the type of the backend. Defaults to "Endpoints"
   *
   * @default Endpoints"
   * @schema BackendSpec#type
   */
  readonly type?: BackendSpecType;
}

/**
 * Converts an object of type 'BackendSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendSpec(obj: BackendSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appProtocols': obj.appProtocols?.map(y => y),
    'endpoints': obj.endpoints?.map(y => toJson_BackendSpecEndpoints(y)),
    'fallback': obj.fallback,
    'tls': toJson_BackendSpecTls(obj.tls),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AppProtocolType defines various backend applications protocols supported by Envoy Gateway
 *
 * @schema BackendSpecAppProtocols
 */
export enum BackendSpecAppProtocols {
  /** gateway.envoyproxy.io/h2c */
  GATEWAY_PERIOD_ENVOYPROXY_PERIOD_IO_FORWARD_SLASH_H2C = "gateway.envoyproxy.io/h2c",
  /** gateway.envoyproxy.io/ws */
  GATEWAY_PERIOD_ENVOYPROXY_PERIOD_IO_FORWARD_SLASH_WS = "gateway.envoyproxy.io/ws",
  /** gateway.envoyproxy.io/wss */
  GATEWAY_PERIOD_ENVOYPROXY_PERIOD_IO_FORWARD_SLASH_WSS = "gateway.envoyproxy.io/wss",
}

/**
 * BackendEndpoint describes a backend endpoint, which can be either a fully-qualified domain name, IP address or unix domain socket
 * corresponding to Envoy's Address: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/address.proto#config-core-v3-address
 *
 * @schema BackendSpecEndpoints
 */
export interface BackendSpecEndpoints {
  /**
   * FQDN defines a FQDN endpoint
   *
   * @schema BackendSpecEndpoints#fqdn
   */
  readonly fqdn?: BackendSpecEndpointsFqdn;

  /**
   * Hostname defines an optional hostname for the backend endpoint.
   *
   * @schema BackendSpecEndpoints#hostname
   */
  readonly hostname?: string;

  /**
   * IP defines an IP endpoint. Supports both IPv4 and IPv6 addresses.
   *
   * @schema BackendSpecEndpoints#ip
   */
  readonly ip?: BackendSpecEndpointsIp;

  /**
   * Unix defines the unix domain socket endpoint
   *
   * @schema BackendSpecEndpoints#unix
   */
  readonly unix?: BackendSpecEndpointsUnix;

  /**
   * Zone defines the service zone of the backend endpoint.
   *
   * @schema BackendSpecEndpoints#zone
   */
  readonly zone?: string;
}

/**
 * Converts an object of type 'BackendSpecEndpoints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendSpecEndpoints(obj: BackendSpecEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fqdn': toJson_BackendSpecEndpointsFqdn(obj.fqdn),
    'hostname': obj.hostname,
    'ip': toJson_BackendSpecEndpointsIp(obj.ip),
    'unix': toJson_BackendSpecEndpointsUnix(obj.unix),
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS defines the TLS settings for the backend.
 * If TLS is specified here and a BackendTLSPolicy is also configured for the backend, the final TLS settings will
 * be a merge of both configurations. In case of overlapping fields, the values defined in the BackendTLSPolicy will
 * take precedence.
 *
 * @schema BackendSpecTls
 */
export interface BackendSpecTls {
  /**
   * ALPNProtocols supplies the list of ALPN protocols that should be
   * exposed by the listener or used by the proxy to connect to the backend.
   * Defaults:
   * 1. HTTPS Routes: h2 and http/1.1 are enabled in listener context.
   * 2. Other Routes: ALPN is disabled.
   * 3. Backends: proxy uses the appropriate ALPN options for the backend protocol.
   * When an empty list is provided, the ALPN TLS extension is disabled.
   *
   * Defaults to [h2, http/1.1] if not specified.
   *
   * Typical Supported values are:
   * - http/1.0
   * - http/1.1
   * - h2
   *
   * @default h2, http/1.1] if not specified.
   * @schema BackendSpecTls#alpnProtocols
   */
  readonly alpnProtocols?: string[];

  /**
   * CACertificateRefs contains one or more references to Kubernetes objects that
   * contain TLS certificates of the Certificate Authorities that can be used
   * as a trust anchor to validate the certificates presented by the backend.
   *
   * A single reference to a Kubernetes ConfigMap or a Kubernetes Secret,
   * with the CA certificate in a key named `ca.crt` is currently supported.
   *
   * If CACertificateRefs is empty or unspecified, then WellKnownCACertificates must be
   * specified. Only one of CACertificateRefs or WellKnownCACertificates may be specified,
   * not both.
   *
   * @schema BackendSpecTls#caCertificateRefs
   */
  readonly caCertificateRefs?: BackendSpecTlsCaCertificateRefs[];

  /**
   * Ciphers specifies the set of cipher suites supported when
   * negotiating TLS 1.0 - 1.2. This setting has no effect for TLS 1.3.
   * In non-FIPS Envoy Proxy builds the default cipher list is:
   * - [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
   * - [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
   * - ECDHE-ECDSA-AES256-GCM-SHA384
   * - ECDHE-RSA-AES256-GCM-SHA384
   * In builds using BoringSSL FIPS the default cipher list is:
   * - ECDHE-ECDSA-AES128-GCM-SHA256
   * - ECDHE-RSA-AES128-GCM-SHA256
   * - ECDHE-ECDSA-AES256-GCM-SHA384
   * - ECDHE-RSA-AES256-GCM-SHA384
   *
   * @schema BackendSpecTls#ciphers
   */
  readonly ciphers?: string[];

  /**
   * ClientCertificateRef defines the reference to a Kubernetes Secret that contains
   * the client certificate and private key for Envoy to use when connecting to
   * backend services and external services, such as ExtAuth, ALS, OpenTelemetry, etc.
   * This secret should be located within the same namespace as the Envoy proxy resource that references it.
   *
   * @schema BackendSpecTls#clientCertificateRef
   */
  readonly clientCertificateRef?: BackendSpecTlsClientCertificateRef;

  /**
   * ECDHCurves specifies the set of supported ECDH curves.
   * In non-FIPS Envoy Proxy builds the default curves are:
   * - X25519
   * - P-256
   * In builds using BoringSSL FIPS the default curve is:
   * - P-256
   *
   * @schema BackendSpecTls#ecdhCurves
   */
  readonly ecdhCurves?: string[];

  /**
   * InsecureSkipVerify indicates whether the upstream's certificate verification
   * should be skipped. Defaults to "false".
   *
   * @default false".
   * @schema BackendSpecTls#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Max specifies the maximal TLS protocol version to allow
   * The default is TLS 1.3 if this is not specified.
   *
   * @schema BackendSpecTls#maxVersion
   */
  readonly maxVersion?: BackendSpecTlsMaxVersion;

  /**
   * Min specifies the minimal TLS protocol version to allow.
   * The default is TLS 1.2 if this is not specified.
   *
   * @schema BackendSpecTls#minVersion
   */
  readonly minVersion?: BackendSpecTlsMinVersion;

  /**
   * SignatureAlgorithms specifies which signature algorithms the listener should
   * support.
   *
   * @schema BackendSpecTls#signatureAlgorithms
   */
  readonly signatureAlgorithms?: string[];

  /**
   * SNI is specifies the SNI value used when establishing an upstream TLS connection to the backend.
   *
   * Envoy Gateway will use the HTTP host header value for SNI, when all resources referenced in BackendRefs are:
   * 1. Backend resources that do not set SNI, or
   * 2. Service/ServiceImport resources that do not have a BackendTLSPolicy attached to them
   *
   * When a BackendTLSPolicy attaches to a Backend resource, the BackendTLSPolicy's Hostname value takes precedence
   * over this value.
   *
   * @schema BackendSpecTls#sni
   */
  readonly sni?: string;

  /**
   * WellKnownCACertificates specifies whether system CA certificates may be used in
   * the TLS handshake between the gateway and backend pod.
   *
   * If WellKnownCACertificates is unspecified or empty (""), then CACertificateRefs
   * must be specified with at least one entry for a valid configuration. Only one of
   * CACertificateRefs or WellKnownCACertificates may be specified, not both.
   *
   * @schema BackendSpecTls#wellKnownCACertificates
   */
  readonly wellKnownCaCertificates?: BackendSpecTlsWellKnownCaCertificates;
}

/**
 * Converts an object of type 'BackendSpecTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendSpecTls(obj: BackendSpecTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alpnProtocols': obj.alpnProtocols?.map(y => y),
    'caCertificateRefs': obj.caCertificateRefs?.map(y => toJson_BackendSpecTlsCaCertificateRefs(y)),
    'ciphers': obj.ciphers?.map(y => y),
    'clientCertificateRef': toJson_BackendSpecTlsClientCertificateRef(obj.clientCertificateRef),
    'ecdhCurves': obj.ecdhCurves?.map(y => y),
    'insecureSkipVerify': obj.insecureSkipVerify,
    'maxVersion': obj.maxVersion,
    'minVersion': obj.minVersion,
    'signatureAlgorithms': obj.signatureAlgorithms?.map(y => y),
    'sni': obj.sni,
    'wellKnownCACertificates': obj.wellKnownCaCertificates,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type defines the type of the backend. Defaults to "Endpoints"
 *
 * @default Endpoints"
 * @schema BackendSpecType
 */
export enum BackendSpecType {
  /** Endpoints */
  ENDPOINTS = "Endpoints",
  /** DynamicResolver */
  DYNAMIC_RESOLVER = "DynamicResolver",
}

/**
 * FQDN defines a FQDN endpoint
 *
 * @schema BackendSpecEndpointsFqdn
 */
export interface BackendSpecEndpointsFqdn {
  /**
   * Hostname defines the FQDN hostname of the backend endpoint.
   *
   * @schema BackendSpecEndpointsFqdn#hostname
   */
  readonly hostname: string;

  /**
   * Port defines the port of the backend endpoint.
   *
   * @schema BackendSpecEndpointsFqdn#port
   */
  readonly port: number;
}

/**
 * Converts an object of type 'BackendSpecEndpointsFqdn' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendSpecEndpointsFqdn(obj: BackendSpecEndpointsFqdn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostname': obj.hostname,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * IP defines an IP endpoint. Supports both IPv4 and IPv6 addresses.
 *
 * @schema BackendSpecEndpointsIp
 */
export interface BackendSpecEndpointsIp {
  /**
   * Address defines the IP address of the backend endpoint.
   * Supports both IPv4 and IPv6 addresses.
   *
   * @schema BackendSpecEndpointsIp#address
   */
  readonly address: string;

  /**
   * Port defines the port of the backend endpoint.
   *
   * @schema BackendSpecEndpointsIp#port
   */
  readonly port: number;
}

/**
 * Converts an object of type 'BackendSpecEndpointsIp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendSpecEndpointsIp(obj: BackendSpecEndpointsIp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Unix defines the unix domain socket endpoint
 *
 * @schema BackendSpecEndpointsUnix
 */
export interface BackendSpecEndpointsUnix {
  /**
   * Path defines the unix domain socket path of the backend endpoint.
   * The path length must not exceed 108 characters.
   *
   * @schema BackendSpecEndpointsUnix#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'BackendSpecEndpointsUnix' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendSpecEndpointsUnix(obj: BackendSpecEndpointsUnix | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference identifies an API object within the namespace of the
 * referrer.
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 *
 * References to objects with invalid Group and Kind are not valid, and must
 * be rejected by the implementation, with appropriate Conditions set
 * on the containing object.
 *
 * @schema BackendSpecTlsCaCertificateRefs
 */
export interface BackendSpecTlsCaCertificateRefs {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema BackendSpecTlsCaCertificateRefs#group
   */
  readonly group: string;

  /**
   * Kind is kind of the referent. For example "HTTPRoute" or "Service".
   *
   * @schema BackendSpecTlsCaCertificateRefs#kind
   */
  readonly kind: string;

  /**
   * Name is the name of the referent.
   *
   * @schema BackendSpecTlsCaCertificateRefs#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'BackendSpecTlsCaCertificateRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendSpecTlsCaCertificateRefs(obj: BackendSpecTlsCaCertificateRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientCertificateRef defines the reference to a Kubernetes Secret that contains
 * the client certificate and private key for Envoy to use when connecting to
 * backend services and external services, such as ExtAuth, ALS, OpenTelemetry, etc.
 * This secret should be located within the same namespace as the Envoy proxy resource that references it.
 *
 * @schema BackendSpecTlsClientCertificateRef
 */
export interface BackendSpecTlsClientCertificateRef {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema BackendSpecTlsClientCertificateRef#group
   */
  readonly group?: string;

  /**
   * Kind is kind of the referent. For example "Secret".
   *
   * @schema BackendSpecTlsClientCertificateRef#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema BackendSpecTlsClientCertificateRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the referenced object. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema BackendSpecTlsClientCertificateRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'BackendSpecTlsClientCertificateRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendSpecTlsClientCertificateRef(obj: BackendSpecTlsClientCertificateRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Max specifies the maximal TLS protocol version to allow
 * The default is TLS 1.3 if this is not specified.
 *
 * @schema BackendSpecTlsMaxVersion
 */
export enum BackendSpecTlsMaxVersion {
  /** Auto */
  AUTO = "Auto",
  /** 1.0 */
  VALUE_1_0 = "1.0",
  /** 1.1 */
  VALUE_1_1 = "1.1",
  /** 1.2 */
  VALUE_1_2 = "1.2",
  /** 1.3 */
  VALUE_1_3 = "1.3",
}

/**
 * Min specifies the minimal TLS protocol version to allow.
 * The default is TLS 1.2 if this is not specified.
 *
 * @schema BackendSpecTlsMinVersion
 */
export enum BackendSpecTlsMinVersion {
  /** Auto */
  AUTO = "Auto",
  /** 1.0 */
  VALUE_1_0 = "1.0",
  /** 1.1 */
  VALUE_1_1 = "1.1",
  /** 1.2 */
  VALUE_1_2 = "1.2",
  /** 1.3 */
  VALUE_1_3 = "1.3",
}

/**
 * WellKnownCACertificates specifies whether system CA certificates may be used in
 * the TLS handshake between the gateway and backend pod.
 *
 * If WellKnownCACertificates is unspecified or empty (""), then CACertificateRefs
 * must be specified with at least one entry for a valid configuration. Only one of
 * CACertificateRefs or WellKnownCACertificates may be specified, not both.
 *
 * @schema BackendSpecTlsWellKnownCaCertificates
 */
export enum BackendSpecTlsWellKnownCaCertificates {
  /** System */
  SYSTEM = "System",
}


/**
 * BackendTrafficPolicy allows the user to configure the behavior of the connection
between the Envoy Proxy listener and the backend service.
 *
 * @schema BackendTrafficPolicy
 */
export class BackendTrafficPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackendTrafficPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'gateway.envoyproxy.io/v1alpha1',
    kind: 'BackendTrafficPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "BackendTrafficPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackendTrafficPolicyProps): any {
    return {
      ...BackendTrafficPolicy.GVK,
      ...toJson_BackendTrafficPolicyProps(props),
    };
  }

  /**
   * Defines a "BackendTrafficPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackendTrafficPolicyProps) {
    super(scope, id, {
      ...BackendTrafficPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackendTrafficPolicy.GVK,
      ...toJson_BackendTrafficPolicyProps(resolved),
    };
  }
}

/**
 * BackendTrafficPolicy allows the user to configure the behavior of the connection
 * between the Envoy Proxy listener and the backend service.
 *
 * @schema BackendTrafficPolicy
 */
export interface BackendTrafficPolicyProps {
  /**
   * @schema BackendTrafficPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * spec defines the desired state of BackendTrafficPolicy.
   *
   * @schema BackendTrafficPolicy#spec
   */
  readonly spec: BackendTrafficPolicySpec;
}

/**
 * Converts an object of type 'BackendTrafficPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicyProps(obj: BackendTrafficPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BackendTrafficPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * spec defines the desired state of BackendTrafficPolicy.
 *
 * @schema BackendTrafficPolicySpec
 */
export interface BackendTrafficPolicySpec {
  /**
   * Circuit Breaker settings for the upstream connections and requests.
   * If not set, circuit breakers will be enabled with the default thresholds
   *
   * @schema BackendTrafficPolicySpec#circuitBreaker
   */
  readonly circuitBreaker?: BackendTrafficPolicySpecCircuitBreaker;

  /**
   * The compression config for the http streams.
   * Deprecated: Use Compressor instead.
   *
   * @schema BackendTrafficPolicySpec#compression
   */
  readonly compression?: BackendTrafficPolicySpecCompression[];

  /**
   * The compressor config for the http streams.
   * This provides more granular control over compression configuration.
   *
   * @schema BackendTrafficPolicySpec#compressor
   */
  readonly compressor?: BackendTrafficPolicySpecCompressor[];

  /**
   * Connection includes backend connection settings.
   *
   * @schema BackendTrafficPolicySpec#connection
   */
  readonly connection?: BackendTrafficPolicySpecConnection;

  /**
   * DNS includes dns resolution settings.
   *
   * @schema BackendTrafficPolicySpec#dns
   */
  readonly dns?: BackendTrafficPolicySpecDns;

  /**
   * FaultInjection defines the fault injection policy to be applied. This configuration can be used to
   * inject delays and abort requests to mimic failure scenarios such as service failures and overloads
   *
   * @schema BackendTrafficPolicySpec#faultInjection
   */
  readonly faultInjection?: BackendTrafficPolicySpecFaultInjection;

  /**
   * HealthCheck allows gateway to perform active health checking on backends.
   *
   * @schema BackendTrafficPolicySpec#healthCheck
   */
  readonly healthCheck?: BackendTrafficPolicySpecHealthCheck;

  /**
   * HTTP2 provides HTTP/2 configuration for backend connections.
   *
   * @schema BackendTrafficPolicySpec#http2
   */
  readonly http2?: BackendTrafficPolicySpecHttp2;

  /**
   * HTTPUpgrade defines the configuration for HTTP protocol upgrades.
   * If not specified, the default upgrade configuration(websocket) will be used.
   *
   * @schema BackendTrafficPolicySpec#httpUpgrade
   */
  readonly httpUpgrade?: BackendTrafficPolicySpecHttpUpgrade[];

  /**
   * LoadBalancer policy to apply when routing traffic from the gateway to
   * the backend endpoints. Defaults to `LeastRequest`.
   *
   * @default LeastRequest`.
   * @schema BackendTrafficPolicySpec#loadBalancer
   */
  readonly loadBalancer?: BackendTrafficPolicySpecLoadBalancer;

  /**
   * MergeType determines how this configuration is merged with existing BackendTrafficPolicy
   * configurations targeting a parent resource. When set, this configuration will be merged
   * into a parent BackendTrafficPolicy (i.e. the one targeting a Gateway or Listener).
   * This field cannot be set when targeting a parent resource (Gateway).
   * If unset, no merging occurs, and only the most specific configuration takes effect.
   *
   * @schema BackendTrafficPolicySpec#mergeType
   */
  readonly mergeType?: string;

  /**
   * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
   *
   * @schema BackendTrafficPolicySpec#proxyProtocol
   */
  readonly proxyProtocol?: BackendTrafficPolicySpecProxyProtocol;

  /**
   * RateLimit allows the user to limit the number of incoming requests
   * to a predefined value based on attributes within the traffic flow.
   *
   * @schema BackendTrafficPolicySpec#rateLimit
   */
  readonly rateLimit?: BackendTrafficPolicySpecRateLimit;

  /**
   * RequestBuffer allows the gateway to buffer and fully receive each request from a client before continuing to send the request
   * upstream to the backends. This can be helpful to shield your backend servers from slow clients, and also to enforce a maximum size per request
   * as any requests larger than the buffer size will be rejected.
   *
   * This can have a negative performance impact so should only be enabled when necessary.
   *
   * When enabling this option, you should also configure your connection buffer size to account for these request buffers. There will also be an
   * increase in memory usage for Envoy that should be accounted for in your deployment settings.
   *
   * @schema BackendTrafficPolicySpec#requestBuffer
   */
  readonly requestBuffer?: BackendTrafficPolicySpecRequestBuffer;

  /**
   * ResponseOverride defines the configuration to override specific responses with a custom one.
   * If multiple configurations are specified, the first one to match wins.
   *
   * @schema BackendTrafficPolicySpec#responseOverride
   */
  readonly responseOverride?: BackendTrafficPolicySpecResponseOverride[];

  /**
   * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
   * If not set, retry will be disabled.
   *
   * @schema BackendTrafficPolicySpec#retry
   */
  readonly retry?: BackendTrafficPolicySpecRetry;

  /**
   * TargetRef is the name of the resource this policy is being attached to.
   * This policy and the TargetRef MUST be in the same namespace for this
   * Policy to have effect
   *
   * Deprecated: use targetRefs/targetSelectors instead
   *
   * @schema BackendTrafficPolicySpec#targetRef
   */
  readonly targetRef?: BackendTrafficPolicySpecTargetRef;

  /**
   * TargetRefs are the names of the Gateway resources this policy
   * is being attached to.
   *
   * @schema BackendTrafficPolicySpec#targetRefs
   */
  readonly targetRefs?: BackendTrafficPolicySpecTargetRefs[];

  /**
   * TargetSelectors allow targeting resources for this policy based on labels
   *
   * @schema BackendTrafficPolicySpec#targetSelectors
   */
  readonly targetSelectors?: BackendTrafficPolicySpecTargetSelectors[];

  /**
   * TcpKeepalive settings associated with the upstream client connection.
   * Disabled by default.
   *
   * @schema BackendTrafficPolicySpec#tcpKeepalive
   */
  readonly tcpKeepalive?: BackendTrafficPolicySpecTcpKeepalive;

  /**
   * Telemetry configures the telemetry settings for the policy target (Gateway or xRoute).
   * This will override the telemetry settings in the EnvoyProxy resource.
   *
   * @schema BackendTrafficPolicySpec#telemetry
   */
  readonly telemetry?: BackendTrafficPolicySpecTelemetry;

  /**
   * Timeout settings for the backend connections.
   *
   * @schema BackendTrafficPolicySpec#timeout
   */
  readonly timeout?: BackendTrafficPolicySpecTimeout;

  /**
   * UseClientProtocol configures Envoy to prefer sending requests to backends using
   * the same HTTP protocol that the incoming request used. Defaults to false, which means
   * that Envoy will use the protocol indicated by the attached BackendRef.
   *
   * @default false, which means
   * @schema BackendTrafficPolicySpec#useClientProtocol
   */
  readonly useClientProtocol?: boolean;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpec(obj: BackendTrafficPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'circuitBreaker': toJson_BackendTrafficPolicySpecCircuitBreaker(obj.circuitBreaker),
    'compression': obj.compression?.map(y => toJson_BackendTrafficPolicySpecCompression(y)),
    'compressor': obj.compressor?.map(y => toJson_BackendTrafficPolicySpecCompressor(y)),
    'connection': toJson_BackendTrafficPolicySpecConnection(obj.connection),
    'dns': toJson_BackendTrafficPolicySpecDns(obj.dns),
    'faultInjection': toJson_BackendTrafficPolicySpecFaultInjection(obj.faultInjection),
    'healthCheck': toJson_BackendTrafficPolicySpecHealthCheck(obj.healthCheck),
    'http2': toJson_BackendTrafficPolicySpecHttp2(obj.http2),
    'httpUpgrade': obj.httpUpgrade?.map(y => toJson_BackendTrafficPolicySpecHttpUpgrade(y)),
    'loadBalancer': toJson_BackendTrafficPolicySpecLoadBalancer(obj.loadBalancer),
    'mergeType': obj.mergeType,
    'proxyProtocol': toJson_BackendTrafficPolicySpecProxyProtocol(obj.proxyProtocol),
    'rateLimit': toJson_BackendTrafficPolicySpecRateLimit(obj.rateLimit),
    'requestBuffer': toJson_BackendTrafficPolicySpecRequestBuffer(obj.requestBuffer),
    'responseOverride': obj.responseOverride?.map(y => toJson_BackendTrafficPolicySpecResponseOverride(y)),
    'retry': toJson_BackendTrafficPolicySpecRetry(obj.retry),
    'targetRef': toJson_BackendTrafficPolicySpecTargetRef(obj.targetRef),
    'targetRefs': obj.targetRefs?.map(y => toJson_BackendTrafficPolicySpecTargetRefs(y)),
    'targetSelectors': obj.targetSelectors?.map(y => toJson_BackendTrafficPolicySpecTargetSelectors(y)),
    'tcpKeepalive': toJson_BackendTrafficPolicySpecTcpKeepalive(obj.tcpKeepalive),
    'telemetry': toJson_BackendTrafficPolicySpecTelemetry(obj.telemetry),
    'timeout': toJson_BackendTrafficPolicySpecTimeout(obj.timeout),
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Circuit Breaker settings for the upstream connections and requests.
 * If not set, circuit breakers will be enabled with the default thresholds
 *
 * @schema BackendTrafficPolicySpecCircuitBreaker
 */
export interface BackendTrafficPolicySpecCircuitBreaker {
  /**
   * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
   *
   * @schema BackendTrafficPolicySpecCircuitBreaker#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
   *
   * @schema BackendTrafficPolicySpecCircuitBreaker#maxParallelRequests
   */
  readonly maxParallelRequests?: number;

  /**
   * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
   *
   * @schema BackendTrafficPolicySpecCircuitBreaker#maxParallelRetries
   */
  readonly maxParallelRetries?: number;

  /**
   * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
   *
   * @schema BackendTrafficPolicySpecCircuitBreaker#maxPendingRequests
   */
  readonly maxPendingRequests?: number;

  /**
   * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
   * Default: unlimited.
   *
   * @schema BackendTrafficPolicySpecCircuitBreaker#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
   *
   * @schema BackendTrafficPolicySpecCircuitBreaker#perEndpoint
   */
  readonly perEndpoint?: BackendTrafficPolicySpecCircuitBreakerPerEndpoint;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecCircuitBreaker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecCircuitBreaker(obj: BackendTrafficPolicySpecCircuitBreaker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
    'maxParallelRequests': obj.maxParallelRequests,
    'maxParallelRetries': obj.maxParallelRetries,
    'maxPendingRequests': obj.maxPendingRequests,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'perEndpoint': toJson_BackendTrafficPolicySpecCircuitBreakerPerEndpoint(obj.perEndpoint),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Compression defines the config of enabling compression.
 * This can help reduce the bandwidth at the expense of higher CPU.
 *
 * @schema BackendTrafficPolicySpecCompression
 */
export interface BackendTrafficPolicySpecCompression {
  /**
   * The configuration for Brotli compressor.
   *
   * @schema BackendTrafficPolicySpecCompression#brotli
   */
  readonly brotli?: any;

  /**
   * The configuration for GZIP compressor.
   *
   * @schema BackendTrafficPolicySpecCompression#gzip
   */
  readonly gzip?: any;

  /**
   * CompressorType defines the compressor type to use for compression.
   *
   * @schema BackendTrafficPolicySpecCompression#type
   */
  readonly type: BackendTrafficPolicySpecCompressionType;

  /**
   * The configuration for Zstd compressor.
   *
   * @schema BackendTrafficPolicySpecCompression#zstd
   */
  readonly zstd?: any;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecCompression' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecCompression(obj: BackendTrafficPolicySpecCompression | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'brotli': obj.brotli,
    'gzip': obj.gzip,
    'type': obj.type,
    'zstd': obj.zstd,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Compression defines the config of enabling compression.
 * This can help reduce the bandwidth at the expense of higher CPU.
 *
 * @schema BackendTrafficPolicySpecCompressor
 */
export interface BackendTrafficPolicySpecCompressor {
  /**
   * The configuration for Brotli compressor.
   *
   * @schema BackendTrafficPolicySpecCompressor#brotli
   */
  readonly brotli?: any;

  /**
   * The configuration for GZIP compressor.
   *
   * @schema BackendTrafficPolicySpecCompressor#gzip
   */
  readonly gzip?: any;

  /**
   * CompressorType defines the compressor type to use for compression.
   *
   * @schema BackendTrafficPolicySpecCompressor#type
   */
  readonly type: BackendTrafficPolicySpecCompressorType;

  /**
   * The configuration for Zstd compressor.
   *
   * @schema BackendTrafficPolicySpecCompressor#zstd
   */
  readonly zstd?: any;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecCompressor' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecCompressor(obj: BackendTrafficPolicySpecCompressor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'brotli': obj.brotli,
    'gzip': obj.gzip,
    'type': obj.type,
    'zstd': obj.zstd,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Connection includes backend connection settings.
 *
 * @schema BackendTrafficPolicySpecConnection
 */
export interface BackendTrafficPolicySpecConnection {
  /**
   * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
   * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
   * If unspecified, an implementation defined default is applied (32768 bytes).
   * For example, 20Mi, 1Gi, 256Ki etc.
   * Note: that when the suffix is not provided, the value is interpreted as bytes.
   *
   * @schema BackendTrafficPolicySpecConnection#bufferLimit
   */
  readonly bufferLimit?: BackendTrafficPolicySpecConnectionBufferLimit;

  /**
   * Preconnect configures proactive upstream connections to reduce latency by establishing
   * connections before they’re needed and avoiding connection establishment overhead.
   *
   * If unset, Envoy will fetch connections as needed to serve in-flight requests.
   *
   * @schema BackendTrafficPolicySpecConnection#preconnect
   */
  readonly preconnect?: BackendTrafficPolicySpecConnectionPreconnect;

  /**
   * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
   * to backend.
   * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
   * For example, 20Mi, 1Gi, 256Ki etc.
   * Note that when the suffix is not provided, the value is interpreted as bytes.
   *
   * @schema BackendTrafficPolicySpecConnection#socketBufferLimit
   */
  readonly socketBufferLimit?: BackendTrafficPolicySpecConnectionSocketBufferLimit;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecConnection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecConnection(obj: BackendTrafficPolicySpecConnection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bufferLimit': obj.bufferLimit?.value,
    'preconnect': toJson_BackendTrafficPolicySpecConnectionPreconnect(obj.preconnect),
    'socketBufferLimit': obj.socketBufferLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DNS includes dns resolution settings.
 *
 * @schema BackendTrafficPolicySpecDns
 */
export interface BackendTrafficPolicySpecDns {
  /**
   * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
   * Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema BackendTrafficPolicySpecDns#dnsRefreshRate
   */
  readonly dnsRefreshRate?: string;

  /**
   * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
   * If set, this configuration overrides other defaults.
   *
   * @schema BackendTrafficPolicySpecDns#lookupFamily
   */
  readonly lookupFamily?: BackendTrafficPolicySpecDnsLookupFamily;

  /**
   * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
   * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
   * Defaults to true.
   *
   * @default true.
   * @schema BackendTrafficPolicySpecDns#respectDnsTtl
   */
  readonly respectDnsTtl?: boolean;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecDns' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecDns(obj: BackendTrafficPolicySpecDns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsRefreshRate': obj.dnsRefreshRate,
    'lookupFamily': obj.lookupFamily,
    'respectDnsTtl': obj.respectDnsTtl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FaultInjection defines the fault injection policy to be applied. This configuration can be used to
 * inject delays and abort requests to mimic failure scenarios such as service failures and overloads
 *
 * @schema BackendTrafficPolicySpecFaultInjection
 */
export interface BackendTrafficPolicySpecFaultInjection {
  /**
   * If specified, the request will be aborted if it meets the configuration criteria.
   *
   * @schema BackendTrafficPolicySpecFaultInjection#abort
   */
  readonly abort?: BackendTrafficPolicySpecFaultInjectionAbort;

  /**
   * If specified, a delay will be injected into the request.
   *
   * @schema BackendTrafficPolicySpecFaultInjection#delay
   */
  readonly delay?: BackendTrafficPolicySpecFaultInjectionDelay;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecFaultInjection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecFaultInjection(obj: BackendTrafficPolicySpecFaultInjection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'abort': toJson_BackendTrafficPolicySpecFaultInjectionAbort(obj.abort),
    'delay': toJson_BackendTrafficPolicySpecFaultInjectionDelay(obj.delay),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HealthCheck allows gateway to perform active health checking on backends.
 *
 * @schema BackendTrafficPolicySpecHealthCheck
 */
export interface BackendTrafficPolicySpecHealthCheck {
  /**
   * Active health check configuration
   *
   * @schema BackendTrafficPolicySpecHealthCheck#active
   */
  readonly active?: BackendTrafficPolicySpecHealthCheckActive;

  /**
   * When number of unhealthy endpoints for a backend reaches this threshold
   * Envoy will disregard health status and balance across all endpoints.
   * It's designed to prevent a situation in which host failures cascade throughout the cluster
   * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
   *
   * @schema BackendTrafficPolicySpecHealthCheck#panicThreshold
   */
  readonly panicThreshold?: number;

  /**
   * Passive passive check configuration
   *
   * @schema BackendTrafficPolicySpecHealthCheck#passive
   */
  readonly passive?: BackendTrafficPolicySpecHealthCheckPassive;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecHealthCheck(obj: BackendTrafficPolicySpecHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'active': toJson_BackendTrafficPolicySpecHealthCheckActive(obj.active),
    'panicThreshold': obj.panicThreshold,
    'passive': toJson_BackendTrafficPolicySpecHealthCheckPassive(obj.passive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP2 provides HTTP/2 configuration for backend connections.
 *
 * @schema BackendTrafficPolicySpecHttp2
 */
export interface BackendTrafficPolicySpecHttp2 {
  /**
   * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
   * If not set, the default value is 1 MiB.
   *
   * @schema BackendTrafficPolicySpecHttp2#initialConnectionWindowSize
   */
  readonly initialConnectionWindowSize?: BackendTrafficPolicySpecHttp2InitialConnectionWindowSize;

  /**
   * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
   * If not set, the default value is 64 KiB(64*1024).
   *
   * @schema BackendTrafficPolicySpecHttp2#initialStreamWindowSize
   */
  readonly initialStreamWindowSize?: BackendTrafficPolicySpecHttp2InitialStreamWindowSize;

  /**
   * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
   * If not set, the default value is 100.
   *
   * @schema BackendTrafficPolicySpecHttp2#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
   * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
   * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
   * Default: TerminateConnection
   *
   * @schema BackendTrafficPolicySpecHttp2#onInvalidMessage
   */
  readonly onInvalidMessage?: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecHttp2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecHttp2(obj: BackendTrafficPolicySpecHttp2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'initialConnectionWindowSize': obj.initialConnectionWindowSize?.value,
    'initialStreamWindowSize': obj.initialStreamWindowSize?.value,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'onInvalidMessage': obj.onInvalidMessage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProtocolUpgradeConfig specifies the configuration for protocol upgrades.
 *
 * @schema BackendTrafficPolicySpecHttpUpgrade
 */
export interface BackendTrafficPolicySpecHttpUpgrade {
  /**
   * Connect specifies the configuration for the CONNECT config.
   * This is allowed only when type is CONNECT.
   *
   * @schema BackendTrafficPolicySpecHttpUpgrade#connect
   */
  readonly connect?: BackendTrafficPolicySpecHttpUpgradeConnect;

  /**
   * Type is the case-insensitive type of protocol upgrade.
   * e.g. `websocket`, `CONNECT`, `spdy/3.1` etc.
   *
   * @schema BackendTrafficPolicySpecHttpUpgrade#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecHttpUpgrade' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecHttpUpgrade(obj: BackendTrafficPolicySpecHttpUpgrade | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connect': toJson_BackendTrafficPolicySpecHttpUpgradeConnect(obj.connect),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LoadBalancer policy to apply when routing traffic from the gateway to
 * the backend endpoints. Defaults to `LeastRequest`.
 *
 * @default LeastRequest`.
 * @schema BackendTrafficPolicySpecLoadBalancer
 */
export interface BackendTrafficPolicySpecLoadBalancer {
  /**
   * ConsistentHash defines the configuration when the load balancer type is
   * set to ConsistentHash
   *
   * @schema BackendTrafficPolicySpecLoadBalancer#consistentHash
   */
  readonly consistentHash?: BackendTrafficPolicySpecLoadBalancerConsistentHash;

  /**
   * EndpointOverride defines the configuration for endpoint override.
   * When specified, the load balancer will attempt to route requests to endpoints
   * based on the override information extracted from request headers or metadata.
   * If the override endpoints are not available, the configured load balancer policy will be used as fallback.
   *
   * @schema BackendTrafficPolicySpecLoadBalancer#endpointOverride
   */
  readonly endpointOverride?: BackendTrafficPolicySpecLoadBalancerEndpointOverride;

  /**
   * SlowStart defines the configuration related to the slow start load balancer policy.
   * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
   * Currently this is only supported for RoundRobin and LeastRequest load balancers
   *
   * @schema BackendTrafficPolicySpecLoadBalancer#slowStart
   */
  readonly slowStart?: BackendTrafficPolicySpecLoadBalancerSlowStart;

  /**
   * Type decides the type of Load Balancer policy.
   * Valid LoadBalancerType values are
   * "ConsistentHash",
   * "LeastRequest",
   * "Random",
   * "RoundRobin".
   *
   * @schema BackendTrafficPolicySpecLoadBalancer#type
   */
  readonly type: BackendTrafficPolicySpecLoadBalancerType;

  /**
   * ZoneAware defines the configuration related to the distribution of requests between locality zones.
   *
   * @schema BackendTrafficPolicySpecLoadBalancer#zoneAware
   */
  readonly zoneAware?: BackendTrafficPolicySpecLoadBalancerZoneAware;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecLoadBalancer(obj: BackendTrafficPolicySpecLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_BackendTrafficPolicySpecLoadBalancerConsistentHash(obj.consistentHash),
    'endpointOverride': toJson_BackendTrafficPolicySpecLoadBalancerEndpointOverride(obj.endpointOverride),
    'slowStart': toJson_BackendTrafficPolicySpecLoadBalancerSlowStart(obj.slowStart),
    'type': obj.type,
    'zoneAware': toJson_BackendTrafficPolicySpecLoadBalancerZoneAware(obj.zoneAware),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
 *
 * @schema BackendTrafficPolicySpecProxyProtocol
 */
export interface BackendTrafficPolicySpecProxyProtocol {
  /**
   * Version of ProxyProtol
   * Valid ProxyProtocolVersion values are
   * "V1"
   * "V2"
   *
   * @schema BackendTrafficPolicySpecProxyProtocol#version
   */
  readonly version: BackendTrafficPolicySpecProxyProtocolVersion;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecProxyProtocol' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecProxyProtocol(obj: BackendTrafficPolicySpecProxyProtocol | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RateLimit allows the user to limit the number of incoming requests
 * to a predefined value based on attributes within the traffic flow.
 *
 * @schema BackendTrafficPolicySpecRateLimit
 */
export interface BackendTrafficPolicySpecRateLimit {
  /**
   * Global defines global rate limit configuration.
   *
   * @schema BackendTrafficPolicySpecRateLimit#global
   */
  readonly global?: BackendTrafficPolicySpecRateLimitGlobal;

  /**
   * Local defines local rate limit configuration.
   *
   * @schema BackendTrafficPolicySpecRateLimit#local
   */
  readonly local?: BackendTrafficPolicySpecRateLimitLocal;

  /**
   * Type decides the scope for the RateLimits.
   * Valid RateLimitType values are "Global" or "Local".
   *
   * Deprecated: Use Global and/or Local fields directly instead. Both can be specified simultaneously for combined rate limiting.
   *
   * @schema BackendTrafficPolicySpecRateLimit#type
   */
  readonly type?: BackendTrafficPolicySpecRateLimitType;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimit' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimit(obj: BackendTrafficPolicySpecRateLimit | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'global': toJson_BackendTrafficPolicySpecRateLimitGlobal(obj.global),
    'local': toJson_BackendTrafficPolicySpecRateLimitLocal(obj.local),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RequestBuffer allows the gateway to buffer and fully receive each request from a client before continuing to send the request
 * upstream to the backends. This can be helpful to shield your backend servers from slow clients, and also to enforce a maximum size per request
 * as any requests larger than the buffer size will be rejected.
 *
 * This can have a negative performance impact so should only be enabled when necessary.
 *
 * When enabling this option, you should also configure your connection buffer size to account for these request buffers. There will also be an
 * increase in memory usage for Envoy that should be accounted for in your deployment settings.
 *
 * @schema BackendTrafficPolicySpecRequestBuffer
 */
export interface BackendTrafficPolicySpecRequestBuffer {
  /**
   * Limit specifies the maximum allowed size in bytes for each incoming request buffer.
   * If exceeded, the request will be rejected with HTTP 413 Content Too Large.
   *
   * Accepts values in resource.Quantity format (e.g., "10Mi", "500Ki").
   *
   * @schema BackendTrafficPolicySpecRequestBuffer#limit
   */
  readonly limit?: BackendTrafficPolicySpecRequestBufferLimit;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRequestBuffer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRequestBuffer(obj: BackendTrafficPolicySpecRequestBuffer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limit': obj.limit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResponseOverride defines the configuration to override specific responses with a custom one.
 *
 * @schema BackendTrafficPolicySpecResponseOverride
 */
export interface BackendTrafficPolicySpecResponseOverride {
  /**
   * Match configuration.
   *
   * @schema BackendTrafficPolicySpecResponseOverride#match
   */
  readonly match: BackendTrafficPolicySpecResponseOverrideMatch;

  /**
   * Redirect configuration
   *
   * @schema BackendTrafficPolicySpecResponseOverride#redirect
   */
  readonly redirect?: BackendTrafficPolicySpecResponseOverrideRedirect;

  /**
   * Response configuration.
   *
   * @schema BackendTrafficPolicySpecResponseOverride#response
   */
  readonly response?: BackendTrafficPolicySpecResponseOverrideResponse;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecResponseOverride' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecResponseOverride(obj: BackendTrafficPolicySpecResponseOverride | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': toJson_BackendTrafficPolicySpecResponseOverrideMatch(obj.match),
    'redirect': toJson_BackendTrafficPolicySpecResponseOverrideRedirect(obj.redirect),
    'response': toJson_BackendTrafficPolicySpecResponseOverrideResponse(obj.response),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
 * If not set, retry will be disabled.
 *
 * @schema BackendTrafficPolicySpecRetry
 */
export interface BackendTrafficPolicySpecRetry {
  /**
   * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
   * that should be sent to the same priority before switching to a different one.
   * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
   *
   * @schema BackendTrafficPolicySpecRetry#numAttemptsPerPriority
   */
  readonly numAttemptsPerPriority?: number;

  /**
   * NumRetries is the number of retries to be attempted. Defaults to 2.
   *
   * @default 2.
   * @schema BackendTrafficPolicySpecRetry#numRetries
   */
  readonly numRetries?: number;

  /**
   * PerRetry is the retry policy to be applied per retry attempt.
   *
   * @schema BackendTrafficPolicySpecRetry#perRetry
   */
  readonly perRetry?: BackendTrafficPolicySpecRetryPerRetry;

  /**
   * RetryOn specifies the retry trigger condition.
   *
   * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
   *
   * @schema BackendTrafficPolicySpecRetry#retryOn
   */
  readonly retryOn?: BackendTrafficPolicySpecRetryRetryOn;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRetry(obj: BackendTrafficPolicySpecRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'numAttemptsPerPriority': obj.numAttemptsPerPriority,
    'numRetries': obj.numRetries,
    'perRetry': toJson_BackendTrafficPolicySpecRetryPerRetry(obj.perRetry),
    'retryOn': toJson_BackendTrafficPolicySpecRetryRetryOn(obj.retryOn),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TargetRef is the name of the resource this policy is being attached to.
 * This policy and the TargetRef MUST be in the same namespace for this
 * Policy to have effect
 *
 * Deprecated: use targetRefs/targetSelectors instead
 *
 * @schema BackendTrafficPolicySpecTargetRef
 */
export interface BackendTrafficPolicySpecTargetRef {
  /**
   * Group is the group of the target resource.
   *
   * @schema BackendTrafficPolicySpecTargetRef#group
   */
  readonly group: string;

  /**
   * Kind is kind of the target resource.
   *
   * @schema BackendTrafficPolicySpecTargetRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of the target resource.
   *
   * @schema BackendTrafficPolicySpecTargetRef#name
   */
  readonly name: string;

  /**
   * SectionName is the name of a section within the target resource. When
   * unspecified, this targetRef targets the entire resource. In the following
   * resources, SectionName is interpreted as the following:
   *
   * * Gateway: Listener name
   * * HTTPRoute: HTTPRouteRule name
   * * Service: Port name
   *
   * If a SectionName is specified, but does not exist on the targeted object,
   * the Policy must fail to attach, and the policy implementation should record
   * a `ResolvedRefs` or similar Condition in the Policy's status.
   *
   * @schema BackendTrafficPolicySpecTargetRef#sectionName
   */
  readonly sectionName?: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecTargetRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecTargetRef(obj: BackendTrafficPolicySpecTargetRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'sectionName': obj.sectionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalPolicyTargetReferenceWithSectionName identifies an API object to apply a
 * direct policy to. This should be used as part of Policy resources that can
 * target single resources. For more information on how this policy attachment
 * mode works, and a sample Policy resource, refer to the policy attachment
 * documentation for Gateway API.
 *
 * Note: This should only be used for direct policy attachment when references
 * to SectionName are actually needed. In all other cases,
 * LocalPolicyTargetReference should be used.
 *
 * @schema BackendTrafficPolicySpecTargetRefs
 */
export interface BackendTrafficPolicySpecTargetRefs {
  /**
   * Group is the group of the target resource.
   *
   * @schema BackendTrafficPolicySpecTargetRefs#group
   */
  readonly group: string;

  /**
   * Kind is kind of the target resource.
   *
   * @schema BackendTrafficPolicySpecTargetRefs#kind
   */
  readonly kind: string;

  /**
   * Name is the name of the target resource.
   *
   * @schema BackendTrafficPolicySpecTargetRefs#name
   */
  readonly name: string;

  /**
   * SectionName is the name of a section within the target resource. When
   * unspecified, this targetRef targets the entire resource. In the following
   * resources, SectionName is interpreted as the following:
   *
   * * Gateway: Listener name
   * * HTTPRoute: HTTPRouteRule name
   * * Service: Port name
   *
   * If a SectionName is specified, but does not exist on the targeted object,
   * the Policy must fail to attach, and the policy implementation should record
   * a `ResolvedRefs` or similar Condition in the Policy's status.
   *
   * @schema BackendTrafficPolicySpecTargetRefs#sectionName
   */
  readonly sectionName?: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecTargetRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecTargetRefs(obj: BackendTrafficPolicySpecTargetRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'sectionName': obj.sectionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BackendTrafficPolicySpecTargetSelectors
 */
export interface BackendTrafficPolicySpecTargetSelectors {
  /**
   * Group is the group that this selector targets. Defaults to gateway.networking.k8s.io
   *
   * @default gateway.networking.k8s.io
   * @schema BackendTrafficPolicySpecTargetSelectors#group
   */
  readonly group?: string;

  /**
   * Kind is the resource kind that this selector targets.
   *
   * @schema BackendTrafficPolicySpecTargetSelectors#kind
   */
  readonly kind: string;

  /**
   * MatchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema BackendTrafficPolicySpecTargetSelectors#matchExpressions
   */
  readonly matchExpressions?: BackendTrafficPolicySpecTargetSelectorsMatchExpressions[];

  /**
   * MatchLabels are the set of label selectors for identifying the targeted resource
   *
   * @schema BackendTrafficPolicySpecTargetSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecTargetSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecTargetSelectors(obj: BackendTrafficPolicySpecTargetSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'matchExpressions': obj.matchExpressions?.map(y => toJson_BackendTrafficPolicySpecTargetSelectorsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TcpKeepalive settings associated with the upstream client connection.
 * Disabled by default.
 *
 * @schema BackendTrafficPolicySpecTcpKeepalive
 */
export interface BackendTrafficPolicySpecTcpKeepalive {
  /**
   * The duration a connection needs to be idle before keep-alive
   * probes start being sent.
   * The duration format is
   * Defaults to `7200s`.
   *
   * @default 7200s`.
   * @schema BackendTrafficPolicySpecTcpKeepalive#idleTime
   */
  readonly idleTime?: string;

  /**
   * The duration between keep-alive probes.
   * Defaults to `75s`.
   *
   * @default 75s`.
   * @schema BackendTrafficPolicySpecTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * The total number of unacknowledged probes to send before deciding
   * the connection is dead.
   * Defaults to 9.
   *
   * @default 9.
   * @schema BackendTrafficPolicySpecTcpKeepalive#probes
   */
  readonly probes?: number;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecTcpKeepalive(obj: BackendTrafficPolicySpecTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idleTime': obj.idleTime,
    'interval': obj.interval,
    'probes': obj.probes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Telemetry configures the telemetry settings for the policy target (Gateway or xRoute).
 * This will override the telemetry settings in the EnvoyProxy resource.
 *
 * @schema BackendTrafficPolicySpecTelemetry
 */
export interface BackendTrafficPolicySpecTelemetry {
  /**
   * Tracing configures the tracing settings for the backend or HTTPRoute.
   *
   * @schema BackendTrafficPolicySpecTelemetry#tracing
   */
  readonly tracing?: BackendTrafficPolicySpecTelemetryTracing;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecTelemetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecTelemetry(obj: BackendTrafficPolicySpecTelemetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tracing': toJson_BackendTrafficPolicySpecTelemetryTracing(obj.tracing),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for the backend connections.
 *
 * @schema BackendTrafficPolicySpecTimeout
 */
export interface BackendTrafficPolicySpecTimeout {
  /**
   * Timeout settings for HTTP.
   *
   * @schema BackendTrafficPolicySpecTimeout#http
   */
  readonly http?: BackendTrafficPolicySpecTimeoutHttp;

  /**
   * Timeout settings for TCP.
   *
   * @schema BackendTrafficPolicySpecTimeout#tcp
   */
  readonly tcp?: BackendTrafficPolicySpecTimeoutTcp;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecTimeout' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecTimeout(obj: BackendTrafficPolicySpecTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_BackendTrafficPolicySpecTimeoutHttp(obj.http),
    'tcp': toJson_BackendTrafficPolicySpecTimeoutTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
 *
 * @schema BackendTrafficPolicySpecCircuitBreakerPerEndpoint
 */
export interface BackendTrafficPolicySpecCircuitBreakerPerEndpoint {
  /**
   * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
   *
   * @schema BackendTrafficPolicySpecCircuitBreakerPerEndpoint#maxConnections
   */
  readonly maxConnections?: number;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecCircuitBreakerPerEndpoint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecCircuitBreakerPerEndpoint(obj: BackendTrafficPolicySpecCircuitBreakerPerEndpoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CompressorType defines the compressor type to use for compression.
 *
 * @schema BackendTrafficPolicySpecCompressionType
 */
export enum BackendTrafficPolicySpecCompressionType {
  /** Gzip */
  GZIP = "Gzip",
  /** Brotli */
  BROTLI = "Brotli",
  /** Zstd */
  ZSTD = "Zstd",
}

/**
 * CompressorType defines the compressor type to use for compression.
 *
 * @schema BackendTrafficPolicySpecCompressorType
 */
export enum BackendTrafficPolicySpecCompressorType {
  /** Gzip */
  GZIP = "Gzip",
  /** Brotli */
  BROTLI = "Brotli",
  /** Zstd */
  ZSTD = "Zstd",
}

/**
 * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
 * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
 * If unspecified, an implementation defined default is applied (32768 bytes).
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note: that when the suffix is not provided, the value is interpreted as bytes.
 *
 * @schema BackendTrafficPolicySpecConnectionBufferLimit
 */
export class BackendTrafficPolicySpecConnectionBufferLimit {
  public static fromNumber(value: number): BackendTrafficPolicySpecConnectionBufferLimit {
    return new BackendTrafficPolicySpecConnectionBufferLimit(value);
  }
  public static fromString(value: string): BackendTrafficPolicySpecConnectionBufferLimit {
    return new BackendTrafficPolicySpecConnectionBufferLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Preconnect configures proactive upstream connections to reduce latency by establishing
 * connections before they’re needed and avoiding connection establishment overhead.
 *
 * If unset, Envoy will fetch connections as needed to serve in-flight requests.
 *
 * @schema BackendTrafficPolicySpecConnectionPreconnect
 */
export interface BackendTrafficPolicySpecConnectionPreconnect {
  /**
   * PerEndpointPercent configures how many additional connections to maintain per
   * upstream endpoint, useful for high-QPS or latency sensitive services. Expressed as a
   * percentage of the connections required by active streams
   * (e.g. 100 = preconnect disabled, 105 = 1.05x connections per-endpoint, 200 = 2.00×).
   *
   * Allowed value range is between 100-300. When both PerEndpointPercent and
   * PredictivePercent are set, Envoy ensures both are satisfied (max of the two).
   *
   * @schema BackendTrafficPolicySpecConnectionPreconnect#perEndpointPercent
   */
  readonly perEndpointPercent?: number;

  /**
   * PredictivePercent configures how many additional connections to maintain
   * across the cluster by anticipating which upstream endpoint the load balancer
   * will select next, useful for low-QPS services. Relies on deterministic
   * loadbalancing and is only supported with Random or RoundRobin.
   * Expressed as a percentage of the connections required by active streams
   * (e.g. 100 = 1.0 (no preconnect), 105 = 1.05× connections across the cluster, 200 = 2.00×).
   *
   * Minimum allowed value is 100. When both PerEndpointPercent and PredictivePercent are
   * set Envoy ensures both are satisfied per host (max of the two).
   *
   * @schema BackendTrafficPolicySpecConnectionPreconnect#predictivePercent
   */
  readonly predictivePercent?: number;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecConnectionPreconnect' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecConnectionPreconnect(obj: BackendTrafficPolicySpecConnectionPreconnect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'perEndpointPercent': obj.perEndpointPercent,
    'predictivePercent': obj.predictivePercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
 * to backend.
 * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note that when the suffix is not provided, the value is interpreted as bytes.
 *
 * @schema BackendTrafficPolicySpecConnectionSocketBufferLimit
 */
export class BackendTrafficPolicySpecConnectionSocketBufferLimit {
  public static fromNumber(value: number): BackendTrafficPolicySpecConnectionSocketBufferLimit {
    return new BackendTrafficPolicySpecConnectionSocketBufferLimit(value);
  }
  public static fromString(value: string): BackendTrafficPolicySpecConnectionSocketBufferLimit {
    return new BackendTrafficPolicySpecConnectionSocketBufferLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
 * If set, this configuration overrides other defaults.
 *
 * @schema BackendTrafficPolicySpecDnsLookupFamily
 */
export enum BackendTrafficPolicySpecDnsLookupFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
  /** IPv4Preferred */
  I_PV4_PREFERRED = "IPv4Preferred",
  /** IPv6Preferred */
  I_PV6_PREFERRED = "IPv6Preferred",
  /** IPv4AndIPv6 */
  I_PV4_AND_I_PV6 = "IPv4AndIPv6",
}

/**
 * If specified, the request will be aborted if it meets the configuration criteria.
 *
 * @schema BackendTrafficPolicySpecFaultInjectionAbort
 */
export interface BackendTrafficPolicySpecFaultInjectionAbort {
  /**
   * GrpcStatus specifies the GRPC status code to be returned
   *
   * @schema BackendTrafficPolicySpecFaultInjectionAbort#grpcStatus
   */
  readonly grpcStatus?: number;

  /**
   * StatusCode specifies the HTTP status code to be returned
   *
   * @schema BackendTrafficPolicySpecFaultInjectionAbort#httpStatus
   */
  readonly httpStatus?: number;

  /**
   * Percentage specifies the percentage of requests to be aborted. Default 100%, if set 0, no requests will be aborted. Accuracy to 0.0001%.
   *
   * @schema BackendTrafficPolicySpecFaultInjectionAbort#percentage
   */
  readonly percentage?: number;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecFaultInjectionAbort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecFaultInjectionAbort(obj: BackendTrafficPolicySpecFaultInjectionAbort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpcStatus': obj.grpcStatus,
    'httpStatus': obj.httpStatus,
    'percentage': obj.percentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * If specified, a delay will be injected into the request.
 *
 * @schema BackendTrafficPolicySpecFaultInjectionDelay
 */
export interface BackendTrafficPolicySpecFaultInjectionDelay {
  /**
   * FixedDelay specifies the fixed delay duration
   *
   * @schema BackendTrafficPolicySpecFaultInjectionDelay#fixedDelay
   */
  readonly fixedDelay: string;

  /**
   * Percentage specifies the percentage of requests to be delayed. Default 100%, if set 0, no requests will be delayed. Accuracy to 0.0001%.
   *
   * @schema BackendTrafficPolicySpecFaultInjectionDelay#percentage
   */
  readonly percentage?: number;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecFaultInjectionDelay' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecFaultInjectionDelay(obj: BackendTrafficPolicySpecFaultInjectionDelay | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixedDelay': obj.fixedDelay,
    'percentage': obj.percentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Active health check configuration
 *
 * @schema BackendTrafficPolicySpecHealthCheckActive
 */
export interface BackendTrafficPolicySpecHealthCheckActive {
  /**
   * GRPC defines the configuration of the GRPC health checker.
   * It's optional, and can only be used if the specified type is GRPC.
   *
   * @schema BackendTrafficPolicySpecHealthCheckActive#grpc
   */
  readonly grpc?: BackendTrafficPolicySpecHealthCheckActiveGrpc;

  /**
   * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
   *
   * @schema BackendTrafficPolicySpecHealthCheckActive#healthyThreshold
   */
  readonly healthyThreshold?: number;

  /**
   * HTTP defines the configuration of http health checker.
   * It's required while the health checker type is HTTP.
   *
   * @schema BackendTrafficPolicySpecHealthCheckActive#http
   */
  readonly http?: BackendTrafficPolicySpecHealthCheckActiveHttp;

  /**
   * InitialJitter defines the maximum time Envoy will wait before the first health check.
   * Envoy will randomly select a value between 0 and the initial jitter value.
   *
   * @schema BackendTrafficPolicySpecHealthCheckActive#initialJitter
   */
  readonly initialJitter?: string;

  /**
   * Interval defines the time between active health checks.
   *
   * @schema BackendTrafficPolicySpecHealthCheckActive#interval
   */
  readonly interval?: string;

  /**
   * TCP defines the configuration of tcp health checker.
   * It's required while the health checker type is TCP.
   *
   * @schema BackendTrafficPolicySpecHealthCheckActive#tcp
   */
  readonly tcp?: BackendTrafficPolicySpecHealthCheckActiveTcp;

  /**
   * Timeout defines the time to wait for a health check response.
   *
   * @schema BackendTrafficPolicySpecHealthCheckActive#timeout
   */
  readonly timeout?: string;

  /**
   * Type defines the type of health checker.
   *
   * @schema BackendTrafficPolicySpecHealthCheckActive#type
   */
  readonly type: string;

  /**
   * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
   *
   * @schema BackendTrafficPolicySpecHealthCheckActive#unhealthyThreshold
   */
  readonly unhealthyThreshold?: number;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecHealthCheckActive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecHealthCheckActive(obj: BackendTrafficPolicySpecHealthCheckActive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpc': toJson_BackendTrafficPolicySpecHealthCheckActiveGrpc(obj.grpc),
    'healthyThreshold': obj.healthyThreshold,
    'http': toJson_BackendTrafficPolicySpecHealthCheckActiveHttp(obj.http),
    'initialJitter': obj.initialJitter,
    'interval': obj.interval,
    'tcp': toJson_BackendTrafficPolicySpecHealthCheckActiveTcp(obj.tcp),
    'timeout': obj.timeout,
    'type': obj.type,
    'unhealthyThreshold': obj.unhealthyThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Passive passive check configuration
 *
 * @schema BackendTrafficPolicySpecHealthCheckPassive
 */
export interface BackendTrafficPolicySpecHealthCheckPassive {
  /**
   * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
   *
   * @schema BackendTrafficPolicySpecHealthCheckPassive#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
   *
   * @schema BackendTrafficPolicySpecHealthCheckPassive#consecutive5XxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
   *
   * @schema BackendTrafficPolicySpecHealthCheckPassive#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
   * Parameter takes effect only when split_external_local_origin_errors is set to true.
   *
   * @schema BackendTrafficPolicySpecHealthCheckPassive#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * FailurePercentageThreshold sets the failure percentage threshold for outlier detection.
   * If the failure percentage of a given host is greater than or equal to this value, it will be ejected.
   * Defaults to 85.
   *
   * @default 85.
   * @schema BackendTrafficPolicySpecHealthCheckPassive#failurePercentageThreshold
   */
  readonly failurePercentageThreshold?: number;

  /**
   * Interval defines the time between passive health checks.
   *
   * @schema BackendTrafficPolicySpecHealthCheckPassive#interval
   */
  readonly interval?: string;

  /**
   * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
   *
   * @schema BackendTrafficPolicySpecHealthCheckPassive#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
   *
   * @schema BackendTrafficPolicySpecHealthCheckPassive#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecHealthCheckPassive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecHealthCheckPassive(obj: BackendTrafficPolicySpecHealthCheckPassive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5XxErrors': obj.consecutive5XxErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'failurePercentageThreshold': obj.failurePercentageThreshold,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
 * If not set, the default value is 1 MiB.
 *
 * @schema BackendTrafficPolicySpecHttp2InitialConnectionWindowSize
 */
export class BackendTrafficPolicySpecHttp2InitialConnectionWindowSize {
  public static fromNumber(value: number): BackendTrafficPolicySpecHttp2InitialConnectionWindowSize {
    return new BackendTrafficPolicySpecHttp2InitialConnectionWindowSize(value);
  }
  public static fromString(value: string): BackendTrafficPolicySpecHttp2InitialConnectionWindowSize {
    return new BackendTrafficPolicySpecHttp2InitialConnectionWindowSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
 * If not set, the default value is 64 KiB(64*1024).
 *
 * @schema BackendTrafficPolicySpecHttp2InitialStreamWindowSize
 */
export class BackendTrafficPolicySpecHttp2InitialStreamWindowSize {
  public static fromNumber(value: number): BackendTrafficPolicySpecHttp2InitialStreamWindowSize {
    return new BackendTrafficPolicySpecHttp2InitialStreamWindowSize(value);
  }
  public static fromString(value: string): BackendTrafficPolicySpecHttp2InitialStreamWindowSize {
    return new BackendTrafficPolicySpecHttp2InitialStreamWindowSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Connect specifies the configuration for the CONNECT config.
 * This is allowed only when type is CONNECT.
 *
 * @schema BackendTrafficPolicySpecHttpUpgradeConnect
 */
export interface BackendTrafficPolicySpecHttpUpgradeConnect {
  /**
   * Terminate the CONNECT request, and forwards the payload as raw TCP data.
   *
   * @schema BackendTrafficPolicySpecHttpUpgradeConnect#terminate
   */
  readonly terminate?: boolean;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecHttpUpgradeConnect' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecHttpUpgradeConnect(obj: BackendTrafficPolicySpecHttpUpgradeConnect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'terminate': obj.terminate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConsistentHash defines the configuration when the load balancer type is
 * set to ConsistentHash
 *
 * @schema BackendTrafficPolicySpecLoadBalancerConsistentHash
 */
export interface BackendTrafficPolicySpecLoadBalancerConsistentHash {
  /**
   * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
   *
   * @schema BackendTrafficPolicySpecLoadBalancerConsistentHash#cookie
   */
  readonly cookie?: BackendTrafficPolicySpecLoadBalancerConsistentHashCookie;

  /**
   * Header configures the header hash policy when the consistent hash type is set to Header.
   *
   * Deprecated: use Headers instead
   *
   * @schema BackendTrafficPolicySpecLoadBalancerConsistentHash#header
   */
  readonly header?: BackendTrafficPolicySpecLoadBalancerConsistentHashHeader;

  /**
   * Headers configures the header hash policy for each header, when the consistent hash type is set to Headers.
   *
   * @schema BackendTrafficPolicySpecLoadBalancerConsistentHash#headers
   */
  readonly headers?: BackendTrafficPolicySpecLoadBalancerConsistentHashHeaders[];

  /**
   * The table size for consistent hashing, must be prime number limited to 5000011.
   *
   * @schema BackendTrafficPolicySpecLoadBalancerConsistentHash#tableSize
   */
  readonly tableSize?: number;

  /**
   * ConsistentHashType defines the type of input to hash on. Valid Type values are
   * "SourceIP",
   * "Header",
   * "Headers",
   * "Cookie".
   *
   * @schema BackendTrafficPolicySpecLoadBalancerConsistentHash#type
   */
  readonly type: BackendTrafficPolicySpecLoadBalancerConsistentHashType;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecLoadBalancerConsistentHash(obj: BackendTrafficPolicySpecLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookie': toJson_BackendTrafficPolicySpecLoadBalancerConsistentHashCookie(obj.cookie),
    'header': toJson_BackendTrafficPolicySpecLoadBalancerConsistentHashHeader(obj.header),
    'headers': obj.headers?.map(y => toJson_BackendTrafficPolicySpecLoadBalancerConsistentHashHeaders(y)),
    'tableSize': obj.tableSize,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EndpointOverride defines the configuration for endpoint override.
 * When specified, the load balancer will attempt to route requests to endpoints
 * based on the override information extracted from request headers or metadata.
 * If the override endpoints are not available, the configured load balancer policy will be used as fallback.
 *
 * @schema BackendTrafficPolicySpecLoadBalancerEndpointOverride
 */
export interface BackendTrafficPolicySpecLoadBalancerEndpointOverride {
  /**
   * ExtractFrom defines the sources to extract endpoint override information from.
   *
   * @schema BackendTrafficPolicySpecLoadBalancerEndpointOverride#extractFrom
   */
  readonly extractFrom: BackendTrafficPolicySpecLoadBalancerEndpointOverrideExtractFrom[];
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecLoadBalancerEndpointOverride' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecLoadBalancerEndpointOverride(obj: BackendTrafficPolicySpecLoadBalancerEndpointOverride | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extractFrom': obj.extractFrom?.map(y => toJson_BackendTrafficPolicySpecLoadBalancerEndpointOverrideExtractFrom(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SlowStart defines the configuration related to the slow start load balancer policy.
 * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
 * Currently this is only supported for RoundRobin and LeastRequest load balancers
 *
 * @schema BackendTrafficPolicySpecLoadBalancerSlowStart
 */
export interface BackendTrafficPolicySpecLoadBalancerSlowStart {
  /**
   * Window defines the duration of the warm up period for newly added host.
   * During slow start window, traffic sent to the newly added hosts will gradually increase.
   * Currently only supports linear growth of traffic. For additional details,
   * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
   *
   * @schema BackendTrafficPolicySpecLoadBalancerSlowStart#window
   */
  readonly window: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecLoadBalancerSlowStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecLoadBalancerSlowStart(obj: BackendTrafficPolicySpecLoadBalancerSlowStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'window': obj.window,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type decides the type of Load Balancer policy.
 * Valid LoadBalancerType values are
 * "ConsistentHash",
 * "LeastRequest",
 * "Random",
 * "RoundRobin".
 *
 * @schema BackendTrafficPolicySpecLoadBalancerType
 */
export enum BackendTrafficPolicySpecLoadBalancerType {
  /** ConsistentHash */
  CONSISTENT_HASH = "ConsistentHash",
  /** LeastRequest */
  LEAST_REQUEST = "LeastRequest",
  /** Random */
  RANDOM = "Random",
  /** RoundRobin */
  ROUND_ROBIN = "RoundRobin",
}

/**
 * ZoneAware defines the configuration related to the distribution of requests between locality zones.
 *
 * @schema BackendTrafficPolicySpecLoadBalancerZoneAware
 */
export interface BackendTrafficPolicySpecLoadBalancerZoneAware {
  /**
   * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
   *
   * @schema BackendTrafficPolicySpecLoadBalancerZoneAware#preferLocal
   */
  readonly preferLocal?: BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocal;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecLoadBalancerZoneAware' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecLoadBalancerZoneAware(obj: BackendTrafficPolicySpecLoadBalancerZoneAware | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferLocal': toJson_BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocal(obj.preferLocal),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Version of ProxyProtol
 * Valid ProxyProtocolVersion values are
 * "V1"
 * "V2"
 *
 * @schema BackendTrafficPolicySpecProxyProtocolVersion
 */
export enum BackendTrafficPolicySpecProxyProtocolVersion {
  /** V1 */
  V1 = "V1",
  /** V2 */
  V2 = "V2",
}

/**
 * Global defines global rate limit configuration.
 *
 * @schema BackendTrafficPolicySpecRateLimitGlobal
 */
export interface BackendTrafficPolicySpecRateLimitGlobal {
  /**
   * Rules are a list of RateLimit selectors and limits. Each rule and its
   * associated limit is applied in a mutually exclusive way. If a request
   * matches multiple rules, each of their associated limits get applied, so a
   * single request might increase the rate limit counters for multiple rules
   * if selected. The rate limit service will return a logical OR of the individual
   * rate limit decisions of all matching rules. For example, if a request
   * matches two rules, one rate limited and one not, the final decision will be
   * to rate limit the request.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobal#rules
   */
  readonly rules: BackendTrafficPolicySpecRateLimitGlobalRules[];
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitGlobal' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitGlobal(obj: BackendTrafficPolicySpecRateLimitGlobal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rules': obj.rules?.map(y => toJson_BackendTrafficPolicySpecRateLimitGlobalRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Local defines local rate limit configuration.
 *
 * @schema BackendTrafficPolicySpecRateLimitLocal
 */
export interface BackendTrafficPolicySpecRateLimitLocal {
  /**
   * Rules are a list of RateLimit selectors and limits. If a request matches
   * multiple rules, the strictest limit is applied. For example, if a request
   * matches two rules, one with 10rps and one with 20rps, the final limit will
   * be based on the rule with 10rps.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocal#rules
   */
  readonly rules?: BackendTrafficPolicySpecRateLimitLocalRules[];
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitLocal' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitLocal(obj: BackendTrafficPolicySpecRateLimitLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rules': obj.rules?.map(y => toJson_BackendTrafficPolicySpecRateLimitLocalRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type decides the scope for the RateLimits.
 * Valid RateLimitType values are "Global" or "Local".
 *
 * Deprecated: Use Global and/or Local fields directly instead. Both can be specified simultaneously for combined rate limiting.
 *
 * @schema BackendTrafficPolicySpecRateLimitType
 */
export enum BackendTrafficPolicySpecRateLimitType {
  /** Global */
  GLOBAL = "Global",
  /** Local */
  LOCAL = "Local",
}

/**
 * Limit specifies the maximum allowed size in bytes for each incoming request buffer.
 * If exceeded, the request will be rejected with HTTP 413 Content Too Large.
 *
 * Accepts values in resource.Quantity format (e.g., "10Mi", "500Ki").
 *
 * @schema BackendTrafficPolicySpecRequestBufferLimit
 */
export class BackendTrafficPolicySpecRequestBufferLimit {
  public static fromNumber(value: number): BackendTrafficPolicySpecRequestBufferLimit {
    return new BackendTrafficPolicySpecRequestBufferLimit(value);
  }
  public static fromString(value: string): BackendTrafficPolicySpecRequestBufferLimit {
    return new BackendTrafficPolicySpecRequestBufferLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Match configuration.
 *
 * @schema BackendTrafficPolicySpecResponseOverrideMatch
 */
export interface BackendTrafficPolicySpecResponseOverrideMatch {
  /**
   * Status code to match on. The match evaluates to true if any of the matches are successful.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideMatch#statusCodes
   */
  readonly statusCodes: BackendTrafficPolicySpecResponseOverrideMatchStatusCodes[];
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecResponseOverrideMatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecResponseOverrideMatch(obj: BackendTrafficPolicySpecResponseOverrideMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'statusCodes': obj.statusCodes?.map(y => toJson_BackendTrafficPolicySpecResponseOverrideMatchStatusCodes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Redirect configuration
 *
 * @schema BackendTrafficPolicySpecResponseOverrideRedirect
 */
export interface BackendTrafficPolicySpecResponseOverrideRedirect {
  /**
   * Hostname is the hostname to be used in the value of the `Location`
   * header in the response.
   * When empty, the hostname in the `Host` header of the request is used.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideRedirect#hostname
   */
  readonly hostname?: string;

  /**
   * Path defines parameters used to modify the path of the incoming request.
   * The modified path is then used to construct the `Location` header. When
   * empty, the request path is used as-is.
   * Only ReplaceFullPath path modifier is supported currently.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideRedirect#path
   */
  readonly path?: BackendTrafficPolicySpecResponseOverrideRedirectPath;

  /**
   * Port is the port to be used in the value of the `Location`
   * header in the response.
   *
   * If redirect scheme is not-empty, the well-known port associated with the redirect scheme will be used.
   * Specifically "http" to port 80 and "https" to port 443. If the redirect scheme does not have a
   * well-known port or redirect scheme is empty, the listener port of the Gateway will be used.
   *
   * Port will not be added in the 'Location' header if scheme is HTTP and port is 80
   * or scheme is HTTPS and port is 443.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideRedirect#port
   */
  readonly port?: number;

  /**
   * Scheme is the scheme to be used in the value of the `Location` header in
   * the response. When empty, the scheme of the request is used.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideRedirect#scheme
   */
  readonly scheme?: BackendTrafficPolicySpecResponseOverrideRedirectScheme;

  /**
   * StatusCode is the HTTP status code to be used in response.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideRedirect#statusCode
   */
  readonly statusCode?: BackendTrafficPolicySpecResponseOverrideRedirectStatusCode;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecResponseOverrideRedirect' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecResponseOverrideRedirect(obj: BackendTrafficPolicySpecResponseOverrideRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostname': obj.hostname,
    'path': toJson_BackendTrafficPolicySpecResponseOverrideRedirectPath(obj.path),
    'port': obj.port,
    'scheme': obj.scheme,
    'statusCode': obj.statusCode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Response configuration.
 *
 * @schema BackendTrafficPolicySpecResponseOverrideResponse
 */
export interface BackendTrafficPolicySpecResponseOverrideResponse {
  /**
   * Body of the Custom Response
   * Supports Envoy command operators for dynamic content (see https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators).
   *
   * @schema BackendTrafficPolicySpecResponseOverrideResponse#body
   */
  readonly body?: BackendTrafficPolicySpecResponseOverrideResponseBody;

  /**
   * Content Type of the response. This will be set in the Content-Type header.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideResponse#contentType
   */
  readonly contentType?: string;

  /**
   * Header defines headers to add, set or remove from the response.
   * This allows the response policy to append, add or override headers
   * of the final response before it is sent to a downstream client.
   * Note: Header removal is not supported for responseOverride.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideResponse#header
   */
  readonly header?: BackendTrafficPolicySpecResponseOverrideResponseHeader;

  /**
   * Status Code of the Custom Response
   * If unset, does not override the status of response.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideResponse#statusCode
   */
  readonly statusCode?: number;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecResponseOverrideResponse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecResponseOverrideResponse(obj: BackendTrafficPolicySpecResponseOverrideResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': toJson_BackendTrafficPolicySpecResponseOverrideResponseBody(obj.body),
    'contentType': obj.contentType,
    'header': toJson_BackendTrafficPolicySpecResponseOverrideResponseHeader(obj.header),
    'statusCode': obj.statusCode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PerRetry is the retry policy to be applied per retry attempt.
 *
 * @schema BackendTrafficPolicySpecRetryPerRetry
 */
export interface BackendTrafficPolicySpecRetryPerRetry {
  /**
   * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
   * back-off algorithm for retries. For additional details,
   * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
   *
   * @schema BackendTrafficPolicySpecRetryPerRetry#backOff
   */
  readonly backOff?: BackendTrafficPolicySpecRetryPerRetryBackOff;

  /**
   * Timeout is the timeout per retry attempt.
   *
   * @schema BackendTrafficPolicySpecRetryPerRetry#timeout
   */
  readonly timeout?: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRetryPerRetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRetryPerRetry(obj: BackendTrafficPolicySpecRetryPerRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backOff': toJson_BackendTrafficPolicySpecRetryPerRetryBackOff(obj.backOff),
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RetryOn specifies the retry trigger condition.
 *
 * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
 *
 * @schema BackendTrafficPolicySpecRetryRetryOn
 */
export interface BackendTrafficPolicySpecRetryRetryOn {
  /**
   * HttpStatusCodes specifies the http status codes to be retried.
   * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
   *
   * @schema BackendTrafficPolicySpecRetryRetryOn#httpStatusCodes
   */
  readonly httpStatusCodes?: number[];

  /**
   * Triggers specifies the retry trigger condition(Http/Grpc).
   *
   * @schema BackendTrafficPolicySpecRetryRetryOn#triggers
   */
  readonly triggers?: BackendTrafficPolicySpecRetryRetryOnTriggers[];
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRetryRetryOn' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRetryRetryOn(obj: BackendTrafficPolicySpecRetryRetryOn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpStatusCodes': obj.httpStatusCodes?.map(y => y),
    'triggers': obj.triggers?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema BackendTrafficPolicySpecTargetSelectorsMatchExpressions
 */
export interface BackendTrafficPolicySpecTargetSelectorsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema BackendTrafficPolicySpecTargetSelectorsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema BackendTrafficPolicySpecTargetSelectorsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema BackendTrafficPolicySpecTargetSelectorsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecTargetSelectorsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecTargetSelectorsMatchExpressions(obj: BackendTrafficPolicySpecTargetSelectorsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Tracing configures the tracing settings for the backend or HTTPRoute.
 *
 * @schema BackendTrafficPolicySpecTelemetryTracing
 */
export interface BackendTrafficPolicySpecTelemetryTracing {
  /**
   * CustomTags defines the custom tags to add to each span.
   * If provider is kubernetes, pod name and namespace are added by default.
   *
   * @schema BackendTrafficPolicySpecTelemetryTracing#customTags
   */
  readonly customTags?: { [key: string]: BackendTrafficPolicySpecTelemetryTracingCustomTags };

  /**
   * SamplingFraction represents the fraction of requests that should be
   * selected for tracing if no prior sampling decision has been made.
   *
   * This will take precedence over sampling fraction on EnvoyProxy if set.
   *
   * @schema BackendTrafficPolicySpecTelemetryTracing#samplingFraction
   */
  readonly samplingFraction?: BackendTrafficPolicySpecTelemetryTracingSamplingFraction;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecTelemetryTracing' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecTelemetryTracing(obj: BackendTrafficPolicySpecTelemetryTracing | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customTags': ((obj.customTags) === undefined) ? undefined : (Object.entries(obj.customTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_BackendTrafficPolicySpecTelemetryTracingCustomTags(i[1]) }), {})),
    'samplingFraction': toJson_BackendTrafficPolicySpecTelemetryTracingSamplingFraction(obj.samplingFraction),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for HTTP.
 *
 * @schema BackendTrafficPolicySpecTimeoutHttp
 */
export interface BackendTrafficPolicySpecTimeoutHttp {
  /**
   * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
   * Default: 1 hour.
   *
   * @schema BackendTrafficPolicySpecTimeoutHttp#connectionIdleTimeout
   */
  readonly connectionIdleTimeout?: string;

  /**
   * The maximum duration of an HTTP connection.
   * Default: unlimited.
   *
   * @schema BackendTrafficPolicySpecTimeoutHttp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * MaxStreamDuration is the maximum duration for a stream to complete. This timeout measures the time
   * from when the request is sent until the response stream is fully consumed and does not apply to
   * non-streaming requests.
   * When set to "0s", no max duration is applied and streams can run indefinitely.
   *
   * @schema BackendTrafficPolicySpecTimeoutHttp#maxStreamDuration
   */
  readonly maxStreamDuration?: string;

  /**
   * RequestTimeout is the time until which entire response is received from the upstream.
   *
   * @schema BackendTrafficPolicySpecTimeoutHttp#requestTimeout
   */
  readonly requestTimeout?: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecTimeoutHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecTimeoutHttp(obj: BackendTrafficPolicySpecTimeoutHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionIdleTimeout': obj.connectionIdleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxStreamDuration': obj.maxStreamDuration,
    'requestTimeout': obj.requestTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for TCP.
 *
 * @schema BackendTrafficPolicySpecTimeoutTcp
 */
export interface BackendTrafficPolicySpecTimeoutTcp {
  /**
   * The timeout for network connection establishment, including TCP and TLS handshakes.
   * Default: 10 seconds.
   *
   * @schema BackendTrafficPolicySpecTimeoutTcp#connectTimeout
   */
  readonly connectTimeout?: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecTimeoutTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecTimeoutTcp(obj: BackendTrafficPolicySpecTimeoutTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC defines the configuration of the GRPC health checker.
 * It's optional, and can only be used if the specified type is GRPC.
 *
 * @schema BackendTrafficPolicySpecHealthCheckActiveGrpc
 */
export interface BackendTrafficPolicySpecHealthCheckActiveGrpc {
  /**
   * Service to send in the health check request.
   * If this is not specified, then the health check request applies to the entire
   * server and not to a specific service.
   *
   * @schema BackendTrafficPolicySpecHealthCheckActiveGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecHealthCheckActiveGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecHealthCheckActiveGrpc(obj: BackendTrafficPolicySpecHealthCheckActiveGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP defines the configuration of http health checker.
 * It's required while the health checker type is HTTP.
 *
 * @schema BackendTrafficPolicySpecHealthCheckActiveHttp
 */
export interface BackendTrafficPolicySpecHealthCheckActiveHttp {
  /**
   * ExpectedResponse defines a list of HTTP expected responses to match.
   *
   * @schema BackendTrafficPolicySpecHealthCheckActiveHttp#expectedResponse
   */
  readonly expectedResponse?: BackendTrafficPolicySpecHealthCheckActiveHttpExpectedResponse;

  /**
   * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
   * Defaults to 200 only
   *
   * @default 200 only
   * @schema BackendTrafficPolicySpecHealthCheckActiveHttp#expectedStatuses
   */
  readonly expectedStatuses?: number[];

  /**
   * Hostname defines the HTTP host that will be requested during health checking.
   * Default: HTTPRoute or GRPCRoute hostname.
   *
   * @schema BackendTrafficPolicySpecHealthCheckActiveHttp#hostname
   */
  readonly hostname?: string;

  /**
   * Method defines the HTTP method used for health checking.
   * Defaults to GET
   *
   * @default GET
   * @schema BackendTrafficPolicySpecHealthCheckActiveHttp#method
   */
  readonly method?: string;

  /**
   * Path defines the HTTP path that will be requested during health checking.
   *
   * @schema BackendTrafficPolicySpecHealthCheckActiveHttp#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecHealthCheckActiveHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecHealthCheckActiveHttp(obj: BackendTrafficPolicySpecHealthCheckActiveHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expectedResponse': toJson_BackendTrafficPolicySpecHealthCheckActiveHttpExpectedResponse(obj.expectedResponse),
    'expectedStatuses': obj.expectedStatuses?.map(y => y),
    'hostname': obj.hostname,
    'method': obj.method,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCP defines the configuration of tcp health checker.
 * It's required while the health checker type is TCP.
 *
 * @schema BackendTrafficPolicySpecHealthCheckActiveTcp
 */
export interface BackendTrafficPolicySpecHealthCheckActiveTcp {
  /**
   * Receive defines the expected response payload.
   *
   * @schema BackendTrafficPolicySpecHealthCheckActiveTcp#receive
   */
  readonly receive?: BackendTrafficPolicySpecHealthCheckActiveTcpReceive;

  /**
   * Send defines the request payload.
   *
   * @schema BackendTrafficPolicySpecHealthCheckActiveTcp#send
   */
  readonly send?: BackendTrafficPolicySpecHealthCheckActiveTcpSend;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecHealthCheckActiveTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecHealthCheckActiveTcp(obj: BackendTrafficPolicySpecHealthCheckActiveTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'receive': toJson_BackendTrafficPolicySpecHealthCheckActiveTcpReceive(obj.receive),
    'send': toJson_BackendTrafficPolicySpecHealthCheckActiveTcpSend(obj.send),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
 *
 * @schema BackendTrafficPolicySpecLoadBalancerConsistentHashCookie
 */
export interface BackendTrafficPolicySpecLoadBalancerConsistentHashCookie {
  /**
   * Additional Attributes to set for the generated cookie.
   *
   * @schema BackendTrafficPolicySpecLoadBalancerConsistentHashCookie#attributes
   */
  readonly attributes?: { [key: string]: string };

  /**
   * Name of the cookie to hash.
   * If this cookie does not exist in the request, Envoy will generate a cookie and set
   * the TTL on the response back to the client based on Layer 4
   * attributes of the backend endpoint, to ensure that these future requests
   * go to the same backend endpoint. Make sure to set the TTL field for this case.
   *
   * @schema BackendTrafficPolicySpecLoadBalancerConsistentHashCookie#name
   */
  readonly name: string;

  /**
   * TTL of the generated cookie if the cookie is not present. This value sets the
   * Max-Age attribute value.
   *
   * @schema BackendTrafficPolicySpecLoadBalancerConsistentHashCookie#ttl
   */
  readonly ttl?: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecLoadBalancerConsistentHashCookie' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecLoadBalancerConsistentHashCookie(obj: BackendTrafficPolicySpecLoadBalancerConsistentHashCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributes': ((obj.attributes) === undefined) ? undefined : (Object.entries(obj.attributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Header configures the header hash policy when the consistent hash type is set to Header.
 *
 * Deprecated: use Headers instead
 *
 * @schema BackendTrafficPolicySpecLoadBalancerConsistentHashHeader
 */
export interface BackendTrafficPolicySpecLoadBalancerConsistentHashHeader {
  /**
   * Name of the header to hash.
   *
   * @schema BackendTrafficPolicySpecLoadBalancerConsistentHashHeader#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecLoadBalancerConsistentHashHeader' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecLoadBalancerConsistentHashHeader(obj: BackendTrafficPolicySpecLoadBalancerConsistentHashHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Header defines the header hashing configuration for consistent hash based
 * load balancing.
 *
 * @schema BackendTrafficPolicySpecLoadBalancerConsistentHashHeaders
 */
export interface BackendTrafficPolicySpecLoadBalancerConsistentHashHeaders {
  /**
   * Name of the header to hash.
   *
   * @schema BackendTrafficPolicySpecLoadBalancerConsistentHashHeaders#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecLoadBalancerConsistentHashHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecLoadBalancerConsistentHashHeaders(obj: BackendTrafficPolicySpecLoadBalancerConsistentHashHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConsistentHashType defines the type of input to hash on. Valid Type values are
 * "SourceIP",
 * "Header",
 * "Headers",
 * "Cookie".
 *
 * @schema BackendTrafficPolicySpecLoadBalancerConsistentHashType
 */
export enum BackendTrafficPolicySpecLoadBalancerConsistentHashType {
  /** SourceIP */
  SOURCE_IP = "SourceIP",
  /** Header */
  HEADER = "Header",
  /** Headers */
  HEADERS = "Headers",
  /** Cookie */
  COOKIE = "Cookie",
}

/**
 * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
 *
 * @schema BackendTrafficPolicySpecLoadBalancerEndpointOverrideExtractFrom
 */
export interface BackendTrafficPolicySpecLoadBalancerEndpointOverrideExtractFrom {
  /**
   * Header defines the header to get the override endpoint addresses.
   * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
   * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
   * The IPv6 address is enclosed in square brackets.
   *
   * @schema BackendTrafficPolicySpecLoadBalancerEndpointOverrideExtractFrom#header
   */
  readonly header?: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecLoadBalancerEndpointOverrideExtractFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecLoadBalancerEndpointOverrideExtractFrom(obj: BackendTrafficPolicySpecLoadBalancerEndpointOverrideExtractFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': obj.header,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
 *
 * @schema BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocal
 */
export interface BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocal {
  /**
   * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
   * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
   *
   * @schema BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocal#force
   */
  readonly force?: BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocalForce;

  /**
   * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
   *
   * @schema BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocal#minEndpointsThreshold
   */
  readonly minEndpointsThreshold?: number;

  /**
   * Configures percentage of requests that will be considered for zone aware routing if zone aware routing is configured. If not specified, Envoy defaults to 100%.
   *
   * @schema BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocal#percentageEnabled
   */
  readonly percentageEnabled?: number;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocal' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocal(obj: BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'force': toJson_BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocalForce(obj.force),
    'minEndpointsThreshold': obj.minEndpointsThreshold,
    'percentageEnabled': obj.percentageEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RateLimitRule defines the semantics for matching attributes
 * from the incoming requests, and setting limits for them.
 *
 * @schema BackendTrafficPolicySpecRateLimitGlobalRules
 */
export interface BackendTrafficPolicySpecRateLimitGlobalRules {
  /**
   * ClientSelectors holds the list of select conditions to select
   * specific clients using attributes from the traffic flow.
   * All individual select conditions must hold True for this rule
   * and its limit to be applied.
   *
   * If no client selectors are specified, the rule applies to all traffic of
   * the targeted Route.
   *
   * If the policy targets a Gateway, the rule applies to each Route of the Gateway.
   * Please note that each Route has its own rate limit counters. For example,
   * if a Gateway has two Routes, and the policy has a rule with limit 10rps,
   * each Route will have its own 10rps limit.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRules#clientSelectors
   */
  readonly clientSelectors?: BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectors[];

  /**
   * Cost specifies the cost of requests and responses for the rule.
   *
   * This is optional and if not specified, the default behavior is to reduce the rate limit counters by 1 on
   * the request path and do not reduce the rate limit counters on the response path.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRules#cost
   */
  readonly cost?: BackendTrafficPolicySpecRateLimitGlobalRulesCost;

  /**
   * Limit holds the rate limit values.
   * This limit is applied for traffic flows when the selectors
   * compute to True, causing the request to be counted towards the limit.
   * The limit is enforced and the request is ratelimited, i.e. a response with
   * 429 HTTP status code is sent back to the client when
   * the selected requests have reached the limit.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRules#limit
   */
  readonly limit: BackendTrafficPolicySpecRateLimitGlobalRulesLimit;

  /**
   * Shared determines whether this rate limit rule applies across all the policy targets.
   * If set to true, the rule is treated as a common bucket and is shared across all policy targets (xRoutes).
   * Default: false.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRules#shared
   */
  readonly shared?: boolean;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitGlobalRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitGlobalRules(obj: BackendTrafficPolicySpecRateLimitGlobalRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientSelectors': obj.clientSelectors?.map(y => toJson_BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectors(y)),
    'cost': toJson_BackendTrafficPolicySpecRateLimitGlobalRulesCost(obj.cost),
    'limit': toJson_BackendTrafficPolicySpecRateLimitGlobalRulesLimit(obj.limit),
    'shared': obj.shared,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RateLimitRule defines the semantics for matching attributes
 * from the incoming requests, and setting limits for them.
 *
 * @schema BackendTrafficPolicySpecRateLimitLocalRules
 */
export interface BackendTrafficPolicySpecRateLimitLocalRules {
  /**
   * ClientSelectors holds the list of select conditions to select
   * specific clients using attributes from the traffic flow.
   * All individual select conditions must hold True for this rule
   * and its limit to be applied.
   *
   * If no client selectors are specified, the rule applies to all traffic of
   * the targeted Route.
   *
   * If the policy targets a Gateway, the rule applies to each Route of the Gateway.
   * Please note that each Route has its own rate limit counters. For example,
   * if a Gateway has two Routes, and the policy has a rule with limit 10rps,
   * each Route will have its own 10rps limit.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRules#clientSelectors
   */
  readonly clientSelectors?: BackendTrafficPolicySpecRateLimitLocalRulesClientSelectors[];

  /**
   * Cost specifies the cost of requests and responses for the rule.
   *
   * This is optional and if not specified, the default behavior is to reduce the rate limit counters by 1 on
   * the request path and do not reduce the rate limit counters on the response path.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRules#cost
   */
  readonly cost?: BackendTrafficPolicySpecRateLimitLocalRulesCost;

  /**
   * Limit holds the rate limit values.
   * This limit is applied for traffic flows when the selectors
   * compute to True, causing the request to be counted towards the limit.
   * The limit is enforced and the request is ratelimited, i.e. a response with
   * 429 HTTP status code is sent back to the client when
   * the selected requests have reached the limit.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRules#limit
   */
  readonly limit: BackendTrafficPolicySpecRateLimitLocalRulesLimit;

  /**
   * Shared determines whether this rate limit rule applies across all the policy targets.
   * If set to true, the rule is treated as a common bucket and is shared across all policy targets (xRoutes).
   * Default: false.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRules#shared
   */
  readonly shared?: boolean;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitLocalRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitLocalRules(obj: BackendTrafficPolicySpecRateLimitLocalRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientSelectors': obj.clientSelectors?.map(y => toJson_BackendTrafficPolicySpecRateLimitLocalRulesClientSelectors(y)),
    'cost': toJson_BackendTrafficPolicySpecRateLimitLocalRulesCost(obj.cost),
    'limit': toJson_BackendTrafficPolicySpecRateLimitLocalRulesLimit(obj.limit),
    'shared': obj.shared,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StatusCodeMatch defines the configuration for matching a status code.
 *
 * @schema BackendTrafficPolicySpecResponseOverrideMatchStatusCodes
 */
export interface BackendTrafficPolicySpecResponseOverrideMatchStatusCodes {
  /**
   * Range contains the range of status codes.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideMatchStatusCodes#range
   */
  readonly range?: BackendTrafficPolicySpecResponseOverrideMatchStatusCodesRange;

  /**
   * Type is the type of value.
   * Valid values are Value and Range, default is Value.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideMatchStatusCodes#type
   */
  readonly type: string;

  /**
   * Value contains the value of the status code.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideMatchStatusCodes#value
   */
  readonly value?: number;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecResponseOverrideMatchStatusCodes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecResponseOverrideMatchStatusCodes(obj: BackendTrafficPolicySpecResponseOverrideMatchStatusCodes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'range': toJson_BackendTrafficPolicySpecResponseOverrideMatchStatusCodesRange(obj.range),
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Path defines parameters used to modify the path of the incoming request.
 * The modified path is then used to construct the `Location` header. When
 * empty, the request path is used as-is.
 * Only ReplaceFullPath path modifier is supported currently.
 *
 * @schema BackendTrafficPolicySpecResponseOverrideRedirectPath
 */
export interface BackendTrafficPolicySpecResponseOverrideRedirectPath {
  /**
   * ReplaceFullPath specifies the value with which to replace the full path
   * of a request during a rewrite or redirect.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideRedirectPath#replaceFullPath
   */
  readonly replaceFullPath?: string;

  /**
   * ReplacePrefixMatch specifies the value with which to replace the prefix
   * match of a request during a rewrite or redirect. For example, a request
   * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
   * of "/xyz" would be modified to "/xyz/bar".
   *
   * Note that this matches the behavior of the PathPrefix match type. This
   * matches full path elements. A path element refers to the list of labels
   * in the path split by the `/` separator. When specified, a trailing `/` is
   * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
   * match the prefix `/abc`, but the path `/abcd` would not.
   *
   * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
   * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
   * the implementation setting the Accepted Condition for the Route to `status: False`.
   *
   * Request Path | Prefix Match | Replace Prefix | Modified Path
   *
   * @schema BackendTrafficPolicySpecResponseOverrideRedirectPath#replacePrefixMatch
   */
  readonly replacePrefixMatch?: string;

  /**
   * Type defines the type of path modifier. Additional types may be
   * added in a future release of the API.
   *
   * Note that values may be added to this enum, implementations
   * must ensure that unknown values will not cause a crash.
   *
   * Unknown values here must result in the implementation setting the
   * Accepted Condition for the Route to `status: False`, with a
   * Reason of `UnsupportedValue`.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideRedirectPath#type
   */
  readonly type: BackendTrafficPolicySpecResponseOverrideRedirectPathType;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecResponseOverrideRedirectPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecResponseOverrideRedirectPath(obj: BackendTrafficPolicySpecResponseOverrideRedirectPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'replaceFullPath': obj.replaceFullPath,
    'replacePrefixMatch': obj.replacePrefixMatch,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Scheme is the scheme to be used in the value of the `Location` header in
 * the response. When empty, the scheme of the request is used.
 *
 * @schema BackendTrafficPolicySpecResponseOverrideRedirectScheme
 */
export enum BackendTrafficPolicySpecResponseOverrideRedirectScheme {
  /** http */
  HTTP = "http",
  /** https */
  HTTPS = "https",
}

/**
 * StatusCode is the HTTP status code to be used in response.
 *
 * @schema BackendTrafficPolicySpecResponseOverrideRedirectStatusCode
 */
export enum BackendTrafficPolicySpecResponseOverrideRedirectStatusCode {
  /** 301 */
  VALUE_301 = 301,
  /** 302 */
  VALUE_302 = 302,
}

/**
 * Body of the Custom Response
 * Supports Envoy command operators for dynamic content (see https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators).
 *
 * @schema BackendTrafficPolicySpecResponseOverrideResponseBody
 */
export interface BackendTrafficPolicySpecResponseOverrideResponseBody {
  /**
   * Inline contains the value as an inline string.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideResponseBody#inline
   */
  readonly inline?: string;

  /**
   * Type is the type of method to use to read the body value.
   * Valid values are Inline and ValueRef, default is Inline.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideResponseBody#type
   */
  readonly type: string;

  /**
   * ValueRef contains the contents of the body
   * specified as a local object reference.
   * Only a reference to ConfigMap is supported.
   *
   * The value of key `response.body` in the ConfigMap will be used as the response body.
   * If the key is not found, the first value in the ConfigMap will be used.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideResponseBody#valueRef
   */
  readonly valueRef?: BackendTrafficPolicySpecResponseOverrideResponseBodyValueRef;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecResponseOverrideResponseBody' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecResponseOverrideResponseBody(obj: BackendTrafficPolicySpecResponseOverrideResponseBody | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inline': obj.inline,
    'type': obj.type,
    'valueRef': toJson_BackendTrafficPolicySpecResponseOverrideResponseBodyValueRef(obj.valueRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Header defines headers to add, set or remove from the response.
 * This allows the response policy to append, add or override headers
 * of the final response before it is sent to a downstream client.
 * Note: Header removal is not supported for responseOverride.
 *
 * @schema BackendTrafficPolicySpecResponseOverrideResponseHeader
 */
export interface BackendTrafficPolicySpecResponseOverrideResponseHeader {
  /**
   * Add adds the given header(s) (name, value) to the request
   * before the action. It appends to any existing values associated
   * with the header name.
   *
   * Input:
   * GET /foo HTTP/1.1
   * my-header: foo
   *
   * Config:
   * add:
   * - name: "my-header"
   * value: "bar,baz"
   *
   * Output:
   * GET /foo HTTP/1.1
   * my-header: foo,bar,baz
   *
   * @schema BackendTrafficPolicySpecResponseOverrideResponseHeader#add
   */
  readonly add?: BackendTrafficPolicySpecResponseOverrideResponseHeaderAdd[];

  /**
   * Remove the given header(s) from the HTTP request before the action. The
   * value of Remove is a list of HTTP header names. Note that the header
   * names are case-insensitive (see
   * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
   *
   * Input:
   * GET /foo HTTP/1.1
   * my-header1: foo
   * my-header2: bar
   * my-header3: baz
   *
   * Config:
   * remove: ["my-header1", "my-header3"]
   *
   * Output:
   * GET /foo HTTP/1.1
   * my-header2: bar
   *
   * @schema BackendTrafficPolicySpecResponseOverrideResponseHeader#remove
   */
  readonly remove?: string[];

  /**
   * Set overwrites the request with the given header (name, value)
   * before the action.
   *
   * Input:
   * GET /foo HTTP/1.1
   * my-header: foo
   *
   * Config:
   * set:
   * - name: "my-header"
   * value: "bar"
   *
   * Output:
   * GET /foo HTTP/1.1
   * my-header: bar
   *
   * @schema BackendTrafficPolicySpecResponseOverrideResponseHeader#set
   */
  readonly set?: BackendTrafficPolicySpecResponseOverrideResponseHeaderSet[];
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecResponseOverrideResponseHeader' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecResponseOverrideResponseHeader(obj: BackendTrafficPolicySpecResponseOverrideResponseHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => toJson_BackendTrafficPolicySpecResponseOverrideResponseHeaderAdd(y)),
    'remove': obj.remove?.map(y => y),
    'set': obj.set?.map(y => toJson_BackendTrafficPolicySpecResponseOverrideResponseHeaderSet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
 * back-off algorithm for retries. For additional details,
 * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
 *
 * @schema BackendTrafficPolicySpecRetryPerRetryBackOff
 */
export interface BackendTrafficPolicySpecRetryPerRetryBackOff {
  /**
   * BaseInterval is the base interval between retries.
   *
   * @schema BackendTrafficPolicySpecRetryPerRetryBackOff#baseInterval
   */
  readonly baseInterval?: string;

  /**
   * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
   * The default is 10 times the base_interval
   *
   * @schema BackendTrafficPolicySpecRetryPerRetryBackOff#maxInterval
   */
  readonly maxInterval?: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRetryPerRetryBackOff' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRetryPerRetryBackOff(obj: BackendTrafficPolicySpecRetryPerRetryBackOff | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseInterval': obj.baseInterval,
    'maxInterval': obj.maxInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TriggerEnum specifies the conditions that trigger retries.
 *
 * @schema BackendTrafficPolicySpecRetryRetryOnTriggers
 */
export enum BackendTrafficPolicySpecRetryRetryOnTriggers {
  /** 5xx */
  VALUE_5XX = "5xx",
  /** gateway-error */
  GATEWAY_HYPHEN_ERROR = "gateway-error",
  /** reset */
  RESET = "reset",
  /** reset-before-request */
  RESET_HYPHEN_BEFORE_HYPHEN_REQUEST = "reset-before-request",
  /** connect-failure */
  CONNECT_HYPHEN_FAILURE = "connect-failure",
  /** retriable-4xx */
  RETRIABLE_HYPHEN_4XX = "retriable-4xx",
  /** refused-stream */
  REFUSED_HYPHEN_STREAM = "refused-stream",
  /** retriable-status-codes */
  RETRIABLE_HYPHEN_STATUS_HYPHEN_CODES = "retriable-status-codes",
  /** cancelled */
  CANCELLED = "cancelled",
  /** deadline-exceeded */
  DEADLINE_HYPHEN_EXCEEDED = "deadline-exceeded",
  /** internal */
  INTERNAL = "internal",
  /** resource-exhausted */
  RESOURCE_HYPHEN_EXHAUSTED = "resource-exhausted",
  /** unavailable */
  UNAVAILABLE = "unavailable",
}

/**
 * @schema BackendTrafficPolicySpecTelemetryTracingCustomTags
 */
export interface BackendTrafficPolicySpecTelemetryTracingCustomTags {
  /**
   * Environment adds value from environment variable to each span.
   * It's required when the type is "Environment".
   *
   * @schema BackendTrafficPolicySpecTelemetryTracingCustomTags#environment
   */
  readonly environment?: BackendTrafficPolicySpecTelemetryTracingCustomTagsEnvironment;

  /**
   * Literal adds hard-coded value to each span.
   * It's required when the type is "Literal".
   *
   * @schema BackendTrafficPolicySpecTelemetryTracingCustomTags#literal
   */
  readonly literal?: BackendTrafficPolicySpecTelemetryTracingCustomTagsLiteral;

  /**
   * RequestHeader adds value from request header to each span.
   * It's required when the type is "RequestHeader".
   *
   * @schema BackendTrafficPolicySpecTelemetryTracingCustomTags#requestHeader
   */
  readonly requestHeader?: BackendTrafficPolicySpecTelemetryTracingCustomTagsRequestHeader;

  /**
   * Type defines the type of custom tag.
   *
   * @schema BackendTrafficPolicySpecTelemetryTracingCustomTags#type
   */
  readonly type: BackendTrafficPolicySpecTelemetryTracingCustomTagsType;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecTelemetryTracingCustomTags' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecTelemetryTracingCustomTags(obj: BackendTrafficPolicySpecTelemetryTracingCustomTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'environment': toJson_BackendTrafficPolicySpecTelemetryTracingCustomTagsEnvironment(obj.environment),
    'literal': toJson_BackendTrafficPolicySpecTelemetryTracingCustomTagsLiteral(obj.literal),
    'requestHeader': toJson_BackendTrafficPolicySpecTelemetryTracingCustomTagsRequestHeader(obj.requestHeader),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SamplingFraction represents the fraction of requests that should be
 * selected for tracing if no prior sampling decision has been made.
 *
 * This will take precedence over sampling fraction on EnvoyProxy if set.
 *
 * @schema BackendTrafficPolicySpecTelemetryTracingSamplingFraction
 */
export interface BackendTrafficPolicySpecTelemetryTracingSamplingFraction {
  /**
   * @schema BackendTrafficPolicySpecTelemetryTracingSamplingFraction#denominator
   */
  readonly denominator?: number;

  /**
   * @schema BackendTrafficPolicySpecTelemetryTracingSamplingFraction#numerator
   */
  readonly numerator: number;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecTelemetryTracingSamplingFraction' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecTelemetryTracingSamplingFraction(obj: BackendTrafficPolicySpecTelemetryTracingSamplingFraction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'denominator': obj.denominator,
    'numerator': obj.numerator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExpectedResponse defines a list of HTTP expected responses to match.
 *
 * @schema BackendTrafficPolicySpecHealthCheckActiveHttpExpectedResponse
 */
export interface BackendTrafficPolicySpecHealthCheckActiveHttpExpectedResponse {
  /**
   * Binary payload base64 encoded.
   *
   * @schema BackendTrafficPolicySpecHealthCheckActiveHttpExpectedResponse#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema BackendTrafficPolicySpecHealthCheckActiveHttpExpectedResponse#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema BackendTrafficPolicySpecHealthCheckActiveHttpExpectedResponse#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecHealthCheckActiveHttpExpectedResponse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecHealthCheckActiveHttpExpectedResponse(obj: BackendTrafficPolicySpecHealthCheckActiveHttpExpectedResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Receive defines the expected response payload.
 *
 * @schema BackendTrafficPolicySpecHealthCheckActiveTcpReceive
 */
export interface BackendTrafficPolicySpecHealthCheckActiveTcpReceive {
  /**
   * Binary payload base64 encoded.
   *
   * @schema BackendTrafficPolicySpecHealthCheckActiveTcpReceive#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema BackendTrafficPolicySpecHealthCheckActiveTcpReceive#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema BackendTrafficPolicySpecHealthCheckActiveTcpReceive#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecHealthCheckActiveTcpReceive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecHealthCheckActiveTcpReceive(obj: BackendTrafficPolicySpecHealthCheckActiveTcpReceive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Send defines the request payload.
 *
 * @schema BackendTrafficPolicySpecHealthCheckActiveTcpSend
 */
export interface BackendTrafficPolicySpecHealthCheckActiveTcpSend {
  /**
   * Binary payload base64 encoded.
   *
   * @schema BackendTrafficPolicySpecHealthCheckActiveTcpSend#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema BackendTrafficPolicySpecHealthCheckActiveTcpSend#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema BackendTrafficPolicySpecHealthCheckActiveTcpSend#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecHealthCheckActiveTcpSend' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecHealthCheckActiveTcpSend(obj: BackendTrafficPolicySpecHealthCheckActiveTcpSend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
 * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
 *
 * @schema BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocalForce
 */
export interface BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocalForce {
  /**
   * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
   * override. This is useful for protecting zones with fewer endpoints.
   *
   * @schema BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocalForce#minEndpointsInZoneThreshold
   */
  readonly minEndpointsInZoneThreshold?: number;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocalForce' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocalForce(obj: BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocalForce | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minEndpointsInZoneThreshold': obj.minEndpointsInZoneThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RateLimitSelectCondition specifies the attributes within the traffic flow that can
 * be used to select a subset of clients to be ratelimited.
 * All the individual conditions must hold True for the overall condition to hold True.
 * And, at least one of headers or methods or path or sourceCIDR condition must be specified.
 *
 * @schema BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectors
 */
export interface BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectors {
  /**
   * Headers is a list of request headers to match. Multiple header values are ANDed together,
   * meaning, a request MUST match all the specified headers.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectors#headers
   */
  readonly headers?: BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsHeaders[];

  /**
   * Methods is a list of request methods to match. Multiple method values are ORed together,
   * meaning, a request can match any one of the specified methods. If not specified, it matches all methods.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectors#methods
   */
  readonly methods?: BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsMethods[];

  /**
   * Path is the request path to match.
   * Support Exact, PathPrefix and RegularExpression match types.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectors#path
   */
  readonly path?: BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsPath;

  /**
   * SourceCIDR is the client IP Address range to match on.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectors#sourceCIDR
   */
  readonly sourceCidr?: BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsSourceCidr;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectors(obj: BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headers': obj.headers?.map(y => toJson_BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsHeaders(y)),
    'methods': obj.methods?.map(y => toJson_BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsMethods(y)),
    'path': toJson_BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsPath(obj.path),
    'sourceCIDR': toJson_BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsSourceCidr(obj.sourceCidr),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cost specifies the cost of requests and responses for the rule.
 *
 * This is optional and if not specified, the default behavior is to reduce the rate limit counters by 1 on
 * the request path and do not reduce the rate limit counters on the response path.
 *
 * @schema BackendTrafficPolicySpecRateLimitGlobalRulesCost
 */
export interface BackendTrafficPolicySpecRateLimitGlobalRulesCost {
  /**
   * Request specifies the number to reduce the rate limit counters
   * on the request path. If this is not specified, the default behavior
   * is to reduce the rate limit counters by 1.
   *
   * When Envoy receives a request that matches the rule, it tries to reduce the
   * rate limit counters by the specified number. If the counter doesn't have
   * enough capacity, the request is rate limited.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesCost#request
   */
  readonly request?: BackendTrafficPolicySpecRateLimitGlobalRulesCostRequest;

  /**
   * Response specifies the number to reduce the rate limit counters
   * after the response is sent back to the client or the request stream is closed.
   *
   * The cost is used to reduce the rate limit counters for the matching requests.
   * Since the reduction happens after the request stream is complete, the rate limit
   * won't be enforced for the current request, but for the subsequent matching requests.
   *
   * This is optional and if not specified, the rate limit counters are not reduced
   * on the response path.
   *
   * Currently, this is only supported for HTTP Global Rate Limits.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesCost#response
   */
  readonly response?: BackendTrafficPolicySpecRateLimitGlobalRulesCostResponse;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitGlobalRulesCost' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitGlobalRulesCost(obj: BackendTrafficPolicySpecRateLimitGlobalRulesCost | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'request': toJson_BackendTrafficPolicySpecRateLimitGlobalRulesCostRequest(obj.request),
    'response': toJson_BackendTrafficPolicySpecRateLimitGlobalRulesCostResponse(obj.response),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Limit holds the rate limit values.
 * This limit is applied for traffic flows when the selectors
 * compute to True, causing the request to be counted towards the limit.
 * The limit is enforced and the request is ratelimited, i.e. a response with
 * 429 HTTP status code is sent back to the client when
 * the selected requests have reached the limit.
 *
 * @schema BackendTrafficPolicySpecRateLimitGlobalRulesLimit
 */
export interface BackendTrafficPolicySpecRateLimitGlobalRulesLimit {
  /**
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesLimit#requests
   */
  readonly requests: number;

  /**
   * RateLimitUnit specifies the intervals for setting rate limits.
   * Valid RateLimitUnit values are "Second", "Minute", "Hour", "Day", "Month" and "Year".
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesLimit#unit
   */
  readonly unit: BackendTrafficPolicySpecRateLimitGlobalRulesLimitUnit;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitGlobalRulesLimit' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitGlobalRulesLimit(obj: BackendTrafficPolicySpecRateLimitGlobalRulesLimit | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requests': obj.requests,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RateLimitSelectCondition specifies the attributes within the traffic flow that can
 * be used to select a subset of clients to be ratelimited.
 * All the individual conditions must hold True for the overall condition to hold True.
 * And, at least one of headers or methods or path or sourceCIDR condition must be specified.
 *
 * @schema BackendTrafficPolicySpecRateLimitLocalRulesClientSelectors
 */
export interface BackendTrafficPolicySpecRateLimitLocalRulesClientSelectors {
  /**
   * Headers is a list of request headers to match. Multiple header values are ANDed together,
   * meaning, a request MUST match all the specified headers.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesClientSelectors#headers
   */
  readonly headers?: BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsHeaders[];

  /**
   * Methods is a list of request methods to match. Multiple method values are ORed together,
   * meaning, a request can match any one of the specified methods. If not specified, it matches all methods.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesClientSelectors#methods
   */
  readonly methods?: BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsMethods[];

  /**
   * Path is the request path to match.
   * Support Exact, PathPrefix and RegularExpression match types.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesClientSelectors#path
   */
  readonly path?: BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsPath;

  /**
   * SourceCIDR is the client IP Address range to match on.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesClientSelectors#sourceCIDR
   */
  readonly sourceCidr?: BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsSourceCidr;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitLocalRulesClientSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitLocalRulesClientSelectors(obj: BackendTrafficPolicySpecRateLimitLocalRulesClientSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headers': obj.headers?.map(y => toJson_BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsHeaders(y)),
    'methods': obj.methods?.map(y => toJson_BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsMethods(y)),
    'path': toJson_BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsPath(obj.path),
    'sourceCIDR': toJson_BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsSourceCidr(obj.sourceCidr),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cost specifies the cost of requests and responses for the rule.
 *
 * This is optional and if not specified, the default behavior is to reduce the rate limit counters by 1 on
 * the request path and do not reduce the rate limit counters on the response path.
 *
 * @schema BackendTrafficPolicySpecRateLimitLocalRulesCost
 */
export interface BackendTrafficPolicySpecRateLimitLocalRulesCost {
  /**
   * Request specifies the number to reduce the rate limit counters
   * on the request path. If this is not specified, the default behavior
   * is to reduce the rate limit counters by 1.
   *
   * When Envoy receives a request that matches the rule, it tries to reduce the
   * rate limit counters by the specified number. If the counter doesn't have
   * enough capacity, the request is rate limited.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesCost#request
   */
  readonly request?: BackendTrafficPolicySpecRateLimitLocalRulesCostRequest;

  /**
   * Response specifies the number to reduce the rate limit counters
   * after the response is sent back to the client or the request stream is closed.
   *
   * The cost is used to reduce the rate limit counters for the matching requests.
   * Since the reduction happens after the request stream is complete, the rate limit
   * won't be enforced for the current request, but for the subsequent matching requests.
   *
   * This is optional and if not specified, the rate limit counters are not reduced
   * on the response path.
   *
   * Currently, this is only supported for HTTP Global Rate Limits.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesCost#response
   */
  readonly response?: BackendTrafficPolicySpecRateLimitLocalRulesCostResponse;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitLocalRulesCost' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitLocalRulesCost(obj: BackendTrafficPolicySpecRateLimitLocalRulesCost | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'request': toJson_BackendTrafficPolicySpecRateLimitLocalRulesCostRequest(obj.request),
    'response': toJson_BackendTrafficPolicySpecRateLimitLocalRulesCostResponse(obj.response),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Limit holds the rate limit values.
 * This limit is applied for traffic flows when the selectors
 * compute to True, causing the request to be counted towards the limit.
 * The limit is enforced and the request is ratelimited, i.e. a response with
 * 429 HTTP status code is sent back to the client when
 * the selected requests have reached the limit.
 *
 * @schema BackendTrafficPolicySpecRateLimitLocalRulesLimit
 */
export interface BackendTrafficPolicySpecRateLimitLocalRulesLimit {
  /**
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesLimit#requests
   */
  readonly requests: number;

  /**
   * RateLimitUnit specifies the intervals for setting rate limits.
   * Valid RateLimitUnit values are "Second", "Minute", "Hour", "Day", "Month" and "Year".
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesLimit#unit
   */
  readonly unit: BackendTrafficPolicySpecRateLimitLocalRulesLimitUnit;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitLocalRulesLimit' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitLocalRulesLimit(obj: BackendTrafficPolicySpecRateLimitLocalRulesLimit | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requests': obj.requests,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Range contains the range of status codes.
 *
 * @schema BackendTrafficPolicySpecResponseOverrideMatchStatusCodesRange
 */
export interface BackendTrafficPolicySpecResponseOverrideMatchStatusCodesRange {
  /**
   * End of the range, including the end value.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideMatchStatusCodesRange#end
   */
  readonly end: number;

  /**
   * Start of the range, including the start value.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideMatchStatusCodesRange#start
   */
  readonly start: number;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecResponseOverrideMatchStatusCodesRange' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecResponseOverrideMatchStatusCodesRange(obj: BackendTrafficPolicySpecResponseOverrideMatchStatusCodesRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type defines the type of path modifier. Additional types may be
 * added in a future release of the API.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * @schema BackendTrafficPolicySpecResponseOverrideRedirectPathType
 */
export enum BackendTrafficPolicySpecResponseOverrideRedirectPathType {
  /** ReplaceFullPath */
  REPLACE_FULL_PATH = "ReplaceFullPath",
  /** ReplacePrefixMatch */
  REPLACE_PREFIX_MATCH = "ReplacePrefixMatch",
}

/**
 * ValueRef contains the contents of the body
 * specified as a local object reference.
 * Only a reference to ConfigMap is supported.
 *
 * The value of key `response.body` in the ConfigMap will be used as the response body.
 * If the key is not found, the first value in the ConfigMap will be used.
 *
 * @schema BackendTrafficPolicySpecResponseOverrideResponseBodyValueRef
 */
export interface BackendTrafficPolicySpecResponseOverrideResponseBodyValueRef {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideResponseBodyValueRef#group
   */
  readonly group: string;

  /**
   * Kind is kind of the referent. For example "HTTPRoute" or "Service".
   *
   * @schema BackendTrafficPolicySpecResponseOverrideResponseBodyValueRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of the referent.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideResponseBodyValueRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecResponseOverrideResponseBodyValueRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecResponseOverrideResponseBodyValueRef(obj: BackendTrafficPolicySpecResponseOverrideResponseBodyValueRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
 *
 * @schema BackendTrafficPolicySpecResponseOverrideResponseHeaderAdd
 */
export interface BackendTrafficPolicySpecResponseOverrideResponseHeaderAdd {
  /**
   * Name is the name of the HTTP Header to be matched. Name matching MUST be
   * case-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
   *
   * If multiple entries specify equivalent header names, the first entry with
   * an equivalent name MUST be considered for a match. Subsequent entries
   * with an equivalent header name MUST be ignored. Due to the
   * case-insensitivity of header names, "foo" and "Foo" are considered
   * equivalent.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideResponseHeaderAdd#name
   */
  readonly name: string;

  /**
   * Value is the value of HTTP Header to be matched.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideResponseHeaderAdd#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecResponseOverrideResponseHeaderAdd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecResponseOverrideResponseHeaderAdd(obj: BackendTrafficPolicySpecResponseOverrideResponseHeaderAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
 *
 * @schema BackendTrafficPolicySpecResponseOverrideResponseHeaderSet
 */
export interface BackendTrafficPolicySpecResponseOverrideResponseHeaderSet {
  /**
   * Name is the name of the HTTP Header to be matched. Name matching MUST be
   * case-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
   *
   * If multiple entries specify equivalent header names, the first entry with
   * an equivalent name MUST be considered for a match. Subsequent entries
   * with an equivalent header name MUST be ignored. Due to the
   * case-insensitivity of header names, "foo" and "Foo" are considered
   * equivalent.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideResponseHeaderSet#name
   */
  readonly name: string;

  /**
   * Value is the value of HTTP Header to be matched.
   *
   * @schema BackendTrafficPolicySpecResponseOverrideResponseHeaderSet#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecResponseOverrideResponseHeaderSet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecResponseOverrideResponseHeaderSet(obj: BackendTrafficPolicySpecResponseOverrideResponseHeaderSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Environment adds value from environment variable to each span.
 * It's required when the type is "Environment".
 *
 * @schema BackendTrafficPolicySpecTelemetryTracingCustomTagsEnvironment
 */
export interface BackendTrafficPolicySpecTelemetryTracingCustomTagsEnvironment {
  /**
   * DefaultValue defines the default value to use if the environment variable is not set.
   *
   * @schema BackendTrafficPolicySpecTelemetryTracingCustomTagsEnvironment#defaultValue
   */
  readonly defaultValue?: string;

  /**
   * Name defines the name of the environment variable which to extract the value from.
   *
   * @schema BackendTrafficPolicySpecTelemetryTracingCustomTagsEnvironment#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecTelemetryTracingCustomTagsEnvironment' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecTelemetryTracingCustomTagsEnvironment(obj: BackendTrafficPolicySpecTelemetryTracingCustomTagsEnvironment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultValue': obj.defaultValue,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Literal adds hard-coded value to each span.
 * It's required when the type is "Literal".
 *
 * @schema BackendTrafficPolicySpecTelemetryTracingCustomTagsLiteral
 */
export interface BackendTrafficPolicySpecTelemetryTracingCustomTagsLiteral {
  /**
   * Value defines the hard-coded value to add to each span.
   *
   * @schema BackendTrafficPolicySpecTelemetryTracingCustomTagsLiteral#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecTelemetryTracingCustomTagsLiteral' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecTelemetryTracingCustomTagsLiteral(obj: BackendTrafficPolicySpecTelemetryTracingCustomTagsLiteral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RequestHeader adds value from request header to each span.
 * It's required when the type is "RequestHeader".
 *
 * @schema BackendTrafficPolicySpecTelemetryTracingCustomTagsRequestHeader
 */
export interface BackendTrafficPolicySpecTelemetryTracingCustomTagsRequestHeader {
  /**
   * DefaultValue defines the default value to use if the request header is not set.
   *
   * @schema BackendTrafficPolicySpecTelemetryTracingCustomTagsRequestHeader#defaultValue
   */
  readonly defaultValue?: string;

  /**
   * Name defines the name of the request header which to extract the value from.
   *
   * @schema BackendTrafficPolicySpecTelemetryTracingCustomTagsRequestHeader#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecTelemetryTracingCustomTagsRequestHeader' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecTelemetryTracingCustomTagsRequestHeader(obj: BackendTrafficPolicySpecTelemetryTracingCustomTagsRequestHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultValue': obj.defaultValue,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type defines the type of custom tag.
 *
 * @schema BackendTrafficPolicySpecTelemetryTracingCustomTagsType
 */
export enum BackendTrafficPolicySpecTelemetryTracingCustomTagsType {
  /** Literal */
  LITERAL = "Literal",
  /** Environment */
  ENVIRONMENT = "Environment",
  /** RequestHeader */
  REQUEST_HEADER = "RequestHeader",
}

/**
 * HeaderMatch defines the match attributes within the HTTP Headers of the request.
 *
 * @schema BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsHeaders
 */
export interface BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsHeaders {
  /**
   * Invert specifies whether the value match result will be inverted.
   * Do not set this field when Type="Distinct", implying matching on any/all unique
   * values within the header.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsHeaders#invert
   */
  readonly invert?: boolean;

  /**
   * Name of the HTTP header.
   * The header name is case-insensitive unless PreserveHeaderCase is set to true.
   * For example, "Foo" and "foo" are considered the same header.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsHeaders#name
   */
  readonly name: string;

  /**
   * Type specifies how to match against the value of the header.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsHeaders#type
   */
  readonly type?: BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsHeadersType;

  /**
   * Value within the HTTP header.
   * Do not set this field when Type="Distinct", implying matching on any/all unique
   * values within the header.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsHeaders#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsHeaders(obj: BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'invert': obj.invert,
    'name': obj.name,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MethodMatch defines the matching criteria for the HTTP method of a request.
 *
 * @schema BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsMethods
 */
export interface BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsMethods {
  /**
   * Invert specifies whether the value match result will be inverted.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsMethods#invert
   */
  readonly invert?: boolean;

  /**
   * Value specifies the HTTP method.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsMethods#value
   */
  readonly value: BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsMethodsValue;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsMethods' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsMethods(obj: BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsMethods | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'invert': obj.invert,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Path is the request path to match.
 * Support Exact, PathPrefix and RegularExpression match types.
 *
 * @schema BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsPath
 */
export interface BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsPath {
  /**
   * Invert specifies whether the value match result will be inverted.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsPath#invert
   */
  readonly invert?: boolean;

  /**
   * Type specifies how to match against the value of the path.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsPath#type
   */
  readonly type?: BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsPathType;

  /**
   * Value specifies the HTTP path.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsPath#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsPath(obj: BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'invert': obj.invert,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SourceCIDR is the client IP Address range to match on.
 *
 * @schema BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsSourceCidr
 */
export interface BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsSourceCidr {
  /**
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsSourceCidr#type
   */
  readonly type?: BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsSourceCidrType;

  /**
   * Value is the IP CIDR that represents the range of Source IP Addresses of the client.
   * These could also be the intermediate addresses through which the request has flown through and is part of the  `X-Forwarded-For` header.
   * For example, `192.168.0.1/32`, `192.168.0.0/24`, `001:db8::/64`.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsSourceCidr#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsSourceCidr' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsSourceCidr(obj: BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsSourceCidr | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Request specifies the number to reduce the rate limit counters
 * on the request path. If this is not specified, the default behavior
 * is to reduce the rate limit counters by 1.
 *
 * When Envoy receives a request that matches the rule, it tries to reduce the
 * rate limit counters by the specified number. If the counter doesn't have
 * enough capacity, the request is rate limited.
 *
 * @schema BackendTrafficPolicySpecRateLimitGlobalRulesCostRequest
 */
export interface BackendTrafficPolicySpecRateLimitGlobalRulesCostRequest {
  /**
   * From specifies where to get the rate limit cost. Currently, only "Number" and "Metadata" are supported.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesCostRequest#from
   */
  readonly from: BackendTrafficPolicySpecRateLimitGlobalRulesCostRequestFrom;

  /**
   * Metadata specifies the per-request metadata to retrieve the usage number from.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesCostRequest#metadata
   */
  readonly metadata?: BackendTrafficPolicySpecRateLimitGlobalRulesCostRequestMetadata;

  /**
   * Number specifies the fixed usage number to reduce the rate limit counters.
   * Using zero can be used to only check the rate limit counters without reducing them.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesCostRequest#number
   */
  readonly number?: number;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitGlobalRulesCostRequest' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitGlobalRulesCostRequest(obj: BackendTrafficPolicySpecRateLimitGlobalRulesCostRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'metadata': toJson_BackendTrafficPolicySpecRateLimitGlobalRulesCostRequestMetadata(obj.metadata),
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Response specifies the number to reduce the rate limit counters
 * after the response is sent back to the client or the request stream is closed.
 *
 * The cost is used to reduce the rate limit counters for the matching requests.
 * Since the reduction happens after the request stream is complete, the rate limit
 * won't be enforced for the current request, but for the subsequent matching requests.
 *
 * This is optional and if not specified, the rate limit counters are not reduced
 * on the response path.
 *
 * Currently, this is only supported for HTTP Global Rate Limits.
 *
 * @schema BackendTrafficPolicySpecRateLimitGlobalRulesCostResponse
 */
export interface BackendTrafficPolicySpecRateLimitGlobalRulesCostResponse {
  /**
   * From specifies where to get the rate limit cost. Currently, only "Number" and "Metadata" are supported.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesCostResponse#from
   */
  readonly from: BackendTrafficPolicySpecRateLimitGlobalRulesCostResponseFrom;

  /**
   * Metadata specifies the per-request metadata to retrieve the usage number from.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesCostResponse#metadata
   */
  readonly metadata?: BackendTrafficPolicySpecRateLimitGlobalRulesCostResponseMetadata;

  /**
   * Number specifies the fixed usage number to reduce the rate limit counters.
   * Using zero can be used to only check the rate limit counters without reducing them.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesCostResponse#number
   */
  readonly number?: number;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitGlobalRulesCostResponse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitGlobalRulesCostResponse(obj: BackendTrafficPolicySpecRateLimitGlobalRulesCostResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'metadata': toJson_BackendTrafficPolicySpecRateLimitGlobalRulesCostResponseMetadata(obj.metadata),
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RateLimitUnit specifies the intervals for setting rate limits.
 * Valid RateLimitUnit values are "Second", "Minute", "Hour", "Day", "Month" and "Year".
 *
 * @schema BackendTrafficPolicySpecRateLimitGlobalRulesLimitUnit
 */
export enum BackendTrafficPolicySpecRateLimitGlobalRulesLimitUnit {
  /** Second */
  SECOND = "Second",
  /** Minute */
  MINUTE = "Minute",
  /** Hour */
  HOUR = "Hour",
  /** Day */
  DAY = "Day",
  /** Month */
  MONTH = "Month",
  /** Year */
  YEAR = "Year",
}

/**
 * HeaderMatch defines the match attributes within the HTTP Headers of the request.
 *
 * @schema BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsHeaders
 */
export interface BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsHeaders {
  /**
   * Invert specifies whether the value match result will be inverted.
   * Do not set this field when Type="Distinct", implying matching on any/all unique
   * values within the header.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsHeaders#invert
   */
  readonly invert?: boolean;

  /**
   * Name of the HTTP header.
   * The header name is case-insensitive unless PreserveHeaderCase is set to true.
   * For example, "Foo" and "foo" are considered the same header.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsHeaders#name
   */
  readonly name: string;

  /**
   * Type specifies how to match against the value of the header.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsHeaders#type
   */
  readonly type?: BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsHeadersType;

  /**
   * Value within the HTTP header.
   * Do not set this field when Type="Distinct", implying matching on any/all unique
   * values within the header.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsHeaders#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsHeaders(obj: BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'invert': obj.invert,
    'name': obj.name,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MethodMatch defines the matching criteria for the HTTP method of a request.
 *
 * @schema BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsMethods
 */
export interface BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsMethods {
  /**
   * Invert specifies whether the value match result will be inverted.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsMethods#invert
   */
  readonly invert?: boolean;

  /**
   * Value specifies the HTTP method.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsMethods#value
   */
  readonly value: BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsMethodsValue;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsMethods' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsMethods(obj: BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsMethods | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'invert': obj.invert,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Path is the request path to match.
 * Support Exact, PathPrefix and RegularExpression match types.
 *
 * @schema BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsPath
 */
export interface BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsPath {
  /**
   * Invert specifies whether the value match result will be inverted.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsPath#invert
   */
  readonly invert?: boolean;

  /**
   * Type specifies how to match against the value of the path.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsPath#type
   */
  readonly type?: BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsPathType;

  /**
   * Value specifies the HTTP path.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsPath#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsPath(obj: BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'invert': obj.invert,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SourceCIDR is the client IP Address range to match on.
 *
 * @schema BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsSourceCidr
 */
export interface BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsSourceCidr {
  /**
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsSourceCidr#type
   */
  readonly type?: BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsSourceCidrType;

  /**
   * Value is the IP CIDR that represents the range of Source IP Addresses of the client.
   * These could also be the intermediate addresses through which the request has flown through and is part of the  `X-Forwarded-For` header.
   * For example, `192.168.0.1/32`, `192.168.0.0/24`, `001:db8::/64`.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsSourceCidr#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsSourceCidr' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsSourceCidr(obj: BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsSourceCidr | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Request specifies the number to reduce the rate limit counters
 * on the request path. If this is not specified, the default behavior
 * is to reduce the rate limit counters by 1.
 *
 * When Envoy receives a request that matches the rule, it tries to reduce the
 * rate limit counters by the specified number. If the counter doesn't have
 * enough capacity, the request is rate limited.
 *
 * @schema BackendTrafficPolicySpecRateLimitLocalRulesCostRequest
 */
export interface BackendTrafficPolicySpecRateLimitLocalRulesCostRequest {
  /**
   * From specifies where to get the rate limit cost. Currently, only "Number" and "Metadata" are supported.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesCostRequest#from
   */
  readonly from: BackendTrafficPolicySpecRateLimitLocalRulesCostRequestFrom;

  /**
   * Metadata specifies the per-request metadata to retrieve the usage number from.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesCostRequest#metadata
   */
  readonly metadata?: BackendTrafficPolicySpecRateLimitLocalRulesCostRequestMetadata;

  /**
   * Number specifies the fixed usage number to reduce the rate limit counters.
   * Using zero can be used to only check the rate limit counters without reducing them.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesCostRequest#number
   */
  readonly number?: number;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitLocalRulesCostRequest' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitLocalRulesCostRequest(obj: BackendTrafficPolicySpecRateLimitLocalRulesCostRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'metadata': toJson_BackendTrafficPolicySpecRateLimitLocalRulesCostRequestMetadata(obj.metadata),
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Response specifies the number to reduce the rate limit counters
 * after the response is sent back to the client or the request stream is closed.
 *
 * The cost is used to reduce the rate limit counters for the matching requests.
 * Since the reduction happens after the request stream is complete, the rate limit
 * won't be enforced for the current request, but for the subsequent matching requests.
 *
 * This is optional and if not specified, the rate limit counters are not reduced
 * on the response path.
 *
 * Currently, this is only supported for HTTP Global Rate Limits.
 *
 * @schema BackendTrafficPolicySpecRateLimitLocalRulesCostResponse
 */
export interface BackendTrafficPolicySpecRateLimitLocalRulesCostResponse {
  /**
   * From specifies where to get the rate limit cost. Currently, only "Number" and "Metadata" are supported.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesCostResponse#from
   */
  readonly from: BackendTrafficPolicySpecRateLimitLocalRulesCostResponseFrom;

  /**
   * Metadata specifies the per-request metadata to retrieve the usage number from.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesCostResponse#metadata
   */
  readonly metadata?: BackendTrafficPolicySpecRateLimitLocalRulesCostResponseMetadata;

  /**
   * Number specifies the fixed usage number to reduce the rate limit counters.
   * Using zero can be used to only check the rate limit counters without reducing them.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesCostResponse#number
   */
  readonly number?: number;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitLocalRulesCostResponse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitLocalRulesCostResponse(obj: BackendTrafficPolicySpecRateLimitLocalRulesCostResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'metadata': toJson_BackendTrafficPolicySpecRateLimitLocalRulesCostResponseMetadata(obj.metadata),
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RateLimitUnit specifies the intervals for setting rate limits.
 * Valid RateLimitUnit values are "Second", "Minute", "Hour", "Day", "Month" and "Year".
 *
 * @schema BackendTrafficPolicySpecRateLimitLocalRulesLimitUnit
 */
export enum BackendTrafficPolicySpecRateLimitLocalRulesLimitUnit {
  /** Second */
  SECOND = "Second",
  /** Minute */
  MINUTE = "Minute",
  /** Hour */
  HOUR = "Hour",
  /** Day */
  DAY = "Day",
  /** Month */
  MONTH = "Month",
  /** Year */
  YEAR = "Year",
}

/**
 * Type specifies how to match against the value of the header.
 *
 * @schema BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsHeadersType
 */
export enum BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsHeadersType {
  /** Exact */
  EXACT = "Exact",
  /** RegularExpression */
  REGULAR_EXPRESSION = "RegularExpression",
  /** Distinct */
  DISTINCT = "Distinct",
}

/**
 * Value specifies the HTTP method.
 *
 * @schema BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsMethodsValue
 */
export enum BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsMethodsValue {
  /** GET */
  GET = "GET",
  /** HEAD */
  HEAD = "HEAD",
  /** POST */
  POST = "POST",
  /** PUT */
  PUT = "PUT",
  /** DELETE */
  DELETE = "DELETE",
  /** CONNECT */
  CONNECT = "CONNECT",
  /** OPTIONS */
  OPTIONS = "OPTIONS",
  /** TRACE */
  TRACE = "TRACE",
  /** PATCH */
  PATCH = "PATCH",
}

/**
 * Type specifies how to match against the value of the path.
 *
 * @schema BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsPathType
 */
export enum BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsPathType {
  /** Exact */
  EXACT = "Exact",
  /** PathPrefix */
  PATH_PREFIX = "PathPrefix",
  /** RegularExpression */
  REGULAR_EXPRESSION = "RegularExpression",
}

/**
 * @schema BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsSourceCidrType
 */
export enum BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsSourceCidrType {
  /** Exact */
  EXACT = "Exact",
  /** Distinct */
  DISTINCT = "Distinct",
}

/**
 * From specifies where to get the rate limit cost. Currently, only "Number" and "Metadata" are supported.
 *
 * @schema BackendTrafficPolicySpecRateLimitGlobalRulesCostRequestFrom
 */
export enum BackendTrafficPolicySpecRateLimitGlobalRulesCostRequestFrom {
  /** Number */
  NUMBER = "Number",
  /** Metadata */
  METADATA = "Metadata",
}

/**
 * Metadata specifies the per-request metadata to retrieve the usage number from.
 *
 * @schema BackendTrafficPolicySpecRateLimitGlobalRulesCostRequestMetadata
 */
export interface BackendTrafficPolicySpecRateLimitGlobalRulesCostRequestMetadata {
  /**
   * Key is the key to retrieve the usage number from the filter metadata.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesCostRequestMetadata#key
   */
  readonly key: string;

  /**
   * Namespace is the namespace of the dynamic metadata.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesCostRequestMetadata#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitGlobalRulesCostRequestMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitGlobalRulesCostRequestMetadata(obj: BackendTrafficPolicySpecRateLimitGlobalRulesCostRequestMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * From specifies where to get the rate limit cost. Currently, only "Number" and "Metadata" are supported.
 *
 * @schema BackendTrafficPolicySpecRateLimitGlobalRulesCostResponseFrom
 */
export enum BackendTrafficPolicySpecRateLimitGlobalRulesCostResponseFrom {
  /** Number */
  NUMBER = "Number",
  /** Metadata */
  METADATA = "Metadata",
}

/**
 * Metadata specifies the per-request metadata to retrieve the usage number from.
 *
 * @schema BackendTrafficPolicySpecRateLimitGlobalRulesCostResponseMetadata
 */
export interface BackendTrafficPolicySpecRateLimitGlobalRulesCostResponseMetadata {
  /**
   * Key is the key to retrieve the usage number from the filter metadata.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesCostResponseMetadata#key
   */
  readonly key: string;

  /**
   * Namespace is the namespace of the dynamic metadata.
   *
   * @schema BackendTrafficPolicySpecRateLimitGlobalRulesCostResponseMetadata#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitGlobalRulesCostResponseMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitGlobalRulesCostResponseMetadata(obj: BackendTrafficPolicySpecRateLimitGlobalRulesCostResponseMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type specifies how to match against the value of the header.
 *
 * @schema BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsHeadersType
 */
export enum BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsHeadersType {
  /** Exact */
  EXACT = "Exact",
  /** RegularExpression */
  REGULAR_EXPRESSION = "RegularExpression",
  /** Distinct */
  DISTINCT = "Distinct",
}

/**
 * Value specifies the HTTP method.
 *
 * @schema BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsMethodsValue
 */
export enum BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsMethodsValue {
  /** GET */
  GET = "GET",
  /** HEAD */
  HEAD = "HEAD",
  /** POST */
  POST = "POST",
  /** PUT */
  PUT = "PUT",
  /** DELETE */
  DELETE = "DELETE",
  /** CONNECT */
  CONNECT = "CONNECT",
  /** OPTIONS */
  OPTIONS = "OPTIONS",
  /** TRACE */
  TRACE = "TRACE",
  /** PATCH */
  PATCH = "PATCH",
}

/**
 * Type specifies how to match against the value of the path.
 *
 * @schema BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsPathType
 */
export enum BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsPathType {
  /** Exact */
  EXACT = "Exact",
  /** PathPrefix */
  PATH_PREFIX = "PathPrefix",
  /** RegularExpression */
  REGULAR_EXPRESSION = "RegularExpression",
}

/**
 * @schema BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsSourceCidrType
 */
export enum BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsSourceCidrType {
  /** Exact */
  EXACT = "Exact",
  /** Distinct */
  DISTINCT = "Distinct",
}

/**
 * From specifies where to get the rate limit cost. Currently, only "Number" and "Metadata" are supported.
 *
 * @schema BackendTrafficPolicySpecRateLimitLocalRulesCostRequestFrom
 */
export enum BackendTrafficPolicySpecRateLimitLocalRulesCostRequestFrom {
  /** Number */
  NUMBER = "Number",
  /** Metadata */
  METADATA = "Metadata",
}

/**
 * Metadata specifies the per-request metadata to retrieve the usage number from.
 *
 * @schema BackendTrafficPolicySpecRateLimitLocalRulesCostRequestMetadata
 */
export interface BackendTrafficPolicySpecRateLimitLocalRulesCostRequestMetadata {
  /**
   * Key is the key to retrieve the usage number from the filter metadata.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesCostRequestMetadata#key
   */
  readonly key: string;

  /**
   * Namespace is the namespace of the dynamic metadata.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesCostRequestMetadata#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitLocalRulesCostRequestMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitLocalRulesCostRequestMetadata(obj: BackendTrafficPolicySpecRateLimitLocalRulesCostRequestMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * From specifies where to get the rate limit cost. Currently, only "Number" and "Metadata" are supported.
 *
 * @schema BackendTrafficPolicySpecRateLimitLocalRulesCostResponseFrom
 */
export enum BackendTrafficPolicySpecRateLimitLocalRulesCostResponseFrom {
  /** Number */
  NUMBER = "Number",
  /** Metadata */
  METADATA = "Metadata",
}

/**
 * Metadata specifies the per-request metadata to retrieve the usage number from.
 *
 * @schema BackendTrafficPolicySpecRateLimitLocalRulesCostResponseMetadata
 */
export interface BackendTrafficPolicySpecRateLimitLocalRulesCostResponseMetadata {
  /**
   * Key is the key to retrieve the usage number from the filter metadata.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesCostResponseMetadata#key
   */
  readonly key: string;

  /**
   * Namespace is the namespace of the dynamic metadata.
   *
   * @schema BackendTrafficPolicySpecRateLimitLocalRulesCostResponseMetadata#namespace
   */
  readonly namespace: string;
}

/**
 * Converts an object of type 'BackendTrafficPolicySpecRateLimitLocalRulesCostResponseMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackendTrafficPolicySpecRateLimitLocalRulesCostResponseMetadata(obj: BackendTrafficPolicySpecRateLimitLocalRulesCostResponseMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * ClientTrafficPolicy allows the user to configure the behavior of the connection
between the downstream client and Envoy Proxy listener.
 *
 * @schema ClientTrafficPolicy
 */
export class ClientTrafficPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClientTrafficPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'gateway.envoyproxy.io/v1alpha1',
    kind: 'ClientTrafficPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "ClientTrafficPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClientTrafficPolicyProps): any {
    return {
      ...ClientTrafficPolicy.GVK,
      ...toJson_ClientTrafficPolicyProps(props),
    };
  }

  /**
   * Defines a "ClientTrafficPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClientTrafficPolicyProps) {
    super(scope, id, {
      ...ClientTrafficPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClientTrafficPolicy.GVK,
      ...toJson_ClientTrafficPolicyProps(resolved),
    };
  }
}

/**
 * ClientTrafficPolicy allows the user to configure the behavior of the connection
 * between the downstream client and Envoy Proxy listener.
 *
 * @schema ClientTrafficPolicy
 */
export interface ClientTrafficPolicyProps {
  /**
   * @schema ClientTrafficPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec defines the desired state of ClientTrafficPolicy.
   *
   * @schema ClientTrafficPolicy#spec
   */
  readonly spec: ClientTrafficPolicySpec;
}

/**
 * Converts an object of type 'ClientTrafficPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicyProps(obj: ClientTrafficPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClientTrafficPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec defines the desired state of ClientTrafficPolicy.
 *
 * @schema ClientTrafficPolicySpec
 */
export interface ClientTrafficPolicySpec {
  /**
   * ClientIPDetectionSettings provides configuration for determining the original client IP address for requests.
   *
   * @schema ClientTrafficPolicySpec#clientIPDetection
   */
  readonly clientIpDetection?: ClientTrafficPolicySpecClientIpDetection;

  /**
   * Connection includes client connection settings.
   *
   * @schema ClientTrafficPolicySpec#connection
   */
  readonly connection?: ClientTrafficPolicySpecConnection;

  /**
   * EnableProxyProtocol interprets the ProxyProtocol header and adds the
   * Client Address into the X-Forwarded-For header.
   * Note Proxy Protocol must be present when this field is set, else the connection
   * is closed.
   *
   * Deprecated: Use ProxyProtocol instead.
   *
   * @schema ClientTrafficPolicySpec#enableProxyProtocol
   */
  readonly enableProxyProtocol?: boolean;

  /**
   * HeaderSettings provides configuration for header management.
   *
   * @schema ClientTrafficPolicySpec#headers
   */
  readonly headers?: ClientTrafficPolicySpecHeaders;

  /**
   * HealthCheck provides configuration for determining whether the HTTP/HTTPS listener is healthy.
   *
   * @schema ClientTrafficPolicySpec#healthCheck
   */
  readonly healthCheck?: ClientTrafficPolicySpecHealthCheck;

  /**
   * HTTP1 provides HTTP/1 configuration on the listener.
   *
   * @schema ClientTrafficPolicySpec#http1
   */
  readonly http1?: ClientTrafficPolicySpecHttp1;

  /**
   * HTTP2 provides HTTP/2 configuration on the listener.
   *
   * @schema ClientTrafficPolicySpec#http2
   */
  readonly http2?: ClientTrafficPolicySpecHttp2;

  /**
   * HTTP3 provides HTTP/3 configuration on the listener.
   *
   * @schema ClientTrafficPolicySpec#http3
   */
  readonly http3?: any;

  /**
   * Path enables managing how the incoming path set by clients can be normalized.
   *
   * @schema ClientTrafficPolicySpec#path
   */
  readonly path?: ClientTrafficPolicySpecPath;

  /**
   * ProxyProtocol configures the Proxy Protocol settings. When configured,
   * the Proxy Protocol header will be interpreted and the Client Address
   * will be added into the X-Forwarded-For header.
   * If both EnableProxyProtocol and ProxyProtocol are set, ProxyProtocol takes precedence.
   *
   * @schema ClientTrafficPolicySpec#proxyProtocol
   */
  readonly proxyProtocol?: ClientTrafficPolicySpecProxyProtocol;

  /**
   * TargetRef is the name of the resource this policy is being attached to.
   * This policy and the TargetRef MUST be in the same namespace for this
   * Policy to have effect
   *
   * Deprecated: use targetRefs/targetSelectors instead
   *
   * @schema ClientTrafficPolicySpec#targetRef
   */
  readonly targetRef?: ClientTrafficPolicySpecTargetRef;

  /**
   * TargetRefs are the names of the Gateway resources this policy
   * is being attached to.
   *
   * @schema ClientTrafficPolicySpec#targetRefs
   */
  readonly targetRefs?: ClientTrafficPolicySpecTargetRefs[];

  /**
   * TargetSelectors allow targeting resources for this policy based on labels
   *
   * @schema ClientTrafficPolicySpec#targetSelectors
   */
  readonly targetSelectors?: ClientTrafficPolicySpecTargetSelectors[];

  /**
   * TcpKeepalive settings associated with the downstream client connection.
   * If defined, sets SO_KEEPALIVE on the listener socket to enable TCP Keepalives.
   * Disabled by default.
   *
   * @schema ClientTrafficPolicySpec#tcpKeepalive
   */
  readonly tcpKeepalive?: ClientTrafficPolicySpecTcpKeepalive;

  /**
   * Timeout settings for the client connections.
   *
   * @schema ClientTrafficPolicySpec#timeout
   */
  readonly timeout?: ClientTrafficPolicySpecTimeout;

  /**
   * TLS settings configure TLS termination settings with the downstream client.
   *
   * @schema ClientTrafficPolicySpec#tls
   */
  readonly tls?: ClientTrafficPolicySpecTls;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpec(obj: ClientTrafficPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientIPDetection': toJson_ClientTrafficPolicySpecClientIpDetection(obj.clientIpDetection),
    'connection': toJson_ClientTrafficPolicySpecConnection(obj.connection),
    'enableProxyProtocol': obj.enableProxyProtocol,
    'headers': toJson_ClientTrafficPolicySpecHeaders(obj.headers),
    'healthCheck': toJson_ClientTrafficPolicySpecHealthCheck(obj.healthCheck),
    'http1': toJson_ClientTrafficPolicySpecHttp1(obj.http1),
    'http2': toJson_ClientTrafficPolicySpecHttp2(obj.http2),
    'http3': obj.http3,
    'path': toJson_ClientTrafficPolicySpecPath(obj.path),
    'proxyProtocol': toJson_ClientTrafficPolicySpecProxyProtocol(obj.proxyProtocol),
    'targetRef': toJson_ClientTrafficPolicySpecTargetRef(obj.targetRef),
    'targetRefs': obj.targetRefs?.map(y => toJson_ClientTrafficPolicySpecTargetRefs(y)),
    'targetSelectors': obj.targetSelectors?.map(y => toJson_ClientTrafficPolicySpecTargetSelectors(y)),
    'tcpKeepalive': toJson_ClientTrafficPolicySpecTcpKeepalive(obj.tcpKeepalive),
    'timeout': toJson_ClientTrafficPolicySpecTimeout(obj.timeout),
    'tls': toJson_ClientTrafficPolicySpecTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientIPDetectionSettings provides configuration for determining the original client IP address for requests.
 *
 * @schema ClientTrafficPolicySpecClientIpDetection
 */
export interface ClientTrafficPolicySpecClientIpDetection {
  /**
   * CustomHeader provides configuration for determining the client IP address for a request based on
   * a trusted custom HTTP header. This uses the custom_header original IP detection extension.
   * Refer to https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/http/original_ip_detection/custom_header/v3/custom_header.proto
   * for more details.
   *
   * @schema ClientTrafficPolicySpecClientIpDetection#customHeader
   */
  readonly customHeader?: ClientTrafficPolicySpecClientIpDetectionCustomHeader;

  /**
   * XForwardedForSettings provides configuration for using X-Forwarded-For headers for determining the client IP address.
   *
   * @schema ClientTrafficPolicySpecClientIpDetection#xForwardedFor
   */
  readonly xForwardedFor?: ClientTrafficPolicySpecClientIpDetectionXForwardedFor;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecClientIpDetection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecClientIpDetection(obj: ClientTrafficPolicySpecClientIpDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customHeader': toJson_ClientTrafficPolicySpecClientIpDetectionCustomHeader(obj.customHeader),
    'xForwardedFor': toJson_ClientTrafficPolicySpecClientIpDetectionXForwardedFor(obj.xForwardedFor),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Connection includes client connection settings.
 *
 * @schema ClientTrafficPolicySpecConnection
 */
export interface ClientTrafficPolicySpecConnection {
  /**
   * BufferLimit provides configuration for the maximum buffer size in bytes for each incoming connection.
   * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
   * For example, 20Mi, 1Gi, 256Ki etc.
   * Note that when the suffix is not provided, the value is interpreted as bytes.
   * Default: 32768 bytes.
   *
   * @schema ClientTrafficPolicySpecConnection#bufferLimit
   */
  readonly bufferLimit?: ClientTrafficPolicySpecConnectionBufferLimit;

  /**
   * ConnectionLimit defines limits related to connections
   *
   * @schema ClientTrafficPolicySpecConnection#connectionLimit
   */
  readonly connectionLimit?: ClientTrafficPolicySpecConnectionConnectionLimit;

  /**
   * MaxAcceptPerSocketEvent provides configuration for the maximum number of connections to accept from the kernel
   * per socket event. If there are more than MaxAcceptPerSocketEvent connections pending accept, connections over
   * this threshold will be accepted in later event loop iterations.
   * Defaults to 1 and can be disabled by setting to 0 for allowing unlimited accepted connections.
   *
   * @default 1 and can be disabled by setting to 0 for allowing unlimited accepted connections.
   * @schema ClientTrafficPolicySpecConnection#maxAcceptPerSocketEvent
   */
  readonly maxAcceptPerSocketEvent?: number;

  /**
   * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each incoming socket.
   * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
   * For example, 20Mi, 1Gi, 256Ki etc.
   * Note that when the suffix is not provided, the value is interpreted as bytes.
   *
   * @schema ClientTrafficPolicySpecConnection#socketBufferLimit
   */
  readonly socketBufferLimit?: ClientTrafficPolicySpecConnectionSocketBufferLimit;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecConnection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecConnection(obj: ClientTrafficPolicySpecConnection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bufferLimit': obj.bufferLimit?.value,
    'connectionLimit': toJson_ClientTrafficPolicySpecConnectionConnectionLimit(obj.connectionLimit),
    'maxAcceptPerSocketEvent': obj.maxAcceptPerSocketEvent,
    'socketBufferLimit': obj.socketBufferLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HeaderSettings provides configuration for header management.
 *
 * @schema ClientTrafficPolicySpecHeaders
 */
export interface ClientTrafficPolicySpecHeaders {
  /**
   * DisableRateLimitHeaders configures Envoy Proxy to omit the "X-RateLimit-" response headers
   * when rate limiting is enabled.
   *
   * @schema ClientTrafficPolicySpecHeaders#disableRateLimitHeaders
   */
  readonly disableRateLimitHeaders?: boolean;

  /**
   * EarlyRequestHeaders defines settings for early request header modification, before envoy performs
   * routing, tracing and built-in header manipulation.
   *
   * @schema ClientTrafficPolicySpecHeaders#earlyRequestHeaders
   */
  readonly earlyRequestHeaders?: ClientTrafficPolicySpecHeadersEarlyRequestHeaders;

  /**
   * EnableEnvoyHeaders configures Envoy Proxy to add the "X-Envoy-" headers to requests
   * and responses.
   *
   * @schema ClientTrafficPolicySpecHeaders#enableEnvoyHeaders
   */
  readonly enableEnvoyHeaders?: boolean;

  /**
   * LateResponseHeaders defines settings for global response header modification.
   *
   * @schema ClientTrafficPolicySpecHeaders#lateResponseHeaders
   */
  readonly lateResponseHeaders?: ClientTrafficPolicySpecHeadersLateResponseHeaders;

  /**
   * PreserveXRequestID configures Envoy to keep the X-Request-ID header if passed for a request that is edge
   * (Edge request is the request from external clients to front Envoy) and not reset it, which is the current Envoy behaviour.
   * Defaults to false and cannot be combined with RequestID.
   * Deprecated: use RequestID=PreserveOrGenerate instead
   *
   * @default false and cannot be combined with RequestID.
   * @schema ClientTrafficPolicySpecHeaders#preserveXRequestID
   */
  readonly preserveXRequestId?: boolean;

  /**
   * RequestID configures Envoy's behavior for handling the `X-Request-ID` header.
   * When omitted default behavior is `Generate` which builds the `X-Request-ID` for every request
   * and ignores pre-existing values from the edge.
   * (An "edge request" refers to a request from an external client to the Envoy entrypoint.)
   *
   * @schema ClientTrafficPolicySpecHeaders#requestID
   */
  readonly requestId?: ClientTrafficPolicySpecHeadersRequestId;

  /**
   * WithUnderscoresAction configures the action to take when an HTTP header with underscores
   * is encountered. The default action is to reject the request.
   *
   * @schema ClientTrafficPolicySpecHeaders#withUnderscoresAction
   */
  readonly withUnderscoresAction?: ClientTrafficPolicySpecHeadersWithUnderscoresAction;

  /**
   * XForwardedClientCert configures how Envoy Proxy handle the x-forwarded-client-cert (XFCC) HTTP header.
   *
   * x-forwarded-client-cert (XFCC) is an HTTP header used to forward the certificate
   * information of part or all of the clients or proxies that a request has flowed through,
   * on its way from the client to the server.
   *
   * Envoy proxy may choose to sanitize/append/forward the XFCC header before proxying the request.
   *
   * If not set, the default behavior is sanitizing the XFCC header.
   *
   * @schema ClientTrafficPolicySpecHeaders#xForwardedClientCert
   */
  readonly xForwardedClientCert?: ClientTrafficPolicySpecHeadersXForwardedClientCert;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecHeaders(obj: ClientTrafficPolicySpecHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableRateLimitHeaders': obj.disableRateLimitHeaders,
    'earlyRequestHeaders': toJson_ClientTrafficPolicySpecHeadersEarlyRequestHeaders(obj.earlyRequestHeaders),
    'enableEnvoyHeaders': obj.enableEnvoyHeaders,
    'lateResponseHeaders': toJson_ClientTrafficPolicySpecHeadersLateResponseHeaders(obj.lateResponseHeaders),
    'preserveXRequestID': obj.preserveXRequestId,
    'requestID': obj.requestId,
    'withUnderscoresAction': obj.withUnderscoresAction,
    'xForwardedClientCert': toJson_ClientTrafficPolicySpecHeadersXForwardedClientCert(obj.xForwardedClientCert),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HealthCheck provides configuration for determining whether the HTTP/HTTPS listener is healthy.
 *
 * @schema ClientTrafficPolicySpecHealthCheck
 */
export interface ClientTrafficPolicySpecHealthCheck {
  /**
   * Path specifies the HTTP path to match on for health check requests.
   *
   * @schema ClientTrafficPolicySpecHealthCheck#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecHealthCheck(obj: ClientTrafficPolicySpecHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP1 provides HTTP/1 configuration on the listener.
 *
 * @schema ClientTrafficPolicySpecHttp1
 */
export interface ClientTrafficPolicySpecHttp1 {
  /**
   * DisableSafeMaxConnectionDuration controls the close behavior for HTTP/1 connections.
   * By default, connection closure is delayed until the next request arrives after maxConnectionDuration is exceeded.
   * It then adds a Connection: close header and gracefully closes the connection after the response completes.
   * When set to true (disabled), Envoy uses its default drain behavior, closing the connection shortly after maxConnectionDuration elapses.
   * Has no effect unless maxConnectionDuration is set.
   *
   * @schema ClientTrafficPolicySpecHttp1#disableSafeMaxConnectionDuration
   */
  readonly disableSafeMaxConnectionDuration?: boolean;

  /**
   * EnableTrailers defines if HTTP/1 trailers should be proxied by Envoy.
   *
   * @schema ClientTrafficPolicySpecHttp1#enableTrailers
   */
  readonly enableTrailers?: boolean;

  /**
   * HTTP10 turns on support for HTTP/1.0 and HTTP/0.9 requests.
   *
   * @schema ClientTrafficPolicySpecHttp1#http10
   */
  readonly http10?: ClientTrafficPolicySpecHttp1Http10;

  /**
   * PreserveHeaderCase defines if Envoy should preserve the letter case of headers.
   * By default, Envoy will lowercase all the headers.
   *
   * @schema ClientTrafficPolicySpecHttp1#preserveHeaderCase
   */
  readonly preserveHeaderCase?: boolean;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecHttp1' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecHttp1(obj: ClientTrafficPolicySpecHttp1 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableSafeMaxConnectionDuration': obj.disableSafeMaxConnectionDuration,
    'enableTrailers': obj.enableTrailers,
    'http10': toJson_ClientTrafficPolicySpecHttp1Http10(obj.http10),
    'preserveHeaderCase': obj.preserveHeaderCase,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP2 provides HTTP/2 configuration on the listener.
 *
 * @schema ClientTrafficPolicySpecHttp2
 */
export interface ClientTrafficPolicySpecHttp2 {
  /**
   * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
   * If not set, the default value is 1 MiB.
   *
   * @schema ClientTrafficPolicySpecHttp2#initialConnectionWindowSize
   */
  readonly initialConnectionWindowSize?: ClientTrafficPolicySpecHttp2InitialConnectionWindowSize;

  /**
   * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
   * If not set, the default value is 64 KiB(64*1024).
   *
   * @schema ClientTrafficPolicySpecHttp2#initialStreamWindowSize
   */
  readonly initialStreamWindowSize?: ClientTrafficPolicySpecHttp2InitialStreamWindowSize;

  /**
   * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
   * If not set, the default value is 100.
   *
   * @schema ClientTrafficPolicySpecHttp2#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
   * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
   * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
   * Default: TerminateConnection
   *
   * @schema ClientTrafficPolicySpecHttp2#onInvalidMessage
   */
  readonly onInvalidMessage?: string;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecHttp2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecHttp2(obj: ClientTrafficPolicySpecHttp2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'initialConnectionWindowSize': obj.initialConnectionWindowSize?.value,
    'initialStreamWindowSize': obj.initialStreamWindowSize?.value,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'onInvalidMessage': obj.onInvalidMessage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Path enables managing how the incoming path set by clients can be normalized.
 *
 * @schema ClientTrafficPolicySpecPath
 */
export interface ClientTrafficPolicySpecPath {
  /**
   * DisableMergeSlashes allows disabling the default configuration of merging adjacent
   * slashes in the path.
   * Note that slash merging is not part of the HTTP spec and is provided for convenience.
   *
   * @schema ClientTrafficPolicySpecPath#disableMergeSlashes
   */
  readonly disableMergeSlashes?: boolean;

  /**
   * EscapedSlashesAction determines how %2f, %2F, %5c, or %5C sequences in the path URI
   * should be handled.
   * The default is UnescapeAndRedirect.
   *
   * @schema ClientTrafficPolicySpecPath#escapedSlashesAction
   */
  readonly escapedSlashesAction?: ClientTrafficPolicySpecPathEscapedSlashesAction;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecPath(obj: ClientTrafficPolicySpecPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableMergeSlashes': obj.disableMergeSlashes,
    'escapedSlashesAction': obj.escapedSlashesAction,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProxyProtocol configures the Proxy Protocol settings. When configured,
 * the Proxy Protocol header will be interpreted and the Client Address
 * will be added into the X-Forwarded-For header.
 * If both EnableProxyProtocol and ProxyProtocol are set, ProxyProtocol takes precedence.
 *
 * @schema ClientTrafficPolicySpecProxyProtocol
 */
export interface ClientTrafficPolicySpecProxyProtocol {
  /**
   * Optional allows requests without a Proxy Protocol header to be proxied.
   * If set to true, the listener will accept requests without a Proxy Protocol header.
   * If set to false, the listener will reject requests without a Proxy Protocol header.
   * If not set, the default behavior is to reject requests without a Proxy Protocol header.
   * Warning: Optional breaks conformance with the specification. Only enable if ALL traffic to the listener comes from a trusted source.
   * For more information on security implications, see haproxy.org/download/2.1/doc/proxy-protocol.txt
   *
   * @schema ClientTrafficPolicySpecProxyProtocol#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecProxyProtocol' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecProxyProtocol(obj: ClientTrafficPolicySpecProxyProtocol | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TargetRef is the name of the resource this policy is being attached to.
 * This policy and the TargetRef MUST be in the same namespace for this
 * Policy to have effect
 *
 * Deprecated: use targetRefs/targetSelectors instead
 *
 * @schema ClientTrafficPolicySpecTargetRef
 */
export interface ClientTrafficPolicySpecTargetRef {
  /**
   * Group is the group of the target resource.
   *
   * @schema ClientTrafficPolicySpecTargetRef#group
   */
  readonly group: string;

  /**
   * Kind is kind of the target resource.
   *
   * @schema ClientTrafficPolicySpecTargetRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of the target resource.
   *
   * @schema ClientTrafficPolicySpecTargetRef#name
   */
  readonly name: string;

  /**
   * SectionName is the name of a section within the target resource. When
   * unspecified, this targetRef targets the entire resource. In the following
   * resources, SectionName is interpreted as the following:
   *
   * * Gateway: Listener name
   * * HTTPRoute: HTTPRouteRule name
   * * Service: Port name
   *
   * If a SectionName is specified, but does not exist on the targeted object,
   * the Policy must fail to attach, and the policy implementation should record
   * a `ResolvedRefs` or similar Condition in the Policy's status.
   *
   * @schema ClientTrafficPolicySpecTargetRef#sectionName
   */
  readonly sectionName?: string;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecTargetRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecTargetRef(obj: ClientTrafficPolicySpecTargetRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'sectionName': obj.sectionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalPolicyTargetReferenceWithSectionName identifies an API object to apply a
 * direct policy to. This should be used as part of Policy resources that can
 * target single resources. For more information on how this policy attachment
 * mode works, and a sample Policy resource, refer to the policy attachment
 * documentation for Gateway API.
 *
 * Note: This should only be used for direct policy attachment when references
 * to SectionName are actually needed. In all other cases,
 * LocalPolicyTargetReference should be used.
 *
 * @schema ClientTrafficPolicySpecTargetRefs
 */
export interface ClientTrafficPolicySpecTargetRefs {
  /**
   * Group is the group of the target resource.
   *
   * @schema ClientTrafficPolicySpecTargetRefs#group
   */
  readonly group: string;

  /**
   * Kind is kind of the target resource.
   *
   * @schema ClientTrafficPolicySpecTargetRefs#kind
   */
  readonly kind: string;

  /**
   * Name is the name of the target resource.
   *
   * @schema ClientTrafficPolicySpecTargetRefs#name
   */
  readonly name: string;

  /**
   * SectionName is the name of a section within the target resource. When
   * unspecified, this targetRef targets the entire resource. In the following
   * resources, SectionName is interpreted as the following:
   *
   * * Gateway: Listener name
   * * HTTPRoute: HTTPRouteRule name
   * * Service: Port name
   *
   * If a SectionName is specified, but does not exist on the targeted object,
   * the Policy must fail to attach, and the policy implementation should record
   * a `ResolvedRefs` or similar Condition in the Policy's status.
   *
   * @schema ClientTrafficPolicySpecTargetRefs#sectionName
   */
  readonly sectionName?: string;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecTargetRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecTargetRefs(obj: ClientTrafficPolicySpecTargetRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'sectionName': obj.sectionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClientTrafficPolicySpecTargetSelectors
 */
export interface ClientTrafficPolicySpecTargetSelectors {
  /**
   * Group is the group that this selector targets. Defaults to gateway.networking.k8s.io
   *
   * @default gateway.networking.k8s.io
   * @schema ClientTrafficPolicySpecTargetSelectors#group
   */
  readonly group?: string;

  /**
   * Kind is the resource kind that this selector targets.
   *
   * @schema ClientTrafficPolicySpecTargetSelectors#kind
   */
  readonly kind: string;

  /**
   * MatchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClientTrafficPolicySpecTargetSelectors#matchExpressions
   */
  readonly matchExpressions?: ClientTrafficPolicySpecTargetSelectorsMatchExpressions[];

  /**
   * MatchLabels are the set of label selectors for identifying the targeted resource
   *
   * @schema ClientTrafficPolicySpecTargetSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecTargetSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecTargetSelectors(obj: ClientTrafficPolicySpecTargetSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClientTrafficPolicySpecTargetSelectorsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TcpKeepalive settings associated with the downstream client connection.
 * If defined, sets SO_KEEPALIVE on the listener socket to enable TCP Keepalives.
 * Disabled by default.
 *
 * @schema ClientTrafficPolicySpecTcpKeepalive
 */
export interface ClientTrafficPolicySpecTcpKeepalive {
  /**
   * The duration a connection needs to be idle before keep-alive
   * probes start being sent.
   * The duration format is
   * Defaults to `7200s`.
   *
   * @default 7200s`.
   * @schema ClientTrafficPolicySpecTcpKeepalive#idleTime
   */
  readonly idleTime?: string;

  /**
   * The duration between keep-alive probes.
   * Defaults to `75s`.
   *
   * @default 75s`.
   * @schema ClientTrafficPolicySpecTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * The total number of unacknowledged probes to send before deciding
   * the connection is dead.
   * Defaults to 9.
   *
   * @default 9.
   * @schema ClientTrafficPolicySpecTcpKeepalive#probes
   */
  readonly probes?: number;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecTcpKeepalive(obj: ClientTrafficPolicySpecTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idleTime': obj.idleTime,
    'interval': obj.interval,
    'probes': obj.probes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for the client connections.
 *
 * @schema ClientTrafficPolicySpecTimeout
 */
export interface ClientTrafficPolicySpecTimeout {
  /**
   * Timeout settings for HTTP.
   *
   * @schema ClientTrafficPolicySpecTimeout#http
   */
  readonly http?: ClientTrafficPolicySpecTimeoutHttp;

  /**
   * Timeout settings for TCP.
   *
   * @schema ClientTrafficPolicySpecTimeout#tcp
   */
  readonly tcp?: ClientTrafficPolicySpecTimeoutTcp;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecTimeout' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecTimeout(obj: ClientTrafficPolicySpecTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_ClientTrafficPolicySpecTimeoutHttp(obj.http),
    'tcp': toJson_ClientTrafficPolicySpecTimeoutTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS settings configure TLS termination settings with the downstream client.
 *
 * @schema ClientTrafficPolicySpecTls
 */
export interface ClientTrafficPolicySpecTls {
  /**
   * ALPNProtocols supplies the list of ALPN protocols that should be
   * exposed by the listener or used by the proxy to connect to the backend.
   * Defaults:
   * 1. HTTPS Routes: h2 and http/1.1 are enabled in listener context.
   * 2. Other Routes: ALPN is disabled.
   * 3. Backends: proxy uses the appropriate ALPN options for the backend protocol.
   * When an empty list is provided, the ALPN TLS extension is disabled.
   *
   * Defaults to [h2, http/1.1] if not specified.
   *
   * Typical Supported values are:
   * - http/1.0
   * - http/1.1
   * - h2
   *
   * @default h2, http/1.1] if not specified.
   * @schema ClientTrafficPolicySpecTls#alpnProtocols
   */
  readonly alpnProtocols?: string[];

  /**
   * Ciphers specifies the set of cipher suites supported when
   * negotiating TLS 1.0 - 1.2. This setting has no effect for TLS 1.3.
   * In non-FIPS Envoy Proxy builds the default cipher list is:
   * - [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
   * - [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
   * - ECDHE-ECDSA-AES256-GCM-SHA384
   * - ECDHE-RSA-AES256-GCM-SHA384
   * In builds using BoringSSL FIPS the default cipher list is:
   * - ECDHE-ECDSA-AES128-GCM-SHA256
   * - ECDHE-RSA-AES128-GCM-SHA256
   * - ECDHE-ECDSA-AES256-GCM-SHA384
   * - ECDHE-RSA-AES256-GCM-SHA384
   *
   * @schema ClientTrafficPolicySpecTls#ciphers
   */
  readonly ciphers?: string[];

  /**
   * ClientValidation specifies the configuration to validate the client
   * initiating the TLS connection to the Gateway listener.
   *
   * @schema ClientTrafficPolicySpecTls#clientValidation
   */
  readonly clientValidation?: ClientTrafficPolicySpecTlsClientValidation;

  /**
   * ECDHCurves specifies the set of supported ECDH curves.
   * In non-FIPS Envoy Proxy builds the default curves are:
   * - X25519
   * - P-256
   * In builds using BoringSSL FIPS the default curve is:
   * - P-256
   *
   * @schema ClientTrafficPolicySpecTls#ecdhCurves
   */
  readonly ecdhCurves?: string[];

  /**
   * Max specifies the maximal TLS protocol version to allow
   * The default is TLS 1.3 if this is not specified.
   *
   * @schema ClientTrafficPolicySpecTls#maxVersion
   */
  readonly maxVersion?: ClientTrafficPolicySpecTlsMaxVersion;

  /**
   * Min specifies the minimal TLS protocol version to allow.
   * The default is TLS 1.2 if this is not specified.
   *
   * @schema ClientTrafficPolicySpecTls#minVersion
   */
  readonly minVersion?: ClientTrafficPolicySpecTlsMinVersion;

  /**
   * Session defines settings related to TLS session management.
   *
   * @schema ClientTrafficPolicySpecTls#session
   */
  readonly session?: ClientTrafficPolicySpecTlsSession;

  /**
   * SignatureAlgorithms specifies which signature algorithms the listener should
   * support.
   *
   * @schema ClientTrafficPolicySpecTls#signatureAlgorithms
   */
  readonly signatureAlgorithms?: string[];
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecTls(obj: ClientTrafficPolicySpecTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alpnProtocols': obj.alpnProtocols?.map(y => y),
    'ciphers': obj.ciphers?.map(y => y),
    'clientValidation': toJson_ClientTrafficPolicySpecTlsClientValidation(obj.clientValidation),
    'ecdhCurves': obj.ecdhCurves?.map(y => y),
    'maxVersion': obj.maxVersion,
    'minVersion': obj.minVersion,
    'session': toJson_ClientTrafficPolicySpecTlsSession(obj.session),
    'signatureAlgorithms': obj.signatureAlgorithms?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CustomHeader provides configuration for determining the client IP address for a request based on
 * a trusted custom HTTP header. This uses the custom_header original IP detection extension.
 * Refer to https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/http/original_ip_detection/custom_header/v3/custom_header.proto
 * for more details.
 *
 * @schema ClientTrafficPolicySpecClientIpDetectionCustomHeader
 */
export interface ClientTrafficPolicySpecClientIpDetectionCustomHeader {
  /**
   * FailClosed is a switch used to control the flow of traffic when client IP detection
   * fails. If set to true, the listener will respond with 403 Forbidden when the client
   * IP address cannot be determined.
   *
   * @schema ClientTrafficPolicySpecClientIpDetectionCustomHeader#failClosed
   */
  readonly failClosed?: boolean;

  /**
   * Name of the header containing the original downstream remote address, if present.
   *
   * @schema ClientTrafficPolicySpecClientIpDetectionCustomHeader#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecClientIpDetectionCustomHeader' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecClientIpDetectionCustomHeader(obj: ClientTrafficPolicySpecClientIpDetectionCustomHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failClosed': obj.failClosed,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * XForwardedForSettings provides configuration for using X-Forwarded-For headers for determining the client IP address.
 *
 * @schema ClientTrafficPolicySpecClientIpDetectionXForwardedFor
 */
export interface ClientTrafficPolicySpecClientIpDetectionXForwardedFor {
  /**
   * NumTrustedHops specifies how many trusted hops to count from the rightmost side of
   * the X-Forwarded-For (XFF) header when determining the original client’s IP address.
   *
   * If NumTrustedHops is set to N, the client IP is taken from the Nth address from the
   * right end of the XFF header.
   *
   * Example:
   * XFF = "203.0.113.128, 203.0.113.10, 203.0.113.1"
   * NumTrustedHops = 2
   * → Trusted client address = 203.0.113.10
   *
   * Only one of NumTrustedHops or TrustedCIDRs should be configured.
   *
   * @schema ClientTrafficPolicySpecClientIpDetectionXForwardedFor#numTrustedHops
   */
  readonly numTrustedHops?: number;

  /**
   * TrustedCIDRs is a list of CIDR ranges to trust when evaluating
   * the remote IP address to determine the original client’s IP address.
   * When the remote IP address matches a trusted CIDR and the x-forwarded-for header was sent,
   * each entry in the x-forwarded-for header is evaluated from right to left
   * and the first public non-trusted address is used as the original client address.
   * If all addresses in x-forwarded-for are within the trusted list, the first (leftmost) entry is used.
   * Only one of NumTrustedHops and TrustedCIDRs must be set.
   *
   * @schema ClientTrafficPolicySpecClientIpDetectionXForwardedFor#trustedCIDRs
   */
  readonly trustedCidRs?: string[];
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecClientIpDetectionXForwardedFor' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecClientIpDetectionXForwardedFor(obj: ClientTrafficPolicySpecClientIpDetectionXForwardedFor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'numTrustedHops': obj.numTrustedHops,
    'trustedCIDRs': obj.trustedCidRs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BufferLimit provides configuration for the maximum buffer size in bytes for each incoming connection.
 * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note that when the suffix is not provided, the value is interpreted as bytes.
 * Default: 32768 bytes.
 *
 * @schema ClientTrafficPolicySpecConnectionBufferLimit
 */
export class ClientTrafficPolicySpecConnectionBufferLimit {
  public static fromNumber(value: number): ClientTrafficPolicySpecConnectionBufferLimit {
    return new ClientTrafficPolicySpecConnectionBufferLimit(value);
  }
  public static fromString(value: string): ClientTrafficPolicySpecConnectionBufferLimit {
    return new ClientTrafficPolicySpecConnectionBufferLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ConnectionLimit defines limits related to connections
 *
 * @schema ClientTrafficPolicySpecConnectionConnectionLimit
 */
export interface ClientTrafficPolicySpecConnectionConnectionLimit {
  /**
   * CloseDelay defines the delay to use before closing connections that are rejected
   * once the limit value is reached.
   * Default: none.
   *
   * @schema ClientTrafficPolicySpecConnectionConnectionLimit#closeDelay
   */
  readonly closeDelay?: string;

  /**
   * MaxConnectionDuration is the maximum amount of time a connection can remain established
   * (usually via TCP/HTTP Keepalive packets) before being drained and/or closed.
   * If not specified, there is no limit.
   *
   * @schema ClientTrafficPolicySpecConnectionConnectionLimit#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * MaxRequestsPerConnection defines the maximum number of requests allowed over a single connection.
   * If not specified, there is no limit. Setting this parameter to 1 will effectively disable keep alive.
   *
   * @schema ClientTrafficPolicySpecConnectionConnectionLimit#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * MaxStreamDuration is the maximum amount of time to keep alive an http stream. When the limit is reached
   * the stream will be reset independent of any other timeouts. If not specified, no value is set.
   *
   * @schema ClientTrafficPolicySpecConnectionConnectionLimit#maxStreamDuration
   */
  readonly maxStreamDuration?: string;

  /**
   * Value of the maximum concurrent connections limit.
   * When the limit is reached, incoming connections will be closed after the CloseDelay duration.
   *
   * @schema ClientTrafficPolicySpecConnectionConnectionLimit#value
   */
  readonly value: number;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecConnectionConnectionLimit' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecConnectionConnectionLimit(obj: ClientTrafficPolicySpecConnectionConnectionLimit | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'closeDelay': obj.closeDelay,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxStreamDuration': obj.maxStreamDuration,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each incoming socket.
 * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note that when the suffix is not provided, the value is interpreted as bytes.
 *
 * @schema ClientTrafficPolicySpecConnectionSocketBufferLimit
 */
export class ClientTrafficPolicySpecConnectionSocketBufferLimit {
  public static fromNumber(value: number): ClientTrafficPolicySpecConnectionSocketBufferLimit {
    return new ClientTrafficPolicySpecConnectionSocketBufferLimit(value);
  }
  public static fromString(value: string): ClientTrafficPolicySpecConnectionSocketBufferLimit {
    return new ClientTrafficPolicySpecConnectionSocketBufferLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * EarlyRequestHeaders defines settings for early request header modification, before envoy performs
 * routing, tracing and built-in header manipulation.
 *
 * @schema ClientTrafficPolicySpecHeadersEarlyRequestHeaders
 */
export interface ClientTrafficPolicySpecHeadersEarlyRequestHeaders {
  /**
   * Add adds the given header(s) (name, value) to the request
   * before the action. It appends to any existing values associated
   * with the header name.
   *
   * Input:
   * GET /foo HTTP/1.1
   * my-header: foo
   *
   * Config:
   * add:
   * - name: "my-header"
   * value: "bar,baz"
   *
   * Output:
   * GET /foo HTTP/1.1
   * my-header: foo,bar,baz
   *
   * @schema ClientTrafficPolicySpecHeadersEarlyRequestHeaders#add
   */
  readonly add?: ClientTrafficPolicySpecHeadersEarlyRequestHeadersAdd[];

  /**
   * Remove the given header(s) from the HTTP request before the action. The
   * value of Remove is a list of HTTP header names. Note that the header
   * names are case-insensitive (see
   * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
   *
   * Input:
   * GET /foo HTTP/1.1
   * my-header1: foo
   * my-header2: bar
   * my-header3: baz
   *
   * Config:
   * remove: ["my-header1", "my-header3"]
   *
   * Output:
   * GET /foo HTTP/1.1
   * my-header2: bar
   *
   * @schema ClientTrafficPolicySpecHeadersEarlyRequestHeaders#remove
   */
  readonly remove?: string[];

  /**
   * Set overwrites the request with the given header (name, value)
   * before the action.
   *
   * Input:
   * GET /foo HTTP/1.1
   * my-header: foo
   *
   * Config:
   * set:
   * - name: "my-header"
   * value: "bar"
   *
   * Output:
   * GET /foo HTTP/1.1
   * my-header: bar
   *
   * @schema ClientTrafficPolicySpecHeadersEarlyRequestHeaders#set
   */
  readonly set?: ClientTrafficPolicySpecHeadersEarlyRequestHeadersSet[];
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecHeadersEarlyRequestHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecHeadersEarlyRequestHeaders(obj: ClientTrafficPolicySpecHeadersEarlyRequestHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => toJson_ClientTrafficPolicySpecHeadersEarlyRequestHeadersAdd(y)),
    'remove': obj.remove?.map(y => y),
    'set': obj.set?.map(y => toJson_ClientTrafficPolicySpecHeadersEarlyRequestHeadersSet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LateResponseHeaders defines settings for global response header modification.
 *
 * @schema ClientTrafficPolicySpecHeadersLateResponseHeaders
 */
export interface ClientTrafficPolicySpecHeadersLateResponseHeaders {
  /**
   * Add adds the given header(s) (name, value) to the request
   * before the action. It appends to any existing values associated
   * with the header name.
   *
   * Input:
   * GET /foo HTTP/1.1
   * my-header: foo
   *
   * Config:
   * add:
   * - name: "my-header"
   * value: "bar,baz"
   *
   * Output:
   * GET /foo HTTP/1.1
   * my-header: foo,bar,baz
   *
   * @schema ClientTrafficPolicySpecHeadersLateResponseHeaders#add
   */
  readonly add?: ClientTrafficPolicySpecHeadersLateResponseHeadersAdd[];

  /**
   * Remove the given header(s) from the HTTP request before the action. The
   * value of Remove is a list of HTTP header names. Note that the header
   * names are case-insensitive (see
   * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
   *
   * Input:
   * GET /foo HTTP/1.1
   * my-header1: foo
   * my-header2: bar
   * my-header3: baz
   *
   * Config:
   * remove: ["my-header1", "my-header3"]
   *
   * Output:
   * GET /foo HTTP/1.1
   * my-header2: bar
   *
   * @schema ClientTrafficPolicySpecHeadersLateResponseHeaders#remove
   */
  readonly remove?: string[];

  /**
   * Set overwrites the request with the given header (name, value)
   * before the action.
   *
   * Input:
   * GET /foo HTTP/1.1
   * my-header: foo
   *
   * Config:
   * set:
   * - name: "my-header"
   * value: "bar"
   *
   * Output:
   * GET /foo HTTP/1.1
   * my-header: bar
   *
   * @schema ClientTrafficPolicySpecHeadersLateResponseHeaders#set
   */
  readonly set?: ClientTrafficPolicySpecHeadersLateResponseHeadersSet[];
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecHeadersLateResponseHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecHeadersLateResponseHeaders(obj: ClientTrafficPolicySpecHeadersLateResponseHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => toJson_ClientTrafficPolicySpecHeadersLateResponseHeadersAdd(y)),
    'remove': obj.remove?.map(y => y),
    'set': obj.set?.map(y => toJson_ClientTrafficPolicySpecHeadersLateResponseHeadersSet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RequestID configures Envoy's behavior for handling the `X-Request-ID` header.
 * When omitted default behavior is `Generate` which builds the `X-Request-ID` for every request
 * and ignores pre-existing values from the edge.
 * (An "edge request" refers to a request from an external client to the Envoy entrypoint.)
 *
 * @schema ClientTrafficPolicySpecHeadersRequestId
 */
export enum ClientTrafficPolicySpecHeadersRequestId {
  /** PreserveOrGenerate */
  PRESERVE_OR_GENERATE = "PreserveOrGenerate",
  /** Preserve */
  PRESERVE = "Preserve",
  /** Generate */
  GENERATE = "Generate",
  /** Disable */
  DISABLE = "Disable",
}

/**
 * WithUnderscoresAction configures the action to take when an HTTP header with underscores
 * is encountered. The default action is to reject the request.
 *
 * @schema ClientTrafficPolicySpecHeadersWithUnderscoresAction
 */
export enum ClientTrafficPolicySpecHeadersWithUnderscoresAction {
  /** Allow */
  ALLOW = "Allow",
  /** RejectRequest */
  REJECT_REQUEST = "RejectRequest",
  /** DropHeader */
  DROP_HEADER = "DropHeader",
}

/**
 * XForwardedClientCert configures how Envoy Proxy handle the x-forwarded-client-cert (XFCC) HTTP header.
 *
 * x-forwarded-client-cert (XFCC) is an HTTP header used to forward the certificate
 * information of part or all of the clients or proxies that a request has flowed through,
 * on its way from the client to the server.
 *
 * Envoy proxy may choose to sanitize/append/forward the XFCC header before proxying the request.
 *
 * If not set, the default behavior is sanitizing the XFCC header.
 *
 * @schema ClientTrafficPolicySpecHeadersXForwardedClientCert
 */
export interface ClientTrafficPolicySpecHeadersXForwardedClientCert {
  /**
   * CertDetailsToAdd specifies the fields in the client certificate to be forwarded in the XFCC header.
   *
   * Hash(the SHA 256 digest of the current client certificate) and By(the Subject Alternative Name)
   * are always included if the client certificate is forwarded.
   *
   * This field is only applicable when the mode is set to `AppendForward` or
   * `SanitizeSet` and the client connection is mTLS.
   *
   * @schema ClientTrafficPolicySpecHeadersXForwardedClientCert#certDetailsToAdd
   */
  readonly certDetailsToAdd?: ClientTrafficPolicySpecHeadersXForwardedClientCertCertDetailsToAdd[];

  /**
   * Mode defines how XFCC header is handled by Envoy Proxy.
   * If not set, the default mode is `Sanitize`.
   *
   * @schema ClientTrafficPolicySpecHeadersXForwardedClientCert#mode
   */
  readonly mode?: ClientTrafficPolicySpecHeadersXForwardedClientCertMode;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecHeadersXForwardedClientCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecHeadersXForwardedClientCert(obj: ClientTrafficPolicySpecHeadersXForwardedClientCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certDetailsToAdd': obj.certDetailsToAdd?.map(y => y),
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP10 turns on support for HTTP/1.0 and HTTP/0.9 requests.
 *
 * @schema ClientTrafficPolicySpecHttp1Http10
 */
export interface ClientTrafficPolicySpecHttp1Http10 {
  /**
   * UseDefaultHost specifies whether a default Host header should be injected
   * into HTTP/1.0 requests that do not include one.
   *
   * When set to true, Envoy Gateway injects the hostname associated with the
   * listener or route into the request, in the following order:
   *
   * 1. If the targeted listener has a non-wildcard hostname, use that hostname.
   * 2. If there is exactly one HTTPRoute with a non-wildcard hostname under
   * the targeted listener, use that hostname.
   *
   * Note: Setting this field to true without a non-wildcard hostname makes the
   * ClientTrafficPolicy invalid.
   *
   * @schema ClientTrafficPolicySpecHttp1Http10#useDefaultHost
   */
  readonly useDefaultHost?: boolean;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecHttp1Http10' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecHttp1Http10(obj: ClientTrafficPolicySpecHttp1Http10 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'useDefaultHost': obj.useDefaultHost,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
 * If not set, the default value is 1 MiB.
 *
 * @schema ClientTrafficPolicySpecHttp2InitialConnectionWindowSize
 */
export class ClientTrafficPolicySpecHttp2InitialConnectionWindowSize {
  public static fromNumber(value: number): ClientTrafficPolicySpecHttp2InitialConnectionWindowSize {
    return new ClientTrafficPolicySpecHttp2InitialConnectionWindowSize(value);
  }
  public static fromString(value: string): ClientTrafficPolicySpecHttp2InitialConnectionWindowSize {
    return new ClientTrafficPolicySpecHttp2InitialConnectionWindowSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
 * If not set, the default value is 64 KiB(64*1024).
 *
 * @schema ClientTrafficPolicySpecHttp2InitialStreamWindowSize
 */
export class ClientTrafficPolicySpecHttp2InitialStreamWindowSize {
  public static fromNumber(value: number): ClientTrafficPolicySpecHttp2InitialStreamWindowSize {
    return new ClientTrafficPolicySpecHttp2InitialStreamWindowSize(value);
  }
  public static fromString(value: string): ClientTrafficPolicySpecHttp2InitialStreamWindowSize {
    return new ClientTrafficPolicySpecHttp2InitialStreamWindowSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * EscapedSlashesAction determines how %2f, %2F, %5c, or %5C sequences in the path URI
 * should be handled.
 * The default is UnescapeAndRedirect.
 *
 * @schema ClientTrafficPolicySpecPathEscapedSlashesAction
 */
export enum ClientTrafficPolicySpecPathEscapedSlashesAction {
  /** KeepUnchanged */
  KEEP_UNCHANGED = "KeepUnchanged",
  /** RejectRequest */
  REJECT_REQUEST = "RejectRequest",
  /** UnescapeAndForward */
  UNESCAPE_AND_FORWARD = "UnescapeAndForward",
  /** UnescapeAndRedirect */
  UNESCAPE_AND_REDIRECT = "UnescapeAndRedirect",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ClientTrafficPolicySpecTargetSelectorsMatchExpressions
 */
export interface ClientTrafficPolicySpecTargetSelectorsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClientTrafficPolicySpecTargetSelectorsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClientTrafficPolicySpecTargetSelectorsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ClientTrafficPolicySpecTargetSelectorsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecTargetSelectorsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecTargetSelectorsMatchExpressions(obj: ClientTrafficPolicySpecTargetSelectorsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for HTTP.
 *
 * @schema ClientTrafficPolicySpecTimeoutHttp
 */
export interface ClientTrafficPolicySpecTimeoutHttp {
  /**
   * IdleTimeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
   * Default: 1 hour.
   *
   * @schema ClientTrafficPolicySpecTimeoutHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * RequestReceivedTimeout is the duration envoy waits for the complete request reception. This timer starts upon request
   * initiation and stops when either the last byte of the request is sent upstream or when the response begins.
   *
   * @schema ClientTrafficPolicySpecTimeoutHttp#requestReceivedTimeout
   */
  readonly requestReceivedTimeout?: string;

  /**
   * The stream idle timeout defines the amount of time a stream can exist without any upstream or downstream activity.
   * Default: 5 minutes.
   *
   * @schema ClientTrafficPolicySpecTimeoutHttp#streamIdleTimeout
   */
  readonly streamIdleTimeout?: string;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecTimeoutHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecTimeoutHttp(obj: ClientTrafficPolicySpecTimeoutHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idleTimeout': obj.idleTimeout,
    'requestReceivedTimeout': obj.requestReceivedTimeout,
    'streamIdleTimeout': obj.streamIdleTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for TCP.
 *
 * @schema ClientTrafficPolicySpecTimeoutTcp
 */
export interface ClientTrafficPolicySpecTimeoutTcp {
  /**
   * IdleTimeout for a TCP connection. Idle time is defined as a period in which there are no
   * bytes sent or received on either the upstream or downstream connection.
   * Default: 1 hour.
   *
   * @schema ClientTrafficPolicySpecTimeoutTcp#idleTimeout
   */
  readonly idleTimeout?: string;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecTimeoutTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecTimeoutTcp(obj: ClientTrafficPolicySpecTimeoutTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idleTimeout': obj.idleTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientValidation specifies the configuration to validate the client
 * initiating the TLS connection to the Gateway listener.
 *
 * @schema ClientTrafficPolicySpecTlsClientValidation
 */
export interface ClientTrafficPolicySpecTlsClientValidation {
  /**
   * CACertificateRefs contains one or more references to
   * Kubernetes objects that contain TLS certificates of
   * the Certificate Authorities that can be used
   * as a trust anchor to validate the certificates presented by the client.
   *
   * A single reference to a Kubernetes ConfigMap or a Kubernetes Secret,
   * with the CA certificate in a key named `ca.crt` is currently supported.
   *
   * References to a resource in different namespace are invalid UNLESS there
   * is a ReferenceGrant in the target namespace that allows the certificate
   * to be attached.
   *
   * @schema ClientTrafficPolicySpecTlsClientValidation#caCertificateRefs
   */
  readonly caCertificateRefs?: ClientTrafficPolicySpecTlsClientValidationCaCertificateRefs[];

  /**
   * An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will
   * verify that the SHA-256 of the DER-encoded presented certificate matches
   * one of the specified values.
   *
   * @schema ClientTrafficPolicySpecTlsClientValidation#certificateHashes
   */
  readonly certificateHashes?: string[];

  /**
   * Crl specifies the crl configuration that can be used to validate the client initiating the TLS connection
   *
   * @schema ClientTrafficPolicySpecTlsClientValidation#crl
   */
  readonly crl?: ClientTrafficPolicySpecTlsClientValidationCrl;

  /**
   * Optional set to true accepts connections even when a client doesn't present a certificate.
   * Defaults to false, which rejects connections without a valid client certificate.
   *
   * @default false, which rejects connections without a valid client certificate.
   * @schema ClientTrafficPolicySpecTlsClientValidation#optional
   */
  readonly optional?: boolean;

  /**
   * An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will
   * verify that the SHA-256 of the DER-encoded Subject Public Key Information
   * (SPKI) of the presented certificate matches one of the specified values.
   *
   * @schema ClientTrafficPolicySpecTlsClientValidation#spkiHashes
   */
  readonly spkiHashes?: string[];

  /**
   * An optional list of Subject Alternative name matchers. If specified, Envoy
   * will verify that the Subject Alternative Name of the presented certificate
   * matches one of the specified matchers
   *
   * @schema ClientTrafficPolicySpecTlsClientValidation#subjectAltNames
   */
  readonly subjectAltNames?: ClientTrafficPolicySpecTlsClientValidationSubjectAltNames;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecTlsClientValidation' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecTlsClientValidation(obj: ClientTrafficPolicySpecTlsClientValidation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificateRefs': obj.caCertificateRefs?.map(y => toJson_ClientTrafficPolicySpecTlsClientValidationCaCertificateRefs(y)),
    'certificateHashes': obj.certificateHashes?.map(y => y),
    'crl': toJson_ClientTrafficPolicySpecTlsClientValidationCrl(obj.crl),
    'optional': obj.optional,
    'spkiHashes': obj.spkiHashes?.map(y => y),
    'subjectAltNames': toJson_ClientTrafficPolicySpecTlsClientValidationSubjectAltNames(obj.subjectAltNames),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Max specifies the maximal TLS protocol version to allow
 * The default is TLS 1.3 if this is not specified.
 *
 * @schema ClientTrafficPolicySpecTlsMaxVersion
 */
export enum ClientTrafficPolicySpecTlsMaxVersion {
  /** Auto */
  AUTO = "Auto",
  /** 1.0 */
  VALUE_1_0 = "1.0",
  /** 1.1 */
  VALUE_1_1 = "1.1",
  /** 1.2 */
  VALUE_1_2 = "1.2",
  /** 1.3 */
  VALUE_1_3 = "1.3",
}

/**
 * Min specifies the minimal TLS protocol version to allow.
 * The default is TLS 1.2 if this is not specified.
 *
 * @schema ClientTrafficPolicySpecTlsMinVersion
 */
export enum ClientTrafficPolicySpecTlsMinVersion {
  /** Auto */
  AUTO = "Auto",
  /** 1.0 */
  VALUE_1_0 = "1.0",
  /** 1.1 */
  VALUE_1_1 = "1.1",
  /** 1.2 */
  VALUE_1_2 = "1.2",
  /** 1.3 */
  VALUE_1_3 = "1.3",
}

/**
 * Session defines settings related to TLS session management.
 *
 * @schema ClientTrafficPolicySpecTlsSession
 */
export interface ClientTrafficPolicySpecTlsSession {
  /**
   * Resumption determines the proxy's supported TLS session resumption option.
   * By default, Envoy Gateway does not enable session resumption. Use sessionResumption to
   * enable stateful and stateless session resumption. Users should consider security impacts
   * of different resumption methods. Performance gains from resumption are diminished when
   * Envoy proxy is deployed with more than one replica.
   *
   * @schema ClientTrafficPolicySpecTlsSession#resumption
   */
  readonly resumption?: ClientTrafficPolicySpecTlsSessionResumption;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecTlsSession' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecTlsSession(obj: ClientTrafficPolicySpecTlsSession | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resumption': toJson_ClientTrafficPolicySpecTlsSessionResumption(obj.resumption),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
 *
 * @schema ClientTrafficPolicySpecHeadersEarlyRequestHeadersAdd
 */
export interface ClientTrafficPolicySpecHeadersEarlyRequestHeadersAdd {
  /**
   * Name is the name of the HTTP Header to be matched. Name matching MUST be
   * case-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
   *
   * If multiple entries specify equivalent header names, the first entry with
   * an equivalent name MUST be considered for a match. Subsequent entries
   * with an equivalent header name MUST be ignored. Due to the
   * case-insensitivity of header names, "foo" and "Foo" are considered
   * equivalent.
   *
   * @schema ClientTrafficPolicySpecHeadersEarlyRequestHeadersAdd#name
   */
  readonly name: string;

  /**
   * Value is the value of HTTP Header to be matched.
   *
   * @schema ClientTrafficPolicySpecHeadersEarlyRequestHeadersAdd#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecHeadersEarlyRequestHeadersAdd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecHeadersEarlyRequestHeadersAdd(obj: ClientTrafficPolicySpecHeadersEarlyRequestHeadersAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
 *
 * @schema ClientTrafficPolicySpecHeadersEarlyRequestHeadersSet
 */
export interface ClientTrafficPolicySpecHeadersEarlyRequestHeadersSet {
  /**
   * Name is the name of the HTTP Header to be matched. Name matching MUST be
   * case-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
   *
   * If multiple entries specify equivalent header names, the first entry with
   * an equivalent name MUST be considered for a match. Subsequent entries
   * with an equivalent header name MUST be ignored. Due to the
   * case-insensitivity of header names, "foo" and "Foo" are considered
   * equivalent.
   *
   * @schema ClientTrafficPolicySpecHeadersEarlyRequestHeadersSet#name
   */
  readonly name: string;

  /**
   * Value is the value of HTTP Header to be matched.
   *
   * @schema ClientTrafficPolicySpecHeadersEarlyRequestHeadersSet#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecHeadersEarlyRequestHeadersSet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecHeadersEarlyRequestHeadersSet(obj: ClientTrafficPolicySpecHeadersEarlyRequestHeadersSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
 *
 * @schema ClientTrafficPolicySpecHeadersLateResponseHeadersAdd
 */
export interface ClientTrafficPolicySpecHeadersLateResponseHeadersAdd {
  /**
   * Name is the name of the HTTP Header to be matched. Name matching MUST be
   * case-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
   *
   * If multiple entries specify equivalent header names, the first entry with
   * an equivalent name MUST be considered for a match. Subsequent entries
   * with an equivalent header name MUST be ignored. Due to the
   * case-insensitivity of header names, "foo" and "Foo" are considered
   * equivalent.
   *
   * @schema ClientTrafficPolicySpecHeadersLateResponseHeadersAdd#name
   */
  readonly name: string;

  /**
   * Value is the value of HTTP Header to be matched.
   *
   * @schema ClientTrafficPolicySpecHeadersLateResponseHeadersAdd#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecHeadersLateResponseHeadersAdd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecHeadersLateResponseHeadersAdd(obj: ClientTrafficPolicySpecHeadersLateResponseHeadersAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
 *
 * @schema ClientTrafficPolicySpecHeadersLateResponseHeadersSet
 */
export interface ClientTrafficPolicySpecHeadersLateResponseHeadersSet {
  /**
   * Name is the name of the HTTP Header to be matched. Name matching MUST be
   * case-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
   *
   * If multiple entries specify equivalent header names, the first entry with
   * an equivalent name MUST be considered for a match. Subsequent entries
   * with an equivalent header name MUST be ignored. Due to the
   * case-insensitivity of header names, "foo" and "Foo" are considered
   * equivalent.
   *
   * @schema ClientTrafficPolicySpecHeadersLateResponseHeadersSet#name
   */
  readonly name: string;

  /**
   * Value is the value of HTTP Header to be matched.
   *
   * @schema ClientTrafficPolicySpecHeadersLateResponseHeadersSet#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecHeadersLateResponseHeadersSet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecHeadersLateResponseHeadersSet(obj: ClientTrafficPolicySpecHeadersLateResponseHeadersSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * XFCCCertData specifies the fields in the client certificate to be forwarded in the XFCC header.
 *
 * @schema ClientTrafficPolicySpecHeadersXForwardedClientCertCertDetailsToAdd
 */
export enum ClientTrafficPolicySpecHeadersXForwardedClientCertCertDetailsToAdd {
  /** Subject */
  SUBJECT = "Subject",
  /** Cert */
  CERT = "Cert",
  /** Chain */
  CHAIN = "Chain",
  /** DNS */
  DNS = "DNS",
  /** URI */
  URI = "URI",
}

/**
 * Mode defines how XFCC header is handled by Envoy Proxy.
 * If not set, the default mode is `Sanitize`.
 *
 * @schema ClientTrafficPolicySpecHeadersXForwardedClientCertMode
 */
export enum ClientTrafficPolicySpecHeadersXForwardedClientCertMode {
  /** Sanitize */
  SANITIZE = "Sanitize",
  /** ForwardOnly */
  FORWARD_ONLY = "ForwardOnly",
  /** AppendForward */
  APPEND_FORWARD = "AppendForward",
  /** SanitizeSet */
  SANITIZE_SET = "SanitizeSet",
  /** AlwaysForwardOnly */
  ALWAYS_FORWARD_ONLY = "AlwaysForwardOnly",
}

/**
 * SecretObjectReference identifies an API object including its namespace,
 * defaulting to Secret.
 *
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 *
 * References to objects with invalid Group and Kind are not valid, and must
 * be rejected by the implementation, with appropriate Conditions set
 * on the containing object.
 *
 * @schema ClientTrafficPolicySpecTlsClientValidationCaCertificateRefs
 */
export interface ClientTrafficPolicySpecTlsClientValidationCaCertificateRefs {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationCaCertificateRefs#group
   */
  readonly group?: string;

  /**
   * Kind is kind of the referent. For example "Secret".
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationCaCertificateRefs#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationCaCertificateRefs#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the referenced object. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationCaCertificateRefs#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecTlsClientValidationCaCertificateRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecTlsClientValidationCaCertificateRefs(obj: ClientTrafficPolicySpecTlsClientValidationCaCertificateRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Crl specifies the crl configuration that can be used to validate the client initiating the TLS connection
 *
 * @schema ClientTrafficPolicySpecTlsClientValidationCrl
 */
export interface ClientTrafficPolicySpecTlsClientValidationCrl {
  /**
   * If this option is set to true,  Envoy will only verify the certificate at the end of the certificate chain against the CRL.
   * Defaults to false, which will verify the entire certificate chain against the CRL.
   *
   * @default false, which will verify the entire certificate chain against the CRL.
   * @schema ClientTrafficPolicySpecTlsClientValidationCrl#onlyVerifyLeafCertificate
   */
  readonly onlyVerifyLeafCertificate?: boolean;

  /**
   * Refs contains one or more references to a Kubernetes ConfigMap or a Kubernetes Secret,
   * containing the certificate revocation list in PEM format
   * Expects the content in a key named `ca.crl`.
   *
   * References to a resource in different namespace are invalid UNLESS there
   * is a ReferenceGrant in the target namespace that allows the crl
   * to be attached.
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationCrl#refs
   */
  readonly refs: ClientTrafficPolicySpecTlsClientValidationCrlRefs[];
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecTlsClientValidationCrl' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecTlsClientValidationCrl(obj: ClientTrafficPolicySpecTlsClientValidationCrl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'onlyVerifyLeafCertificate': obj.onlyVerifyLeafCertificate,
    'refs': obj.refs?.map(y => toJson_ClientTrafficPolicySpecTlsClientValidationCrlRefs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An optional list of Subject Alternative name matchers. If specified, Envoy
 * will verify that the Subject Alternative Name of the presented certificate
 * matches one of the specified matchers
 *
 * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNames
 */
export interface ClientTrafficPolicySpecTlsClientValidationSubjectAltNames {
  /**
   * DNS names matchers
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNames#dnsNames
   */
  readonly dnsNames?: ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesDnsNames[];

  /**
   * Email addresses matchers
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNames#emailAddresses
   */
  readonly emailAddresses?: ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesEmailAddresses[];

  /**
   * IP addresses matchers
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNames#ipAddresses
   */
  readonly ipAddresses?: ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesIpAddresses[];

  /**
   * Other names matchers
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNames#otherNames
   */
  readonly otherNames?: ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesOtherNames[];

  /**
   * URIs matchers
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNames#uris
   */
  readonly uris?: ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesUris[];
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecTlsClientValidationSubjectAltNames' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecTlsClientValidationSubjectAltNames(obj: ClientTrafficPolicySpecTlsClientValidationSubjectAltNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsNames': obj.dnsNames?.map(y => toJson_ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesDnsNames(y)),
    'emailAddresses': obj.emailAddresses?.map(y => toJson_ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesEmailAddresses(y)),
    'ipAddresses': obj.ipAddresses?.map(y => toJson_ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesIpAddresses(y)),
    'otherNames': obj.otherNames?.map(y => toJson_ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesOtherNames(y)),
    'uris': obj.uris?.map(y => toJson_ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesUris(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resumption determines the proxy's supported TLS session resumption option.
 * By default, Envoy Gateway does not enable session resumption. Use sessionResumption to
 * enable stateful and stateless session resumption. Users should consider security impacts
 * of different resumption methods. Performance gains from resumption are diminished when
 * Envoy proxy is deployed with more than one replica.
 *
 * @schema ClientTrafficPolicySpecTlsSessionResumption
 */
export interface ClientTrafficPolicySpecTlsSessionResumption {
  /**
   * Stateful defines setting for stateful (session-id based) session resumption
   *
   * @schema ClientTrafficPolicySpecTlsSessionResumption#stateful
   */
  readonly stateful?: any;

  /**
   * Stateless defines setting for stateless (session-ticket based) session resumption
   *
   * @schema ClientTrafficPolicySpecTlsSessionResumption#stateless
   */
  readonly stateless?: any;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecTlsSessionResumption' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecTlsSessionResumption(obj: ClientTrafficPolicySpecTlsSessionResumption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'stateful': obj.stateful,
    'stateless': obj.stateless,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretObjectReference identifies an API object including its namespace,
 * defaulting to Secret.
 *
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 *
 * References to objects with invalid Group and Kind are not valid, and must
 * be rejected by the implementation, with appropriate Conditions set
 * on the containing object.
 *
 * @schema ClientTrafficPolicySpecTlsClientValidationCrlRefs
 */
export interface ClientTrafficPolicySpecTlsClientValidationCrlRefs {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationCrlRefs#group
   */
  readonly group?: string;

  /**
   * Kind is kind of the referent. For example "Secret".
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationCrlRefs#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationCrlRefs#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the referenced object. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationCrlRefs#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecTlsClientValidationCrlRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecTlsClientValidationCrlRefs(obj: ClientTrafficPolicySpecTlsClientValidationCrlRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StringMatch defines how to match any strings.
 * This is a general purpose match condition that can be used by other EG APIs
 * that need to match against a string.
 *
 * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesDnsNames
 */
export interface ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesDnsNames {
  /**
   * Type specifies how to match against a string.
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesDnsNames#type
   */
  readonly type?: ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesDnsNamesType;

  /**
   * Value specifies the string value that the match must have.
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesDnsNames#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesDnsNames' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesDnsNames(obj: ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesDnsNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StringMatch defines how to match any strings.
 * This is a general purpose match condition that can be used by other EG APIs
 * that need to match against a string.
 *
 * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesEmailAddresses
 */
export interface ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesEmailAddresses {
  /**
   * Type specifies how to match against a string.
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesEmailAddresses#type
   */
  readonly type?: ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesEmailAddressesType;

  /**
   * Value specifies the string value that the match must have.
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesEmailAddresses#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesEmailAddresses' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesEmailAddresses(obj: ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesEmailAddresses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StringMatch defines how to match any strings.
 * This is a general purpose match condition that can be used by other EG APIs
 * that need to match against a string.
 *
 * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesIpAddresses
 */
export interface ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesIpAddresses {
  /**
   * Type specifies how to match against a string.
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesIpAddresses#type
   */
  readonly type?: ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesIpAddressesType;

  /**
   * Value specifies the string value that the match must have.
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesIpAddresses#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesIpAddresses' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesIpAddresses(obj: ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesIpAddresses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesOtherNames
 */
export interface ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesOtherNames {
  /**
   * OID Value
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesOtherNames#oid
   */
  readonly oid: string;

  /**
   * Type specifies how to match against a string.
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesOtherNames#type
   */
  readonly type?: ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesOtherNamesType;

  /**
   * Value specifies the string value that the match must have.
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesOtherNames#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesOtherNames' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesOtherNames(obj: ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesOtherNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'oid': obj.oid,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StringMatch defines how to match any strings.
 * This is a general purpose match condition that can be used by other EG APIs
 * that need to match against a string.
 *
 * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesUris
 */
export interface ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesUris {
  /**
   * Type specifies how to match against a string.
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesUris#type
   */
  readonly type?: ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesUrisType;

  /**
   * Value specifies the string value that the match must have.
   *
   * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesUris#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesUris' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesUris(obj: ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesUris | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type specifies how to match against a string.
 *
 * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesDnsNamesType
 */
export enum ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesDnsNamesType {
  /** Exact */
  EXACT = "Exact",
  /** Prefix */
  PREFIX = "Prefix",
  /** Suffix */
  SUFFIX = "Suffix",
  /** RegularExpression */
  REGULAR_EXPRESSION = "RegularExpression",
}

/**
 * Type specifies how to match against a string.
 *
 * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesEmailAddressesType
 */
export enum ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesEmailAddressesType {
  /** Exact */
  EXACT = "Exact",
  /** Prefix */
  PREFIX = "Prefix",
  /** Suffix */
  SUFFIX = "Suffix",
  /** RegularExpression */
  REGULAR_EXPRESSION = "RegularExpression",
}

/**
 * Type specifies how to match against a string.
 *
 * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesIpAddressesType
 */
export enum ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesIpAddressesType {
  /** Exact */
  EXACT = "Exact",
  /** Prefix */
  PREFIX = "Prefix",
  /** Suffix */
  SUFFIX = "Suffix",
  /** RegularExpression */
  REGULAR_EXPRESSION = "RegularExpression",
}

/**
 * Type specifies how to match against a string.
 *
 * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesOtherNamesType
 */
export enum ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesOtherNamesType {
  /** Exact */
  EXACT = "Exact",
  /** Prefix */
  PREFIX = "Prefix",
  /** Suffix */
  SUFFIX = "Suffix",
  /** RegularExpression */
  REGULAR_EXPRESSION = "RegularExpression",
}

/**
 * Type specifies how to match against a string.
 *
 * @schema ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesUrisType
 */
export enum ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesUrisType {
  /** Exact */
  EXACT = "Exact",
  /** Prefix */
  PREFIX = "Prefix",
  /** Suffix */
  SUFFIX = "Suffix",
  /** RegularExpression */
  REGULAR_EXPRESSION = "RegularExpression",
}


/**
 * EnvoyExtensionPolicy allows the user to configure various envoy extensibility options for the Gateway.
 *
 * @schema EnvoyExtensionPolicy
 */
export class EnvoyExtensionPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EnvoyExtensionPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'gateway.envoyproxy.io/v1alpha1',
    kind: 'EnvoyExtensionPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "EnvoyExtensionPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EnvoyExtensionPolicyProps): any {
    return {
      ...EnvoyExtensionPolicy.GVK,
      ...toJson_EnvoyExtensionPolicyProps(props),
    };
  }

  /**
   * Defines a "EnvoyExtensionPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EnvoyExtensionPolicyProps) {
    super(scope, id, {
      ...EnvoyExtensionPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...EnvoyExtensionPolicy.GVK,
      ...toJson_EnvoyExtensionPolicyProps(resolved),
    };
  }
}

/**
 * EnvoyExtensionPolicy allows the user to configure various envoy extensibility options for the Gateway.
 *
 * @schema EnvoyExtensionPolicy
 */
export interface EnvoyExtensionPolicyProps {
  /**
   * @schema EnvoyExtensionPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec defines the desired state of EnvoyExtensionPolicy.
   *
   * @schema EnvoyExtensionPolicy#spec
   */
  readonly spec: EnvoyExtensionPolicySpec;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicyProps(obj: EnvoyExtensionPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EnvoyExtensionPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec defines the desired state of EnvoyExtensionPolicy.
 *
 * @schema EnvoyExtensionPolicySpec
 */
export interface EnvoyExtensionPolicySpec {
  /**
   * ExtProc is an ordered list of external processing filters
   * that should be added to the envoy filter chain
   *
   * @schema EnvoyExtensionPolicySpec#extProc
   */
  readonly extProc?: EnvoyExtensionPolicySpecExtProc[];

  /**
   * Lua is an ordered list of Lua filters
   * that should be added to the envoy filter chain
   *
   * @schema EnvoyExtensionPolicySpec#lua
   */
  readonly lua?: EnvoyExtensionPolicySpecLua[];

  /**
   * TargetRef is the name of the resource this policy is being attached to.
   * This policy and the TargetRef MUST be in the same namespace for this
   * Policy to have effect
   *
   * Deprecated: use targetRefs/targetSelectors instead
   *
   * @schema EnvoyExtensionPolicySpec#targetRef
   */
  readonly targetRef?: EnvoyExtensionPolicySpecTargetRef;

  /**
   * TargetRefs are the names of the Gateway resources this policy
   * is being attached to.
   *
   * @schema EnvoyExtensionPolicySpec#targetRefs
   */
  readonly targetRefs?: EnvoyExtensionPolicySpecTargetRefs[];

  /**
   * TargetSelectors allow targeting resources for this policy based on labels
   *
   * @schema EnvoyExtensionPolicySpec#targetSelectors
   */
  readonly targetSelectors?: EnvoyExtensionPolicySpecTargetSelectors[];

  /**
   * Wasm is a list of Wasm extensions to be loaded by the Gateway.
   * Order matters, as the extensions will be loaded in the order they are
   * defined in this list.
   *
   * @schema EnvoyExtensionPolicySpec#wasm
   */
  readonly wasm?: EnvoyExtensionPolicySpecWasm[];
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpec(obj: EnvoyExtensionPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extProc': obj.extProc?.map(y => toJson_EnvoyExtensionPolicySpecExtProc(y)),
    'lua': obj.lua?.map(y => toJson_EnvoyExtensionPolicySpecLua(y)),
    'targetRef': toJson_EnvoyExtensionPolicySpecTargetRef(obj.targetRef),
    'targetRefs': obj.targetRefs?.map(y => toJson_EnvoyExtensionPolicySpecTargetRefs(y)),
    'targetSelectors': obj.targetSelectors?.map(y => toJson_EnvoyExtensionPolicySpecTargetSelectors(y)),
    'wasm': obj.wasm?.map(y => toJson_EnvoyExtensionPolicySpecWasm(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExtProc defines the configuration for External Processing filter.
 *
 * @schema EnvoyExtensionPolicySpecExtProc
 */
export interface EnvoyExtensionPolicySpecExtProc {
  /**
   * BackendRef references a Kubernetes object that represents the
   * backend server to which the authorization request will be sent.
   *
   * Deprecated: Use BackendRefs instead.
   *
   * @schema EnvoyExtensionPolicySpecExtProc#backendRef
   */
  readonly backendRef?: EnvoyExtensionPolicySpecExtProcBackendRef;

  /**
   * BackendRefs references a Kubernetes object that represents the
   * backend server to which the authorization request will be sent.
   *
   * @schema EnvoyExtensionPolicySpecExtProc#backendRefs
   */
  readonly backendRefs?: EnvoyExtensionPolicySpecExtProcBackendRefs[];

  /**
   * BackendSettings holds configuration for managing the connection
   * to the backend.
   *
   * @schema EnvoyExtensionPolicySpecExtProc#backendSettings
   */
  readonly backendSettings?: EnvoyExtensionPolicySpecExtProcBackendSettings;

  /**
   * FailOpen is a switch used to control the behavior when failing to call the external processor.
   *
   * If FailOpen is set to true, the system bypasses the ExtProc extension and
   * allows the traffic to pass through. If it is set to false or
   * not set (defaulting to false), the system blocks the traffic and returns
   * an HTTP 5xx error.
   *
   * If set to true, the ExtProc extension will also be bypassed if the configuration is invalid.
   *
   * @schema EnvoyExtensionPolicySpecExtProc#failOpen
   */
  readonly failOpen?: boolean;

  /**
   * MessageTimeout is the timeout for a response to be returned from the external processor
   * Default: 200ms
   *
   * @schema EnvoyExtensionPolicySpecExtProc#messageTimeout
   */
  readonly messageTimeout?: string;

  /**
   * Metadata defines options related to the sending and receiving of dynamic metadata.
   * These options define which metadata namespaces would be sent to the processor and which dynamic metadata
   * namespaces the processor would be permitted to emit metadata to.
   * Users can specify custom namespaces or well-known envoy metadata namespace (such as envoy.filters.http.ext_authz)
   * documented here: https://www.envoyproxy.io/docs/envoy/latest/configuration/advanced/well_known_dynamic_metadata#well-known-dynamic-metadata
   * Default: no metadata context is sent or received from the external processor
   *
   * @schema EnvoyExtensionPolicySpecExtProc#metadata
   */
  readonly metadata?: EnvoyExtensionPolicySpecExtProcMetadata;

  /**
   * ProcessingMode defines how request and response body is processed
   * Default: header and body are not sent to the external processor
   *
   * @schema EnvoyExtensionPolicySpecExtProc#processingMode
   */
  readonly processingMode?: EnvoyExtensionPolicySpecExtProcProcessingMode;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProc(obj: EnvoyExtensionPolicySpecExtProc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendRef': toJson_EnvoyExtensionPolicySpecExtProcBackendRef(obj.backendRef),
    'backendRefs': obj.backendRefs?.map(y => toJson_EnvoyExtensionPolicySpecExtProcBackendRefs(y)),
    'backendSettings': toJson_EnvoyExtensionPolicySpecExtProcBackendSettings(obj.backendSettings),
    'failOpen': obj.failOpen,
    'messageTimeout': obj.messageTimeout,
    'metadata': toJson_EnvoyExtensionPolicySpecExtProcMetadata(obj.metadata),
    'processingMode': toJson_EnvoyExtensionPolicySpecExtProcProcessingMode(obj.processingMode),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Lua defines a Lua extension
 * Only one of Inline or ValueRef must be set
 *
 * @schema EnvoyExtensionPolicySpecLua
 */
export interface EnvoyExtensionPolicySpecLua {
  /**
   * Inline contains the source code as an inline string.
   *
   * @schema EnvoyExtensionPolicySpecLua#inline
   */
  readonly inline?: string;

  /**
   * Type is the type of method to use to read the Lua value.
   * Valid values are Inline and ValueRef, default is Inline.
   *
   * @schema EnvoyExtensionPolicySpecLua#type
   */
  readonly type: EnvoyExtensionPolicySpecLuaType;

  /**
   * ValueRef has the source code specified as a local object reference.
   * Only a reference to ConfigMap is supported.
   * The value of key `lua` in the ConfigMap will be used.
   * If the key is not found, the first value in the ConfigMap will be used.
   *
   * @schema EnvoyExtensionPolicySpecLua#valueRef
   */
  readonly valueRef?: EnvoyExtensionPolicySpecLuaValueRef;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecLua' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecLua(obj: EnvoyExtensionPolicySpecLua | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inline': obj.inline,
    'type': obj.type,
    'valueRef': toJson_EnvoyExtensionPolicySpecLuaValueRef(obj.valueRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TargetRef is the name of the resource this policy is being attached to.
 * This policy and the TargetRef MUST be in the same namespace for this
 * Policy to have effect
 *
 * Deprecated: use targetRefs/targetSelectors instead
 *
 * @schema EnvoyExtensionPolicySpecTargetRef
 */
export interface EnvoyExtensionPolicySpecTargetRef {
  /**
   * Group is the group of the target resource.
   *
   * @schema EnvoyExtensionPolicySpecTargetRef#group
   */
  readonly group: string;

  /**
   * Kind is kind of the target resource.
   *
   * @schema EnvoyExtensionPolicySpecTargetRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of the target resource.
   *
   * @schema EnvoyExtensionPolicySpecTargetRef#name
   */
  readonly name: string;

  /**
   * SectionName is the name of a section within the target resource. When
   * unspecified, this targetRef targets the entire resource. In the following
   * resources, SectionName is interpreted as the following:
   *
   * * Gateway: Listener name
   * * HTTPRoute: HTTPRouteRule name
   * * Service: Port name
   *
   * If a SectionName is specified, but does not exist on the targeted object,
   * the Policy must fail to attach, and the policy implementation should record
   * a `ResolvedRefs` or similar Condition in the Policy's status.
   *
   * @schema EnvoyExtensionPolicySpecTargetRef#sectionName
   */
  readonly sectionName?: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecTargetRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecTargetRef(obj: EnvoyExtensionPolicySpecTargetRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'sectionName': obj.sectionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalPolicyTargetReferenceWithSectionName identifies an API object to apply a
 * direct policy to. This should be used as part of Policy resources that can
 * target single resources. For more information on how this policy attachment
 * mode works, and a sample Policy resource, refer to the policy attachment
 * documentation for Gateway API.
 *
 * Note: This should only be used for direct policy attachment when references
 * to SectionName are actually needed. In all other cases,
 * LocalPolicyTargetReference should be used.
 *
 * @schema EnvoyExtensionPolicySpecTargetRefs
 */
export interface EnvoyExtensionPolicySpecTargetRefs {
  /**
   * Group is the group of the target resource.
   *
   * @schema EnvoyExtensionPolicySpecTargetRefs#group
   */
  readonly group: string;

  /**
   * Kind is kind of the target resource.
   *
   * @schema EnvoyExtensionPolicySpecTargetRefs#kind
   */
  readonly kind: string;

  /**
   * Name is the name of the target resource.
   *
   * @schema EnvoyExtensionPolicySpecTargetRefs#name
   */
  readonly name: string;

  /**
   * SectionName is the name of a section within the target resource. When
   * unspecified, this targetRef targets the entire resource. In the following
   * resources, SectionName is interpreted as the following:
   *
   * * Gateway: Listener name
   * * HTTPRoute: HTTPRouteRule name
   * * Service: Port name
   *
   * If a SectionName is specified, but does not exist on the targeted object,
   * the Policy must fail to attach, and the policy implementation should record
   * a `ResolvedRefs` or similar Condition in the Policy's status.
   *
   * @schema EnvoyExtensionPolicySpecTargetRefs#sectionName
   */
  readonly sectionName?: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecTargetRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecTargetRefs(obj: EnvoyExtensionPolicySpecTargetRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'sectionName': obj.sectionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EnvoyExtensionPolicySpecTargetSelectors
 */
export interface EnvoyExtensionPolicySpecTargetSelectors {
  /**
   * Group is the group that this selector targets. Defaults to gateway.networking.k8s.io
   *
   * @default gateway.networking.k8s.io
   * @schema EnvoyExtensionPolicySpecTargetSelectors#group
   */
  readonly group?: string;

  /**
   * Kind is the resource kind that this selector targets.
   *
   * @schema EnvoyExtensionPolicySpecTargetSelectors#kind
   */
  readonly kind: string;

  /**
   * MatchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyExtensionPolicySpecTargetSelectors#matchExpressions
   */
  readonly matchExpressions?: EnvoyExtensionPolicySpecTargetSelectorsMatchExpressions[];

  /**
   * MatchLabels are the set of label selectors for identifying the targeted resource
   *
   * @schema EnvoyExtensionPolicySpecTargetSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecTargetSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecTargetSelectors(obj: EnvoyExtensionPolicySpecTargetSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyExtensionPolicySpecTargetSelectorsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Wasm defines a Wasm extension.
 *
 * Note: at the moment, Envoy Gateway does not support configuring Wasm runtime.
 * v8 is used as the VM runtime for the Wasm extensions.
 *
 * @schema EnvoyExtensionPolicySpecWasm
 */
export interface EnvoyExtensionPolicySpecWasm {
  /**
   * Code is the Wasm code for the extension.
   *
   * @schema EnvoyExtensionPolicySpecWasm#code
   */
  readonly code: EnvoyExtensionPolicySpecWasmCode;

  /**
   * Config is the configuration for the Wasm extension.
   * This configuration will be passed as a JSON string to the Wasm extension.
   *
   * @schema EnvoyExtensionPolicySpecWasm#config
   */
  readonly config?: any;

  /**
   * Env configures the environment for the Wasm extension
   *
   * @schema EnvoyExtensionPolicySpecWasm#env
   */
  readonly env?: EnvoyExtensionPolicySpecWasmEnv;

  /**
   * FailOpen is a switch used to control the behavior when a fatal error occurs
   * during the initialization or the execution of the Wasm extension.
   *
   * If FailOpen is set to true, the system bypasses the Wasm extension and
   * allows the traffic to pass through. If it is set to false or
   * not set (defaulting to false), the system blocks the traffic and returns
   * an HTTP 5xx error.
   *
   * If set to true, the Wasm extension will also be bypassed if the configuration is invalid.
   *
   * @schema EnvoyExtensionPolicySpecWasm#failOpen
   */
  readonly failOpen?: boolean;

  /**
   * Name is a unique name for this Wasm extension. It is used to identify the
   * Wasm extension if multiple extensions are handled by the same vm_id and root_id.
   * It's also used for logging/debugging.
   * If not specified, EG will generate a unique name for the Wasm extension.
   *
   * @schema EnvoyExtensionPolicySpecWasm#name
   */
  readonly name?: string;

  /**
   * RootID is a unique ID for a set of extensions in a VM which will share a
   * RootContext and Contexts if applicable (e.g., an Wasm HttpFilter and an Wasm AccessLog).
   * If left blank, all extensions with a blank root_id with the same vm_id will share Context(s).
   *
   * Note: RootID must match the root_id parameter used to register the Context in the Wasm code.
   *
   * @schema EnvoyExtensionPolicySpecWasm#rootID
   */
  readonly rootId?: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecWasm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecWasm(obj: EnvoyExtensionPolicySpecWasm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'code': toJson_EnvoyExtensionPolicySpecWasmCode(obj.code),
    'config': obj.config,
    'env': toJson_EnvoyExtensionPolicySpecWasmEnv(obj.env),
    'failOpen': obj.failOpen,
    'name': obj.name,
    'rootID': obj.rootId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendRef references a Kubernetes object that represents the
 * backend server to which the authorization request will be sent.
 *
 * Deprecated: Use BackendRefs instead.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendRef
 */
export interface EnvoyExtensionPolicySpecExtProcBackendRef {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendRef#group
   */
  readonly group?: string;

  /**
   * Kind is the Kubernetes resource kind of the referent. For example
   * "Service".
   *
   * Defaults to "Service" when not specified.
   *
   * ExternalName services can refer to CNAME DNS records that may live
   * outside of the cluster and as such are difficult to reason about in
   * terms of conformance. They also may not be safe to forward to (see
   * CVE-2021-25740 for more information). Implementations SHOULD NOT
   * support ExternalName Services.
   *
   * Support: Core (Services with a type other than ExternalName)
   *
   * Support: Implementation-specific (Services with type ExternalName)
   *
   * @default Service" when not specified.
   * @schema EnvoyExtensionPolicySpecExtProcBackendRef#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the backend. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendRef#namespace
   */
  readonly namespace?: string;

  /**
   * Port specifies the destination port number to use for this resource.
   * Port is required when the referent is a Kubernetes Service. In this
   * case, the port number is the service port number, not the target port.
   * For other resources, destination port might be derived from the referent
   * resource or this field.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendRef#port
   */
  readonly port?: number;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendRef(obj: EnvoyExtensionPolicySpecExtProcBackendRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendRef defines how an ObjectReference that is specific to BackendRef.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendRefs
 */
export interface EnvoyExtensionPolicySpecExtProcBackendRefs {
  /**
   * Fallback indicates whether the backend is designated as a fallback.
   * Multiple fallback backends can be configured.
   * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
   * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
   * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
   * the health of the active backends falls below 72%.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendRefs#fallback
   */
  readonly fallback?: boolean;

  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendRefs#group
   */
  readonly group?: string;

  /**
   * Kind is the Kubernetes resource kind of the referent. For example
   * "Service".
   *
   * Defaults to "Service" when not specified.
   *
   * ExternalName services can refer to CNAME DNS records that may live
   * outside of the cluster and as such are difficult to reason about in
   * terms of conformance. They also may not be safe to forward to (see
   * CVE-2021-25740 for more information). Implementations SHOULD NOT
   * support ExternalName Services.
   *
   * Support: Core (Services with a type other than ExternalName)
   *
   * Support: Implementation-specific (Services with type ExternalName)
   *
   * @default Service" when not specified.
   * @schema EnvoyExtensionPolicySpecExtProcBackendRefs#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendRefs#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the backend. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendRefs#namespace
   */
  readonly namespace?: string;

  /**
   * Port specifies the destination port number to use for this resource.
   * Port is required when the referent is a Kubernetes Service. In this
   * case, the port number is the service port number, not the target port.
   * For other resources, destination port might be derived from the referent
   * resource or this field.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendRefs#port
   */
  readonly port?: number;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendRefs(obj: EnvoyExtensionPolicySpecExtProcBackendRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fallback': obj.fallback,
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendSettings holds configuration for managing the connection
 * to the backend.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettings
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettings {
  /**
   * Circuit Breaker settings for the upstream connections and requests.
   * If not set, circuit breakers will be enabled with the default thresholds
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettings#circuitBreaker
   */
  readonly circuitBreaker?: EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreaker;

  /**
   * Connection includes backend connection settings.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettings#connection
   */
  readonly connection?: EnvoyExtensionPolicySpecExtProcBackendSettingsConnection;

  /**
   * DNS includes dns resolution settings.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettings#dns
   */
  readonly dns?: EnvoyExtensionPolicySpecExtProcBackendSettingsDns;

  /**
   * HealthCheck allows gateway to perform active health checking on backends.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettings#healthCheck
   */
  readonly healthCheck?: EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheck;

  /**
   * HTTP2 provides HTTP/2 configuration for backend connections.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettings#http2
   */
  readonly http2?: EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2;

  /**
   * LoadBalancer policy to apply when routing traffic from the gateway to
   * the backend endpoints. Defaults to `LeastRequest`.
   *
   * @default LeastRequest`.
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettings#loadBalancer
   */
  readonly loadBalancer?: EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancer;

  /**
   * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettings#proxyProtocol
   */
  readonly proxyProtocol?: EnvoyExtensionPolicySpecExtProcBackendSettingsProxyProtocol;

  /**
   * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
   * If not set, retry will be disabled.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettings#retry
   */
  readonly retry?: EnvoyExtensionPolicySpecExtProcBackendSettingsRetry;

  /**
   * TcpKeepalive settings associated with the upstream client connection.
   * Disabled by default.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettings#tcpKeepalive
   */
  readonly tcpKeepalive?: EnvoyExtensionPolicySpecExtProcBackendSettingsTcpKeepalive;

  /**
   * Timeout settings for the backend connections.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettings#timeout
   */
  readonly timeout?: EnvoyExtensionPolicySpecExtProcBackendSettingsTimeout;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettings(obj: EnvoyExtensionPolicySpecExtProcBackendSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'circuitBreaker': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreaker(obj.circuitBreaker),
    'connection': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsConnection(obj.connection),
    'dns': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsDns(obj.dns),
    'healthCheck': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheck(obj.healthCheck),
    'http2': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2(obj.http2),
    'loadBalancer': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancer(obj.loadBalancer),
    'proxyProtocol': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsProxyProtocol(obj.proxyProtocol),
    'retry': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsRetry(obj.retry),
    'tcpKeepalive': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsTcpKeepalive(obj.tcpKeepalive),
    'timeout': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsTimeout(obj.timeout),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metadata defines options related to the sending and receiving of dynamic metadata.
 * These options define which metadata namespaces would be sent to the processor and which dynamic metadata
 * namespaces the processor would be permitted to emit metadata to.
 * Users can specify custom namespaces or well-known envoy metadata namespace (such as envoy.filters.http.ext_authz)
 * documented here: https://www.envoyproxy.io/docs/envoy/latest/configuration/advanced/well_known_dynamic_metadata#well-known-dynamic-metadata
 * Default: no metadata context is sent or received from the external processor
 *
 * @schema EnvoyExtensionPolicySpecExtProcMetadata
 */
export interface EnvoyExtensionPolicySpecExtProcMetadata {
  /**
   * AccessibleNamespaces are metadata namespaces that are sent to the external processor as context
   *
   * @schema EnvoyExtensionPolicySpecExtProcMetadata#accessibleNamespaces
   */
  readonly accessibleNamespaces?: string[];

  /**
   * WritableNamespaces are metadata namespaces that the external processor can write to
   *
   * @schema EnvoyExtensionPolicySpecExtProcMetadata#writableNamespaces
   */
  readonly writableNamespaces?: string[];
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcMetadata(obj: EnvoyExtensionPolicySpecExtProcMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessibleNamespaces': obj.accessibleNamespaces?.map(y => y),
    'writableNamespaces': obj.writableNamespaces?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProcessingMode defines how request and response body is processed
 * Default: header and body are not sent to the external processor
 *
 * @schema EnvoyExtensionPolicySpecExtProcProcessingMode
 */
export interface EnvoyExtensionPolicySpecExtProcProcessingMode {
  /**
   * AllowModeOverride allows the external processor to override the processing mode set via the
   * `mode_override` field in the gRPC response message. This defaults to false.
   *
   * @schema EnvoyExtensionPolicySpecExtProcProcessingMode#allowModeOverride
   */
  readonly allowModeOverride?: boolean;

  /**
   * Defines processing mode for requests. If present, request headers are sent. Request body is processed according
   * to the specified mode.
   *
   * @schema EnvoyExtensionPolicySpecExtProcProcessingMode#request
   */
  readonly request?: EnvoyExtensionPolicySpecExtProcProcessingModeRequest;

  /**
   * Defines processing mode for responses. If present, response headers are sent. Response body is processed according
   * to the specified mode.
   *
   * @schema EnvoyExtensionPolicySpecExtProcProcessingMode#response
   */
  readonly response?: EnvoyExtensionPolicySpecExtProcProcessingModeResponse;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcProcessingMode' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcProcessingMode(obj: EnvoyExtensionPolicySpecExtProcProcessingMode | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowModeOverride': obj.allowModeOverride,
    'request': toJson_EnvoyExtensionPolicySpecExtProcProcessingModeRequest(obj.request),
    'response': toJson_EnvoyExtensionPolicySpecExtProcProcessingModeResponse(obj.response),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type is the type of method to use to read the Lua value.
 * Valid values are Inline and ValueRef, default is Inline.
 *
 * @schema EnvoyExtensionPolicySpecLuaType
 */
export enum EnvoyExtensionPolicySpecLuaType {
  /** Inline */
  INLINE = "Inline",
  /** ValueRef */
  VALUE_REF = "ValueRef",
}

/**
 * ValueRef has the source code specified as a local object reference.
 * Only a reference to ConfigMap is supported.
 * The value of key `lua` in the ConfigMap will be used.
 * If the key is not found, the first value in the ConfigMap will be used.
 *
 * @schema EnvoyExtensionPolicySpecLuaValueRef
 */
export interface EnvoyExtensionPolicySpecLuaValueRef {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema EnvoyExtensionPolicySpecLuaValueRef#group
   */
  readonly group: string;

  /**
   * Kind is kind of the referent. For example "HTTPRoute" or "Service".
   *
   * @schema EnvoyExtensionPolicySpecLuaValueRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of the referent.
   *
   * @schema EnvoyExtensionPolicySpecLuaValueRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecLuaValueRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecLuaValueRef(obj: EnvoyExtensionPolicySpecLuaValueRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyExtensionPolicySpecTargetSelectorsMatchExpressions
 */
export interface EnvoyExtensionPolicySpecTargetSelectorsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyExtensionPolicySpecTargetSelectorsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyExtensionPolicySpecTargetSelectorsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyExtensionPolicySpecTargetSelectorsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecTargetSelectorsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecTargetSelectorsMatchExpressions(obj: EnvoyExtensionPolicySpecTargetSelectorsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Code is the Wasm code for the extension.
 *
 * @schema EnvoyExtensionPolicySpecWasmCode
 */
export interface EnvoyExtensionPolicySpecWasmCode {
  /**
   * HTTP is the HTTP URL containing the Wasm code.
   *
   * Note that the HTTP server must be accessible from the Envoy proxy.
   *
   * @schema EnvoyExtensionPolicySpecWasmCode#http
   */
  readonly http?: EnvoyExtensionPolicySpecWasmCodeHttp;

  /**
   * Image is the OCI image containing the Wasm code.
   *
   * Note that the image must be accessible from the Envoy Gateway.
   *
   * @schema EnvoyExtensionPolicySpecWasmCode#image
   */
  readonly image?: EnvoyExtensionPolicySpecWasmCodeImage;

  /**
   * PullPolicy is the policy to use when pulling the Wasm module by either the HTTP or Image source.
   * This field is only applicable when the SHA256 field is not set.
   *
   * If not specified, the default policy is IfNotPresent except for OCI images whose tag is latest.
   *
   * Note: EG does not update the Wasm module every time an Envoy proxy requests
   * the Wasm module even if the pull policy is set to Always.
   * It only updates the Wasm module when the EnvoyExtension resource version changes.
   *
   * @schema EnvoyExtensionPolicySpecWasmCode#pullPolicy
   */
  readonly pullPolicy?: EnvoyExtensionPolicySpecWasmCodePullPolicy;

  /**
   * Type is the type of the source of the Wasm code.
   * Valid WasmCodeSourceType values are "HTTP" or "Image".
   *
   * @schema EnvoyExtensionPolicySpecWasmCode#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecWasmCode' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecWasmCode(obj: EnvoyExtensionPolicySpecWasmCode | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_EnvoyExtensionPolicySpecWasmCodeHttp(obj.http),
    'image': toJson_EnvoyExtensionPolicySpecWasmCodeImage(obj.image),
    'pullPolicy': obj.pullPolicy,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Env configures the environment for the Wasm extension
 *
 * @schema EnvoyExtensionPolicySpecWasmEnv
 */
export interface EnvoyExtensionPolicySpecWasmEnv {
  /**
   * HostKeys is a list of keys for environment variables from the host envoy process
   * that should be passed into the Wasm VM. This is useful for passing secrets to to Wasm extensions.
   *
   * @schema EnvoyExtensionPolicySpecWasmEnv#hostKeys
   */
  readonly hostKeys?: string[];
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecWasmEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecWasmEnv(obj: EnvoyExtensionPolicySpecWasmEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostKeys': obj.hostKeys?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Circuit Breaker settings for the upstream connections and requests.
 * If not set, circuit breakers will be enabled with the default thresholds
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreaker
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreaker {
  /**
   * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreaker#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreaker#maxParallelRequests
   */
  readonly maxParallelRequests?: number;

  /**
   * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreaker#maxParallelRetries
   */
  readonly maxParallelRetries?: number;

  /**
   * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreaker#maxPendingRequests
   */
  readonly maxPendingRequests?: number;

  /**
   * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
   * Default: unlimited.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreaker#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreaker#perEndpoint
   */
  readonly perEndpoint?: EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreakerPerEndpoint;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreaker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreaker(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreaker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
    'maxParallelRequests': obj.maxParallelRequests,
    'maxParallelRetries': obj.maxParallelRetries,
    'maxPendingRequests': obj.maxPendingRequests,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'perEndpoint': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreakerPerEndpoint(obj.perEndpoint),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Connection includes backend connection settings.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsConnection
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsConnection {
  /**
   * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
   * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
   * If unspecified, an implementation defined default is applied (32768 bytes).
   * For example, 20Mi, 1Gi, 256Ki etc.
   * Note: that when the suffix is not provided, the value is interpreted as bytes.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsConnection#bufferLimit
   */
  readonly bufferLimit?: EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionBufferLimit;

  /**
   * Preconnect configures proactive upstream connections to reduce latency by establishing
   * connections before they’re needed and avoiding connection establishment overhead.
   *
   * If unset, Envoy will fetch connections as needed to serve in-flight requests.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsConnection#preconnect
   */
  readonly preconnect?: EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionPreconnect;

  /**
   * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
   * to backend.
   * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
   * For example, 20Mi, 1Gi, 256Ki etc.
   * Note that when the suffix is not provided, the value is interpreted as bytes.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsConnection#socketBufferLimit
   */
  readonly socketBufferLimit?: EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionSocketBufferLimit;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsConnection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsConnection(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsConnection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bufferLimit': obj.bufferLimit?.value,
    'preconnect': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionPreconnect(obj.preconnect),
    'socketBufferLimit': obj.socketBufferLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DNS includes dns resolution settings.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsDns
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsDns {
  /**
   * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
   * Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsDns#dnsRefreshRate
   */
  readonly dnsRefreshRate?: string;

  /**
   * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
   * If set, this configuration overrides other defaults.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsDns#lookupFamily
   */
  readonly lookupFamily?: EnvoyExtensionPolicySpecExtProcBackendSettingsDnsLookupFamily;

  /**
   * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
   * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
   * Defaults to true.
   *
   * @default true.
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsDns#respectDnsTtl
   */
  readonly respectDnsTtl?: boolean;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsDns' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsDns(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsDns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsRefreshRate': obj.dnsRefreshRate,
    'lookupFamily': obj.lookupFamily,
    'respectDnsTtl': obj.respectDnsTtl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HealthCheck allows gateway to perform active health checking on backends.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheck
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheck {
  /**
   * Active health check configuration
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheck#active
   */
  readonly active?: EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActive;

  /**
   * When number of unhealthy endpoints for a backend reaches this threshold
   * Envoy will disregard health status and balance across all endpoints.
   * It's designed to prevent a situation in which host failures cascade throughout the cluster
   * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheck#panicThreshold
   */
  readonly panicThreshold?: number;

  /**
   * Passive passive check configuration
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheck#passive
   */
  readonly passive?: EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckPassive;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheck(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'active': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActive(obj.active),
    'panicThreshold': obj.panicThreshold,
    'passive': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckPassive(obj.passive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP2 provides HTTP/2 configuration for backend connections.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2 {
  /**
   * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
   * If not set, the default value is 1 MiB.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2#initialConnectionWindowSize
   */
  readonly initialConnectionWindowSize?: EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2InitialConnectionWindowSize;

  /**
   * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
   * If not set, the default value is 64 KiB(64*1024).
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2#initialStreamWindowSize
   */
  readonly initialStreamWindowSize?: EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2InitialStreamWindowSize;

  /**
   * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
   * If not set, the default value is 100.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
   * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
   * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
   * Default: TerminateConnection
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2#onInvalidMessage
   */
  readonly onInvalidMessage?: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'initialConnectionWindowSize': obj.initialConnectionWindowSize?.value,
    'initialStreamWindowSize': obj.initialStreamWindowSize?.value,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'onInvalidMessage': obj.onInvalidMessage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LoadBalancer policy to apply when routing traffic from the gateway to
 * the backend endpoints. Defaults to `LeastRequest`.
 *
 * @default LeastRequest`.
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancer
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancer {
  /**
   * ConsistentHash defines the configuration when the load balancer type is
   * set to ConsistentHash
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancer#consistentHash
   */
  readonly consistentHash?: EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHash;

  /**
   * EndpointOverride defines the configuration for endpoint override.
   * When specified, the load balancer will attempt to route requests to endpoints
   * based on the override information extracted from request headers or metadata.
   * If the override endpoints are not available, the configured load balancer policy will be used as fallback.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancer#endpointOverride
   */
  readonly endpointOverride?: EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverride;

  /**
   * SlowStart defines the configuration related to the slow start load balancer policy.
   * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
   * Currently this is only supported for RoundRobin and LeastRequest load balancers
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancer#slowStart
   */
  readonly slowStart?: EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerSlowStart;

  /**
   * Type decides the type of Load Balancer policy.
   * Valid LoadBalancerType values are
   * "ConsistentHash",
   * "LeastRequest",
   * "Random",
   * "RoundRobin".
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancer#type
   */
  readonly type: EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerType;

  /**
   * ZoneAware defines the configuration related to the distribution of requests between locality zones.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancer#zoneAware
   */
  readonly zoneAware?: EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAware;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancer(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHash(obj.consistentHash),
    'endpointOverride': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverride(obj.endpointOverride),
    'slowStart': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerSlowStart(obj.slowStart),
    'type': obj.type,
    'zoneAware': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAware(obj.zoneAware),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsProxyProtocol
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsProxyProtocol {
  /**
   * Version of ProxyProtol
   * Valid ProxyProtocolVersion values are
   * "V1"
   * "V2"
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsProxyProtocol#version
   */
  readonly version: EnvoyExtensionPolicySpecExtProcBackendSettingsProxyProtocolVersion;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsProxyProtocol' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsProxyProtocol(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsProxyProtocol | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
 * If not set, retry will be disabled.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsRetry
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsRetry {
  /**
   * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
   * that should be sent to the same priority before switching to a different one.
   * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsRetry#numAttemptsPerPriority
   */
  readonly numAttemptsPerPriority?: number;

  /**
   * NumRetries is the number of retries to be attempted. Defaults to 2.
   *
   * @default 2.
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsRetry#numRetries
   */
  readonly numRetries?: number;

  /**
   * PerRetry is the retry policy to be applied per retry attempt.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsRetry#perRetry
   */
  readonly perRetry?: EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetry;

  /**
   * RetryOn specifies the retry trigger condition.
   *
   * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsRetry#retryOn
   */
  readonly retryOn?: EnvoyExtensionPolicySpecExtProcBackendSettingsRetryRetryOn;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsRetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsRetry(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'numAttemptsPerPriority': obj.numAttemptsPerPriority,
    'numRetries': obj.numRetries,
    'perRetry': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetry(obj.perRetry),
    'retryOn': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsRetryRetryOn(obj.retryOn),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TcpKeepalive settings associated with the upstream client connection.
 * Disabled by default.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsTcpKeepalive
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsTcpKeepalive {
  /**
   * The duration a connection needs to be idle before keep-alive
   * probes start being sent.
   * The duration format is
   * Defaults to `7200s`.
   *
   * @default 7200s`.
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsTcpKeepalive#idleTime
   */
  readonly idleTime?: string;

  /**
   * The duration between keep-alive probes.
   * Defaults to `75s`.
   *
   * @default 75s`.
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * The total number of unacknowledged probes to send before deciding
   * the connection is dead.
   * Defaults to 9.
   *
   * @default 9.
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsTcpKeepalive#probes
   */
  readonly probes?: number;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsTcpKeepalive(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idleTime': obj.idleTime,
    'interval': obj.interval,
    'probes': obj.probes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for the backend connections.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsTimeout
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsTimeout {
  /**
   * Timeout settings for HTTP.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsTimeout#http
   */
  readonly http?: EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutHttp;

  /**
   * Timeout settings for TCP.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsTimeout#tcp
   */
  readonly tcp?: EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutTcp;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsTimeout' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsTimeout(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutHttp(obj.http),
    'tcp': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines processing mode for requests. If present, request headers are sent. Request body is processed according
 * to the specified mode.
 *
 * @schema EnvoyExtensionPolicySpecExtProcProcessingModeRequest
 */
export interface EnvoyExtensionPolicySpecExtProcProcessingModeRequest {
  /**
   * Defines which attributes are sent to the external processor. Envoy Gateway currently
   * supports only the following attribute prefixes: connection, source, destination,
   * request, response, upstream and xds.route.
   * https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/advanced/attributes
   *
   * @schema EnvoyExtensionPolicySpecExtProcProcessingModeRequest#attributes
   */
  readonly attributes?: string[];

  /**
   * Defines body processing mode
   *
   * @schema EnvoyExtensionPolicySpecExtProcProcessingModeRequest#body
   */
  readonly body?: EnvoyExtensionPolicySpecExtProcProcessingModeRequestBody;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcProcessingModeRequest' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcProcessingModeRequest(obj: EnvoyExtensionPolicySpecExtProcProcessingModeRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributes': obj.attributes?.map(y => y),
    'body': obj.body,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines processing mode for responses. If present, response headers are sent. Response body is processed according
 * to the specified mode.
 *
 * @schema EnvoyExtensionPolicySpecExtProcProcessingModeResponse
 */
export interface EnvoyExtensionPolicySpecExtProcProcessingModeResponse {
  /**
   * Defines which attributes are sent to the external processor. Envoy Gateway currently
   * supports only the following attribute prefixes: connection, source, destination,
   * request, response, upstream and xds.route.
   * https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/advanced/attributes
   *
   * @schema EnvoyExtensionPolicySpecExtProcProcessingModeResponse#attributes
   */
  readonly attributes?: string[];

  /**
   * Defines body processing mode
   *
   * @schema EnvoyExtensionPolicySpecExtProcProcessingModeResponse#body
   */
  readonly body?: EnvoyExtensionPolicySpecExtProcProcessingModeResponseBody;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcProcessingModeResponse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcProcessingModeResponse(obj: EnvoyExtensionPolicySpecExtProcProcessingModeResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributes': obj.attributes?.map(y => y),
    'body': obj.body,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP is the HTTP URL containing the Wasm code.
 *
 * Note that the HTTP server must be accessible from the Envoy proxy.
 *
 * @schema EnvoyExtensionPolicySpecWasmCodeHttp
 */
export interface EnvoyExtensionPolicySpecWasmCodeHttp {
  /**
   * SHA256 checksum that will be used to verify the Wasm code.
   *
   * If not specified, Envoy Gateway will not verify the downloaded Wasm code.
   * kubebuilder:validation:Pattern=`^[a-f0-9]{64}$`
   *
   * @schema EnvoyExtensionPolicySpecWasmCodeHttp#sha256
   */
  readonly sha256?: string;

  /**
   * TLS configuration when connecting to the Wasm code source.
   *
   * @schema EnvoyExtensionPolicySpecWasmCodeHttp#tls
   */
  readonly tls?: EnvoyExtensionPolicySpecWasmCodeHttpTls;

  /**
   * URL is the URL containing the Wasm code.
   *
   * @schema EnvoyExtensionPolicySpecWasmCodeHttp#url
   */
  readonly url: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecWasmCodeHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecWasmCodeHttp(obj: EnvoyExtensionPolicySpecWasmCodeHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sha256': obj.sha256,
    'tls': toJson_EnvoyExtensionPolicySpecWasmCodeHttpTls(obj.tls),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Image is the OCI image containing the Wasm code.
 *
 * Note that the image must be accessible from the Envoy Gateway.
 *
 * @schema EnvoyExtensionPolicySpecWasmCodeImage
 */
export interface EnvoyExtensionPolicySpecWasmCodeImage {
  /**
   * PullSecretRef is a reference to the secret containing the credentials to pull the image.
   * Only support Kubernetes Secret resource from the same namespace.
   *
   * @schema EnvoyExtensionPolicySpecWasmCodeImage#pullSecretRef
   */
  readonly pullSecretRef?: EnvoyExtensionPolicySpecWasmCodeImagePullSecretRef;

  /**
   * SHA256 checksum that will be used to verify the OCI image.
   *
   * It must match the digest of the OCI image.
   *
   * If not specified, Envoy Gateway will not verify the downloaded OCI image.
   * kubebuilder:validation:Pattern=`^[a-f0-9]{64}$`
   *
   * @schema EnvoyExtensionPolicySpecWasmCodeImage#sha256
   */
  readonly sha256?: string;

  /**
   * TLS configuration when connecting to the Wasm code source.
   *
   * @schema EnvoyExtensionPolicySpecWasmCodeImage#tls
   */
  readonly tls?: EnvoyExtensionPolicySpecWasmCodeImageTls;

  /**
   * URL is the URL of the OCI image.
   * URL can be in the format of `registry/image:tag` or `registry/image@sha256:digest`.
   *
   * @schema EnvoyExtensionPolicySpecWasmCodeImage#url
   */
  readonly url: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecWasmCodeImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecWasmCodeImage(obj: EnvoyExtensionPolicySpecWasmCodeImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullSecretRef': toJson_EnvoyExtensionPolicySpecWasmCodeImagePullSecretRef(obj.pullSecretRef),
    'sha256': obj.sha256,
    'tls': toJson_EnvoyExtensionPolicySpecWasmCodeImageTls(obj.tls),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PullPolicy is the policy to use when pulling the Wasm module by either the HTTP or Image source.
 * This field is only applicable when the SHA256 field is not set.
 *
 * If not specified, the default policy is IfNotPresent except for OCI images whose tag is latest.
 *
 * Note: EG does not update the Wasm module every time an Envoy proxy requests
 * the Wasm module even if the pull policy is set to Always.
 * It only updates the Wasm module when the EnvoyExtension resource version changes.
 *
 * @schema EnvoyExtensionPolicySpecWasmCodePullPolicy
 */
export enum EnvoyExtensionPolicySpecWasmCodePullPolicy {
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
  /** Always */
  ALWAYS = "Always",
}

/**
 * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreakerPerEndpoint
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreakerPerEndpoint {
  /**
   * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreakerPerEndpoint#maxConnections
   */
  readonly maxConnections?: number;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreakerPerEndpoint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreakerPerEndpoint(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreakerPerEndpoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
 * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
 * If unspecified, an implementation defined default is applied (32768 bytes).
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note: that when the suffix is not provided, the value is interpreted as bytes.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionBufferLimit
 */
export class EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionBufferLimit {
  public static fromNumber(value: number): EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionBufferLimit {
    return new EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionBufferLimit(value);
  }
  public static fromString(value: string): EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionBufferLimit {
    return new EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionBufferLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Preconnect configures proactive upstream connections to reduce latency by establishing
 * connections before they’re needed and avoiding connection establishment overhead.
 *
 * If unset, Envoy will fetch connections as needed to serve in-flight requests.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionPreconnect
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionPreconnect {
  /**
   * PerEndpointPercent configures how many additional connections to maintain per
   * upstream endpoint, useful for high-QPS or latency sensitive services. Expressed as a
   * percentage of the connections required by active streams
   * (e.g. 100 = preconnect disabled, 105 = 1.05x connections per-endpoint, 200 = 2.00×).
   *
   * Allowed value range is between 100-300. When both PerEndpointPercent and
   * PredictivePercent are set, Envoy ensures both are satisfied (max of the two).
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionPreconnect#perEndpointPercent
   */
  readonly perEndpointPercent?: number;

  /**
   * PredictivePercent configures how many additional connections to maintain
   * across the cluster by anticipating which upstream endpoint the load balancer
   * will select next, useful for low-QPS services. Relies on deterministic
   * loadbalancing and is only supported with Random or RoundRobin.
   * Expressed as a percentage of the connections required by active streams
   * (e.g. 100 = 1.0 (no preconnect), 105 = 1.05× connections across the cluster, 200 = 2.00×).
   *
   * Minimum allowed value is 100. When both PerEndpointPercent and PredictivePercent are
   * set Envoy ensures both are satisfied per host (max of the two).
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionPreconnect#predictivePercent
   */
  readonly predictivePercent?: number;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionPreconnect' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionPreconnect(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionPreconnect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'perEndpointPercent': obj.perEndpointPercent,
    'predictivePercent': obj.predictivePercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
 * to backend.
 * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note that when the suffix is not provided, the value is interpreted as bytes.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionSocketBufferLimit
 */
export class EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionSocketBufferLimit {
  public static fromNumber(value: number): EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionSocketBufferLimit {
    return new EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionSocketBufferLimit(value);
  }
  public static fromString(value: string): EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionSocketBufferLimit {
    return new EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionSocketBufferLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
 * If set, this configuration overrides other defaults.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsDnsLookupFamily
 */
export enum EnvoyExtensionPolicySpecExtProcBackendSettingsDnsLookupFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
  /** IPv4Preferred */
  I_PV4_PREFERRED = "IPv4Preferred",
  /** IPv6Preferred */
  I_PV6_PREFERRED = "IPv6Preferred",
  /** IPv4AndIPv6 */
  I_PV4_AND_I_PV6 = "IPv4AndIPv6",
}

/**
 * Active health check configuration
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActive
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActive {
  /**
   * GRPC defines the configuration of the GRPC health checker.
   * It's optional, and can only be used if the specified type is GRPC.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActive#grpc
   */
  readonly grpc?: EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveGrpc;

  /**
   * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActive#healthyThreshold
   */
  readonly healthyThreshold?: number;

  /**
   * HTTP defines the configuration of http health checker.
   * It's required while the health checker type is HTTP.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActive#http
   */
  readonly http?: EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttp;

  /**
   * InitialJitter defines the maximum time Envoy will wait before the first health check.
   * Envoy will randomly select a value between 0 and the initial jitter value.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActive#initialJitter
   */
  readonly initialJitter?: string;

  /**
   * Interval defines the time between active health checks.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActive#interval
   */
  readonly interval?: string;

  /**
   * TCP defines the configuration of tcp health checker.
   * It's required while the health checker type is TCP.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActive#tcp
   */
  readonly tcp?: EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcp;

  /**
   * Timeout defines the time to wait for a health check response.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActive#timeout
   */
  readonly timeout?: string;

  /**
   * Type defines the type of health checker.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActive#type
   */
  readonly type: string;

  /**
   * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActive#unhealthyThreshold
   */
  readonly unhealthyThreshold?: number;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActive(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpc': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveGrpc(obj.grpc),
    'healthyThreshold': obj.healthyThreshold,
    'http': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttp(obj.http),
    'initialJitter': obj.initialJitter,
    'interval': obj.interval,
    'tcp': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcp(obj.tcp),
    'timeout': obj.timeout,
    'type': obj.type,
    'unhealthyThreshold': obj.unhealthyThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Passive passive check configuration
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckPassive
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckPassive {
  /**
   * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckPassive#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckPassive#consecutive5XxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckPassive#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
   * Parameter takes effect only when split_external_local_origin_errors is set to true.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckPassive#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * FailurePercentageThreshold sets the failure percentage threshold for outlier detection.
   * If the failure percentage of a given host is greater than or equal to this value, it will be ejected.
   * Defaults to 85.
   *
   * @default 85.
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckPassive#failurePercentageThreshold
   */
  readonly failurePercentageThreshold?: number;

  /**
   * Interval defines the time between passive health checks.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckPassive#interval
   */
  readonly interval?: string;

  /**
   * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckPassive#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckPassive#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckPassive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckPassive(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckPassive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5XxErrors': obj.consecutive5XxErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'failurePercentageThreshold': obj.failurePercentageThreshold,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
 * If not set, the default value is 1 MiB.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2InitialConnectionWindowSize
 */
export class EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2InitialConnectionWindowSize {
  public static fromNumber(value: number): EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2InitialConnectionWindowSize {
    return new EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2InitialConnectionWindowSize(value);
  }
  public static fromString(value: string): EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2InitialConnectionWindowSize {
    return new EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2InitialConnectionWindowSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
 * If not set, the default value is 64 KiB(64*1024).
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2InitialStreamWindowSize
 */
export class EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2InitialStreamWindowSize {
  public static fromNumber(value: number): EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2InitialStreamWindowSize {
    return new EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2InitialStreamWindowSize(value);
  }
  public static fromString(value: string): EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2InitialStreamWindowSize {
    return new EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2InitialStreamWindowSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ConsistentHash defines the configuration when the load balancer type is
 * set to ConsistentHash
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHash
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHash {
  /**
   * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHash#cookie
   */
  readonly cookie?: EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashCookie;

  /**
   * Header configures the header hash policy when the consistent hash type is set to Header.
   *
   * Deprecated: use Headers instead
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHash#header
   */
  readonly header?: EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashHeader;

  /**
   * Headers configures the header hash policy for each header, when the consistent hash type is set to Headers.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHash#headers
   */
  readonly headers?: EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashHeaders[];

  /**
   * The table size for consistent hashing, must be prime number limited to 5000011.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHash#tableSize
   */
  readonly tableSize?: number;

  /**
   * ConsistentHashType defines the type of input to hash on. Valid Type values are
   * "SourceIP",
   * "Header",
   * "Headers",
   * "Cookie".
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHash#type
   */
  readonly type: EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashType;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHash(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookie': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashCookie(obj.cookie),
    'header': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashHeader(obj.header),
    'headers': obj.headers?.map(y => toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashHeaders(y)),
    'tableSize': obj.tableSize,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EndpointOverride defines the configuration for endpoint override.
 * When specified, the load balancer will attempt to route requests to endpoints
 * based on the override information extracted from request headers or metadata.
 * If the override endpoints are not available, the configured load balancer policy will be used as fallback.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverride
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverride {
  /**
   * ExtractFrom defines the sources to extract endpoint override information from.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverride#extractFrom
   */
  readonly extractFrom: EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverrideExtractFrom[];
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverride' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverride(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverride | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extractFrom': obj.extractFrom?.map(y => toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverrideExtractFrom(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SlowStart defines the configuration related to the slow start load balancer policy.
 * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
 * Currently this is only supported for RoundRobin and LeastRequest load balancers
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerSlowStart
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerSlowStart {
  /**
   * Window defines the duration of the warm up period for newly added host.
   * During slow start window, traffic sent to the newly added hosts will gradually increase.
   * Currently only supports linear growth of traffic. For additional details,
   * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerSlowStart#window
   */
  readonly window: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerSlowStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerSlowStart(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerSlowStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'window': obj.window,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type decides the type of Load Balancer policy.
 * Valid LoadBalancerType values are
 * "ConsistentHash",
 * "LeastRequest",
 * "Random",
 * "RoundRobin".
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerType
 */
export enum EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerType {
  /** ConsistentHash */
  CONSISTENT_HASH = "ConsistentHash",
  /** LeastRequest */
  LEAST_REQUEST = "LeastRequest",
  /** Random */
  RANDOM = "Random",
  /** RoundRobin */
  ROUND_ROBIN = "RoundRobin",
}

/**
 * ZoneAware defines the configuration related to the distribution of requests between locality zones.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAware
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAware {
  /**
   * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAware#preferLocal
   */
  readonly preferLocal?: EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocal;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAware' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAware(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAware | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferLocal': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocal(obj.preferLocal),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Version of ProxyProtol
 * Valid ProxyProtocolVersion values are
 * "V1"
 * "V2"
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsProxyProtocolVersion
 */
export enum EnvoyExtensionPolicySpecExtProcBackendSettingsProxyProtocolVersion {
  /** V1 */
  V1 = "V1",
  /** V2 */
  V2 = "V2",
}

/**
 * PerRetry is the retry policy to be applied per retry attempt.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetry
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetry {
  /**
   * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
   * back-off algorithm for retries. For additional details,
   * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetry#backOff
   */
  readonly backOff?: EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetryBackOff;

  /**
   * Timeout is the timeout per retry attempt.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetry#timeout
   */
  readonly timeout?: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetry(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backOff': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetryBackOff(obj.backOff),
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RetryOn specifies the retry trigger condition.
 *
 * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsRetryRetryOn
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsRetryRetryOn {
  /**
   * HttpStatusCodes specifies the http status codes to be retried.
   * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsRetryRetryOn#httpStatusCodes
   */
  readonly httpStatusCodes?: number[];

  /**
   * Triggers specifies the retry trigger condition(Http/Grpc).
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsRetryRetryOn#triggers
   */
  readonly triggers?: EnvoyExtensionPolicySpecExtProcBackendSettingsRetryRetryOnTriggers[];
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsRetryRetryOn' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsRetryRetryOn(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsRetryRetryOn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpStatusCodes': obj.httpStatusCodes?.map(y => y),
    'triggers': obj.triggers?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for HTTP.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutHttp
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutHttp {
  /**
   * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
   * Default: 1 hour.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutHttp#connectionIdleTimeout
   */
  readonly connectionIdleTimeout?: string;

  /**
   * The maximum duration of an HTTP connection.
   * Default: unlimited.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutHttp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * MaxStreamDuration is the maximum duration for a stream to complete. This timeout measures the time
   * from when the request is sent until the response stream is fully consumed and does not apply to
   * non-streaming requests.
   * When set to "0s", no max duration is applied and streams can run indefinitely.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutHttp#maxStreamDuration
   */
  readonly maxStreamDuration?: string;

  /**
   * RequestTimeout is the time until which entire response is received from the upstream.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutHttp#requestTimeout
   */
  readonly requestTimeout?: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutHttp(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionIdleTimeout': obj.connectionIdleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxStreamDuration': obj.maxStreamDuration,
    'requestTimeout': obj.requestTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for TCP.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutTcp
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutTcp {
  /**
   * The timeout for network connection establishment, including TCP and TLS handshakes.
   * Default: 10 seconds.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutTcp#connectTimeout
   */
  readonly connectTimeout?: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutTcp(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines body processing mode
 *
 * @schema EnvoyExtensionPolicySpecExtProcProcessingModeRequestBody
 */
export enum EnvoyExtensionPolicySpecExtProcProcessingModeRequestBody {
  /** Streamed */
  STREAMED = "Streamed",
  /** Buffered */
  BUFFERED = "Buffered",
  /** BufferedPartial */
  BUFFERED_PARTIAL = "BufferedPartial",
  /** FullDuplexStreamed */
  FULL_DUPLEX_STREAMED = "FullDuplexStreamed",
}

/**
 * Defines body processing mode
 *
 * @schema EnvoyExtensionPolicySpecExtProcProcessingModeResponseBody
 */
export enum EnvoyExtensionPolicySpecExtProcProcessingModeResponseBody {
  /** Streamed */
  STREAMED = "Streamed",
  /** Buffered */
  BUFFERED = "Buffered",
  /** BufferedPartial */
  BUFFERED_PARTIAL = "BufferedPartial",
  /** FullDuplexStreamed */
  FULL_DUPLEX_STREAMED = "FullDuplexStreamed",
}

/**
 * TLS configuration when connecting to the Wasm code source.
 *
 * @schema EnvoyExtensionPolicySpecWasmCodeHttpTls
 */
export interface EnvoyExtensionPolicySpecWasmCodeHttpTls {
  /**
   * CACertificateRef contains a references to
   * Kubernetes objects that contain TLS certificates of
   * the Certificate Authorities that can be used
   * as a trust anchor to validate the certificates presented by the Wasm code source.
   *
   * Kubernetes ConfigMap and Kubernetes Secret are supported.
   * Note: The ConfigMap or Secret must be in the same namespace as the EnvoyExtensionPolicy.
   *
   * @schema EnvoyExtensionPolicySpecWasmCodeHttpTls#caCertificateRef
   */
  readonly caCertificateRef: EnvoyExtensionPolicySpecWasmCodeHttpTlsCaCertificateRef;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecWasmCodeHttpTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecWasmCodeHttpTls(obj: EnvoyExtensionPolicySpecWasmCodeHttpTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificateRef': toJson_EnvoyExtensionPolicySpecWasmCodeHttpTlsCaCertificateRef(obj.caCertificateRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PullSecretRef is a reference to the secret containing the credentials to pull the image.
 * Only support Kubernetes Secret resource from the same namespace.
 *
 * @schema EnvoyExtensionPolicySpecWasmCodeImagePullSecretRef
 */
export interface EnvoyExtensionPolicySpecWasmCodeImagePullSecretRef {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema EnvoyExtensionPolicySpecWasmCodeImagePullSecretRef#group
   */
  readonly group?: string;

  /**
   * Kind is kind of the referent. For example "Secret".
   *
   * @schema EnvoyExtensionPolicySpecWasmCodeImagePullSecretRef#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema EnvoyExtensionPolicySpecWasmCodeImagePullSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the referenced object. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema EnvoyExtensionPolicySpecWasmCodeImagePullSecretRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecWasmCodeImagePullSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecWasmCodeImagePullSecretRef(obj: EnvoyExtensionPolicySpecWasmCodeImagePullSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS configuration when connecting to the Wasm code source.
 *
 * @schema EnvoyExtensionPolicySpecWasmCodeImageTls
 */
export interface EnvoyExtensionPolicySpecWasmCodeImageTls {
  /**
   * CACertificateRef contains a references to
   * Kubernetes objects that contain TLS certificates of
   * the Certificate Authorities that can be used
   * as a trust anchor to validate the certificates presented by the Wasm code source.
   *
   * Kubernetes ConfigMap and Kubernetes Secret are supported.
   * Note: The ConfigMap or Secret must be in the same namespace as the EnvoyExtensionPolicy.
   *
   * @schema EnvoyExtensionPolicySpecWasmCodeImageTls#caCertificateRef
   */
  readonly caCertificateRef: EnvoyExtensionPolicySpecWasmCodeImageTlsCaCertificateRef;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecWasmCodeImageTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecWasmCodeImageTls(obj: EnvoyExtensionPolicySpecWasmCodeImageTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificateRef': toJson_EnvoyExtensionPolicySpecWasmCodeImageTlsCaCertificateRef(obj.caCertificateRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC defines the configuration of the GRPC health checker.
 * It's optional, and can only be used if the specified type is GRPC.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveGrpc
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveGrpc {
  /**
   * Service to send in the health check request.
   * If this is not specified, then the health check request applies to the entire
   * server and not to a specific service.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveGrpc(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP defines the configuration of http health checker.
 * It's required while the health checker type is HTTP.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttp
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttp {
  /**
   * ExpectedResponse defines a list of HTTP expected responses to match.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttp#expectedResponse
   */
  readonly expectedResponse?: EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttpExpectedResponse;

  /**
   * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
   * Defaults to 200 only
   *
   * @default 200 only
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttp#expectedStatuses
   */
  readonly expectedStatuses?: number[];

  /**
   * Hostname defines the HTTP host that will be requested during health checking.
   * Default: HTTPRoute or GRPCRoute hostname.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttp#hostname
   */
  readonly hostname?: string;

  /**
   * Method defines the HTTP method used for health checking.
   * Defaults to GET
   *
   * @default GET
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttp#method
   */
  readonly method?: string;

  /**
   * Path defines the HTTP path that will be requested during health checking.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttp#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttp(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expectedResponse': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttpExpectedResponse(obj.expectedResponse),
    'expectedStatuses': obj.expectedStatuses?.map(y => y),
    'hostname': obj.hostname,
    'method': obj.method,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCP defines the configuration of tcp health checker.
 * It's required while the health checker type is TCP.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcp
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcp {
  /**
   * Receive defines the expected response payload.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcp#receive
   */
  readonly receive?: EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpReceive;

  /**
   * Send defines the request payload.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcp#send
   */
  readonly send?: EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpSend;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcp(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'receive': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpReceive(obj.receive),
    'send': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpSend(obj.send),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashCookie
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashCookie {
  /**
   * Additional Attributes to set for the generated cookie.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashCookie#attributes
   */
  readonly attributes?: { [key: string]: string };

  /**
   * Name of the cookie to hash.
   * If this cookie does not exist in the request, Envoy will generate a cookie and set
   * the TTL on the response back to the client based on Layer 4
   * attributes of the backend endpoint, to ensure that these future requests
   * go to the same backend endpoint. Make sure to set the TTL field for this case.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashCookie#name
   */
  readonly name: string;

  /**
   * TTL of the generated cookie if the cookie is not present. This value sets the
   * Max-Age attribute value.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashCookie#ttl
   */
  readonly ttl?: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashCookie' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashCookie(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributes': ((obj.attributes) === undefined) ? undefined : (Object.entries(obj.attributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Header configures the header hash policy when the consistent hash type is set to Header.
 *
 * Deprecated: use Headers instead
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashHeader
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashHeader {
  /**
   * Name of the header to hash.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashHeader#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashHeader' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashHeader(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Header defines the header hashing configuration for consistent hash based
 * load balancing.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashHeaders
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashHeaders {
  /**
   * Name of the header to hash.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashHeaders#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashHeaders(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConsistentHashType defines the type of input to hash on. Valid Type values are
 * "SourceIP",
 * "Header",
 * "Headers",
 * "Cookie".
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashType
 */
export enum EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashType {
  /** SourceIP */
  SOURCE_IP = "SourceIP",
  /** Header */
  HEADER = "Header",
  /** Headers */
  HEADERS = "Headers",
  /** Cookie */
  COOKIE = "Cookie",
}

/**
 * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverrideExtractFrom
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverrideExtractFrom {
  /**
   * Header defines the header to get the override endpoint addresses.
   * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
   * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
   * The IPv6 address is enclosed in square brackets.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverrideExtractFrom#header
   */
  readonly header?: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverrideExtractFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverrideExtractFrom(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverrideExtractFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': obj.header,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocal
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocal {
  /**
   * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
   * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocal#force
   */
  readonly force?: EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocalForce;

  /**
   * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocal#minEndpointsThreshold
   */
  readonly minEndpointsThreshold?: number;

  /**
   * Configures percentage of requests that will be considered for zone aware routing if zone aware routing is configured. If not specified, Envoy defaults to 100%.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocal#percentageEnabled
   */
  readonly percentageEnabled?: number;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocal' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocal(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'force': toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocalForce(obj.force),
    'minEndpointsThreshold': obj.minEndpointsThreshold,
    'percentageEnabled': obj.percentageEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
 * back-off algorithm for retries. For additional details,
 * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetryBackOff
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetryBackOff {
  /**
   * BaseInterval is the base interval between retries.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetryBackOff#baseInterval
   */
  readonly baseInterval?: string;

  /**
   * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
   * The default is 10 times the base_interval
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetryBackOff#maxInterval
   */
  readonly maxInterval?: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetryBackOff' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetryBackOff(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetryBackOff | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseInterval': obj.baseInterval,
    'maxInterval': obj.maxInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TriggerEnum specifies the conditions that trigger retries.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsRetryRetryOnTriggers
 */
export enum EnvoyExtensionPolicySpecExtProcBackendSettingsRetryRetryOnTriggers {
  /** 5xx */
  VALUE_5XX = "5xx",
  /** gateway-error */
  GATEWAY_HYPHEN_ERROR = "gateway-error",
  /** reset */
  RESET = "reset",
  /** reset-before-request */
  RESET_HYPHEN_BEFORE_HYPHEN_REQUEST = "reset-before-request",
  /** connect-failure */
  CONNECT_HYPHEN_FAILURE = "connect-failure",
  /** retriable-4xx */
  RETRIABLE_HYPHEN_4XX = "retriable-4xx",
  /** refused-stream */
  REFUSED_HYPHEN_STREAM = "refused-stream",
  /** retriable-status-codes */
  RETRIABLE_HYPHEN_STATUS_HYPHEN_CODES = "retriable-status-codes",
  /** cancelled */
  CANCELLED = "cancelled",
  /** deadline-exceeded */
  DEADLINE_HYPHEN_EXCEEDED = "deadline-exceeded",
  /** internal */
  INTERNAL = "internal",
  /** resource-exhausted */
  RESOURCE_HYPHEN_EXHAUSTED = "resource-exhausted",
  /** unavailable */
  UNAVAILABLE = "unavailable",
}

/**
 * CACertificateRef contains a references to
 * Kubernetes objects that contain TLS certificates of
 * the Certificate Authorities that can be used
 * as a trust anchor to validate the certificates presented by the Wasm code source.
 *
 * Kubernetes ConfigMap and Kubernetes Secret are supported.
 * Note: The ConfigMap or Secret must be in the same namespace as the EnvoyExtensionPolicy.
 *
 * @schema EnvoyExtensionPolicySpecWasmCodeHttpTlsCaCertificateRef
 */
export interface EnvoyExtensionPolicySpecWasmCodeHttpTlsCaCertificateRef {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema EnvoyExtensionPolicySpecWasmCodeHttpTlsCaCertificateRef#group
   */
  readonly group?: string;

  /**
   * Kind is kind of the referent. For example "Secret".
   *
   * @schema EnvoyExtensionPolicySpecWasmCodeHttpTlsCaCertificateRef#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema EnvoyExtensionPolicySpecWasmCodeHttpTlsCaCertificateRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the referenced object. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema EnvoyExtensionPolicySpecWasmCodeHttpTlsCaCertificateRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecWasmCodeHttpTlsCaCertificateRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecWasmCodeHttpTlsCaCertificateRef(obj: EnvoyExtensionPolicySpecWasmCodeHttpTlsCaCertificateRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CACertificateRef contains a references to
 * Kubernetes objects that contain TLS certificates of
 * the Certificate Authorities that can be used
 * as a trust anchor to validate the certificates presented by the Wasm code source.
 *
 * Kubernetes ConfigMap and Kubernetes Secret are supported.
 * Note: The ConfigMap or Secret must be in the same namespace as the EnvoyExtensionPolicy.
 *
 * @schema EnvoyExtensionPolicySpecWasmCodeImageTlsCaCertificateRef
 */
export interface EnvoyExtensionPolicySpecWasmCodeImageTlsCaCertificateRef {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema EnvoyExtensionPolicySpecWasmCodeImageTlsCaCertificateRef#group
   */
  readonly group?: string;

  /**
   * Kind is kind of the referent. For example "Secret".
   *
   * @schema EnvoyExtensionPolicySpecWasmCodeImageTlsCaCertificateRef#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema EnvoyExtensionPolicySpecWasmCodeImageTlsCaCertificateRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the referenced object. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema EnvoyExtensionPolicySpecWasmCodeImageTlsCaCertificateRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecWasmCodeImageTlsCaCertificateRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecWasmCodeImageTlsCaCertificateRef(obj: EnvoyExtensionPolicySpecWasmCodeImageTlsCaCertificateRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExpectedResponse defines a list of HTTP expected responses to match.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttpExpectedResponse
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttpExpectedResponse {
  /**
   * Binary payload base64 encoded.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttpExpectedResponse#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttpExpectedResponse#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttpExpectedResponse#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttpExpectedResponse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttpExpectedResponse(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttpExpectedResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Receive defines the expected response payload.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpReceive
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpReceive {
  /**
   * Binary payload base64 encoded.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpReceive#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpReceive#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpReceive#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpReceive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpReceive(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpReceive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Send defines the request payload.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpSend
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpSend {
  /**
   * Binary payload base64 encoded.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpSend#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpSend#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpSend#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpSend' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpSend(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpSend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
 * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
 *
 * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocalForce
 */
export interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocalForce {
  /**
   * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
   * override. This is useful for protecting zones with fewer endpoints.
   *
   * @schema EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocalForce#minEndpointsInZoneThreshold
   */
  readonly minEndpointsInZoneThreshold?: number;
}

/**
 * Converts an object of type 'EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocalForce' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocalForce(obj: EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocalForce | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minEndpointsInZoneThreshold': obj.minEndpointsInZoneThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * EnvoyPatchPolicy allows the user to modify the generated Envoy xDS
resources by Envoy Gateway using this patch API
 *
 * @schema EnvoyPatchPolicy
 */
export class EnvoyPatchPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EnvoyPatchPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'gateway.envoyproxy.io/v1alpha1',
    kind: 'EnvoyPatchPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "EnvoyPatchPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EnvoyPatchPolicyProps): any {
    return {
      ...EnvoyPatchPolicy.GVK,
      ...toJson_EnvoyPatchPolicyProps(props),
    };
  }

  /**
   * Defines a "EnvoyPatchPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EnvoyPatchPolicyProps) {
    super(scope, id, {
      ...EnvoyPatchPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...EnvoyPatchPolicy.GVK,
      ...toJson_EnvoyPatchPolicyProps(resolved),
    };
  }
}

/**
 * EnvoyPatchPolicy allows the user to modify the generated Envoy xDS
 * resources by Envoy Gateway using this patch API
 *
 * @schema EnvoyPatchPolicy
 */
export interface EnvoyPatchPolicyProps {
  /**
   * @schema EnvoyPatchPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec defines the desired state of EnvoyPatchPolicy.
   *
   * @schema EnvoyPatchPolicy#spec
   */
  readonly spec: EnvoyPatchPolicySpec;
}

/**
 * Converts an object of type 'EnvoyPatchPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyPatchPolicyProps(obj: EnvoyPatchPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EnvoyPatchPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec defines the desired state of EnvoyPatchPolicy.
 *
 * @schema EnvoyPatchPolicySpec
 */
export interface EnvoyPatchPolicySpec {
  /**
   * JSONPatch defines the JSONPatch configuration.
   *
   * @schema EnvoyPatchPolicySpec#jsonPatches
   */
  readonly jsonPatches?: EnvoyPatchPolicySpecJsonPatches[];

  /**
   * Priority of the EnvoyPatchPolicy.
   * If multiple EnvoyPatchPolicies are applied to the same
   * TargetRef, they will be applied in the ascending order of
   * the priority i.e. int32.min has the highest priority and
   * int32.max has the lowest priority.
   * Defaults to 0.
   *
   * @default 0.
   * @schema EnvoyPatchPolicySpec#priority
   */
  readonly priority?: number;

  /**
   * TargetRef is the name of the Gateway API resource this policy
   * is being attached to.
   * By default, attaching to Gateway is supported and
   * when mergeGateways is enabled it should attach to GatewayClass.
   * This Policy and the TargetRef MUST be in the same namespace
   * for this Policy to have effect and be applied to the Gateway
   * TargetRef
   *
   * @schema EnvoyPatchPolicySpec#targetRef
   */
  readonly targetRef: EnvoyPatchPolicySpecTargetRef;

  /**
   * Type decides the type of patch.
   * Valid EnvoyPatchType values are "JSONPatch".
   *
   * @schema EnvoyPatchPolicySpec#type
   */
  readonly type: EnvoyPatchPolicySpecType;
}

/**
 * Converts an object of type 'EnvoyPatchPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyPatchPolicySpec(obj: EnvoyPatchPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jsonPatches': obj.jsonPatches?.map(y => toJson_EnvoyPatchPolicySpecJsonPatches(y)),
    'priority': obj.priority,
    'targetRef': toJson_EnvoyPatchPolicySpecTargetRef(obj.targetRef),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvoyJSONPatchConfig defines the configuration for patching a Envoy xDS Resource
 * using JSONPatch semantic
 *
 * @schema EnvoyPatchPolicySpecJsonPatches
 */
export interface EnvoyPatchPolicySpecJsonPatches {
  /**
   * Name is the name of the resource
   *
   * @schema EnvoyPatchPolicySpecJsonPatches#name
   */
  readonly name: string;

  /**
   * Patch defines the JSON Patch Operation
   *
   * @schema EnvoyPatchPolicySpecJsonPatches#operation
   */
  readonly operation: EnvoyPatchPolicySpecJsonPatchesOperation;

  /**
   * Type is the typed URL of the Envoy xDS Resource
   *
   * @schema EnvoyPatchPolicySpecJsonPatches#type
   */
  readonly type: EnvoyPatchPolicySpecJsonPatchesType;
}

/**
 * Converts an object of type 'EnvoyPatchPolicySpecJsonPatches' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyPatchPolicySpecJsonPatches(obj: EnvoyPatchPolicySpecJsonPatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'operation': toJson_EnvoyPatchPolicySpecJsonPatchesOperation(obj.operation),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TargetRef is the name of the Gateway API resource this policy
 * is being attached to.
 * By default, attaching to Gateway is supported and
 * when mergeGateways is enabled it should attach to GatewayClass.
 * This Policy and the TargetRef MUST be in the same namespace
 * for this Policy to have effect and be applied to the Gateway
 * TargetRef
 *
 * @schema EnvoyPatchPolicySpecTargetRef
 */
export interface EnvoyPatchPolicySpecTargetRef {
  /**
   * Group is the group of the target resource.
   *
   * @schema EnvoyPatchPolicySpecTargetRef#group
   */
  readonly group: string;

  /**
   * Kind is kind of the target resource.
   *
   * @schema EnvoyPatchPolicySpecTargetRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of the target resource.
   *
   * @schema EnvoyPatchPolicySpecTargetRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EnvoyPatchPolicySpecTargetRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyPatchPolicySpecTargetRef(obj: EnvoyPatchPolicySpecTargetRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type decides the type of patch.
 * Valid EnvoyPatchType values are "JSONPatch".
 *
 * @schema EnvoyPatchPolicySpecType
 */
export enum EnvoyPatchPolicySpecType {
  /** JSONPatch */
  JSON_PATCH = "JSONPatch",
}

/**
 * Patch defines the JSON Patch Operation
 *
 * @schema EnvoyPatchPolicySpecJsonPatchesOperation
 */
export interface EnvoyPatchPolicySpecJsonPatchesOperation {
  /**
   * From is the source location of the value to be copied or moved. Only valid
   * for move or copy operations
   * Refer to https://datatracker.ietf.org/doc/html/rfc6901 for more details.
   *
   * @schema EnvoyPatchPolicySpecJsonPatchesOperation#from
   */
  readonly from?: string;

  /**
   * JSONPath is a JSONPath expression. Refer to https://datatracker.ietf.org/doc/rfc9535/ for more details.
   * It produces one or more JSONPointer expressions based on the given JSON document.
   * If no JSONPointer is found, it will result in an error.
   * If the 'Path' property is also set, it will be appended to the resulting JSONPointer expressions from the JSONPath evaluation.
   * This is useful when creating a property that does not yet exist in the JSON document.
   * The final JSONPointer expressions specifies the locations in the target document/field where the operation will be applied.
   *
   * @schema EnvoyPatchPolicySpecJsonPatchesOperation#jsonPath
   */
  readonly jsonPath?: string;

  /**
   * Op is the type of operation to perform
   *
   * @schema EnvoyPatchPolicySpecJsonPatchesOperation#op
   */
  readonly op: EnvoyPatchPolicySpecJsonPatchesOperationOp;

  /**
   * Path is a JSONPointer expression. Refer to https://datatracker.ietf.org/doc/html/rfc6901 for more details.
   * It specifies the location of the target document/field where the operation will be performed
   *
   * @schema EnvoyPatchPolicySpecJsonPatchesOperation#path
   */
  readonly path?: string;

  /**
   * Value is the new value of the path location. The value is only used by
   * the `add` and `replace` operations.
   *
   * @schema EnvoyPatchPolicySpecJsonPatchesOperation#value
   */
  readonly value?: any;
}

/**
 * Converts an object of type 'EnvoyPatchPolicySpecJsonPatchesOperation' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyPatchPolicySpecJsonPatchesOperation(obj: EnvoyPatchPolicySpecJsonPatchesOperation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'jsonPath': obj.jsonPath,
    'op': obj.op,
    'path': obj.path,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type is the typed URL of the Envoy xDS Resource
 *
 * @schema EnvoyPatchPolicySpecJsonPatchesType
 */
export enum EnvoyPatchPolicySpecJsonPatchesType {
  /** type.googleapis.com/envoy.config.listener.v3.Listener */
  TYPE_PERIOD_GOOGLEAPIS_PERIOD_COM_FORWARD_SLASH_ENVOY_PERIOD_CONFIG_PERIOD_LISTENER_PERIOD_V3_PERIOD_LISTENER = "type.googleapis.com/envoy.config.listener.v3.Listener",
  /** type.googleapis.com/envoy.config.route.v3.RouteConfiguration */
  TYPE_PERIOD_GOOGLEAPIS_PERIOD_COM_FORWARD_SLASH_ENVOY_PERIOD_CONFIG_PERIOD_ROUTE_PERIOD_V3_PERIOD_ROUTE_CONFIGURATION = "type.googleapis.com/envoy.config.route.v3.RouteConfiguration",
  /** type.googleapis.com/envoy.config.cluster.v3.Cluster */
  TYPE_PERIOD_GOOGLEAPIS_PERIOD_COM_FORWARD_SLASH_ENVOY_PERIOD_CONFIG_PERIOD_CLUSTER_PERIOD_V3_PERIOD_CLUSTER = "type.googleapis.com/envoy.config.cluster.v3.Cluster",
  /** type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment */
  TYPE_PERIOD_GOOGLEAPIS_PERIOD_COM_FORWARD_SLASH_ENVOY_PERIOD_CONFIG_PERIOD_ENDPOINT_PERIOD_V3_PERIOD_CLUSTER_LOAD_ASSIGNMENT = "type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment",
  /** type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.Secret */
  TYPE_PERIOD_GOOGLEAPIS_PERIOD_COM_FORWARD_SLASH_ENVOY_PERIOD_EXTENSIONS_PERIOD_TRANSPORT_UNDERSCORE_SOCKETS_PERIOD_TLS_PERIOD_V3_PERIOD_SECRET = "type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.Secret",
}

/**
 * Op is the type of operation to perform
 *
 * @schema EnvoyPatchPolicySpecJsonPatchesOperationOp
 */
export enum EnvoyPatchPolicySpecJsonPatchesOperationOp {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
  /** move */
  MOVE = "move",
  /** copy */
  COPY = "copy",
  /** test */
  TEST = "test",
}


/**
 * EnvoyProxy is the schema for the envoyproxies API.
 *
 * @schema EnvoyProxy
 */
export class EnvoyProxy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EnvoyProxy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'gateway.envoyproxy.io/v1alpha1',
    kind: 'EnvoyProxy',
  }

  /**
   * Renders a Kubernetes manifest for "EnvoyProxy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EnvoyProxyProps = {}): any {
    return {
      ...EnvoyProxy.GVK,
      ...toJson_EnvoyProxyProps(props),
    };
  }

  /**
   * Defines a "EnvoyProxy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EnvoyProxyProps = {}) {
    super(scope, id, {
      ...EnvoyProxy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...EnvoyProxy.GVK,
      ...toJson_EnvoyProxyProps(resolved),
    };
  }
}

/**
 * EnvoyProxy is the schema for the envoyproxies API.
 *
 * @schema EnvoyProxy
 */
export interface EnvoyProxyProps {
  /**
   * @schema EnvoyProxy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EnvoyProxySpec defines the desired state of EnvoyProxy.
   *
   * @schema EnvoyProxy#spec
   */
  readonly spec?: EnvoyProxySpec;
}

/**
 * Converts an object of type 'EnvoyProxyProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxyProps(obj: EnvoyProxyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EnvoyProxySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvoyProxySpec defines the desired state of EnvoyProxy.
 *
 * @schema EnvoyProxySpec
 */
export interface EnvoyProxySpec {
  /**
   * BackendTLS is the TLS configuration for the Envoy proxy to use when connecting to backends.
   * These settings are applied on backends for which TLS policies are specified.
   *
   * @schema EnvoyProxySpec#backendTLS
   */
  readonly backendTls?: EnvoyProxySpecBackendTls;

  /**
   * Bootstrap defines the Envoy Bootstrap as a YAML string.
   * Visit https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/bootstrap/v3/bootstrap.proto#envoy-v3-api-msg-config-bootstrap-v3-bootstrap
   * to learn more about the syntax.
   * If set, this is the Bootstrap configuration used for the managed Envoy Proxy fleet instead of the default Bootstrap configuration
   * set by Envoy Gateway.
   * Some fields within the Bootstrap that are required to communicate with the xDS Server (Envoy Gateway) and receive xDS resources
   * from it are not configurable and will result in the `EnvoyProxy` resource being rejected.
   * Backward compatibility across minor versions is not guaranteed.
   * We strongly recommend using `egctl x translate` to generate a `EnvoyProxy` resource with the `Bootstrap` field set to the default
   * Bootstrap configuration used. You can edit this configuration, and rerun `egctl x translate` to ensure there are no validation errors.
   *
   * @schema EnvoyProxySpec#bootstrap
   */
  readonly bootstrap?: EnvoyProxySpecBootstrap;

  /**
   * Concurrency defines the number of worker threads to run. If unset, it defaults to
   * the number of cpuset threads on the platform.
   *
   * @schema EnvoyProxySpec#concurrency
   */
  readonly concurrency?: number;

  /**
   * ExtraArgs defines additional command line options that are provided to Envoy.
   * More info: https://www.envoyproxy.io/docs/envoy/latest/operations/cli#command-line-options
   * Note: some command line options are used internally(e.g. --log-level) so they cannot be provided here.
   *
   * @schema EnvoyProxySpec#extraArgs
   */
  readonly extraArgs?: string[];

  /**
   * FilterOrder defines the order of filters in the Envoy proxy's HTTP filter chain.
   * The FilterPosition in the list will be applied in the order they are defined.
   * If unspecified, the default filter order is applied.
   * Default filter order is:
   *
   * - envoy.filters.http.health_check
   *
   * - envoy.filters.http.fault
   *
   * - envoy.filters.http.cors
   *
   * - envoy.filters.http.ext_authz
   *
   * - envoy.filters.http.api_key_auth
   *
   * - envoy.filters.http.basic_auth
   *
   * - envoy.filters.http.oauth2
   *
   * - envoy.filters.http.jwt_authn
   *
   * - envoy.filters.http.stateful_session
   *
   * - envoy.filters.http.buffer
   *
   * - envoy.filters.http.lua
   *
   * - envoy.filters.http.ext_proc
   *
   * - envoy.filters.http.wasm
   *
   * - envoy.filters.http.rbac
   *
   * - envoy.filters.http.local_ratelimit
   *
   * - envoy.filters.http.ratelimit
   *
   * - envoy.filters.http.grpc_web
   *
   * - envoy.filters.http.grpc_stats
   *
   * - envoy.filters.http.custom_response
   *
   * - envoy.filters.http.credential_injector
   *
   * - envoy.filters.http.compressor
   *
   * - envoy.filters.http.router
   *
   * Note: "envoy.filters.http.router" cannot be reordered, it's always the last filter in the chain.
   *
   * @schema EnvoyProxySpec#filterOrder
   */
  readonly filterOrder?: EnvoyProxySpecFilterOrder[];

  /**
   * IPFamily specifies the IP family for the EnvoyProxy fleet.
   * This setting only affects the Gateway listener port and does not impact
   * other aspects of the Envoy proxy configuration.
   * If not specified, the system will operate as follows:
   * - It defaults to IPv4 only.
   * - IPv6 and dual-stack environments are not supported in this default configuration.
   * Note: To enable IPv6 or dual-stack functionality, explicit configuration is required.
   *
   * @schema EnvoyProxySpec#ipFamily
   */
  readonly ipFamily?: EnvoyProxySpecIpFamily;

  /**
   * Logging defines logging parameters for managed proxies.
   *
   * @schema EnvoyProxySpec#logging
   */
  readonly logging?: EnvoyProxySpecLogging;

  /**
   * LuaValidation determines strictness of the Lua script validation for Lua EnvoyExtensionPolicies
   * Default: Strict
   *
   * @schema EnvoyProxySpec#luaValidation
   */
  readonly luaValidation?: EnvoyProxySpecLuaValidation;

  /**
   * MergeGateways defines if Gateway resources should be merged onto the same Envoy Proxy Infrastructure.
   * Setting this field to true would merge all Gateway Listeners under the parent Gateway Class.
   * This means that the port, protocol and hostname tuple must be unique for every listener.
   * If a duplicate listener is detected, the newer listener (based on timestamp) will be rejected and its status will be updated with a "Accepted=False" condition.
   *
   * @schema EnvoyProxySpec#mergeGateways
   */
  readonly mergeGateways?: boolean;

  /**
   * PreserveRouteOrder determines if the order of matching for HTTPRoutes is determined by Gateway-API
   * specification (https://gateway-api.sigs.k8s.io/reference/1.4/spec/#httprouterule)
   * or preserves the order defined by users in the HTTPRoute's HTTPRouteRule list.
   * Default: False
   *
   * @schema EnvoyProxySpec#preserveRouteOrder
   */
  readonly preserveRouteOrder?: boolean;

  /**
   * Provider defines the desired resource provider and provider-specific configuration.
   * If unspecified, the "Kubernetes" resource provider is used with default configuration
   * parameters.
   *
   * @schema EnvoyProxySpec#provider
   */
  readonly provider?: EnvoyProxySpecProvider;

  /**
   * RoutingType can be set to "Service" to use the Service Cluster IP for routing to the backend,
   * or it can be set to "Endpoint" to use Endpoint routing. The default is "Endpoint".
   *
   * @schema EnvoyProxySpec#routingType
   */
  readonly routingType?: string;

  /**
   * Shutdown defines configuration for graceful envoy shutdown process.
   *
   * @schema EnvoyProxySpec#shutdown
   */
  readonly shutdown?: EnvoyProxySpecShutdown;

  /**
   * Telemetry defines telemetry parameters for managed proxies.
   *
   * @schema EnvoyProxySpec#telemetry
   */
  readonly telemetry?: EnvoyProxySpecTelemetry;
}

/**
 * Converts an object of type 'EnvoyProxySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpec(obj: EnvoyProxySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendTLS': toJson_EnvoyProxySpecBackendTls(obj.backendTls),
    'bootstrap': toJson_EnvoyProxySpecBootstrap(obj.bootstrap),
    'concurrency': obj.concurrency,
    'extraArgs': obj.extraArgs?.map(y => y),
    'filterOrder': obj.filterOrder?.map(y => toJson_EnvoyProxySpecFilterOrder(y)),
    'ipFamily': obj.ipFamily,
    'logging': toJson_EnvoyProxySpecLogging(obj.logging),
    'luaValidation': obj.luaValidation,
    'mergeGateways': obj.mergeGateways,
    'preserveRouteOrder': obj.preserveRouteOrder,
    'provider': toJson_EnvoyProxySpecProvider(obj.provider),
    'routingType': obj.routingType,
    'shutdown': toJson_EnvoyProxySpecShutdown(obj.shutdown),
    'telemetry': toJson_EnvoyProxySpecTelemetry(obj.telemetry),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendTLS is the TLS configuration for the Envoy proxy to use when connecting to backends.
 * These settings are applied on backends for which TLS policies are specified.
 *
 * @schema EnvoyProxySpecBackendTls
 */
export interface EnvoyProxySpecBackendTls {
  /**
   * ALPNProtocols supplies the list of ALPN protocols that should be
   * exposed by the listener or used by the proxy to connect to the backend.
   * Defaults:
   * 1. HTTPS Routes: h2 and http/1.1 are enabled in listener context.
   * 2. Other Routes: ALPN is disabled.
   * 3. Backends: proxy uses the appropriate ALPN options for the backend protocol.
   * When an empty list is provided, the ALPN TLS extension is disabled.
   *
   * Defaults to [h2, http/1.1] if not specified.
   *
   * Typical Supported values are:
   * - http/1.0
   * - http/1.1
   * - h2
   *
   * @default h2, http/1.1] if not specified.
   * @schema EnvoyProxySpecBackendTls#alpnProtocols
   */
  readonly alpnProtocols?: string[];

  /**
   * Ciphers specifies the set of cipher suites supported when
   * negotiating TLS 1.0 - 1.2. This setting has no effect for TLS 1.3.
   * In non-FIPS Envoy Proxy builds the default cipher list is:
   * - [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
   * - [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
   * - ECDHE-ECDSA-AES256-GCM-SHA384
   * - ECDHE-RSA-AES256-GCM-SHA384
   * In builds using BoringSSL FIPS the default cipher list is:
   * - ECDHE-ECDSA-AES128-GCM-SHA256
   * - ECDHE-RSA-AES128-GCM-SHA256
   * - ECDHE-ECDSA-AES256-GCM-SHA384
   * - ECDHE-RSA-AES256-GCM-SHA384
   *
   * @schema EnvoyProxySpecBackendTls#ciphers
   */
  readonly ciphers?: string[];

  /**
   * ClientCertificateRef defines the reference to a Kubernetes Secret that contains
   * the client certificate and private key for Envoy to use when connecting to
   * backend services and external services, such as ExtAuth, ALS, OpenTelemetry, etc.
   * This secret should be located within the same namespace as the Envoy proxy resource that references it.
   *
   * @schema EnvoyProxySpecBackendTls#clientCertificateRef
   */
  readonly clientCertificateRef?: EnvoyProxySpecBackendTlsClientCertificateRef;

  /**
   * ECDHCurves specifies the set of supported ECDH curves.
   * In non-FIPS Envoy Proxy builds the default curves are:
   * - X25519
   * - P-256
   * In builds using BoringSSL FIPS the default curve is:
   * - P-256
   *
   * @schema EnvoyProxySpecBackendTls#ecdhCurves
   */
  readonly ecdhCurves?: string[];

  /**
   * Max specifies the maximal TLS protocol version to allow
   * The default is TLS 1.3 if this is not specified.
   *
   * @schema EnvoyProxySpecBackendTls#maxVersion
   */
  readonly maxVersion?: EnvoyProxySpecBackendTlsMaxVersion;

  /**
   * Min specifies the minimal TLS protocol version to allow.
   * The default is TLS 1.2 if this is not specified.
   *
   * @schema EnvoyProxySpecBackendTls#minVersion
   */
  readonly minVersion?: EnvoyProxySpecBackendTlsMinVersion;

  /**
   * SignatureAlgorithms specifies which signature algorithms the listener should
   * support.
   *
   * @schema EnvoyProxySpecBackendTls#signatureAlgorithms
   */
  readonly signatureAlgorithms?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecBackendTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecBackendTls(obj: EnvoyProxySpecBackendTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alpnProtocols': obj.alpnProtocols?.map(y => y),
    'ciphers': obj.ciphers?.map(y => y),
    'clientCertificateRef': toJson_EnvoyProxySpecBackendTlsClientCertificateRef(obj.clientCertificateRef),
    'ecdhCurves': obj.ecdhCurves?.map(y => y),
    'maxVersion': obj.maxVersion,
    'minVersion': obj.minVersion,
    'signatureAlgorithms': obj.signatureAlgorithms?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Bootstrap defines the Envoy Bootstrap as a YAML string.
 * Visit https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/bootstrap/v3/bootstrap.proto#envoy-v3-api-msg-config-bootstrap-v3-bootstrap
 * to learn more about the syntax.
 * If set, this is the Bootstrap configuration used for the managed Envoy Proxy fleet instead of the default Bootstrap configuration
 * set by Envoy Gateway.
 * Some fields within the Bootstrap that are required to communicate with the xDS Server (Envoy Gateway) and receive xDS resources
 * from it are not configurable and will result in the `EnvoyProxy` resource being rejected.
 * Backward compatibility across minor versions is not guaranteed.
 * We strongly recommend using `egctl x translate` to generate a `EnvoyProxy` resource with the `Bootstrap` field set to the default
 * Bootstrap configuration used. You can edit this configuration, and rerun `egctl x translate` to ensure there are no validation errors.
 *
 * @schema EnvoyProxySpecBootstrap
 */
export interface EnvoyProxySpecBootstrap {
  /**
   * JSONPatches is an array of JSONPatches to be applied to the default bootstrap. Patches are
   * applied in the order in which they are defined.
   *
   * @schema EnvoyProxySpecBootstrap#jsonPatches
   */
  readonly jsonPatches?: EnvoyProxySpecBootstrapJsonPatches[];

  /**
   * Type is the type of the bootstrap configuration, it should be either **Replace**,  **Merge**, or **JSONPatch**.
   * If unspecified, it defaults to Replace.
   *
   * @schema EnvoyProxySpecBootstrap#type
   */
  readonly type?: EnvoyProxySpecBootstrapType;

  /**
   * Value is a YAML string of the bootstrap.
   *
   * @schema EnvoyProxySpecBootstrap#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecBootstrap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecBootstrap(obj: EnvoyProxySpecBootstrap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jsonPatches': obj.jsonPatches?.map(y => toJson_EnvoyProxySpecBootstrapJsonPatches(y)),
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FilterPosition defines the position of an Envoy HTTP filter in the filter chain.
 *
 * @schema EnvoyProxySpecFilterOrder
 */
export interface EnvoyProxySpecFilterOrder {
  /**
   * After defines the filter that should come after the filter.
   * Only one of Before or After must be set.
   *
   * @schema EnvoyProxySpecFilterOrder#after
   */
  readonly after?: EnvoyProxySpecFilterOrderAfter;

  /**
   * Before defines the filter that should come before the filter.
   * Only one of Before or After must be set.
   *
   * @schema EnvoyProxySpecFilterOrder#before
   */
  readonly before?: EnvoyProxySpecFilterOrderBefore;

  /**
   * Name of the filter.
   *
   * @schema EnvoyProxySpecFilterOrder#name
   */
  readonly name: EnvoyProxySpecFilterOrderName;
}

/**
 * Converts an object of type 'EnvoyProxySpecFilterOrder' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecFilterOrder(obj: EnvoyProxySpecFilterOrder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'after': obj.after,
    'before': obj.before,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * IPFamily specifies the IP family for the EnvoyProxy fleet.
 * This setting only affects the Gateway listener port and does not impact
 * other aspects of the Envoy proxy configuration.
 * If not specified, the system will operate as follows:
 * - It defaults to IPv4 only.
 * - IPv6 and dual-stack environments are not supported in this default configuration.
 * Note: To enable IPv6 or dual-stack functionality, explicit configuration is required.
 *
 * @schema EnvoyProxySpecIpFamily
 */
export enum EnvoyProxySpecIpFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
  /** DualStack */
  DUAL_STACK = "DualStack",
}

/**
 * Logging defines logging parameters for managed proxies.
 *
 * @schema EnvoyProxySpecLogging
 */
export interface EnvoyProxySpecLogging {
  /**
   * Level is a map of logging level per component, where the component is the key
   * and the log level is the value. If unspecified, defaults to "default: warn".
   *
   * @schema EnvoyProxySpecLogging#level
   */
  readonly level?: { [key: string]: EnvoyProxySpecLoggingLevel };
}

/**
 * Converts an object of type 'EnvoyProxySpecLogging' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecLogging(obj: EnvoyProxySpecLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': ((obj.level) === undefined) ? undefined : (Object.entries(obj.level).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LuaValidation determines strictness of the Lua script validation for Lua EnvoyExtensionPolicies
 * Default: Strict
 *
 * @schema EnvoyProxySpecLuaValidation
 */
export enum EnvoyProxySpecLuaValidation {
  /** Strict */
  STRICT = "Strict",
  /** Disabled */
  DISABLED = "Disabled",
}

/**
 * Provider defines the desired resource provider and provider-specific configuration.
 * If unspecified, the "Kubernetes" resource provider is used with default configuration
 * parameters.
 *
 * @schema EnvoyProxySpecProvider
 */
export interface EnvoyProxySpecProvider {
  /**
   * Host provides runtime deployment of the data plane as a child process on the
   * host environment.
   * If unspecified and type is "Host", default settings for the custom provider
   * are applied.
   *
   * @schema EnvoyProxySpecProvider#host
   */
  readonly host?: EnvoyProxySpecProviderHost;

  /**
   * Kubernetes defines the desired state of the Kubernetes resource provider.
   * Kubernetes provides infrastructure resources for running the data plane,
   * e.g. Envoy proxy. If unspecified and type is "Kubernetes", default settings
   * for managed Kubernetes resources are applied.
   *
   * @schema EnvoyProxySpecProvider#kubernetes
   */
  readonly kubernetes?: EnvoyProxySpecProviderKubernetes;

  /**
   * Type is the type of resource provider to use. A resource provider provides
   * infrastructure resources for running the data plane, e.g. Envoy proxy, and
   * optional auxiliary control planes. Supported types are "Kubernetes"and "Host".
   *
   * @schema EnvoyProxySpecProvider#type
   */
  readonly type: EnvoyProxySpecProviderType;
}

/**
 * Converts an object of type 'EnvoyProxySpecProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProvider(obj: EnvoyProxySpecProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': toJson_EnvoyProxySpecProviderHost(obj.host),
    'kubernetes': toJson_EnvoyProxySpecProviderKubernetes(obj.kubernetes),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Shutdown defines configuration for graceful envoy shutdown process.
 *
 * @schema EnvoyProxySpecShutdown
 */
export interface EnvoyProxySpecShutdown {
  /**
   * DrainTimeout defines the graceful drain timeout. This should be less than the pod's terminationGracePeriodSeconds.
   * If unspecified, defaults to 60 seconds.
   *
   * @schema EnvoyProxySpecShutdown#drainTimeout
   */
  readonly drainTimeout?: string;

  /**
   * MinDrainDuration defines the minimum drain duration allowing time for endpoint deprogramming to complete.
   * If unspecified, defaults to 10 seconds.
   *
   * @schema EnvoyProxySpecShutdown#minDrainDuration
   */
  readonly minDrainDuration?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecShutdown' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecShutdown(obj: EnvoyProxySpecShutdown | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'drainTimeout': obj.drainTimeout,
    'minDrainDuration': obj.minDrainDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Telemetry defines telemetry parameters for managed proxies.
 *
 * @schema EnvoyProxySpecTelemetry
 */
export interface EnvoyProxySpecTelemetry {
  /**
   * AccessLogs defines accesslog parameters for managed proxies.
   * If unspecified, will send default format to stdout.
   *
   * @schema EnvoyProxySpecTelemetry#accessLog
   */
  readonly accessLog?: EnvoyProxySpecTelemetryAccessLog;

  /**
   * Metrics defines metrics configuration for managed proxies.
   *
   * @schema EnvoyProxySpecTelemetry#metrics
   */
  readonly metrics?: EnvoyProxySpecTelemetryMetrics;

  /**
   * Tracing defines tracing configuration for managed proxies.
   * If unspecified, will not send tracing data.
   *
   * @schema EnvoyProxySpecTelemetry#tracing
   */
  readonly tracing?: EnvoyProxySpecTelemetryTracing;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetry(obj: EnvoyProxySpecTelemetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLog': toJson_EnvoyProxySpecTelemetryAccessLog(obj.accessLog),
    'metrics': toJson_EnvoyProxySpecTelemetryMetrics(obj.metrics),
    'tracing': toJson_EnvoyProxySpecTelemetryTracing(obj.tracing),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientCertificateRef defines the reference to a Kubernetes Secret that contains
 * the client certificate and private key for Envoy to use when connecting to
 * backend services and external services, such as ExtAuth, ALS, OpenTelemetry, etc.
 * This secret should be located within the same namespace as the Envoy proxy resource that references it.
 *
 * @schema EnvoyProxySpecBackendTlsClientCertificateRef
 */
export interface EnvoyProxySpecBackendTlsClientCertificateRef {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema EnvoyProxySpecBackendTlsClientCertificateRef#group
   */
  readonly group?: string;

  /**
   * Kind is kind of the referent. For example "Secret".
   *
   * @schema EnvoyProxySpecBackendTlsClientCertificateRef#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema EnvoyProxySpecBackendTlsClientCertificateRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the referenced object. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema EnvoyProxySpecBackendTlsClientCertificateRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecBackendTlsClientCertificateRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecBackendTlsClientCertificateRef(obj: EnvoyProxySpecBackendTlsClientCertificateRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Max specifies the maximal TLS protocol version to allow
 * The default is TLS 1.3 if this is not specified.
 *
 * @schema EnvoyProxySpecBackendTlsMaxVersion
 */
export enum EnvoyProxySpecBackendTlsMaxVersion {
  /** Auto */
  AUTO = "Auto",
  /** 1.0 */
  VALUE_1_0 = "1.0",
  /** 1.1 */
  VALUE_1_1 = "1.1",
  /** 1.2 */
  VALUE_1_2 = "1.2",
  /** 1.3 */
  VALUE_1_3 = "1.3",
}

/**
 * Min specifies the minimal TLS protocol version to allow.
 * The default is TLS 1.2 if this is not specified.
 *
 * @schema EnvoyProxySpecBackendTlsMinVersion
 */
export enum EnvoyProxySpecBackendTlsMinVersion {
  /** Auto */
  AUTO = "Auto",
  /** 1.0 */
  VALUE_1_0 = "1.0",
  /** 1.1 */
  VALUE_1_1 = "1.1",
  /** 1.2 */
  VALUE_1_2 = "1.2",
  /** 1.3 */
  VALUE_1_3 = "1.3",
}

/**
 * JSONPatchOperation defines the JSON Patch Operation as defined in
 * https://datatracker.ietf.org/doc/html/rfc6902
 *
 * @schema EnvoyProxySpecBootstrapJsonPatches
 */
export interface EnvoyProxySpecBootstrapJsonPatches {
  /**
   * From is the source location of the value to be copied or moved. Only valid
   * for move or copy operations
   * Refer to https://datatracker.ietf.org/doc/html/rfc6901 for more details.
   *
   * @schema EnvoyProxySpecBootstrapJsonPatches#from
   */
  readonly from?: string;

  /**
   * JSONPath is a JSONPath expression. Refer to https://datatracker.ietf.org/doc/rfc9535/ for more details.
   * It produces one or more JSONPointer expressions based on the given JSON document.
   * If no JSONPointer is found, it will result in an error.
   * If the 'Path' property is also set, it will be appended to the resulting JSONPointer expressions from the JSONPath evaluation.
   * This is useful when creating a property that does not yet exist in the JSON document.
   * The final JSONPointer expressions specifies the locations in the target document/field where the operation will be applied.
   *
   * @schema EnvoyProxySpecBootstrapJsonPatches#jsonPath
   */
  readonly jsonPath?: string;

  /**
   * Op is the type of operation to perform
   *
   * @schema EnvoyProxySpecBootstrapJsonPatches#op
   */
  readonly op: EnvoyProxySpecBootstrapJsonPatchesOp;

  /**
   * Path is a JSONPointer expression. Refer to https://datatracker.ietf.org/doc/html/rfc6901 for more details.
   * It specifies the location of the target document/field where the operation will be performed
   *
   * @schema EnvoyProxySpecBootstrapJsonPatches#path
   */
  readonly path?: string;

  /**
   * Value is the new value of the path location. The value is only used by
   * the `add` and `replace` operations.
   *
   * @schema EnvoyProxySpecBootstrapJsonPatches#value
   */
  readonly value?: any;
}

/**
 * Converts an object of type 'EnvoyProxySpecBootstrapJsonPatches' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecBootstrapJsonPatches(obj: EnvoyProxySpecBootstrapJsonPatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'jsonPath': obj.jsonPath,
    'op': obj.op,
    'path': obj.path,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type is the type of the bootstrap configuration, it should be either **Replace**,  **Merge**, or **JSONPatch**.
 * If unspecified, it defaults to Replace.
 *
 * @schema EnvoyProxySpecBootstrapType
 */
export enum EnvoyProxySpecBootstrapType {
  /** Merge */
  MERGE = "Merge",
  /** Replace */
  REPLACE = "Replace",
  /** JSONPatch */
  JSON_PATCH = "JSONPatch",
}

/**
 * After defines the filter that should come after the filter.
 * Only one of Before or After must be set.
 *
 * @schema EnvoyProxySpecFilterOrderAfter
 */
export enum EnvoyProxySpecFilterOrderAfter {
  /** envoy.filters.http.health_check */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_HEALTH_UNDERSCORE_CHECK = "envoy.filters.http.health_check",
  /** envoy.filters.http.fault */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_FAULT = "envoy.filters.http.fault",
  /** envoy.filters.http.cors */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_CORS = "envoy.filters.http.cors",
  /** envoy.filters.http.ext_authz */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_EXT_UNDERSCORE_AUTHZ = "envoy.filters.http.ext_authz",
  /** envoy.filters.http.api_key_auth */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_API_UNDERSCORE_KEY_UNDERSCORE_AUTH = "envoy.filters.http.api_key_auth",
  /** envoy.filters.http.basic_auth */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_BASIC_UNDERSCORE_AUTH = "envoy.filters.http.basic_auth",
  /** envoy.filters.http.oauth2 */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_OAUTH2 = "envoy.filters.http.oauth2",
  /** envoy.filters.http.jwt_authn */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_JWT_UNDERSCORE_AUTHN = "envoy.filters.http.jwt_authn",
  /** envoy.filters.http.stateful_session */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_STATEFUL_UNDERSCORE_SESSION = "envoy.filters.http.stateful_session",
  /** envoy.filters.http.buffer */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_BUFFER = "envoy.filters.http.buffer",
  /** envoy.filters.http.lua */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_LUA = "envoy.filters.http.lua",
  /** envoy.filters.http.ext_proc */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_EXT_UNDERSCORE_PROC = "envoy.filters.http.ext_proc",
  /** envoy.filters.http.wasm */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_WASM = "envoy.filters.http.wasm",
  /** envoy.filters.http.rbac */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_RBAC = "envoy.filters.http.rbac",
  /** envoy.filters.http.local_ratelimit */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_LOCAL_UNDERSCORE_RATELIMIT = "envoy.filters.http.local_ratelimit",
  /** envoy.filters.http.ratelimit */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_RATELIMIT = "envoy.filters.http.ratelimit",
  /** envoy.filters.http.grpc_web */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_GRPC_UNDERSCORE_WEB = "envoy.filters.http.grpc_web",
  /** envoy.filters.http.grpc_stats */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_GRPC_UNDERSCORE_STATS = "envoy.filters.http.grpc_stats",
  /** envoy.filters.http.custom_response */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_CUSTOM_UNDERSCORE_RESPONSE = "envoy.filters.http.custom_response",
  /** envoy.filters.http.credential_injector */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_CREDENTIAL_UNDERSCORE_INJECTOR = "envoy.filters.http.credential_injector",
  /** envoy.filters.http.compressor */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_COMPRESSOR = "envoy.filters.http.compressor",
}

/**
 * Before defines the filter that should come before the filter.
 * Only one of Before or After must be set.
 *
 * @schema EnvoyProxySpecFilterOrderBefore
 */
export enum EnvoyProxySpecFilterOrderBefore {
  /** envoy.filters.http.health_check */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_HEALTH_UNDERSCORE_CHECK = "envoy.filters.http.health_check",
  /** envoy.filters.http.fault */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_FAULT = "envoy.filters.http.fault",
  /** envoy.filters.http.cors */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_CORS = "envoy.filters.http.cors",
  /** envoy.filters.http.ext_authz */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_EXT_UNDERSCORE_AUTHZ = "envoy.filters.http.ext_authz",
  /** envoy.filters.http.api_key_auth */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_API_UNDERSCORE_KEY_UNDERSCORE_AUTH = "envoy.filters.http.api_key_auth",
  /** envoy.filters.http.basic_auth */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_BASIC_UNDERSCORE_AUTH = "envoy.filters.http.basic_auth",
  /** envoy.filters.http.oauth2 */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_OAUTH2 = "envoy.filters.http.oauth2",
  /** envoy.filters.http.jwt_authn */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_JWT_UNDERSCORE_AUTHN = "envoy.filters.http.jwt_authn",
  /** envoy.filters.http.stateful_session */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_STATEFUL_UNDERSCORE_SESSION = "envoy.filters.http.stateful_session",
  /** envoy.filters.http.buffer */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_BUFFER = "envoy.filters.http.buffer",
  /** envoy.filters.http.lua */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_LUA = "envoy.filters.http.lua",
  /** envoy.filters.http.ext_proc */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_EXT_UNDERSCORE_PROC = "envoy.filters.http.ext_proc",
  /** envoy.filters.http.wasm */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_WASM = "envoy.filters.http.wasm",
  /** envoy.filters.http.rbac */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_RBAC = "envoy.filters.http.rbac",
  /** envoy.filters.http.local_ratelimit */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_LOCAL_UNDERSCORE_RATELIMIT = "envoy.filters.http.local_ratelimit",
  /** envoy.filters.http.ratelimit */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_RATELIMIT = "envoy.filters.http.ratelimit",
  /** envoy.filters.http.grpc_web */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_GRPC_UNDERSCORE_WEB = "envoy.filters.http.grpc_web",
  /** envoy.filters.http.grpc_stats */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_GRPC_UNDERSCORE_STATS = "envoy.filters.http.grpc_stats",
  /** envoy.filters.http.custom_response */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_CUSTOM_UNDERSCORE_RESPONSE = "envoy.filters.http.custom_response",
  /** envoy.filters.http.credential_injector */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_CREDENTIAL_UNDERSCORE_INJECTOR = "envoy.filters.http.credential_injector",
  /** envoy.filters.http.compressor */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_COMPRESSOR = "envoy.filters.http.compressor",
}

/**
 * Name of the filter.
 *
 * @schema EnvoyProxySpecFilterOrderName
 */
export enum EnvoyProxySpecFilterOrderName {
  /** envoy.filters.http.health_check */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_HEALTH_UNDERSCORE_CHECK = "envoy.filters.http.health_check",
  /** envoy.filters.http.fault */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_FAULT = "envoy.filters.http.fault",
  /** envoy.filters.http.cors */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_CORS = "envoy.filters.http.cors",
  /** envoy.filters.http.ext_authz */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_EXT_UNDERSCORE_AUTHZ = "envoy.filters.http.ext_authz",
  /** envoy.filters.http.api_key_auth */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_API_UNDERSCORE_KEY_UNDERSCORE_AUTH = "envoy.filters.http.api_key_auth",
  /** envoy.filters.http.basic_auth */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_BASIC_UNDERSCORE_AUTH = "envoy.filters.http.basic_auth",
  /** envoy.filters.http.oauth2 */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_OAUTH2 = "envoy.filters.http.oauth2",
  /** envoy.filters.http.jwt_authn */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_JWT_UNDERSCORE_AUTHN = "envoy.filters.http.jwt_authn",
  /** envoy.filters.http.stateful_session */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_STATEFUL_UNDERSCORE_SESSION = "envoy.filters.http.stateful_session",
  /** envoy.filters.http.buffer */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_BUFFER = "envoy.filters.http.buffer",
  /** envoy.filters.http.lua */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_LUA = "envoy.filters.http.lua",
  /** envoy.filters.http.ext_proc */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_EXT_UNDERSCORE_PROC = "envoy.filters.http.ext_proc",
  /** envoy.filters.http.wasm */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_WASM = "envoy.filters.http.wasm",
  /** envoy.filters.http.rbac */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_RBAC = "envoy.filters.http.rbac",
  /** envoy.filters.http.local_ratelimit */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_LOCAL_UNDERSCORE_RATELIMIT = "envoy.filters.http.local_ratelimit",
  /** envoy.filters.http.ratelimit */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_RATELIMIT = "envoy.filters.http.ratelimit",
  /** envoy.filters.http.grpc_web */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_GRPC_UNDERSCORE_WEB = "envoy.filters.http.grpc_web",
  /** envoy.filters.http.grpc_stats */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_GRPC_UNDERSCORE_STATS = "envoy.filters.http.grpc_stats",
  /** envoy.filters.http.custom_response */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_CUSTOM_UNDERSCORE_RESPONSE = "envoy.filters.http.custom_response",
  /** envoy.filters.http.credential_injector */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_CREDENTIAL_UNDERSCORE_INJECTOR = "envoy.filters.http.credential_injector",
  /** envoy.filters.http.compressor */
  ENVOY_PERIOD_FILTERS_PERIOD_HTTP_PERIOD_COMPRESSOR = "envoy.filters.http.compressor",
}

/**
 * LogLevel defines a log level for Envoy Gateway and EnvoyProxy system logs.
 *
 * @schema EnvoyProxySpecLoggingLevel
 */
export enum EnvoyProxySpecLoggingLevel {
  /** trace */
  TRACE = "trace",
  /** debug */
  DEBUG = "debug",
  /** info */
  INFO = "info",
  /** warn */
  WARN = "warn",
  /** error */
  ERROR = "error",
}

/**
 * Host provides runtime deployment of the data plane as a child process on the
 * host environment.
 * If unspecified and type is "Host", default settings for the custom provider
 * are applied.
 *
 * @schema EnvoyProxySpecProviderHost
 */
export interface EnvoyProxySpecProviderHost {
  /**
   * EnvoyVersion is the version of Envoy to use. If unspecified, the version
   * against which Envoy Gateway is built will be used.
   *
   * @schema EnvoyProxySpecProviderHost#envoyVersion
   */
  readonly envoyVersion?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderHost' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderHost(obj: EnvoyProxySpecProviderHost | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'envoyVersion': obj.envoyVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubernetes defines the desired state of the Kubernetes resource provider.
 * Kubernetes provides infrastructure resources for running the data plane,
 * e.g. Envoy proxy. If unspecified and type is "Kubernetes", default settings
 * for managed Kubernetes resources are applied.
 *
 * @schema EnvoyProxySpecProviderKubernetes
 */
export interface EnvoyProxySpecProviderKubernetes {
  /**
   * EnvoyDaemonSet defines the desired state of the Envoy daemonset resource.
   * Disabled by default, a deployment resource is used instead to provision the Envoy Proxy fleet
   *
   * @schema EnvoyProxySpecProviderKubernetes#envoyDaemonSet
   */
  readonly envoyDaemonSet?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSet;

  /**
   * EnvoyDeployment defines the desired state of the Envoy deployment resource.
   * If unspecified, default settings for the managed Envoy deployment resource
   * are applied.
   *
   * @schema EnvoyProxySpecProviderKubernetes#envoyDeployment
   */
  readonly envoyDeployment?: EnvoyProxySpecProviderKubernetesEnvoyDeployment;

  /**
   * EnvoyHpa defines the Horizontal Pod Autoscaler settings for Envoy Proxy Deployment.
   *
   * @schema EnvoyProxySpecProviderKubernetes#envoyHpa
   */
  readonly envoyHpa?: EnvoyProxySpecProviderKubernetesEnvoyHpa;

  /**
   * EnvoyPDB allows to control the pod disruption budget of an Envoy Proxy.
   *
   * @schema EnvoyProxySpecProviderKubernetes#envoyPDB
   */
  readonly envoyPdb?: EnvoyProxySpecProviderKubernetesEnvoyPdb;

  /**
   * EnvoyService defines the desired state of the Envoy service resource.
   * If unspecified, default settings for the managed Envoy service resource
   * are applied.
   *
   * @schema EnvoyProxySpecProviderKubernetes#envoyService
   */
  readonly envoyService?: EnvoyProxySpecProviderKubernetesEnvoyService;

  /**
   * EnvoyServiceAccount defines the desired state of the Envoy service account resource.
   *
   * @schema EnvoyProxySpecProviderKubernetes#envoyServiceAccount
   */
  readonly envoyServiceAccount?: EnvoyProxySpecProviderKubernetesEnvoyServiceAccount;

  /**
   * UseListenerPortAsContainerPort disables the port shifting feature in the Envoy Proxy.
   * When set to false (default value), if the service port is a privileged port (1-1023), add a constant to the value converting it into an ephemeral port.
   * This allows the container to bind to the port without needing a CAP_NET_BIND_SERVICE capability.
   *
   * @schema EnvoyProxySpecProviderKubernetes#useListenerPortAsContainerPort
   */
  readonly useListenerPortAsContainerPort?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetes(obj: EnvoyProxySpecProviderKubernetes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'envoyDaemonSet': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSet(obj.envoyDaemonSet),
    'envoyDeployment': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeployment(obj.envoyDeployment),
    'envoyHpa': toJson_EnvoyProxySpecProviderKubernetesEnvoyHpa(obj.envoyHpa),
    'envoyPDB': toJson_EnvoyProxySpecProviderKubernetesEnvoyPdb(obj.envoyPdb),
    'envoyService': toJson_EnvoyProxySpecProviderKubernetesEnvoyService(obj.envoyService),
    'envoyServiceAccount': toJson_EnvoyProxySpecProviderKubernetesEnvoyServiceAccount(obj.envoyServiceAccount),
    'useListenerPortAsContainerPort': obj.useListenerPortAsContainerPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type is the type of resource provider to use. A resource provider provides
 * infrastructure resources for running the data plane, e.g. Envoy proxy, and
 * optional auxiliary control planes. Supported types are "Kubernetes"and "Host".
 *
 * @schema EnvoyProxySpecProviderType
 */
export enum EnvoyProxySpecProviderType {
  /** Kubernetes */
  KUBERNETES = "Kubernetes",
  /** Host */
  HOST = "Host",
}

/**
 * AccessLogs defines accesslog parameters for managed proxies.
 * If unspecified, will send default format to stdout.
 *
 * @schema EnvoyProxySpecTelemetryAccessLog
 */
export interface EnvoyProxySpecTelemetryAccessLog {
  /**
   * Disable disables access logging for managed proxies if set to true.
   *
   * @schema EnvoyProxySpecTelemetryAccessLog#disable
   */
  readonly disable?: boolean;

  /**
   * Settings defines accesslog settings for managed proxies.
   * If unspecified, will send default format to stdout.
   *
   * @schema EnvoyProxySpecTelemetryAccessLog#settings
   */
  readonly settings?: EnvoyProxySpecTelemetryAccessLogSettings[];
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLog' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLog(obj: EnvoyProxySpecTelemetryAccessLog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disable': obj.disable,
    'settings': obj.settings?.map(y => toJson_EnvoyProxySpecTelemetryAccessLogSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metrics defines metrics configuration for managed proxies.
 *
 * @schema EnvoyProxySpecTelemetryMetrics
 */
export interface EnvoyProxySpecTelemetryMetrics {
  /**
   * ClusterStatName defines the value of cluster alt_stat_name, determining how cluster stats are named.
   * For more details, see envoy docs: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto.html
   * The supported operators for this pattern are:
   * %ROUTE_NAME%: name of Gateway API xRoute resource
   * %ROUTE_NAMESPACE%: namespace of Gateway API xRoute resource
   * %ROUTE_KIND%: kind of Gateway API xRoute resource
   * %ROUTE_RULE_NAME%: name of the Gateway API xRoute section
   * %ROUTE_RULE_NUMBER%: name of the Gateway API xRoute section
   * %BACKEND_REFS%: names of all backends referenced in <NAMESPACE>/<NAME>|<NAMESPACE>/<NAME>|... format
   * Only xDS Clusters created for HTTPRoute and GRPCRoute are currently supported.
   * Default: %ROUTE_KIND%/%ROUTE_NAMESPACE%/%ROUTE_NAME%/rule/%ROUTE_RULE_NUMBER%
   * Example: httproute/my-ns/my-route/rule/0
   *
   * @schema EnvoyProxySpecTelemetryMetrics#clusterStatName
   */
  readonly clusterStatName?: string;

  /**
   * EnablePerEndpointStats enables per endpoint envoy stats metrics.
   * Please use with caution.
   *
   * @schema EnvoyProxySpecTelemetryMetrics#enablePerEndpointStats
   */
  readonly enablePerEndpointStats?: boolean;

  /**
   * EnableRequestResponseSizesStats enables publishing of histograms tracking header and body sizes of requests and responses.
   *
   * @schema EnvoyProxySpecTelemetryMetrics#enableRequestResponseSizesStats
   */
  readonly enableRequestResponseSizesStats?: boolean;

  /**
   * EnableVirtualHostStats enables envoy stat metrics for virtual hosts.
   *
   * @schema EnvoyProxySpecTelemetryMetrics#enableVirtualHostStats
   */
  readonly enableVirtualHostStats?: boolean;

  /**
   * Matches defines configuration for selecting specific metrics instead of generating all metrics stats
   * that are enabled by default. This helps reduce CPU and memory overhead in Envoy, but eliminating some stats
   * may after critical functionality. Here are the stats that we strongly recommend not disabling:
   * `cluster_manager.warming_clusters`, `cluster.<cluster_name>.membership_total`,`cluster.<cluster_name>.membership_healthy`,
   * `cluster.<cluster_name>.membership_degraded`，reference  https://github.com/envoyproxy/envoy/issues/9856,
   * https://github.com/envoyproxy/envoy/issues/14610
   *
   * @schema EnvoyProxySpecTelemetryMetrics#matches
   */
  readonly matches?: EnvoyProxySpecTelemetryMetricsMatches[];

  /**
   * Prometheus defines the configuration for Admin endpoint `/stats/prometheus`.
   *
   * @schema EnvoyProxySpecTelemetryMetrics#prometheus
   */
  readonly prometheus?: EnvoyProxySpecTelemetryMetricsPrometheus;

  /**
   * Sinks defines the metric sinks where metrics are sent to.
   *
   * @schema EnvoyProxySpecTelemetryMetrics#sinks
   */
  readonly sinks?: EnvoyProxySpecTelemetryMetricsSinks[];
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetrics' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetrics(obj: EnvoyProxySpecTelemetryMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterStatName': obj.clusterStatName,
    'enablePerEndpointStats': obj.enablePerEndpointStats,
    'enableRequestResponseSizesStats': obj.enableRequestResponseSizesStats,
    'enableVirtualHostStats': obj.enableVirtualHostStats,
    'matches': obj.matches?.map(y => toJson_EnvoyProxySpecTelemetryMetricsMatches(y)),
    'prometheus': toJson_EnvoyProxySpecTelemetryMetricsPrometheus(obj.prometheus),
    'sinks': obj.sinks?.map(y => toJson_EnvoyProxySpecTelemetryMetricsSinks(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Tracing defines tracing configuration for managed proxies.
 * If unspecified, will not send tracing data.
 *
 * @schema EnvoyProxySpecTelemetryTracing
 */
export interface EnvoyProxySpecTelemetryTracing {
  /**
   * CustomTags defines the custom tags to add to each span.
   * If provider is kubernetes, pod name and namespace are added by default.
   *
   * @schema EnvoyProxySpecTelemetryTracing#customTags
   */
  readonly customTags?: { [key: string]: EnvoyProxySpecTelemetryTracingCustomTags };

  /**
   * Provider defines the tracing provider.
   *
   * @schema EnvoyProxySpecTelemetryTracing#provider
   */
  readonly provider: EnvoyProxySpecTelemetryTracingProvider;

  /**
   * SamplingFraction represents the fraction of requests that should be
   * selected for tracing if no prior sampling decision has been made.
   *
   * Only one of SamplingRate or SamplingFraction may be specified.
   * If neither field is specified, all requests will be sampled.
   *
   * @schema EnvoyProxySpecTelemetryTracing#samplingFraction
   */
  readonly samplingFraction?: EnvoyProxySpecTelemetryTracingSamplingFraction;

  /**
   * SamplingRate controls the rate at which traffic will be
   * selected for tracing if no prior sampling decision has been made.
   * Defaults to 100, valid values [0-100]. 100 indicates 100% sampling.
   *
   * Only one of SamplingRate or SamplingFraction may be specified.
   * If neither field is specified, all requests will be sampled.
   *
   * @default 100, valid values [0-100]. 100 indicates 100% sampling.
   * @schema EnvoyProxySpecTelemetryTracing#samplingRate
   */
  readonly samplingRate?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracing' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracing(obj: EnvoyProxySpecTelemetryTracing | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customTags': ((obj.customTags) === undefined) ? undefined : (Object.entries(obj.customTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_EnvoyProxySpecTelemetryTracingCustomTags(i[1]) }), {})),
    'provider': toJson_EnvoyProxySpecTelemetryTracingProvider(obj.provider),
    'samplingFraction': toJson_EnvoyProxySpecTelemetryTracingSamplingFraction(obj.samplingFraction),
    'samplingRate': obj.samplingRate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Op is the type of operation to perform
 *
 * @schema EnvoyProxySpecBootstrapJsonPatchesOp
 */
export enum EnvoyProxySpecBootstrapJsonPatchesOp {
  /** add */
  ADD = "add",
  /** remove */
  REMOVE = "remove",
  /** replace */
  REPLACE = "replace",
  /** move */
  MOVE = "move",
  /** copy */
  COPY = "copy",
  /** test */
  TEST = "test",
}

/**
 * EnvoyDaemonSet defines the desired state of the Envoy daemonset resource.
 * Disabled by default, a deployment resource is used instead to provision the Envoy Proxy fleet
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSet
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSet {
  /**
   * Container defines the desired specification of main container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSet#container
   */
  readonly container?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainer;

  /**
   * Name of the daemonSet.
   * When unset, this defaults to an autogenerated name.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSet#name
   */
  readonly name?: string;

  /**
   * Patch defines how to perform the patch operation to daemonset
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSet#patch
   */
  readonly patch?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPatch;

  /**
   * Pod defines the desired specification of pod.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSet#pod
   */
  readonly pod?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPod;

  /**
   * The daemonset strategy to use to replace existing pods with new ones.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSet#strategy
   */
  readonly strategy?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategy;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSet(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'container': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainer(obj.container),
    'name': obj.name,
    'patch': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPatch(obj.patch),
    'pod': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPod(obj.pod),
    'strategy': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategy(obj.strategy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvoyDeployment defines the desired state of the Envoy deployment resource.
 * If unspecified, default settings for the managed Envoy deployment resource
 * are applied.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeployment
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeployment {
  /**
   * Container defines the desired specification of main container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeployment#container
   */
  readonly container?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainer;

  /**
   * List of initialization containers belonging to the pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeployment#initContainers
   */
  readonly initContainers?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers[];

  /**
   * Name of the deployment.
   * When unset, this defaults to an autogenerated name.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeployment#name
   */
  readonly name?: string;

  /**
   * Patch defines how to perform the patch operation to deployment
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeployment#patch
   */
  readonly patch?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPatch;

  /**
   * Pod defines the desired specification of pod.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeployment#pod
   */
  readonly pod?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPod;

  /**
   * Replicas is the number of desired pods. Defaults to 1.
   *
   * @default 1.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeployment#replicas
   */
  readonly replicas?: number;

  /**
   * The deployment strategy to use to replace existing pods with new ones.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeployment#strategy
   */
  readonly strategy?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategy;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeployment' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeployment(obj: EnvoyProxySpecProviderKubernetesEnvoyDeployment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'container': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainer(obj.container),
    'initContainers': obj.initContainers?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers(y)),
    'name': obj.name,
    'patch': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPatch(obj.patch),
    'pod': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPod(obj.pod),
    'replicas': obj.replicas,
    'strategy': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategy(obj.strategy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvoyHpa defines the Horizontal Pod Autoscaler settings for Envoy Proxy Deployment.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpa
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpa {
  /**
   * behavior configures the scaling behavior of the target
   * in both Up and Down directions (scaleUp and scaleDown fields respectively).
   * If not set, the default HPAScalingRules for scale up and scale down are used.
   * See k8s.io.autoscaling.v2.HorizontalPodAutoScalerBehavior.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpa#behavior
   */
  readonly behavior?: EnvoyProxySpecProviderKubernetesEnvoyHpaBehavior;

  /**
   * maxReplicas is the upper limit for the number of replicas to which the autoscaler can scale up.
   * It cannot be less that minReplicas.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpa#maxReplicas
   */
  readonly maxReplicas: number;

  /**
   * metrics contains the specifications for which to use to calculate the
   * desired replica count (the maximum replica count across all metrics will
   * be used).
   * If left empty, it defaults to being based on CPU utilization with average on 80% usage.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpa#metrics
   */
  readonly metrics?: EnvoyProxySpecProviderKubernetesEnvoyHpaMetrics[];

  /**
   * minReplicas is the lower limit for the number of replicas to which the autoscaler
   * can scale down. It defaults to 1 replica.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpa#minReplicas
   */
  readonly minReplicas?: number;

  /**
   * Name of the horizontalPodAutoScaler.
   * When unset, this defaults to an autogenerated name.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpa#name
   */
  readonly name?: string;

  /**
   * Patch defines how to perform the patch operation to the HorizontalPodAutoscaler
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpa#patch
   */
  readonly patch?: EnvoyProxySpecProviderKubernetesEnvoyHpaPatch;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpa(obj: EnvoyProxySpecProviderKubernetesEnvoyHpa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'behavior': toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaBehavior(obj.behavior),
    'maxReplicas': obj.maxReplicas,
    'metrics': obj.metrics?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetrics(y)),
    'minReplicas': obj.minReplicas,
    'name': obj.name,
    'patch': toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaPatch(obj.patch),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvoyPDB allows to control the pod disruption budget of an Envoy Proxy.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyPdb
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyPdb {
  /**
   * MaxUnavailable specifies the maximum amount of pods (can be expressed as integers or as a percentage) that can be unavailable at all times during voluntary disruptions,
   * such as node drains or updates. This setting ensures that your envoy proxy maintains a certain level of availability
   * and resilience during maintenance operations. Cannot be combined with minAvailable.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyPdb#maxUnavailable
   */
  readonly maxUnavailable?: EnvoyProxySpecProviderKubernetesEnvoyPdbMaxUnavailable;

  /**
   * MinAvailable specifies the minimum amount of pods (can be expressed as integers or as a percentage) that must be available at all times during voluntary disruptions,
   * such as node drains or updates. This setting ensures that your envoy proxy maintains a certain level of availability
   * and resilience during maintenance operations. Cannot be combined with maxUnavailable.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyPdb#minAvailable
   */
  readonly minAvailable?: EnvoyProxySpecProviderKubernetesEnvoyPdbMinAvailable;

  /**
   * Name of the podDisruptionBudget.
   * When unset, this defaults to an autogenerated name.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyPdb#name
   */
  readonly name?: string;

  /**
   * Patch defines how to perform the patch operation to the PodDisruptionBudget
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyPdb#patch
   */
  readonly patch?: EnvoyProxySpecProviderKubernetesEnvoyPdbPatch;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyPdb' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyPdb(obj: EnvoyProxySpecProviderKubernetesEnvoyPdb | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxUnavailable': obj.maxUnavailable?.value,
    'minAvailable': obj.minAvailable?.value,
    'name': obj.name,
    'patch': toJson_EnvoyProxySpecProviderKubernetesEnvoyPdbPatch(obj.patch),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvoyService defines the desired state of the Envoy service resource.
 * If unspecified, default settings for the managed Envoy service resource
 * are applied.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyService
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyService {
  /**
   * AllocateLoadBalancerNodePorts defines if NodePorts will be automatically allocated for
   * services with type LoadBalancer. Default is "true". It may be set to "false" if the cluster
   * load-balancer does not rely on NodePorts. If the caller requests specific NodePorts (by specifying a
   * value), those requests will be respected, regardless of this field. This field may only be set for
   * services with type LoadBalancer and will be cleared if the type is changed to any other type.
   *
   * @default true". It may be set to "false" if the cluster
   * @schema EnvoyProxySpecProviderKubernetesEnvoyService#allocateLoadBalancerNodePorts
   */
  readonly allocateLoadBalancerNodePorts?: boolean;

  /**
   * Annotations that should be appended to the service.
   * By default, no annotations are appended.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyService#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * ExternalTrafficPolicy determines the externalTrafficPolicy for the Envoy Service. Valid options
   * are Local and Cluster. Default is "Local". "Local" means traffic will only go to pods on the node
   * receiving the traffic. "Cluster" means connections are loadbalanced to all pods in the cluster.
   *
   * @default Local". "Local" means traffic will only go to pods on the node
   * @schema EnvoyProxySpecProviderKubernetesEnvoyService#externalTrafficPolicy
   */
  readonly externalTrafficPolicy?: EnvoyProxySpecProviderKubernetesEnvoyServiceExternalTrafficPolicy;

  /**
   * Labels that should be appended to the service.
   * By default, no labels are appended.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyService#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * LoadBalancerClass, when specified, allows for choosing the LoadBalancer provider
   * implementation if more than one are available or is otherwise expected to be specified
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyService#loadBalancerClass
   */
  readonly loadBalancerClass?: string;

  /**
   * LoadBalancerIP defines the IP Address of the underlying load balancer service. This field
   * may be ignored if the load balancer provider does not support this feature.
   * This field has been deprecated in Kubernetes, but it is still used for setting the IP Address in some cloud
   * providers such as GCP.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyService#loadBalancerIP
   */
  readonly loadBalancerIp?: string;

  /**
   * LoadBalancerSourceRanges defines a list of allowed IP addresses which will be configured as
   * firewall rules on the platform providers load balancer. This is not guaranteed to be working as
   * it happens outside of kubernetes and has to be supported and handled by the platform provider.
   * This field may only be set for services with type LoadBalancer and will be cleared if the type
   * is changed to any other type.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyService#loadBalancerSourceRanges
   */
  readonly loadBalancerSourceRanges?: string[];

  /**
   * Name of the service.
   * When unset, this defaults to an autogenerated name.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyService#name
   */
  readonly name?: string;

  /**
   * Patch defines how to perform the patch operation to the service
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyService#patch
   */
  readonly patch?: EnvoyProxySpecProviderKubernetesEnvoyServicePatch;

  /**
   * Type determines how the Service is exposed. Defaults to LoadBalancer.
   * Valid options are ClusterIP, LoadBalancer and NodePort.
   * "LoadBalancer" means a service will be exposed via an external load balancer (if the cloud provider supports it).
   * "ClusterIP" means a service will only be accessible inside the cluster, via the cluster IP.
   * "NodePort" means a service will be exposed on a static Port on all Nodes of the cluster.
   *
   * @default LoadBalancer.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyService#type
   */
  readonly type?: EnvoyProxySpecProviderKubernetesEnvoyServiceType;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyService' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyService(obj: EnvoyProxySpecProviderKubernetesEnvoyService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allocateLoadBalancerNodePorts': obj.allocateLoadBalancerNodePorts,
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'externalTrafficPolicy': obj.externalTrafficPolicy,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'loadBalancerClass': obj.loadBalancerClass,
    'loadBalancerIP': obj.loadBalancerIp,
    'loadBalancerSourceRanges': obj.loadBalancerSourceRanges?.map(y => y),
    'name': obj.name,
    'patch': toJson_EnvoyProxySpecProviderKubernetesEnvoyServicePatch(obj.patch),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvoyServiceAccount defines the desired state of the Envoy service account resource.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyServiceAccount
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyServiceAccount {
  /**
   * Name of the Service Account.
   * When unset, this defaults to an autogenerated name.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyServiceAccount#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyServiceAccount(obj: EnvoyProxySpecProviderKubernetesEnvoyServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EnvoyProxySpecTelemetryAccessLogSettings
 */
export interface EnvoyProxySpecTelemetryAccessLogSettings {
  /**
   * Format defines the format of accesslog.
   * This will be ignored if sink type is ALS.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettings#format
   */
  readonly format?: EnvoyProxySpecTelemetryAccessLogSettingsFormat;

  /**
   * Matches defines the match conditions for accesslog in CEL expression.
   * An accesslog will be emitted only when one or more match conditions are evaluated to true.
   * Invalid [CEL](https://www.envoyproxy.io/docs/envoy/latest/xds/type/v3/cel.proto.html#common-expression-language-cel-proto) expressions will be ignored.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettings#matches
   */
  readonly matches?: string[];

  /**
   * Sinks defines the sinks of accesslog.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettings#sinks
   */
  readonly sinks: EnvoyProxySpecTelemetryAccessLogSettingsSinks[];

  /**
   * Type defines the component emitting the accesslog, such as Listener and Route.
   * If type not defined, the setting would apply to:
   * (1) All Routes.
   * (2) Listeners if and only if Envoy does not find a matching route for a request.
   * If type is defined, the accesslog settings would apply to the relevant component (as-is).
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettings#type
   */
  readonly type?: EnvoyProxySpecTelemetryAccessLogSettingsType;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettings(obj: EnvoyProxySpecTelemetryAccessLogSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'format': toJson_EnvoyProxySpecTelemetryAccessLogSettingsFormat(obj.format),
    'matches': obj.matches?.map(y => y),
    'sinks': obj.sinks?.map(y => toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinks(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StringMatch defines how to match any strings.
 * This is a general purpose match condition that can be used by other EG APIs
 * that need to match against a string.
 *
 * @schema EnvoyProxySpecTelemetryMetricsMatches
 */
export interface EnvoyProxySpecTelemetryMetricsMatches {
  /**
   * Type specifies how to match against a string.
   *
   * @schema EnvoyProxySpecTelemetryMetricsMatches#type
   */
  readonly type?: EnvoyProxySpecTelemetryMetricsMatchesType;

  /**
   * Value specifies the string value that the match must have.
   *
   * @schema EnvoyProxySpecTelemetryMetricsMatches#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsMatches' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsMatches(obj: EnvoyProxySpecTelemetryMetricsMatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Prometheus defines the configuration for Admin endpoint `/stats/prometheus`.
 *
 * @schema EnvoyProxySpecTelemetryMetricsPrometheus
 */
export interface EnvoyProxySpecTelemetryMetricsPrometheus {
  /**
   * Configure the compression on Prometheus endpoint. Compression is useful in situations when bandwidth is scarce and large payloads can be effectively compressed at the expense of higher CPU load.
   *
   * @schema EnvoyProxySpecTelemetryMetricsPrometheus#compression
   */
  readonly compression?: EnvoyProxySpecTelemetryMetricsPrometheusCompression;

  /**
   * Disable the Prometheus endpoint.
   *
   * @schema EnvoyProxySpecTelemetryMetricsPrometheus#disable
   */
  readonly disable?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsPrometheus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsPrometheus(obj: EnvoyProxySpecTelemetryMetricsPrometheus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'compression': toJson_EnvoyProxySpecTelemetryMetricsPrometheusCompression(obj.compression),
    'disable': obj.disable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProxyMetricSink defines the sink of metrics.
 * Default metrics sink is OpenTelemetry.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinks
 */
export interface EnvoyProxySpecTelemetryMetricsSinks {
  /**
   * OpenTelemetry defines the configuration for OpenTelemetry sink.
   * It's required if the sink type is OpenTelemetry.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinks#openTelemetry
   */
  readonly openTelemetry?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetry;

  /**
   * Type defines the metric sink type.
   * EG currently only supports OpenTelemetry.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinks#type
   */
  readonly type: EnvoyProxySpecTelemetryMetricsSinksType;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinks(obj: EnvoyProxySpecTelemetryMetricsSinks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'openTelemetry': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetry(obj.openTelemetry),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EnvoyProxySpecTelemetryTracingCustomTags
 */
export interface EnvoyProxySpecTelemetryTracingCustomTags {
  /**
   * Environment adds value from environment variable to each span.
   * It's required when the type is "Environment".
   *
   * @schema EnvoyProxySpecTelemetryTracingCustomTags#environment
   */
  readonly environment?: EnvoyProxySpecTelemetryTracingCustomTagsEnvironment;

  /**
   * Literal adds hard-coded value to each span.
   * It's required when the type is "Literal".
   *
   * @schema EnvoyProxySpecTelemetryTracingCustomTags#literal
   */
  readonly literal?: EnvoyProxySpecTelemetryTracingCustomTagsLiteral;

  /**
   * RequestHeader adds value from request header to each span.
   * It's required when the type is "RequestHeader".
   *
   * @schema EnvoyProxySpecTelemetryTracingCustomTags#requestHeader
   */
  readonly requestHeader?: EnvoyProxySpecTelemetryTracingCustomTagsRequestHeader;

  /**
   * Type defines the type of custom tag.
   *
   * @schema EnvoyProxySpecTelemetryTracingCustomTags#type
   */
  readonly type: EnvoyProxySpecTelemetryTracingCustomTagsType;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingCustomTags' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingCustomTags(obj: EnvoyProxySpecTelemetryTracingCustomTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'environment': toJson_EnvoyProxySpecTelemetryTracingCustomTagsEnvironment(obj.environment),
    'literal': toJson_EnvoyProxySpecTelemetryTracingCustomTagsLiteral(obj.literal),
    'requestHeader': toJson_EnvoyProxySpecTelemetryTracingCustomTagsRequestHeader(obj.requestHeader),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Provider defines the tracing provider.
 *
 * @schema EnvoyProxySpecTelemetryTracingProvider
 */
export interface EnvoyProxySpecTelemetryTracingProvider {
  /**
   * BackendRef references a Kubernetes object that represents the
   * backend server to which the authorization request will be sent.
   *
   * Deprecated: Use BackendRefs instead.
   *
   * @schema EnvoyProxySpecTelemetryTracingProvider#backendRef
   */
  readonly backendRef?: EnvoyProxySpecTelemetryTracingProviderBackendRef;

  /**
   * BackendRefs references a Kubernetes object that represents the
   * backend server to which the authorization request will be sent.
   *
   * @schema EnvoyProxySpecTelemetryTracingProvider#backendRefs
   */
  readonly backendRefs?: EnvoyProxySpecTelemetryTracingProviderBackendRefs[];

  /**
   * BackendSettings holds configuration for managing the connection
   * to the backend.
   *
   * @schema EnvoyProxySpecTelemetryTracingProvider#backendSettings
   */
  readonly backendSettings?: EnvoyProxySpecTelemetryTracingProviderBackendSettings;

  /**
   * Host define the provider service hostname.
   * Deprecated: Use BackendRefs instead.
   *
   * @schema EnvoyProxySpecTelemetryTracingProvider#host
   */
  readonly host?: string;

  /**
   * Port defines the port the provider service is exposed on.
   * Deprecated: Use BackendRefs instead.
   *
   * @schema EnvoyProxySpecTelemetryTracingProvider#port
   */
  readonly port?: number;

  /**
   * ServiceName defines the service name to use in tracing configuration.
   * If not set, Envoy Gateway will use a default service name set as
   * "name.namespace" (e.g., "my-gateway.default").
   * Note: This field is only supported for OpenTelemetry and Datadog tracing providers.
   * For Zipkin, the service name in traces is always derived from the Envoy --service-cluster flag
   * (typically "namespace/name" format). Setting this field has no effect for Zipkin.
   *
   * @schema EnvoyProxySpecTelemetryTracingProvider#serviceName
   */
  readonly serviceName?: string;

  /**
   * Type defines the tracing provider type.
   *
   * @schema EnvoyProxySpecTelemetryTracingProvider#type
   */
  readonly type: EnvoyProxySpecTelemetryTracingProviderType;

  /**
   * Zipkin defines the Zipkin tracing provider configuration
   *
   * @schema EnvoyProxySpecTelemetryTracingProvider#zipkin
   */
  readonly zipkin?: EnvoyProxySpecTelemetryTracingProviderZipkin;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProvider(obj: EnvoyProxySpecTelemetryTracingProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendRef': toJson_EnvoyProxySpecTelemetryTracingProviderBackendRef(obj.backendRef),
    'backendRefs': obj.backendRefs?.map(y => toJson_EnvoyProxySpecTelemetryTracingProviderBackendRefs(y)),
    'backendSettings': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettings(obj.backendSettings),
    'host': obj.host,
    'port': obj.port,
    'serviceName': obj.serviceName,
    'type': obj.type,
    'zipkin': toJson_EnvoyProxySpecTelemetryTracingProviderZipkin(obj.zipkin),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SamplingFraction represents the fraction of requests that should be
 * selected for tracing if no prior sampling decision has been made.
 *
 * Only one of SamplingRate or SamplingFraction may be specified.
 * If neither field is specified, all requests will be sampled.
 *
 * @schema EnvoyProxySpecTelemetryTracingSamplingFraction
 */
export interface EnvoyProxySpecTelemetryTracingSamplingFraction {
  /**
   * @schema EnvoyProxySpecTelemetryTracingSamplingFraction#denominator
   */
  readonly denominator?: number;

  /**
   * @schema EnvoyProxySpecTelemetryTracingSamplingFraction#numerator
   */
  readonly numerator: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingSamplingFraction' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingSamplingFraction(obj: EnvoyProxySpecTelemetryTracingSamplingFraction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'denominator': obj.denominator,
    'numerator': obj.numerator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Container defines the desired specification of main container.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainer
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainer {
  /**
   * List of environment variables to set in the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainer#env
   */
  readonly env?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnv[];

  /**
   * Image specifies the EnvoyProxy container image to be used including a tag, instead of the default image.
   * This field is mutually exclusive with ImageRepository.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainer#image
   */
  readonly image?: string;

  /**
   * ImageRepository specifies the container image repository to be used without specifying a tag.
   * The default tag will be used.
   * This field is mutually exclusive with Image.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainer#imageRepository
   */
  readonly imageRepository?: string;

  /**
   * Resources required by this container.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainer#resources
   */
  readonly resources?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResources;

  /**
   * SecurityContext defines the security options the container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainer#securityContext
   */
  readonly securityContext?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContext;

  /**
   * VolumeMounts are volumes to mount into the container's filesystem.
   * Cannot be updated.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainer#volumeMounts
   */
  readonly volumeMounts?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerVolumeMounts[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainer(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnv(y)),
    'image': obj.image,
    'imageRepository': obj.imageRepository,
    'resources': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResources(obj.resources),
    'securityContext': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContext(obj.securityContext),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerVolumeMounts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Patch defines how to perform the patch operation to daemonset
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPatch
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPatch {
  /**
   * Type is the type of merge operation to perform
   *
   * By default, StrategicMerge is used as the patch type.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPatch#type
   */
  readonly type?: string;

  /**
   * Object contains the raw configuration for merged object
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPatch#value
   */
  readonly value: any;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPatch(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Pod defines the desired specification of pod.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPod
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPod {
  /**
   * If specified, the pod's scheduling constraints.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPod#affinity
   */
  readonly affinity?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinity;

  /**
   * Annotations are the annotations that should be appended to the pods.
   * By default, no pod annotations are appended.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPod#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * ImagePullSecrets is an optional list of references to secrets
   * in the same namespace to use for pulling any of the images used by this PodSpec.
   * If specified, these secrets will be passed to individual puller implementations for them to use.
   * More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPod#imagePullSecrets
   */
  readonly imagePullSecrets?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodImagePullSecrets[];

  /**
   * Labels are the additional labels that should be tagged to the pods.
   * By default, no additional pod labels are tagged.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPod#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node.
   * Selector which must match a node's labels for the pod to be scheduled on that node.
   * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPod#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * Optional: Defaults to empty.  See type description for default values of each field.
   *
   * @default empty.  See type description for default values of each field.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPod#securityContext
   */
  readonly securityContext?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContext;

  /**
   * If specified, the pod's tolerations.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPod#tolerations
   */
  readonly tolerations?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTolerations[];

  /**
   * TopologySpreadConstraints describes how a group of pods ought to spread across topology
   * domains. Scheduler will schedule pods in a way which abides by the constraints.
   * All topologySpreadConstraints are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPod#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraints[];

  /**
   * Volumes that can be mounted by containers belonging to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPod#volumes
   */
  readonly volumes?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPod' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPod(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinity(obj.affinity),
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodImagePullSecrets(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'securityContext': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContext(obj.securityContext),
    'tolerations': obj.tolerations?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraints(y)),
    'volumes': obj.volumes?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The daemonset strategy to use to replace existing pods with new ones.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategy
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategy {
  /**
   * Rolling update config params. Present only if type = "RollingUpdate".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategy#rollingUpdate
   */
  readonly rollingUpdate?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdate;

  /**
   * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
   *
   * @default RollingUpdate.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategy#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategy(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rollingUpdate': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdate(obj.rollingUpdate),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Container defines the desired specification of main container.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainer
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainer {
  /**
   * List of environment variables to set in the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainer#env
   */
  readonly env?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnv[];

  /**
   * Image specifies the EnvoyProxy container image to be used including a tag, instead of the default image.
   * This field is mutually exclusive with ImageRepository.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainer#image
   */
  readonly image?: string;

  /**
   * ImageRepository specifies the container image repository to be used without specifying a tag.
   * The default tag will be used.
   * This field is mutually exclusive with Image.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainer#imageRepository
   */
  readonly imageRepository?: string;

  /**
   * Resources required by this container.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainer#resources
   */
  readonly resources?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResources;

  /**
   * SecurityContext defines the security options the container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainer#securityContext
   */
  readonly securityContext?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContext;

  /**
   * VolumeMounts are volumes to mount into the container's filesystem.
   * Cannot be updated.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainer#volumeMounts
   */
  readonly volumeMounts?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerVolumeMounts[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainer(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnv(y)),
    'image': obj.image,
    'imageRepository': obj.imageRepository,
    'resources': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResources(obj.resources),
    'securityContext': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContext(obj.securityContext),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerVolumeMounts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers {
  /**
   * Arguments to the entrypoint.
   * The container image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell.
   * The container image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#env
   */
  readonly env?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnv[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source may consist of any printable ASCII characters except '='.
   * When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#envFrom
   */
  readonly envFrom?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFrom[];

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events.
   * Cannot be updated.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#lifecycle
   */
  readonly lifecycle?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecycle;

  /**
   * Periodic probe of container liveness.
   * Container will be restarted if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#livenessProbe
   */
  readonly livenessProbe?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL.
   * Each container in a pod must have a unique name (DNS_LABEL).
   * Cannot be updated.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here
   * DOES NOT prevent that port from being exposed. Any port which is
   * listening on the default "0.0.0.0" address inside a container will be
   * accessible from the network.
   * Modifying this array with strategic merge patch may corrupt the data.
   * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
   * Cannot be updated.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#ports
   */
  readonly ports?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersPorts[];

  /**
   * Periodic probe of container service readiness.
   * Container will be removed from service endpoints if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#readinessProbe
   */
  readonly readinessProbe?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#resizePolicy
   */
  readonly resizePolicy?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResizePolicy[];

  /**
   * Compute Resources required by this container.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#resources
   */
  readonly resources?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod.
   * This overrides the pod-level restart policy. When this field is not specified,
   * the restart behavior is defined by the Pod's restart policy and the container type.
   * Additionally, setting the RestartPolicy as "Always" for the init container will
   * have the following effect:
   * this init container will be continually restarted on
   * exit until all regular containers have terminated. Once all regular
   * containers have completed, all init containers with restartPolicy "Always"
   * will be shut down. This lifecycle differs from normal init containers and
   * is often referred to as a "sidecar" container. Although this init
   * container still starts in the init container sequence, it does not wait
   * for the container to complete before proceeding to the next init
   * container. Instead, the next init container starts immediately after this
   * init container is started, or after any startupProbe has successfully
   * completed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * Represents a list of rules to be checked to determine if the
   * container should be restarted on exit. The rules are evaluated in
   * order. Once a rule matches a container exit condition, the remaining
   * rules are ignored. If no rule matches the container exit condition,
   * the Container-level restart policy determines the whether the container
   * is restarted or not. Constraints on the rules:
   * - At most 20 rules are allowed.
   * - Rules can have the same action.
   * - Identical rules are not forbidden in validations.
   * When rules are specified, container MUST set RestartPolicy explicitly
   * even it if matches the Pod's RestartPolicy.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#restartPolicyRules
   */
  readonly restartPolicyRules?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersRestartPolicyRules[];

  /**
   * SecurityContext defines the security options the container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#securityContext
   */
  readonly securityContext?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized.
   * If specified, no other probes are executed until this completes successfully.
   * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
   * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
   * when it might take a long time to load data or warm a cache, than during steady-state operation.
   * This cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#startupProbe
   */
  readonly startupProbe?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   *
   * @default false.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   *
   * @default false
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   *
   * @default dev/termination-log.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   *
   * @default File.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   *
   * @default false.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#volumeDevices
   */
  readonly volumeDevices?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem.
   * Cannot be updated.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#volumeMounts
   */
  readonly volumeMounts?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeMounts[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers#workingDir
   */
  readonly workingDir?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnv(y)),
    'envFrom': obj.envFrom?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFrom(y)),
    'image': obj.image,
    'imagePullPolicy': obj.imagePullPolicy,
    'lifecycle': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecycle(obj.lifecycle),
    'livenessProbe': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbe(obj.livenessProbe),
    'name': obj.name,
    'ports': obj.ports?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersPorts(y)),
    'readinessProbe': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbe(obj.readinessProbe),
    'resizePolicy': obj.resizePolicy?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResizePolicy(y)),
    'resources': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResources(obj.resources),
    'restartPolicy': obj.restartPolicy,
    'restartPolicyRules': obj.restartPolicyRules?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersRestartPolicyRules(y)),
    'securityContext': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContext(obj.securityContext),
    'startupProbe': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbe(obj.startupProbe),
    'stdin': obj.stdin,
    'stdinOnce': obj.stdinOnce,
    'terminationMessagePath': obj.terminationMessagePath,
    'terminationMessagePolicy': obj.terminationMessagePolicy,
    'tty': obj.tty,
    'volumeDevices': obj.volumeDevices?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeDevices(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeMounts(y)),
    'workingDir': obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Patch defines how to perform the patch operation to deployment
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPatch
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPatch {
  /**
   * Type is the type of merge operation to perform
   *
   * By default, StrategicMerge is used as the patch type.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPatch#type
   */
  readonly type?: string;

  /**
   * Object contains the raw configuration for merged object
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPatch#value
   */
  readonly value: any;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPatch(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Pod defines the desired specification of pod.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPod
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPod {
  /**
   * If specified, the pod's scheduling constraints.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPod#affinity
   */
  readonly affinity?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinity;

  /**
   * Annotations are the annotations that should be appended to the pods.
   * By default, no pod annotations are appended.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPod#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * ImagePullSecrets is an optional list of references to secrets
   * in the same namespace to use for pulling any of the images used by this PodSpec.
   * If specified, these secrets will be passed to individual puller implementations for them to use.
   * More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPod#imagePullSecrets
   */
  readonly imagePullSecrets?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodImagePullSecrets[];

  /**
   * Labels are the additional labels that should be tagged to the pods.
   * By default, no additional pod labels are tagged.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPod#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node.
   * Selector which must match a node's labels for the pod to be scheduled on that node.
   * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPod#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * Optional: Defaults to empty.  See type description for default values of each field.
   *
   * @default empty.  See type description for default values of each field.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPod#securityContext
   */
  readonly securityContext?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContext;

  /**
   * If specified, the pod's tolerations.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPod#tolerations
   */
  readonly tolerations?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTolerations[];

  /**
   * TopologySpreadConstraints describes how a group of pods ought to spread across topology
   * domains. Scheduler will schedule pods in a way which abides by the constraints.
   * All topologySpreadConstraints are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPod#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraints[];

  /**
   * Volumes that can be mounted by containers belonging to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPod#volumes
   */
  readonly volumes?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPod' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPod(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinity(obj.affinity),
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodImagePullSecrets(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'securityContext': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContext(obj.securityContext),
    'tolerations': obj.tolerations?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTolerations(y)),
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraints(y)),
    'volumes': obj.volumes?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The deployment strategy to use to replace existing pods with new ones.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategy
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategy {
  /**
   * Rolling update config params. Present only if DeploymentStrategyType =
   * RollingUpdate.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategy#rollingUpdate
   */
  readonly rollingUpdate?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdate;

  /**
   * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
   *
   * @default RollingUpdate.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategy#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategy(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rollingUpdate': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdate(obj.rollingUpdate),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * behavior configures the scaling behavior of the target
 * in both Up and Down directions (scaleUp and scaleDown fields respectively).
 * If not set, the default HPAScalingRules for scale up and scale down are used.
 * See k8s.io.autoscaling.v2.HorizontalPodAutoScalerBehavior.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaBehavior
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaBehavior {
  /**
   * scaleDown is scaling policy for scaling Down.
   * If not set, the default value is to allow to scale down to minReplicas pods, with a
   * 300 second stabilization window (i.e., the highest recommendation for
   * the last 300sec is used).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaBehavior#scaleDown
   */
  readonly scaleDown?: EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDown;

  /**
   * scaleUp is scaling policy for scaling Up.
   * If not set, the default value is the higher of:
   * * increase no more than 4 pods per 60 seconds
   * * double the number of pods per 60 seconds
   * No stabilization is used.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaBehavior#scaleUp
   */
  readonly scaleUp?: EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUp;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaBehavior' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaBehavior(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaBehavior | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'scaleDown': toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDown(obj.scaleDown),
    'scaleUp': toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUp(obj.scaleUp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MetricSpec specifies how to scale based on a single metric
 * (only `type` and one other matching field should be set at once).
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetrics
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetrics {
  /**
   * containerResource refers to a resource metric (such as those specified in
   * requests and limits) known to Kubernetes describing a single container in
   * each pod of the current scale target (e.g. CPU or memory). Such metrics are
   * built in to Kubernetes, and have special scaling options on top of those
   * available to normal per-pod metrics using the "pods" source.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetrics#containerResource
   */
  readonly containerResource?: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResource;

  /**
   * external refers to a global metric that is not associated
   * with any Kubernetes object. It allows autoscaling based on information
   * coming from components running outside of cluster
   * (for example length of queue in cloud messaging service, or
   * QPS from loadbalancer running outside of cluster).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetrics#external
   */
  readonly external?: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternal;

  /**
   * object refers to a metric describing a single kubernetes object
   * (for example, hits-per-second on an Ingress object).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetrics#object
   */
  readonly object?: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObject;

  /**
   * pods refers to a metric describing each pod in the current scale target
   * (for example, transactions-processed-per-second).  The values will be
   * averaged together before being compared to the target value.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetrics#pods
   */
  readonly pods?: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPods;

  /**
   * resource refers to a resource metric (such as those specified in
   * requests and limits) known to Kubernetes describing each pod in the
   * current scale target (e.g. CPU or memory). Such metrics are built in to
   * Kubernetes, and have special scaling options on top of those available
   * to normal per-pod metrics using the "pods" source.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetrics#resource
   */
  readonly resource?: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResource;

  /**
   * type is the type of metric source.  It should be one of "ContainerResource", "External",
   * "Object", "Pods" or "Resource", each mapping to a matching field in the object.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetrics#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaMetrics' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetrics(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerResource': toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResource(obj.containerResource),
    'external': toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternal(obj.external),
    'object': toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObject(obj.object),
    'pods': toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPods(obj.pods),
    'resource': toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResource(obj.resource),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Patch defines how to perform the patch operation to the HorizontalPodAutoscaler
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaPatch
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaPatch {
  /**
   * Type is the type of merge operation to perform
   *
   * By default, StrategicMerge is used as the patch type.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaPatch#type
   */
  readonly type?: string;

  /**
   * Object contains the raw configuration for merged object
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaPatch#value
   */
  readonly value: any;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaPatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaPatch(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaPatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MaxUnavailable specifies the maximum amount of pods (can be expressed as integers or as a percentage) that can be unavailable at all times during voluntary disruptions,
 * such as node drains or updates. This setting ensures that your envoy proxy maintains a certain level of availability
 * and resilience during maintenance operations. Cannot be combined with minAvailable.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyPdbMaxUnavailable
 */
export class EnvoyProxySpecProviderKubernetesEnvoyPdbMaxUnavailable {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyPdbMaxUnavailable {
    return new EnvoyProxySpecProviderKubernetesEnvoyPdbMaxUnavailable(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyPdbMaxUnavailable {
    return new EnvoyProxySpecProviderKubernetesEnvoyPdbMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * MinAvailable specifies the minimum amount of pods (can be expressed as integers or as a percentage) that must be available at all times during voluntary disruptions,
 * such as node drains or updates. This setting ensures that your envoy proxy maintains a certain level of availability
 * and resilience during maintenance operations. Cannot be combined with maxUnavailable.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyPdbMinAvailable
 */
export class EnvoyProxySpecProviderKubernetesEnvoyPdbMinAvailable {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyPdbMinAvailable {
    return new EnvoyProxySpecProviderKubernetesEnvoyPdbMinAvailable(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyPdbMinAvailable {
    return new EnvoyProxySpecProviderKubernetesEnvoyPdbMinAvailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Patch defines how to perform the patch operation to the PodDisruptionBudget
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyPdbPatch
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyPdbPatch {
  /**
   * Type is the type of merge operation to perform
   *
   * By default, StrategicMerge is used as the patch type.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyPdbPatch#type
   */
  readonly type?: string;

  /**
   * Object contains the raw configuration for merged object
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyPdbPatch#value
   */
  readonly value: any;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyPdbPatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyPdbPatch(obj: EnvoyProxySpecProviderKubernetesEnvoyPdbPatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExternalTrafficPolicy determines the externalTrafficPolicy for the Envoy Service. Valid options
 * are Local and Cluster. Default is "Local". "Local" means traffic will only go to pods on the node
 * receiving the traffic. "Cluster" means connections are loadbalanced to all pods in the cluster.
 *
 * @default Local". "Local" means traffic will only go to pods on the node
 * @schema EnvoyProxySpecProviderKubernetesEnvoyServiceExternalTrafficPolicy
 */
export enum EnvoyProxySpecProviderKubernetesEnvoyServiceExternalTrafficPolicy {
  /** Local */
  LOCAL = "Local",
  /** Cluster */
  CLUSTER = "Cluster",
}

/**
 * Patch defines how to perform the patch operation to the service
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyServicePatch
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyServicePatch {
  /**
   * Type is the type of merge operation to perform
   *
   * By default, StrategicMerge is used as the patch type.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyServicePatch#type
   */
  readonly type?: string;

  /**
   * Object contains the raw configuration for merged object
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyServicePatch#value
   */
  readonly value: any;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyServicePatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyServicePatch(obj: EnvoyProxySpecProviderKubernetesEnvoyServicePatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type determines how the Service is exposed. Defaults to LoadBalancer.
 * Valid options are ClusterIP, LoadBalancer and NodePort.
 * "LoadBalancer" means a service will be exposed via an external load balancer (if the cloud provider supports it).
 * "ClusterIP" means a service will only be accessible inside the cluster, via the cluster IP.
 * "NodePort" means a service will be exposed on a static Port on all Nodes of the cluster.
 *
 * @default LoadBalancer.
 * @schema EnvoyProxySpecProviderKubernetesEnvoyServiceType
 */
export enum EnvoyProxySpecProviderKubernetesEnvoyServiceType {
  /** ClusterIP */
  CLUSTER_IP = "ClusterIP",
  /** LoadBalancer */
  LOAD_BALANCER = "LoadBalancer",
  /** NodePort */
  NODE_PORT = "NodePort",
}

/**
 * Format defines the format of accesslog.
 * This will be ignored if sink type is ALS.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsFormat
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsFormat {
  /**
   * JSON is additional attributes that describe the specific event occurrence.
   * Structured format for the envoy access logs. Envoy [command operators](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators)
   * can be used as values for fields within the Struct.
   * It's required when the format type is "JSON".
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsFormat#json
   */
  readonly json?: { [key: string]: string };

  /**
   * Text defines the text accesslog format, following Envoy accesslog formatting,
   * It's required when the format type is "Text".
   * Envoy [command operators](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators) may be used in the format.
   * The [format string documentation](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#config-access-log-format-strings) provides more information.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsFormat#text
   */
  readonly text?: string;

  /**
   * Type defines the type of accesslog format.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsFormat#type
   */
  readonly type?: EnvoyProxySpecTelemetryAccessLogSettingsFormatType;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsFormat' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsFormat(obj: EnvoyProxySpecTelemetryAccessLogSettingsFormat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'json': ((obj.json) === undefined) ? undefined : (Object.entries(obj.json).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProxyAccessLogSink defines the sink of accesslog.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinks
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinks {
  /**
   * ALS defines the gRPC Access Log Service (ALS) sink.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinks#als
   */
  readonly als?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAls;

  /**
   * File defines the file accesslog sink.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinks#file
   */
  readonly file?: EnvoyProxySpecTelemetryAccessLogSettingsSinksFile;

  /**
   * OpenTelemetry defines the OpenTelemetry accesslog sink.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinks#openTelemetry
   */
  readonly openTelemetry?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetry;

  /**
   * Type defines the type of accesslog sink.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinks#type
   */
  readonly type?: EnvoyProxySpecTelemetryAccessLogSettingsSinksType;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinks(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'als': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAls(obj.als),
    'file': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksFile(obj.file),
    'openTelemetry': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetry(obj.openTelemetry),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type defines the component emitting the accesslog, such as Listener and Route.
 * If type not defined, the setting would apply to:
 * (1) All Routes.
 * (2) Listeners if and only if Envoy does not find a matching route for a request.
 * If type is defined, the accesslog settings would apply to the relevant component (as-is).
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsType
 */
export enum EnvoyProxySpecTelemetryAccessLogSettingsType {
  /** Listener */
  LISTENER = "Listener",
  /** Route */
  ROUTE = "Route",
}

/**
 * Type specifies how to match against a string.
 *
 * @schema EnvoyProxySpecTelemetryMetricsMatchesType
 */
export enum EnvoyProxySpecTelemetryMetricsMatchesType {
  /** Exact */
  EXACT = "Exact",
  /** Prefix */
  PREFIX = "Prefix",
  /** Suffix */
  SUFFIX = "Suffix",
  /** RegularExpression */
  REGULAR_EXPRESSION = "RegularExpression",
}

/**
 * Configure the compression on Prometheus endpoint. Compression is useful in situations when bandwidth is scarce and large payloads can be effectively compressed at the expense of higher CPU load.
 *
 * @schema EnvoyProxySpecTelemetryMetricsPrometheusCompression
 */
export interface EnvoyProxySpecTelemetryMetricsPrometheusCompression {
  /**
   * The configuration for Brotli compressor.
   *
   * @schema EnvoyProxySpecTelemetryMetricsPrometheusCompression#brotli
   */
  readonly brotli?: any;

  /**
   * The configuration for GZIP compressor.
   *
   * @schema EnvoyProxySpecTelemetryMetricsPrometheusCompression#gzip
   */
  readonly gzip?: any;

  /**
   * CompressorType defines the compressor type to use for compression.
   *
   * @schema EnvoyProxySpecTelemetryMetricsPrometheusCompression#type
   */
  readonly type: EnvoyProxySpecTelemetryMetricsPrometheusCompressionType;

  /**
   * The configuration for Zstd compressor.
   *
   * @schema EnvoyProxySpecTelemetryMetricsPrometheusCompression#zstd
   */
  readonly zstd?: any;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsPrometheusCompression' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsPrometheusCompression(obj: EnvoyProxySpecTelemetryMetricsPrometheusCompression | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'brotli': obj.brotli,
    'gzip': obj.gzip,
    'type': obj.type,
    'zstd': obj.zstd,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OpenTelemetry defines the configuration for OpenTelemetry sink.
 * It's required if the sink type is OpenTelemetry.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetry
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetry {
  /**
   * BackendRef references a Kubernetes object that represents the
   * backend server to which the authorization request will be sent.
   *
   * Deprecated: Use BackendRefs instead.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetry#backendRef
   */
  readonly backendRef?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRef;

  /**
   * BackendRefs references a Kubernetes object that represents the
   * backend server to which the authorization request will be sent.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetry#backendRefs
   */
  readonly backendRefs?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRefs[];

  /**
   * BackendSettings holds configuration for managing the connection
   * to the backend.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetry#backendSettings
   */
  readonly backendSettings?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettings;

  /**
   * Host define the service hostname.
   * Deprecated: Use BackendRefs instead.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetry#host
   */
  readonly host?: string;

  /**
   * Port defines the port the service is exposed on.
   * Deprecated: Use BackendRefs instead.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetry#port
   */
  readonly port?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetry(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendRef': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRef(obj.backendRef),
    'backendRefs': obj.backendRefs?.map(y => toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRefs(y)),
    'backendSettings': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettings(obj.backendSettings),
    'host': obj.host,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type defines the metric sink type.
 * EG currently only supports OpenTelemetry.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksType
 */
export enum EnvoyProxySpecTelemetryMetricsSinksType {
  /** OpenTelemetry */
  OPEN_TELEMETRY = "OpenTelemetry",
}

/**
 * Environment adds value from environment variable to each span.
 * It's required when the type is "Environment".
 *
 * @schema EnvoyProxySpecTelemetryTracingCustomTagsEnvironment
 */
export interface EnvoyProxySpecTelemetryTracingCustomTagsEnvironment {
  /**
   * DefaultValue defines the default value to use if the environment variable is not set.
   *
   * @schema EnvoyProxySpecTelemetryTracingCustomTagsEnvironment#defaultValue
   */
  readonly defaultValue?: string;

  /**
   * Name defines the name of the environment variable which to extract the value from.
   *
   * @schema EnvoyProxySpecTelemetryTracingCustomTagsEnvironment#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingCustomTagsEnvironment' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingCustomTagsEnvironment(obj: EnvoyProxySpecTelemetryTracingCustomTagsEnvironment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultValue': obj.defaultValue,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Literal adds hard-coded value to each span.
 * It's required when the type is "Literal".
 *
 * @schema EnvoyProxySpecTelemetryTracingCustomTagsLiteral
 */
export interface EnvoyProxySpecTelemetryTracingCustomTagsLiteral {
  /**
   * Value defines the hard-coded value to add to each span.
   *
   * @schema EnvoyProxySpecTelemetryTracingCustomTagsLiteral#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingCustomTagsLiteral' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingCustomTagsLiteral(obj: EnvoyProxySpecTelemetryTracingCustomTagsLiteral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RequestHeader adds value from request header to each span.
 * It's required when the type is "RequestHeader".
 *
 * @schema EnvoyProxySpecTelemetryTracingCustomTagsRequestHeader
 */
export interface EnvoyProxySpecTelemetryTracingCustomTagsRequestHeader {
  /**
   * DefaultValue defines the default value to use if the request header is not set.
   *
   * @schema EnvoyProxySpecTelemetryTracingCustomTagsRequestHeader#defaultValue
   */
  readonly defaultValue?: string;

  /**
   * Name defines the name of the request header which to extract the value from.
   *
   * @schema EnvoyProxySpecTelemetryTracingCustomTagsRequestHeader#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingCustomTagsRequestHeader' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingCustomTagsRequestHeader(obj: EnvoyProxySpecTelemetryTracingCustomTagsRequestHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultValue': obj.defaultValue,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type defines the type of custom tag.
 *
 * @schema EnvoyProxySpecTelemetryTracingCustomTagsType
 */
export enum EnvoyProxySpecTelemetryTracingCustomTagsType {
  /** Literal */
  LITERAL = "Literal",
  /** Environment */
  ENVIRONMENT = "Environment",
  /** RequestHeader */
  REQUEST_HEADER = "RequestHeader",
}

/**
 * BackendRef references a Kubernetes object that represents the
 * backend server to which the authorization request will be sent.
 *
 * Deprecated: Use BackendRefs instead.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendRef
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendRef {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendRef#group
   */
  readonly group?: string;

  /**
   * Kind is the Kubernetes resource kind of the referent. For example
   * "Service".
   *
   * Defaults to "Service" when not specified.
   *
   * ExternalName services can refer to CNAME DNS records that may live
   * outside of the cluster and as such are difficult to reason about in
   * terms of conformance. They also may not be safe to forward to (see
   * CVE-2021-25740 for more information). Implementations SHOULD NOT
   * support ExternalName Services.
   *
   * Support: Core (Services with a type other than ExternalName)
   *
   * Support: Implementation-specific (Services with type ExternalName)
   *
   * @default Service" when not specified.
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendRef#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the backend. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendRef#namespace
   */
  readonly namespace?: string;

  /**
   * Port specifies the destination port number to use for this resource.
   * Port is required when the referent is a Kubernetes Service. In this
   * case, the port number is the service port number, not the target port.
   * For other resources, destination port might be derived from the referent
   * resource or this field.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendRef#port
   */
  readonly port?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendRef(obj: EnvoyProxySpecTelemetryTracingProviderBackendRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendRef defines how an ObjectReference that is specific to BackendRef.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendRefs
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendRefs {
  /**
   * Fallback indicates whether the backend is designated as a fallback.
   * Multiple fallback backends can be configured.
   * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
   * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
   * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
   * the health of the active backends falls below 72%.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendRefs#fallback
   */
  readonly fallback?: boolean;

  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendRefs#group
   */
  readonly group?: string;

  /**
   * Kind is the Kubernetes resource kind of the referent. For example
   * "Service".
   *
   * Defaults to "Service" when not specified.
   *
   * ExternalName services can refer to CNAME DNS records that may live
   * outside of the cluster and as such are difficult to reason about in
   * terms of conformance. They also may not be safe to forward to (see
   * CVE-2021-25740 for more information). Implementations SHOULD NOT
   * support ExternalName Services.
   *
   * Support: Core (Services with a type other than ExternalName)
   *
   * Support: Implementation-specific (Services with type ExternalName)
   *
   * @default Service" when not specified.
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendRefs#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendRefs#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the backend. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendRefs#namespace
   */
  readonly namespace?: string;

  /**
   * Port specifies the destination port number to use for this resource.
   * Port is required when the referent is a Kubernetes Service. In this
   * case, the port number is the service port number, not the target port.
   * For other resources, destination port might be derived from the referent
   * resource or this field.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendRefs#port
   */
  readonly port?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendRefs(obj: EnvoyProxySpecTelemetryTracingProviderBackendRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fallback': obj.fallback,
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendSettings holds configuration for managing the connection
 * to the backend.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettings
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettings {
  /**
   * Circuit Breaker settings for the upstream connections and requests.
   * If not set, circuit breakers will be enabled with the default thresholds
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettings#circuitBreaker
   */
  readonly circuitBreaker?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreaker;

  /**
   * Connection includes backend connection settings.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettings#connection
   */
  readonly connection?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnection;

  /**
   * DNS includes dns resolution settings.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettings#dns
   */
  readonly dns?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsDns;

  /**
   * HealthCheck allows gateway to perform active health checking on backends.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettings#healthCheck
   */
  readonly healthCheck?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheck;

  /**
   * HTTP2 provides HTTP/2 configuration for backend connections.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettings#http2
   */
  readonly http2?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2;

  /**
   * LoadBalancer policy to apply when routing traffic from the gateway to
   * the backend endpoints. Defaults to `LeastRequest`.
   *
   * @default LeastRequest`.
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettings#loadBalancer
   */
  readonly loadBalancer?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancer;

  /**
   * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettings#proxyProtocol
   */
  readonly proxyProtocol?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsProxyProtocol;

  /**
   * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
   * If not set, retry will be disabled.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettings#retry
   */
  readonly retry?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetry;

  /**
   * TcpKeepalive settings associated with the upstream client connection.
   * Disabled by default.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettings#tcpKeepalive
   */
  readonly tcpKeepalive?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsTcpKeepalive;

  /**
   * Timeout settings for the backend connections.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettings#timeout
   */
  readonly timeout?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeout;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettings(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'circuitBreaker': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreaker(obj.circuitBreaker),
    'connection': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnection(obj.connection),
    'dns': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsDns(obj.dns),
    'healthCheck': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheck(obj.healthCheck),
    'http2': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2(obj.http2),
    'loadBalancer': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancer(obj.loadBalancer),
    'proxyProtocol': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsProxyProtocol(obj.proxyProtocol),
    'retry': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetry(obj.retry),
    'tcpKeepalive': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsTcpKeepalive(obj.tcpKeepalive),
    'timeout': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeout(obj.timeout),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type defines the tracing provider type.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderType
 */
export enum EnvoyProxySpecTelemetryTracingProviderType {
  /** OpenTelemetry */
  OPEN_TELEMETRY = "OpenTelemetry",
  /** Zipkin */
  ZIPKIN = "Zipkin",
  /** Datadog */
  DATADOG = "Datadog",
}

/**
 * Zipkin defines the Zipkin tracing provider configuration
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderZipkin
 */
export interface EnvoyProxySpecTelemetryTracingProviderZipkin {
  /**
   * DisableSharedSpanContext determines whether the default Envoy behaviour of
   * client and server spans sharing the same span context should be disabled.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderZipkin#disableSharedSpanContext
   */
  readonly disableSharedSpanContext?: boolean;

  /**
   * Enable128BitTraceID determines whether a 128bit trace id will be used
   * when creating a new trace instance. If set to false, a 64bit trace
   * id will be used.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderZipkin#enable128BitTraceId
   */
  readonly enable128BitTraceId?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderZipkin' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderZipkin(obj: EnvoyProxySpecTelemetryTracingProviderZipkin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableSharedSpanContext': obj.disableSharedSpanContext,
    'enable128BitTraceId': obj.enable128BitTraceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnv
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnv {
  /**
   * Name of the environment variable.
   * May consist of any printable ASCII characters except '='.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnv#valueFrom
   */
  readonly valueFrom?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFrom;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnv(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources required by this container.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResources
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This field depends on the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResources#claims
   */
  readonly claims?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResources#limits
   */
  readonly limits?: { [key: string]: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResources#requests
   */
  readonly requests?: { [key: string]: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesRequests };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResources(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecurityContext defines the security options the container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContext
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * appArmorProfile is the AppArmor options to use by this container. If set, this profile
   * overrides the pod's appArmorProfile.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextAppArmorProfile;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContext#capabilities
   */
  readonly capabilities?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default value is Default which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContext(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'appArmorProfile': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextAppArmorProfile(obj.appArmorProfile),
    'capabilities': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerVolumeMounts
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerVolumeMounts(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * If specified, the pod's scheduling constraints.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinity
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinity#podAffinity
   */
  readonly podAffinity?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinity;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinity(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodImagePullSecrets
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodImagePullSecrets#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodImagePullSecrets(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecurityContext holds pod-level security attributes and common container settings.
 * Optional: Defaults to empty.  See type description for default values of each field.
 *
 * @default empty.  See type description for default values of each field.
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContext
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContext {
  /**
   * appArmorProfile is the AppArmor options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextAppArmorProfile;

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
   * It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
   * Valid values are "MountOption" and "Recursive".
   *
   * "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
   * This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.
   *
   * "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
   * This requires all Pods that share the same volume to use the same SELinux label.
   * It is not possible to share the same volume among privileged and unprivileged Pods.
   * Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
   * whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
   * CSIDriver instance. Other volumes are always re-labelled recursively.
   * "MountOption" value is allowed only when SELinuxMount feature gate is enabled.
   *
   * If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
   * If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
   * and "Recursive" for all other volumes.
   *
   * This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.
   *
   * All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContext#seLinuxChangePolicy
   */
  readonly seLinuxChangePolicy?: string;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in
   * addition to the container's primary GID and fsGroup (if specified).  If
   * the SupplementalGroupsPolicy feature is enabled, the
   * supplementalGroupsPolicy field determines whether these are in addition
   * to or instead of any group memberships defined in the container image.
   * If unspecified, no additional groups are added, though group memberships
   * defined in the container image may still be used, depending on the
   * supplementalGroupsPolicy field.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Defines how supplemental groups of the first container processes are calculated.
   * Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
   * (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
   * and the container runtime must implement support for this feature.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContext#supplementalGroupsPolicy
   */
  readonly supplementalGroupsPolicy?: string;

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContext#sysctls
   */
  readonly sysctls?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContext(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appArmorProfile': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextAppArmorProfile(obj.appArmorProfile),
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxChangePolicy': obj.seLinuxChangePolicy,
    'seLinuxOptions': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'supplementalGroupsPolicy': obj.supplementalGroupsPolicy,
    'sysctls': obj.sysctls?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSysctls(y)),
    'windowsOptions': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTolerations
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTolerations(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraints
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are ANDed with labelSelector
   * to select the group of existing pods over which spreading will be calculated
   * for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * MatchLabelKeys cannot be set when LabelSelector isn't set.
   * Keys that don't exist in the incoming pod labels will
   * be ignored. A null or empty list means only match against labelSelector.
   *
   * This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   * The global minimum is the minimum number of matching pods in an eligible domain
   * or zero if the number of eligible domains is less than MinDomains.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 2/2/1:
   * In this case, the global minimum is 1.
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |   P   |
   * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
   * scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
   * violate MaxSkew(1).
   * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
   * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
   * to topologies that satisfy it.
   * It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   * And when the number of eligible domains with matching topology keys equals or greater than minDomains,
   * this value has no effect on scheduling.
   * As a result, when the number of eligible domains is less than minDomains,
   * scheduler won't schedule more than maxSkew Pods to those domains.
   * If value is nil, the constraint behaves as if MinDomains is equal to 1.
   * Valid values are integers greater than 0.
   * When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
   *
   * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
   * labelSelector spread as 2/2/2:
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |  P P  |
   * The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
   * In this situation, new pod with the same labelSelector cannot be scheduled,
   * because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
   * it will violate MaxSkew.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
   *
   * If this value is nil, the behavior is equivalent to the Honor policy.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   * If this value is nil, the behavior is equivalent to the Ignore policy.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   * We define a domain as a particular instance of a topology.
   * Also, we define an eligible domain as a domain whose nodes meet the requirements of
   * nodeAffinityPolicy and nodeTaintsPolicy.
   * e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
   * And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
   * It's a required field.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
   * but giving higher precedence to topologies that would help reduce the
   * skew.
   * A constraint is considered "Unsatisfiable" for an incoming pod
   * if and only if every possible node assignment for that pod would violate
   * "MaxSkew" on some topology.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 3/1/1:
   * | zone1 | zone2 | zone3 |
   * | P P P |   P   |   P   |
   * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
   * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
   * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
   * won't make it *more* imbalanced.
   * It's a required field.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraints(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
   * awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   * Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
   * are redirected to the disk.csi.azure.com CSI driver.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#azureDisk
   */
  readonly azureDisk?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   * Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
   * are redirected to the file.csi.azure.com CSI driver.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#azureFile
   */
  readonly azureFile?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
   * Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#cephfs
   */
  readonly cephfs?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine.
   * Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
   * are redirected to the cinder.csi.openstack.org CSI driver.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#cinder
   */
  readonly cinder?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#configMap
   */
  readonly configMap?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#csi
   */
  readonly csi?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#downwardAPI
   */
  readonly downwardApi?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#emptyDir
   */
  readonly emptyDir?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver.
   * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
   * and deleted when the pod is removed.
   *
   * Use this if:
   * a) the volume is only needed while the pod runs,
   * b) features of normal volumes like restoring from snapshot or capacity
   * tracking are needed,
   * c) the storage driver is specified through a storage class, and
   * d) the storage driver supports dynamic volume provisioning through
   * a PersistentVolumeClaim (see EphemeralVolumeSource for more
   * information on the connection between this volume type
   * and PersistentVolumeClaim).
   *
   * Use PersistentVolumeClaim or one of the vendor-specific
   * APIs for volumes that persist for longer than the lifecycle
   * of an individual pod.
   *
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
   * be used that way - see the documentation of the driver for
   * more information.
   *
   * A pod can use both types of ephemeral volumes and
   * persistent volumes at the same time.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#ephemeral
   */
  readonly ephemeral?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#fc
   */
  readonly fc?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFc;

  /**
   * flexVolume represents a generic volume resource that is
   * provisioned/attached using an exec based plugin.
   * Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#flexVolume
   */
  readonly flexVolume?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
   * Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#flocker
   */
  readonly flocker?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
   * gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision.
   * Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
   * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
   * into the Pod's container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#gitRepo
   */
  readonly gitRepo?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
   * Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#glusterfs
   */
  readonly glusterfs?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host
   * machine that is directly exposed to the container. This is generally
   * used for system agents or other privileged things that are allowed
   * to see the host machine. Most containers will NOT need this.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#hostPath
   */
  readonly hostPath?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesHostPath;

  /**
   * image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
   * The volume is resolved at pod startup depending on which PullPolicy value is provided:
   *
   * - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
   * - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
   * - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
   *
   * The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
   * A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
   * The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
   * The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
   * The volume will be mounted read-only (ro) and non-executable files (noexec).
   * Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath) before 1.33.
   * The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#image
   */
  readonly image?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesImage;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes/#iscsi
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#iscsi
   */
  readonly iscsi?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsi;

  /**
   * name of the volume.
   * Must be a DNS_LABEL and unique within the pod.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#name
   */
  readonly name: string;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#nfs
   */
  readonly nfs?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesNfs;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a
   * PersistentVolumeClaim in the same namespace.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
   * Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
   * Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
   * are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
   * is on.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#portworxVolume
   */
  readonly portworxVolume?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#projected
   */
  readonly projected?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
   * Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#quobyte
   */
  readonly quobyte?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
   * Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#rbd
   */
  readonly rbd?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbd;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   * Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#scaleIO
   */
  readonly scaleIo?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIo;

  /**
   * secret represents a secret that should populate this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#secret
   */
  readonly secret?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   * Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#storageos
   */
  readonly storageos?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
   * Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
   * are redirected to the csi.vsphere.vmware.com CSI driver.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes#vsphereVolume
   */
  readonly vsphereVolume?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesVsphereVolume;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsElasticBlockStore': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAwsElasticBlockStore(obj.awsElasticBlockStore),
    'azureDisk': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureDisk(obj.azureDisk),
    'azureFile': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureFile(obj.azureFile),
    'cephfs': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfs(obj.cephfs),
    'cinder': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinder(obj.cinder),
    'configMap': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMap(obj.configMap),
    'csi': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsi(obj.csi),
    'downwardAPI': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApi(obj.downwardApi),
    'emptyDir': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEmptyDir(obj.emptyDir),
    'ephemeral': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeral(obj.ephemeral),
    'fc': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFc(obj.fc),
    'flexVolume': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolume(obj.flexVolume),
    'flocker': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlocker(obj.flocker),
    'gcePersistentDisk': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGcePersistentDisk(obj.gcePersistentDisk),
    'gitRepo': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGitRepo(obj.gitRepo),
    'glusterfs': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGlusterfs(obj.glusterfs),
    'hostPath': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesHostPath(obj.hostPath),
    'image': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesImage(obj.image),
    'iscsi': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsi(obj.iscsi),
    'name': obj.name,
    'nfs': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesNfs(obj.nfs),
    'persistentVolumeClaim': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPersistentVolumeClaim(obj.persistentVolumeClaim),
    'photonPersistentDisk': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPhotonPersistentDisk(obj.photonPersistentDisk),
    'portworxVolume': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPortworxVolume(obj.portworxVolume),
    'projected': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjected(obj.projected),
    'quobyte': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesQuobyte(obj.quobyte),
    'rbd': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbd(obj.rbd),
    'scaleIO': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIo(obj.scaleIo),
    'secret': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecret(obj.secret),
    'storageos': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageos(obj.storageos),
    'vsphereVolume': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Rolling update config params. Present only if type = "RollingUpdate".
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdate
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdate {
  /**
   * The maximum number of nodes with an existing available DaemonSet pod that
   * can have an updated DaemonSet pod during during an update.
   * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
   * This can not be 0 if MaxUnavailable is 0.
   * Absolute number is calculated from percentage by rounding up to a minimum of 1.
   * Default value is 0.
   * Example: when this is set to 30%, at most 30% of the total number of nodes
   * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
   * can have their a new pod created before the old pod is marked as deleted.
   * The update starts by launching new pods on 30% of nodes. Once an updated
   * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
   * on that node is marked deleted. If the old pod becomes unavailable for any
   * reason (Ready transitions to false, is evicted, or is drained) an updated
   * pod is immediately created on that node without considering surge limits.
   * Allowing surge implies the possibility that the resources consumed by the
   * daemonset on any given node can double if the readiness check fails, and
   * so resource intensive daemonsets should take into account that they may
   * cause evictions during disruption.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdate#maxSurge
   */
  readonly maxSurge?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdateMaxSurge;

  /**
   * The maximum number of DaemonSet pods that can be unavailable during the
   * update. Value can be an absolute number (ex: 5) or a percentage of total
   * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
   * number is calculated from percentage by rounding up.
   * This cannot be 0 if MaxSurge is 0
   * Default value is 1.
   * Example: when this is set to 30%, at most 30% of the total number of nodes
   * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
   * can have their pods stopped for an update at any given time. The update
   * starts by stopping at most 30% of those DaemonSet pods and then brings
   * up new DaemonSet pods in their place. Once the new pods are available,
   * it then proceeds onto other DaemonSet pods, thus ensuring that at least
   * 70% of original number of DaemonSet pods are available at all times during
   * the update.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdate#maxUnavailable
   */
  readonly maxUnavailable?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdateMaxUnavailable;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdate(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxSurge': obj.maxSurge?.value,
    'maxUnavailable': obj.maxUnavailable?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnv
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnv {
  /**
   * Name of the environment variable.
   * May consist of any printable ASCII characters except '='.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnv#valueFrom
   */
  readonly valueFrom?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFrom;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnv(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources required by this container.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResources
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This field depends on the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResources#claims
   */
  readonly claims?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResources#limits
   */
  readonly limits?: { [key: string]: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResources#requests
   */
  readonly requests?: { [key: string]: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesRequests };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResources(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecurityContext defines the security options the container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContext
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * appArmorProfile is the AppArmor options to use by this container. If set, this profile
   * overrides the pod's appArmorProfile.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextAppArmorProfile;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContext#capabilities
   */
  readonly capabilities?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default value is Default which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContext(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'appArmorProfile': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextAppArmorProfile(obj.appArmorProfile),
    'capabilities': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerVolumeMounts
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerVolumeMounts(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnv
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnv {
  /**
   * Name of the environment variable.
   * May consist of any printable ASCII characters except '='.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnv#valueFrom
   */
  readonly valueFrom?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFrom;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnv(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps or Secrets
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFrom
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromConfigMapRef;

  /**
   * Optional text to prepend to the name of each environment variable.
   * May consist of any printable ASCII characters except '='.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFrom#secretRef
   */
  readonly secretRef?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromSecretRef;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFrom(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromConfigMapRef(obj.configMapRef),
    'prefix': obj.prefix,
    'secretRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events.
 * Cannot be updated.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecycle
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecycle#postStart
   */
  readonly postStart?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecycle#preStop
   */
  readonly preStop?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStop;

  /**
   * StopSignal defines which signal will be sent to a container when it is being stopped.
   * If not specified, the default is defined by the container runtime in use.
   * StopSignal can only be set for Pods with a non-empty .spec.os.name
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecycle#stopSignal
   */
  readonly stopSignal?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecycle(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecycle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'postStart': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStart(obj.postStart),
    'preStop': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStop(obj.preStop),
    'stopSignal': obj.stopSignal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container liveness.
 * Container will be restarted if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbe
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbe#exec
   */
  readonly exec?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbe#grpc
   */
  readonly grpc?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbe#httpGet
   */
  readonly httpGet?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbe(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersPorts
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersPorts {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   *
   * @default TCP".
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersPorts#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersPorts(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerPort': obj.containerPort,
    'hostIP': obj.hostIp,
    'hostPort': obj.hostPort,
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container service readiness.
 * Container will be removed from service endpoints if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbe
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbe#exec
   */
  readonly exec?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbe#grpc
   */
  readonly grpc?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbe#httpGet
   */
  readonly httpGet?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbe(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResizePolicy
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies.
   * Supported values: cpu, memory.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized.
   * If not specified, it defaults to NotRequired.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResizePolicy(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResizePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceName': obj.resourceName,
    'restartPolicy': obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Compute Resources required by this container.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResources
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This field depends on the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResources#claims
   */
  readonly claims?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResources#limits
   */
  readonly limits?: { [key: string]: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResources#requests
   */
  readonly requests?: { [key: string]: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesRequests };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResources(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerRestartRule describes how a container exit is handled.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersRestartPolicyRules
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersRestartPolicyRules {
  /**
   * Specifies the action taken on a container exit if the requirements
   * are satisfied. The only possible value is "Restart" to restart the
   * container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersRestartPolicyRules#action
   */
  readonly action: string;

  /**
   * Represents the exit codes to check on container exits.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersRestartPolicyRules#exitCodes
   */
  readonly exitCodes?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersRestartPolicyRulesExitCodes;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersRestartPolicyRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersRestartPolicyRules(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersRestartPolicyRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'exitCodes': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersRestartPolicyRulesExitCodes(obj.exitCodes),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecurityContext defines the security options the container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContext
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * appArmorProfile is the AppArmor options to use by this container. If set, this profile
   * overrides the pod's appArmorProfile.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextAppArmorProfile;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContext#capabilities
   */
  readonly capabilities?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default value is Default which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContext(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'appArmorProfile': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextAppArmorProfile(obj.appArmorProfile),
    'capabilities': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized.
 * If specified, no other probes are executed until this completes successfully.
 * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
 * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
 * when it might take a long time to load data or warm a cache, than during steady-state operation.
 * This cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbe
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbe#exec
   */
  readonly exec?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbe#grpc
   */
  readonly grpc?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbe#httpGet
   */
  readonly httpGet?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbe(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeGrpc(obj.grpc),
    'httpGet': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeDevices
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeDevices#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeDevices(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeDevices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'devicePath': obj.devicePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeMounts
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeMounts(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'recursiveReadOnly': obj.recursiveReadOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * If specified, the pod's scheduling constraints.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinity
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinity#podAffinity
   */
  readonly podAffinity?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinity;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinity(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodImagePullSecrets
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodImagePullSecrets#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodImagePullSecrets(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecurityContext holds pod-level security attributes and common container settings.
 * Optional: Defaults to empty.  See type description for default values of each field.
 *
 * @default empty.  See type description for default values of each field.
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContext
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContext {
  /**
   * appArmorProfile is the AppArmor options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextAppArmorProfile;

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
   * It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
   * Valid values are "MountOption" and "Recursive".
   *
   * "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
   * This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.
   *
   * "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
   * This requires all Pods that share the same volume to use the same SELinux label.
   * It is not possible to share the same volume among privileged and unprivileged Pods.
   * Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
   * whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
   * CSIDriver instance. Other volumes are always re-labelled recursively.
   * "MountOption" value is allowed only when SELinuxMount feature gate is enabled.
   *
   * If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
   * If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
   * and "Recursive" for all other volumes.
   *
   * This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.
   *
   * All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContext#seLinuxChangePolicy
   */
  readonly seLinuxChangePolicy?: string;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in
   * addition to the container's primary GID and fsGroup (if specified).  If
   * the SupplementalGroupsPolicy feature is enabled, the
   * supplementalGroupsPolicy field determines whether these are in addition
   * to or instead of any group memberships defined in the container image.
   * If unspecified, no additional groups are added, though group memberships
   * defined in the container image may still be used, depending on the
   * supplementalGroupsPolicy field.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Defines how supplemental groups of the first container processes are calculated.
   * Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
   * (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
   * and the container runtime must implement support for this feature.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContext#supplementalGroupsPolicy
   */
  readonly supplementalGroupsPolicy?: string;

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContext#sysctls
   */
  readonly sysctls?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContext(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appArmorProfile': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextAppArmorProfile(obj.appArmorProfile),
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxChangePolicy': obj.seLinuxChangePolicy,
    'seLinuxOptions': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'supplementalGroupsPolicy': obj.supplementalGroupsPolicy,
    'sysctls': obj.sysctls?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSysctls(y)),
    'windowsOptions': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTolerations
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTolerations(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraints
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are ANDed with labelSelector
   * to select the group of existing pods over which spreading will be calculated
   * for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * MatchLabelKeys cannot be set when LabelSelector isn't set.
   * Keys that don't exist in the incoming pod labels will
   * be ignored. A null or empty list means only match against labelSelector.
   *
   * This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   * The global minimum is the minimum number of matching pods in an eligible domain
   * or zero if the number of eligible domains is less than MinDomains.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 2/2/1:
   * In this case, the global minimum is 1.
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |   P   |
   * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
   * scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
   * violate MaxSkew(1).
   * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
   * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
   * to topologies that satisfy it.
   * It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   * And when the number of eligible domains with matching topology keys equals or greater than minDomains,
   * this value has no effect on scheduling.
   * As a result, when the number of eligible domains is less than minDomains,
   * scheduler won't schedule more than maxSkew Pods to those domains.
   * If value is nil, the constraint behaves as if MinDomains is equal to 1.
   * Valid values are integers greater than 0.
   * When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
   *
   * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
   * labelSelector spread as 2/2/2:
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |  P P  |
   * The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
   * In this situation, new pod with the same labelSelector cannot be scheduled,
   * because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
   * it will violate MaxSkew.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
   *
   * If this value is nil, the behavior is equivalent to the Honor policy.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   * If this value is nil, the behavior is equivalent to the Ignore policy.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   * We define a domain as a particular instance of a topology.
   * Also, we define an eligible domain as a domain whose nodes meet the requirements of
   * nodeAffinityPolicy and nodeTaintsPolicy.
   * e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
   * And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
   * It's a required field.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
   * but giving higher precedence to topologies that would help reduce the
   * skew.
   * A constraint is considered "Unsatisfiable" for an incoming pod
   * if and only if every possible node assignment for that pod would violate
   * "MaxSkew" on some topology.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 3/1/1:
   * | zone1 | zone2 | zone3 |
   * | P P P |   P   |   P   |
   * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
   * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
   * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
   * won't make it *more* imbalanced.
   * It's a required field.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraints(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
   * awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   * Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
   * are redirected to the disk.csi.azure.com CSI driver.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#azureDisk
   */
  readonly azureDisk?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   * Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
   * are redirected to the file.csi.azure.com CSI driver.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#azureFile
   */
  readonly azureFile?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
   * Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#cephfs
   */
  readonly cephfs?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine.
   * Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
   * are redirected to the cinder.csi.openstack.org CSI driver.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#cinder
   */
  readonly cinder?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#configMap
   */
  readonly configMap?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#csi
   */
  readonly csi?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#downwardAPI
   */
  readonly downwardApi?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#emptyDir
   */
  readonly emptyDir?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver.
   * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
   * and deleted when the pod is removed.
   *
   * Use this if:
   * a) the volume is only needed while the pod runs,
   * b) features of normal volumes like restoring from snapshot or capacity
   * tracking are needed,
   * c) the storage driver is specified through a storage class, and
   * d) the storage driver supports dynamic volume provisioning through
   * a PersistentVolumeClaim (see EphemeralVolumeSource for more
   * information on the connection between this volume type
   * and PersistentVolumeClaim).
   *
   * Use PersistentVolumeClaim or one of the vendor-specific
   * APIs for volumes that persist for longer than the lifecycle
   * of an individual pod.
   *
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
   * be used that way - see the documentation of the driver for
   * more information.
   *
   * A pod can use both types of ephemeral volumes and
   * persistent volumes at the same time.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#ephemeral
   */
  readonly ephemeral?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#fc
   */
  readonly fc?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFc;

  /**
   * flexVolume represents a generic volume resource that is
   * provisioned/attached using an exec based plugin.
   * Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#flexVolume
   */
  readonly flexVolume?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
   * Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#flocker
   */
  readonly flocker?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
   * gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision.
   * Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
   * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
   * into the Pod's container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#gitRepo
   */
  readonly gitRepo?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
   * Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#glusterfs
   */
  readonly glusterfs?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host
   * machine that is directly exposed to the container. This is generally
   * used for system agents or other privileged things that are allowed
   * to see the host machine. Most containers will NOT need this.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#hostPath
   */
  readonly hostPath?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesHostPath;

  /**
   * image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
   * The volume is resolved at pod startup depending on which PullPolicy value is provided:
   *
   * - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
   * - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
   * - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
   *
   * The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
   * A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
   * The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
   * The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
   * The volume will be mounted read-only (ro) and non-executable files (noexec).
   * Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath) before 1.33.
   * The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#image
   */
  readonly image?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesImage;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes/#iscsi
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#iscsi
   */
  readonly iscsi?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsi;

  /**
   * name of the volume.
   * Must be a DNS_LABEL and unique within the pod.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#name
   */
  readonly name: string;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#nfs
   */
  readonly nfs?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesNfs;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a
   * PersistentVolumeClaim in the same namespace.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
   * Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
   * Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
   * are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
   * is on.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#portworxVolume
   */
  readonly portworxVolume?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#projected
   */
  readonly projected?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
   * Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#quobyte
   */
  readonly quobyte?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
   * Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#rbd
   */
  readonly rbd?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbd;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   * Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#scaleIO
   */
  readonly scaleIo?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIo;

  /**
   * secret represents a secret that should populate this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#secret
   */
  readonly secret?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   * Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#storageos
   */
  readonly storageos?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
   * Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
   * are redirected to the csi.vsphere.vmware.com CSI driver.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes#vsphereVolume
   */
  readonly vsphereVolume?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesVsphereVolume;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsElasticBlockStore': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAwsElasticBlockStore(obj.awsElasticBlockStore),
    'azureDisk': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureDisk(obj.azureDisk),
    'azureFile': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureFile(obj.azureFile),
    'cephfs': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfs(obj.cephfs),
    'cinder': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinder(obj.cinder),
    'configMap': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMap(obj.configMap),
    'csi': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsi(obj.csi),
    'downwardAPI': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApi(obj.downwardApi),
    'emptyDir': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEmptyDir(obj.emptyDir),
    'ephemeral': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeral(obj.ephemeral),
    'fc': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFc(obj.fc),
    'flexVolume': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolume(obj.flexVolume),
    'flocker': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlocker(obj.flocker),
    'gcePersistentDisk': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGcePersistentDisk(obj.gcePersistentDisk),
    'gitRepo': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGitRepo(obj.gitRepo),
    'glusterfs': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGlusterfs(obj.glusterfs),
    'hostPath': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesHostPath(obj.hostPath),
    'image': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesImage(obj.image),
    'iscsi': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsi(obj.iscsi),
    'name': obj.name,
    'nfs': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesNfs(obj.nfs),
    'persistentVolumeClaim': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPersistentVolumeClaim(obj.persistentVolumeClaim),
    'photonPersistentDisk': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPhotonPersistentDisk(obj.photonPersistentDisk),
    'portworxVolume': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPortworxVolume(obj.portworxVolume),
    'projected': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjected(obj.projected),
    'quobyte': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesQuobyte(obj.quobyte),
    'rbd': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbd(obj.rbd),
    'scaleIO': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIo(obj.scaleIo),
    'secret': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecret(obj.secret),
    'storageos': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageos(obj.storageos),
    'vsphereVolume': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Rolling update config params. Present only if DeploymentStrategyType =
 * RollingUpdate.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdate
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdate {
  /**
   * The maximum number of pods that can be scheduled above the desired number of
   * pods.
   * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
   * This can not be 0 if MaxUnavailable is 0.
   * Absolute number is calculated from percentage by rounding up.
   * Defaults to 25%.
   * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
   * the rolling update starts, such that the total number of old and new pods do not exceed
   * 130% of desired pods. Once old pods have been killed,
   * new ReplicaSet can be scaled up further, ensuring that total number of pods running
   * at any time during the update is at most 130% of desired pods.
   *
   * @default 25%.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdate#maxSurge
   */
  readonly maxSurge?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdateMaxSurge;

  /**
   * The maximum number of pods that can be unavailable during the update.
   * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
   * Absolute number is calculated from percentage by rounding down.
   * This can not be 0 if MaxSurge is 0.
   * Defaults to 25%.
   * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
   * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
   * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
   * that the total number of pods available at all times during the update is at
   * least 70% of desired pods.
   *
   * @default 25%.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdate#maxUnavailable
   */
  readonly maxUnavailable?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdateMaxUnavailable;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdate(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxSurge': obj.maxSurge?.value,
    'maxUnavailable': obj.maxUnavailable?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * scaleDown is scaling policy for scaling Down.
 * If not set, the default value is to allow to scale down to minReplicas pods, with a
 * 300 second stabilization window (i.e., the highest recommendation for
 * the last 300sec is used).
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDown
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDown {
  /**
   * policies is a list of potential scaling polices which can be used during scaling.
   * If not set, use the default values:
   * - For scale up: allow doubling the number of pods, or an absolute change of 4 pods in a 15s window.
   * - For scale down: allow all pods to be removed in a 15s window.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDown#policies
   */
  readonly policies?: EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDownPolicies[];

  /**
   * selectPolicy is used to specify which policy should be used.
   * If not set, the default value Max is used.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDown#selectPolicy
   */
  readonly selectPolicy?: string;

  /**
   * stabilizationWindowSeconds is the number of seconds for which past recommendations should be
   * considered while scaling up or scaling down.
   * StabilizationWindowSeconds must be greater than or equal to zero and less than or equal to 3600 (one hour).
   * If not set, use the default values:
   * - For scale up: 0 (i.e. no stabilization is done).
   * - For scale down: 300 (i.e. the stabilization window is 300 seconds long).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDown#stabilizationWindowSeconds
   */
  readonly stabilizationWindowSeconds?: number;

  /**
   * tolerance is the tolerance on the ratio between the current and desired
   * metric value under which no updates are made to the desired number of
   * replicas (e.g. 0.01 for 1%). Must be greater than or equal to zero. If not
   * set, the default cluster-wide tolerance is applied (by default 10%).
   *
   * For example, if autoscaling is configured with a memory consumption target of 100Mi,
   * and scale-down and scale-up tolerances of 5% and 1% respectively, scaling will be
   * triggered when the actual consumption falls below 95Mi or exceeds 101Mi.
   *
   * This is an alpha field and requires enabling the HPAConfigurableTolerance
   * feature gate.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDown#tolerance
   */
  readonly tolerance?: EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDownTolerance;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDown' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDown(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDown | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policies': obj.policies?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDownPolicies(y)),
    'selectPolicy': obj.selectPolicy,
    'stabilizationWindowSeconds': obj.stabilizationWindowSeconds,
    'tolerance': obj.tolerance?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * scaleUp is scaling policy for scaling Up.
 * If not set, the default value is the higher of:
 * * increase no more than 4 pods per 60 seconds
 * * double the number of pods per 60 seconds
 * No stabilization is used.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUp
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUp {
  /**
   * policies is a list of potential scaling polices which can be used during scaling.
   * If not set, use the default values:
   * - For scale up: allow doubling the number of pods, or an absolute change of 4 pods in a 15s window.
   * - For scale down: allow all pods to be removed in a 15s window.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUp#policies
   */
  readonly policies?: EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUpPolicies[];

  /**
   * selectPolicy is used to specify which policy should be used.
   * If not set, the default value Max is used.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUp#selectPolicy
   */
  readonly selectPolicy?: string;

  /**
   * stabilizationWindowSeconds is the number of seconds for which past recommendations should be
   * considered while scaling up or scaling down.
   * StabilizationWindowSeconds must be greater than or equal to zero and less than or equal to 3600 (one hour).
   * If not set, use the default values:
   * - For scale up: 0 (i.e. no stabilization is done).
   * - For scale down: 300 (i.e. the stabilization window is 300 seconds long).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUp#stabilizationWindowSeconds
   */
  readonly stabilizationWindowSeconds?: number;

  /**
   * tolerance is the tolerance on the ratio between the current and desired
   * metric value under which no updates are made to the desired number of
   * replicas (e.g. 0.01 for 1%). Must be greater than or equal to zero. If not
   * set, the default cluster-wide tolerance is applied (by default 10%).
   *
   * For example, if autoscaling is configured with a memory consumption target of 100Mi,
   * and scale-down and scale-up tolerances of 5% and 1% respectively, scaling will be
   * triggered when the actual consumption falls below 95Mi or exceeds 101Mi.
   *
   * This is an alpha field and requires enabling the HPAConfigurableTolerance
   * feature gate.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUp#tolerance
   */
  readonly tolerance?: EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUpTolerance;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUp(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policies': obj.policies?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUpPolicies(y)),
    'selectPolicy': obj.selectPolicy,
    'stabilizationWindowSeconds': obj.stabilizationWindowSeconds,
    'tolerance': obj.tolerance?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * containerResource refers to a resource metric (such as those specified in
 * requests and limits) known to Kubernetes describing a single container in
 * each pod of the current scale target (e.g. CPU or memory). Such metrics are
 * built in to Kubernetes, and have special scaling options on top of those
 * available to normal per-pod metrics using the "pods" source.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResource
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResource {
  /**
   * container is the name of the container in the pods of the scaling target
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResource#container
   */
  readonly container: string;

  /**
   * name is the name of the resource in question.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResource#name
   */
  readonly name: string;

  /**
   * target specifies the target value for the given metric
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResource#target
   */
  readonly target: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTarget;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResource(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'container': obj.container,
    'name': obj.name,
    'target': toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTarget(obj.target),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * external refers to a global metric that is not associated
 * with any Kubernetes object. It allows autoscaling based on information
 * coming from components running outside of cluster
 * (for example length of queue in cloud messaging service, or
 * QPS from loadbalancer running outside of cluster).
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternal
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternal {
  /**
   * metric identifies the target metric by name and selector
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternal#metric
   */
  readonly metric: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetric;

  /**
   * target specifies the target value for the given metric
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternal#target
   */
  readonly target: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTarget;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternal' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternal(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metric': toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetric(obj.metric),
    'target': toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTarget(obj.target),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * object refers to a metric describing a single kubernetes object
 * (for example, hits-per-second on an Ingress object).
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObject
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObject {
  /**
   * describedObject specifies the descriptions of a object,such as kind,name apiVersion
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObject#describedObject
   */
  readonly describedObject: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectDescribedObject;

  /**
   * metric identifies the target metric by name and selector
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObject#metric
   */
  readonly metric: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetric;

  /**
   * target specifies the target value for the given metric
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObject#target
   */
  readonly target: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTarget;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObject' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObject(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'describedObject': toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectDescribedObject(obj.describedObject),
    'metric': toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetric(obj.metric),
    'target': toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTarget(obj.target),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * pods refers to a metric describing each pod in the current scale target
 * (for example, transactions-processed-per-second).  The values will be
 * averaged together before being compared to the target value.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPods
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPods {
  /**
   * metric identifies the target metric by name and selector
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPods#metric
   */
  readonly metric: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetric;

  /**
   * target specifies the target value for the given metric
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPods#target
   */
  readonly target: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTarget;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPods' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPods(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPods | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metric': toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetric(obj.metric),
    'target': toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTarget(obj.target),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resource refers to a resource metric (such as those specified in
 * requests and limits) known to Kubernetes describing each pod in the
 * current scale target (e.g. CPU or memory). Such metrics are built in to
 * Kubernetes, and have special scaling options on top of those available
 * to normal per-pod metrics using the "pods" source.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResource
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResource {
  /**
   * name is the name of the resource in question.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResource#name
   */
  readonly name: string;

  /**
   * target specifies the target value for the given metric
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResource#target
   */
  readonly target: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTarget;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResource(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'target': toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTarget(obj.target),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type defines the type of accesslog format.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsFormatType
 */
export enum EnvoyProxySpecTelemetryAccessLogSettingsFormatType {
  /** Text */
  TEXT = "Text",
  /** JSON */
  JSON = "JSON",
}

/**
 * ALS defines the gRPC Access Log Service (ALS) sink.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAls
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAls {
  /**
   * BackendRef references a Kubernetes object that represents the
   * backend server to which the authorization request will be sent.
   *
   * Deprecated: Use BackendRefs instead.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAls#backendRef
   */
  readonly backendRef?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRef;

  /**
   * BackendRefs references a Kubernetes object that represents the
   * backend server to which the authorization request will be sent.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAls#backendRefs
   */
  readonly backendRefs?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRefs[];

  /**
   * BackendSettings holds configuration for managing the connection
   * to the backend.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAls#backendSettings
   */
  readonly backendSettings?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettings;

  /**
   * HTTP defines additional configuration specific to HTTP access logs.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAls#http
   */
  readonly http?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsHttp;

  /**
   * LogName defines the friendly name of the access log to be returned in
   * StreamAccessLogsMessage.Identifier. This allows the access log server
   * to differentiate between different access logs coming from the same Envoy.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAls#logName
   */
  readonly logName?: string;

  /**
   * Type defines the type of accesslog. Supported types are "HTTP" and "TCP".
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAls#type
   */
  readonly type: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsType;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAls(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendRef': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRef(obj.backendRef),
    'backendRefs': obj.backendRefs?.map(y => toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRefs(y)),
    'backendSettings': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettings(obj.backendSettings),
    'http': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsHttp(obj.http),
    'logName': obj.logName,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * File defines the file accesslog sink.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksFile
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksFile {
  /**
   * Path defines the file path used to expose envoy access log(e.g. /dev/stdout).
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksFile#path
   */
  readonly path?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksFile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksFile(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OpenTelemetry defines the OpenTelemetry accesslog sink.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetry
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetry {
  /**
   * BackendRef references a Kubernetes object that represents the
   * backend server to which the authorization request will be sent.
   *
   * Deprecated: Use BackendRefs instead.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetry#backendRef
   */
  readonly backendRef?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRef;

  /**
   * BackendRefs references a Kubernetes object that represents the
   * backend server to which the authorization request will be sent.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetry#backendRefs
   */
  readonly backendRefs?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRefs[];

  /**
   * BackendSettings holds configuration for managing the connection
   * to the backend.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetry#backendSettings
   */
  readonly backendSettings?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettings;

  /**
   * Host define the extension service hostname.
   * Deprecated: Use BackendRefs instead.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetry#host
   */
  readonly host?: string;

  /**
   * Port defines the port the extension service is exposed on.
   * Deprecated: Use BackendRefs instead.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetry#port
   */
  readonly port?: number;

  /**
   * Resources is a set of labels that describe the source of a log entry, including envoy node info.
   * It's recommended to follow [semantic conventions](https://opentelemetry.io/docs/reference/specification/resource/semantic_conventions/).
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetry#resources
   */
  readonly resources?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetry(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendRef': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRef(obj.backendRef),
    'backendRefs': obj.backendRefs?.map(y => toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRefs(y)),
    'backendSettings': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettings(obj.backendSettings),
    'host': obj.host,
    'port': obj.port,
    'resources': ((obj.resources) === undefined) ? undefined : (Object.entries(obj.resources).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type defines the type of accesslog sink.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksType
 */
export enum EnvoyProxySpecTelemetryAccessLogSettingsSinksType {
  /** ALS */
  ALS = "ALS",
  /** File */
  FILE = "File",
  /** OpenTelemetry */
  OPEN_TELEMETRY = "OpenTelemetry",
}

/**
 * CompressorType defines the compressor type to use for compression.
 *
 * @schema EnvoyProxySpecTelemetryMetricsPrometheusCompressionType
 */
export enum EnvoyProxySpecTelemetryMetricsPrometheusCompressionType {
  /** Gzip */
  GZIP = "Gzip",
  /** Brotli */
  BROTLI = "Brotli",
  /** Zstd */
  ZSTD = "Zstd",
}

/**
 * BackendRef references a Kubernetes object that represents the
 * backend server to which the authorization request will be sent.
 *
 * Deprecated: Use BackendRefs instead.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRef
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRef {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRef#group
   */
  readonly group?: string;

  /**
   * Kind is the Kubernetes resource kind of the referent. For example
   * "Service".
   *
   * Defaults to "Service" when not specified.
   *
   * ExternalName services can refer to CNAME DNS records that may live
   * outside of the cluster and as such are difficult to reason about in
   * terms of conformance. They also may not be safe to forward to (see
   * CVE-2021-25740 for more information). Implementations SHOULD NOT
   * support ExternalName Services.
   *
   * Support: Core (Services with a type other than ExternalName)
   *
   * Support: Implementation-specific (Services with type ExternalName)
   *
   * @default Service" when not specified.
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRef#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the backend. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRef#namespace
   */
  readonly namespace?: string;

  /**
   * Port specifies the destination port number to use for this resource.
   * Port is required when the referent is a Kubernetes Service. In this
   * case, the port number is the service port number, not the target port.
   * For other resources, destination port might be derived from the referent
   * resource or this field.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRef#port
   */
  readonly port?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRef(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendRef defines how an ObjectReference that is specific to BackendRef.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRefs
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRefs {
  /**
   * Fallback indicates whether the backend is designated as a fallback.
   * Multiple fallback backends can be configured.
   * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
   * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
   * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
   * the health of the active backends falls below 72%.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRefs#fallback
   */
  readonly fallback?: boolean;

  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRefs#group
   */
  readonly group?: string;

  /**
   * Kind is the Kubernetes resource kind of the referent. For example
   * "Service".
   *
   * Defaults to "Service" when not specified.
   *
   * ExternalName services can refer to CNAME DNS records that may live
   * outside of the cluster and as such are difficult to reason about in
   * terms of conformance. They also may not be safe to forward to (see
   * CVE-2021-25740 for more information). Implementations SHOULD NOT
   * support ExternalName Services.
   *
   * Support: Core (Services with a type other than ExternalName)
   *
   * Support: Implementation-specific (Services with type ExternalName)
   *
   * @default Service" when not specified.
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRefs#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRefs#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the backend. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRefs#namespace
   */
  readonly namespace?: string;

  /**
   * Port specifies the destination port number to use for this resource.
   * Port is required when the referent is a Kubernetes Service. In this
   * case, the port number is the service port number, not the target port.
   * For other resources, destination port might be derived from the referent
   * resource or this field.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRefs#port
   */
  readonly port?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRefs(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fallback': obj.fallback,
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendSettings holds configuration for managing the connection
 * to the backend.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettings
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettings {
  /**
   * Circuit Breaker settings for the upstream connections and requests.
   * If not set, circuit breakers will be enabled with the default thresholds
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettings#circuitBreaker
   */
  readonly circuitBreaker?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreaker;

  /**
   * Connection includes backend connection settings.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettings#connection
   */
  readonly connection?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnection;

  /**
   * DNS includes dns resolution settings.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettings#dns
   */
  readonly dns?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsDns;

  /**
   * HealthCheck allows gateway to perform active health checking on backends.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettings#healthCheck
   */
  readonly healthCheck?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheck;

  /**
   * HTTP2 provides HTTP/2 configuration for backend connections.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettings#http2
   */
  readonly http2?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2;

  /**
   * LoadBalancer policy to apply when routing traffic from the gateway to
   * the backend endpoints. Defaults to `LeastRequest`.
   *
   * @default LeastRequest`.
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettings#loadBalancer
   */
  readonly loadBalancer?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancer;

  /**
   * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettings#proxyProtocol
   */
  readonly proxyProtocol?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsProxyProtocol;

  /**
   * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
   * If not set, retry will be disabled.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettings#retry
   */
  readonly retry?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetry;

  /**
   * TcpKeepalive settings associated with the upstream client connection.
   * Disabled by default.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettings#tcpKeepalive
   */
  readonly tcpKeepalive?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTcpKeepalive;

  /**
   * Timeout settings for the backend connections.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettings#timeout
   */
  readonly timeout?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeout;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettings(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'circuitBreaker': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreaker(obj.circuitBreaker),
    'connection': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnection(obj.connection),
    'dns': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsDns(obj.dns),
    'healthCheck': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheck(obj.healthCheck),
    'http2': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2(obj.http2),
    'loadBalancer': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancer(obj.loadBalancer),
    'proxyProtocol': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsProxyProtocol(obj.proxyProtocol),
    'retry': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetry(obj.retry),
    'tcpKeepalive': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTcpKeepalive(obj.tcpKeepalive),
    'timeout': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeout(obj.timeout),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Circuit Breaker settings for the upstream connections and requests.
 * If not set, circuit breakers will be enabled with the default thresholds
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreaker
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreaker {
  /**
   * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreaker#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreaker#maxParallelRequests
   */
  readonly maxParallelRequests?: number;

  /**
   * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreaker#maxParallelRetries
   */
  readonly maxParallelRetries?: number;

  /**
   * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreaker#maxPendingRequests
   */
  readonly maxPendingRequests?: number;

  /**
   * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
   * Default: unlimited.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreaker#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreaker#perEndpoint
   */
  readonly perEndpoint?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreakerPerEndpoint;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreaker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreaker(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreaker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
    'maxParallelRequests': obj.maxParallelRequests,
    'maxParallelRetries': obj.maxParallelRetries,
    'maxPendingRequests': obj.maxPendingRequests,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'perEndpoint': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreakerPerEndpoint(obj.perEndpoint),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Connection includes backend connection settings.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnection
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnection {
  /**
   * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
   * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
   * If unspecified, an implementation defined default is applied (32768 bytes).
   * For example, 20Mi, 1Gi, 256Ki etc.
   * Note: that when the suffix is not provided, the value is interpreted as bytes.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnection#bufferLimit
   */
  readonly bufferLimit?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionBufferLimit;

  /**
   * Preconnect configures proactive upstream connections to reduce latency by establishing
   * connections before they’re needed and avoiding connection establishment overhead.
   *
   * If unset, Envoy will fetch connections as needed to serve in-flight requests.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnection#preconnect
   */
  readonly preconnect?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionPreconnect;

  /**
   * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
   * to backend.
   * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
   * For example, 20Mi, 1Gi, 256Ki etc.
   * Note that when the suffix is not provided, the value is interpreted as bytes.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnection#socketBufferLimit
   */
  readonly socketBufferLimit?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionSocketBufferLimit;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnection(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bufferLimit': obj.bufferLimit?.value,
    'preconnect': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionPreconnect(obj.preconnect),
    'socketBufferLimit': obj.socketBufferLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DNS includes dns resolution settings.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsDns
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsDns {
  /**
   * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
   * Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsDns#dnsRefreshRate
   */
  readonly dnsRefreshRate?: string;

  /**
   * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
   * If set, this configuration overrides other defaults.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsDns#lookupFamily
   */
  readonly lookupFamily?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsDnsLookupFamily;

  /**
   * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
   * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
   * Defaults to true.
   *
   * @default true.
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsDns#respectDnsTtl
   */
  readonly respectDnsTtl?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsDns' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsDns(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsDns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsRefreshRate': obj.dnsRefreshRate,
    'lookupFamily': obj.lookupFamily,
    'respectDnsTtl': obj.respectDnsTtl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HealthCheck allows gateway to perform active health checking on backends.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheck
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheck {
  /**
   * Active health check configuration
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheck#active
   */
  readonly active?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActive;

  /**
   * When number of unhealthy endpoints for a backend reaches this threshold
   * Envoy will disregard health status and balance across all endpoints.
   * It's designed to prevent a situation in which host failures cascade throughout the cluster
   * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheck#panicThreshold
   */
  readonly panicThreshold?: number;

  /**
   * Passive passive check configuration
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheck#passive
   */
  readonly passive?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckPassive;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheck(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'active': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActive(obj.active),
    'panicThreshold': obj.panicThreshold,
    'passive': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckPassive(obj.passive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP2 provides HTTP/2 configuration for backend connections.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2 {
  /**
   * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
   * If not set, the default value is 1 MiB.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2#initialConnectionWindowSize
   */
  readonly initialConnectionWindowSize?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2InitialConnectionWindowSize;

  /**
   * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
   * If not set, the default value is 64 KiB(64*1024).
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2#initialStreamWindowSize
   */
  readonly initialStreamWindowSize?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2InitialStreamWindowSize;

  /**
   * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
   * If not set, the default value is 100.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
   * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
   * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
   * Default: TerminateConnection
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2#onInvalidMessage
   */
  readonly onInvalidMessage?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'initialConnectionWindowSize': obj.initialConnectionWindowSize?.value,
    'initialStreamWindowSize': obj.initialStreamWindowSize?.value,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'onInvalidMessage': obj.onInvalidMessage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LoadBalancer policy to apply when routing traffic from the gateway to
 * the backend endpoints. Defaults to `LeastRequest`.
 *
 * @default LeastRequest`.
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancer
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancer {
  /**
   * ConsistentHash defines the configuration when the load balancer type is
   * set to ConsistentHash
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancer#consistentHash
   */
  readonly consistentHash?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHash;

  /**
   * EndpointOverride defines the configuration for endpoint override.
   * When specified, the load balancer will attempt to route requests to endpoints
   * based on the override information extracted from request headers or metadata.
   * If the override endpoints are not available, the configured load balancer policy will be used as fallback.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancer#endpointOverride
   */
  readonly endpointOverride?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverride;

  /**
   * SlowStart defines the configuration related to the slow start load balancer policy.
   * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
   * Currently this is only supported for RoundRobin and LeastRequest load balancers
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancer#slowStart
   */
  readonly slowStart?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerSlowStart;

  /**
   * Type decides the type of Load Balancer policy.
   * Valid LoadBalancerType values are
   * "ConsistentHash",
   * "LeastRequest",
   * "Random",
   * "RoundRobin".
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancer#type
   */
  readonly type: EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerType;

  /**
   * ZoneAware defines the configuration related to the distribution of requests between locality zones.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancer#zoneAware
   */
  readonly zoneAware?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAware;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancer(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHash(obj.consistentHash),
    'endpointOverride': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverride(obj.endpointOverride),
    'slowStart': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerSlowStart(obj.slowStart),
    'type': obj.type,
    'zoneAware': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAware(obj.zoneAware),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsProxyProtocol
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsProxyProtocol {
  /**
   * Version of ProxyProtol
   * Valid ProxyProtocolVersion values are
   * "V1"
   * "V2"
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsProxyProtocol#version
   */
  readonly version: EnvoyProxySpecTelemetryTracingProviderBackendSettingsProxyProtocolVersion;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsProxyProtocol' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsProxyProtocol(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsProxyProtocol | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
 * If not set, retry will be disabled.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetry
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetry {
  /**
   * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
   * that should be sent to the same priority before switching to a different one.
   * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetry#numAttemptsPerPriority
   */
  readonly numAttemptsPerPriority?: number;

  /**
   * NumRetries is the number of retries to be attempted. Defaults to 2.
   *
   * @default 2.
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetry#numRetries
   */
  readonly numRetries?: number;

  /**
   * PerRetry is the retry policy to be applied per retry attempt.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetry#perRetry
   */
  readonly perRetry?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetry;

  /**
   * RetryOn specifies the retry trigger condition.
   *
   * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetry#retryOn
   */
  readonly retryOn?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryRetryOn;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetry(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'numAttemptsPerPriority': obj.numAttemptsPerPriority,
    'numRetries': obj.numRetries,
    'perRetry': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetry(obj.perRetry),
    'retryOn': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryRetryOn(obj.retryOn),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TcpKeepalive settings associated with the upstream client connection.
 * Disabled by default.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsTcpKeepalive
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsTcpKeepalive {
  /**
   * The duration a connection needs to be idle before keep-alive
   * probes start being sent.
   * The duration format is
   * Defaults to `7200s`.
   *
   * @default 7200s`.
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsTcpKeepalive#idleTime
   */
  readonly idleTime?: string;

  /**
   * The duration between keep-alive probes.
   * Defaults to `75s`.
   *
   * @default 75s`.
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * The total number of unacknowledged probes to send before deciding
   * the connection is dead.
   * Defaults to 9.
   *
   * @default 9.
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsTcpKeepalive#probes
   */
  readonly probes?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsTcpKeepalive(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idleTime': obj.idleTime,
    'interval': obj.interval,
    'probes': obj.probes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for the backend connections.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeout
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeout {
  /**
   * Timeout settings for HTTP.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeout#http
   */
  readonly http?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutHttp;

  /**
   * Timeout settings for TCP.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeout#tcp
   */
  readonly tcp?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutTcp;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeout' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeout(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutHttp(obj.http),
    'tcp': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFrom
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFrom#fieldRef
   */
  readonly fieldRef?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFieldRef;

  /**
   * FileKeyRef selects a key of the env file.
   * Requires the EnvFiles feature gate to be enabled.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFrom#fileKeyRef
   */
  readonly fileKeyRef?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFileKeyRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFrom(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFieldRef(obj.fieldRef),
    'fileKeyRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFileKeyRef(obj.fileKeyRef),
    'resourceFieldRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesClaims
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesClaims(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesLimits
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesLimits {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesLimits {
    return new EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesLimits(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesLimits {
    return new EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesRequests
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesRequests {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesRequests {
    return new EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesRequests(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesRequests {
    return new EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * appArmorProfile is the AppArmor options to use by this container. If set, this profile
 * overrides the pod's appArmorProfile.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextAppArmorProfile
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextAppArmorProfile(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextAppArmorProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextCapabilities
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextCapabilities(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeLinuxOptions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeLinuxOptions(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeccompProfile
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeccompProfile(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextWindowsOptions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextWindowsOptions(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinity
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinity(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinity
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinity(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinity
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and subtracting
   * "weight" from the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinity(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * appArmorProfile is the AppArmor options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextAppArmorProfile
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextAppArmorProfile(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextAppArmorProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeLinuxOptions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeLinuxOptions(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeccompProfile
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeccompProfile(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSysctls
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSysctls#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSysctls(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextWindowsOptions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextWindowsOptions(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
 * awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAwsElasticBlockStore
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAwsElasticBlockStore(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAwsElasticBlockStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 * Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
 * are redirected to the disk.csi.azure.com CSI driver.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureDisk
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureDisk(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingMode': obj.cachingMode,
    'diskName': obj.diskName,
    'diskURI': obj.diskUri,
    'fsType': obj.fsType,
    'kind': obj.kind,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 * Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
 * are redirected to the file.csi.azure.com CSI driver.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureFile
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureFile#shareName
   */
  readonly shareName: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureFile(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'secretName': obj.secretName,
    'shareName': obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
 * Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfs
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfs#secretRef
   */
  readonly secretRef?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfs#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfs(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitors': obj.monitors?.map(y => y),
    'path': obj.path,
    'readOnly': obj.readOnly,
    'secretFile': obj.secretFile,
    'secretRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfsSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine.
 * Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
 * are redirected to the cinder.csi.openstack.org CSI driver.
 * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinder
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinder {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect
   * to OpenStack.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinder#secretRef
   */
  readonly secretRef?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinder#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinder(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinderSecretRef(obj.secretRef),
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMap
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMap#items
   */
  readonly items?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMap(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsi
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsi {
  /**
   * driver is the name of the CSI driver that handles this volume.
   * Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs".
   * If not provided, the empty value is passed to the associated CSI driver
   * which will determine the default filesystem to apply.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * NodePublishVolume and NodeUnpublishVolume calls.
   * This field is optional, and  may be empty if no secret is required. If the
   * secret object contains more than one secret, all secret references are passed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume.
   * Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI
   * driver. Consult your driver's documentation for supported values.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsi(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'nodePublishSecretRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    'readOnly': obj.readOnly,
    'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApi
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a
   * Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApi#items
   */
  readonly items?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItems[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApi(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEmptyDir
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEmptyDirSizeLimit;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEmptyDir(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver.
 * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
 * and deleted when the pod is removed.
 *
 * Use this if:
 * a) the volume is only needed while the pod runs,
 * b) features of normal volumes like restoring from snapshot or capacity
 * tracking are needed,
 * c) the storage driver is specified through a storage class, and
 * d) the storage driver supports dynamic volume provisioning through
 * a PersistentVolumeClaim (see EphemeralVolumeSource for more
 * information on the connection between this volume type
 * and PersistentVolumeClaim).
 *
 * Use PersistentVolumeClaim or one of the vendor-specific
 * APIs for volumes that persist for longer than the lifecycle
 * of an individual pod.
 *
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
 * be used that way - see the documentation of the driver for
 * more information.
 *
 * A pod can use both types of ephemeral volumes and
 * persistent volumes at the same time.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeral
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume.
   * The pod in which this EphemeralVolumeSource is embedded will be the
   * owner of the PVC, i.e. the PVC will be deleted together with the
   * pod.  The name of the PVC will be `<pod name>-<volume name>` where
   * `<volume name>` is the name from the `PodSpec.Volumes` array
   * entry. Pod validation will reject the pod if the concatenated name
   * is not valid for a PVC (for example, too long).
   *
   * An existing PVC with that name that is not owned by the pod
   * will *not* be used for the pod to avoid using an unrelated
   * volume by mistake. Starting the pod is then blocked until
   * the unrelated PVC is removed. If such a pre-created PVC is
   * meant to be used by the pod, the PVC has to updated with an
   * owner reference to the pod once the pod exists. Normally
   * this should not be necessary, but it may be useful when
   * manually reconstructing a broken cluster.
   *
   * This field is read-only and no changes will be made by Kubernetes
   * to the PVC after it has been created.
   *
   * Required, must not be nil.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplate;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeral(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFc
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFc {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids)
   * Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFc#wwids
   */
  readonly wwids?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFc(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'lun': obj.lun,
    'readOnly': obj.readOnly,
    'targetWWNs': obj.targetWwNs?.map(y => y),
    'wwids': obj.wwids?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flexVolume represents a generic volume resource that is
 * provisioned/attached using an exec based plugin.
 * Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolume
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing
   * sensitive information to pass to the plugin scripts. This may be
   * empty if no secret object is specified. If the secret object
   * contains more than one secret, all secrets are passed to the plugin
   * scripts.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolume#secretRef
   */
  readonly secretRef?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolumeSecretRef;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolume(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readOnly': obj.readOnly,
    'secretRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
 * Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlocker
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
   * should be considered as deprecated
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlocker(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlocker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetName': obj.datasetName,
    'datasetUUID': obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
 * gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGcePersistentDisk
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGcePersistentDisk(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGcePersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'pdName': obj.pdName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gitRepo represents a git repository at a particular revision.
 * Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
 * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
 * into the Pod's container.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGitRepo
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGitRepo {
  /**
   * directory is the target directory name.
   * Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
   * git repository.  Otherwise, if specified, the volume will contain the git repository in
   * the subdirectory with the given name.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGitRepo#revision
   */
  readonly revision?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGitRepo(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGitRepo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
    'repository': obj.repository,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
 * Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGlusterfs
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGlusterfs(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGlusterfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints,
    'path': obj.path,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host
 * machine that is directly exposed to the container. This is generally
 * used for system agents or other privileged things that are allowed
 * to see the host machine. Most containers will NOT need this.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesHostPath
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesHostPath {
  /**
   * path of the directory on the host.
   * If the path is a symlink, it will follow the link to the real path.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume
   * Defaults to ""
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesHostPath#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesHostPath(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesHostPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
 * The volume is resolved at pod startup depending on which PullPolicy value is provided:
 *
 * - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
 * - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
 * - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
 *
 * The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
 * A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
 * The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
 * The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
 * The volume will be mounted read-only (ro) and non-executable files (noexec).
 * Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath) before 1.33.
 * The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesImage
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesImage {
  /**
   * Policy for pulling OCI objects. Possible values are:
   * Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
   * Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
   * IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Required: Image or artifact reference to be used.
   * Behaves in the same way as pod.spec.containers[*].image.
   * Pull secrets will be assembled in the same way as for the container image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesImage#reference
   */
  readonly reference?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesImage(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'reference': obj.reference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes/#iscsi
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsi
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name.
   * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
   * <target portal>:<volume name> will be created for the connection.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport.
   * Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   *
   * @default false.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsi#secretRef
   */
  readonly secretRef?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsi(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chapAuthDiscovery': obj.chapAuthDiscovery,
    'chapAuthSession': obj.chapAuthSession,
    'fsType': obj.fsType,
    'initiatorName': obj.initiatorName,
    'iqn': obj.iqn,
    'iscsiInterface': obj.iscsiInterface,
    'lun': obj.lun,
    'portals': obj.portals?.map(y => y),
    'readOnly': obj.readOnly,
    'secretRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsiSecretRef(obj.secretRef),
    'targetPortal': obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesNfs
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesNfs {
  /**
   * path that is exported by the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesNfs#server
   */
  readonly server: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesNfs(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesNfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'readOnly': obj.readOnly,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a
 * PersistentVolumeClaim in the same namespace.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPersistentVolumeClaim
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts.
   * Default false.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPersistentVolumeClaim(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
 * Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPhotonPersistentDisk
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPhotonPersistentDisk(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPhotonPersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'pdID': obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
 * Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
 * are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
 * is on.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPortworxVolume
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPortworxVolume {
  /**
   * fSType represents the filesystem type to mount
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPortworxVolume(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPortworxVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjected
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections. Each entry in this list
   * handles one source.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjected#sources
   */
  readonly sources?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSources[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjected(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjected | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
 * Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesQuobyte
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesQuobyte {
  /**
   * group to map volume access to
   * Default is no group
   *
   * @default no group
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions.
   * Defaults to false.
   *
   * @default false.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services
   * specified as a string as host:port pair (multiple entries are separated with commas)
   * which acts as the central registry for volumes
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend
   * Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to
   * Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesQuobyte#volume
   */
  readonly volume: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesQuobyte(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesQuobyte | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'readOnly': obj.readOnly,
    'registry': obj.registry,
    'tenant': obj.tenant,
    'user': obj.user,
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
 * Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbd
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser.
   * Default is /etc/ceph/keyring.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name.
   * Default is rbd.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided
   * overrides keyring.
   * Default is nil.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbd#secretRef
   */
  readonly secretRef?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbdSecretRef;

  /**
   * user is the rados user name.
   * Default is admin.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbd#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbd(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'image': obj.image,
    'keyring': obj.keyring,
    'monitors': obj.monitors?.map(y => y),
    'pool': obj.pool,
    'readOnly': obj.readOnly,
    'secretRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbdSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 * Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIo
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIo {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * Default is "xfs".
   *
   * @default xfs".
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other
   * sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIo#secretRef
   */
  readonly secretRef: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
   * Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system
   * that is associated with this volume source.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIo(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'gateway': obj.gateway,
    'protectionDomain': obj.protectionDomain,
    'readOnly': obj.readOnly,
    'secretRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIoSecretRef(obj.secretRef),
    'sslEnabled': obj.sslEnabled,
    'storageMode': obj.storageMode,
    'storagePool': obj.storagePool,
    'system': obj.system,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret represents a secret that should populate this volume.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecret
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values
   * for mode bits. Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecret#items
   */
  readonly items?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecret#secretName
   */
  readonly secretName?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecret(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 * Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageos
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageos {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API
   * credentials.  If not specified, default values will be attempted.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageos#secretRef
   */
  readonly secretRef?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume
   * names are only unique within a namespace.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no
   * namespace is specified then the Pod's namespace will be used.  This allows the
   * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
   * Set VolumeName to any name to override the default behaviour.
   * Set to "default" if you are not using namespaces within StorageOS.
   * Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageos(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageosSecretRef(obj.secretRef),
    'volumeName': obj.volumeName,
    'volumeNamespace': obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
 * Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
 * are redirected to the csi.vsphere.vmware.com CSI driver.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesVsphereVolume
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesVsphereVolume {
  /**
   * fsType is filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesVsphereVolume(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesVsphereVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'storagePolicyID': obj.storagePolicyId,
    'storagePolicyName': obj.storagePolicyName,
    'volumePath': obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The maximum number of nodes with an existing available DaemonSet pod that
 * can have an updated DaemonSet pod during during an update.
 * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
 * This can not be 0 if MaxUnavailable is 0.
 * Absolute number is calculated from percentage by rounding up to a minimum of 1.
 * Default value is 0.
 * Example: when this is set to 30%, at most 30% of the total number of nodes
 * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
 * can have their a new pod created before the old pod is marked as deleted.
 * The update starts by launching new pods on 30% of nodes. Once an updated
 * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
 * on that node is marked deleted. If the old pod becomes unavailable for any
 * reason (Ready transitions to false, is evicted, or is drained) an updated
 * pod is immediately created on that node without considering surge limits.
 * Allowing surge implies the possibility that the resources consumed by the
 * daemonset on any given node can double if the readiness check fails, and
 * so resource intensive daemonsets should take into account that they may
 * cause evictions during disruption.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdateMaxSurge
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdateMaxSurge {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdateMaxSurge {
    return new EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdateMaxSurge(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdateMaxSurge {
    return new EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdateMaxSurge(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of DaemonSet pods that can be unavailable during the
 * update. Value can be an absolute number (ex: 5) or a percentage of total
 * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
 * number is calculated from percentage by rounding up.
 * This cannot be 0 if MaxSurge is 0
 * Default value is 1.
 * Example: when this is set to 30%, at most 30% of the total number of nodes
 * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
 * can have their pods stopped for an update at any given time. The update
 * starts by stopping at most 30% of those DaemonSet pods and then brings
 * up new DaemonSet pods in their place. Once the new pods are available,
 * it then proceeds onto other DaemonSet pods, thus ensuring that at least
 * 70% of original number of DaemonSet pods are available at all times during
 * the update.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdateMaxUnavailable
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdateMaxUnavailable {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdateMaxUnavailable {
    return new EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdateMaxUnavailable(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdateMaxUnavailable {
    return new EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdateMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFrom
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFrom#fieldRef
   */
  readonly fieldRef?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFieldRef;

  /**
   * FileKeyRef selects a key of the env file.
   * Requires the EnvFiles feature gate to be enabled.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFrom#fileKeyRef
   */
  readonly fileKeyRef?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFileKeyRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFrom(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFieldRef(obj.fieldRef),
    'fileKeyRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFileKeyRef(obj.fileKeyRef),
    'resourceFieldRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesClaims
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesClaims(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesLimits
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesLimits {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesLimits {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesLimits(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesLimits {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesRequests
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesRequests {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesRequests {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesRequests(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesRequests {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * appArmorProfile is the AppArmor options to use by this container. If set, this profile
 * overrides the pod's appArmorProfile.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextAppArmorProfile
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextAppArmorProfile(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextAppArmorProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextCapabilities
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextCapabilities(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeLinuxOptions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeLinuxOptions(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeccompProfile
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeccompProfile(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextWindowsOptions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextWindowsOptions(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFrom
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFieldRef;

  /**
   * FileKeyRef selects a key of the env file.
   * Requires the EnvFiles feature gate to be enabled.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFrom#fileKeyRef
   */
  readonly fileKeyRef?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFileKeyRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFrom(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFieldRef(obj.fieldRef),
    'fileKeyRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFileKeyRef(obj.fileKeyRef),
    'resourceFieldRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromConfigMapRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromConfigMapRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromConfigMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromSecretRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromSecretRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails,
 * the container is terminated and restarted according to its restart policy.
 * Other management of the container blocks until the hook completes.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStart
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStart {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStart#exec
   */
  readonly exec?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStart#sleep
   */
  readonly sleep?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartTcpSocket;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStart(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartExec(obj.exec),
    'httpGet': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGet(obj.httpGet),
    'sleep': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartSleep(obj.sleep),
    'tcpSocket': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an
 * API request or management event such as liveness/startup probe failure,
 * preemption, resource contention, etc. The handler is not called if the
 * container crashes or exits. The Pod's termination grace period countdown begins before the
 * PreStop hook is executed. Regardless of the outcome of the handler, the
 * container will eventually terminate within the Pod's termination grace
 * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
 * or until the termination grace period is reached.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStop
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStop {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStop#exec
   */
  readonly exec?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStop#sleep
   */
  readonly sleep?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopTcpSocket;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStop(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStop | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopExec(obj.exec),
    'httpGet': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGet(obj.httpGet),
    'sleep': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopSleep(obj.sleep),
    'tcpSocket': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeExec
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeExec(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeGrpc
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeGrpc(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGet
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGet#port
   */
  readonly port: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGet(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeTcpSocket
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeTcpSocket#port
   */
  readonly port: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeTcpSocket(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeExec
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeExec(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeGrpc
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeGrpc(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGet
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGet#port
   */
  readonly port: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGet(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeTcpSocket
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeTcpSocket#port
   */
  readonly port: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeTcpSocket(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesClaims
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesClaims(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'request': obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesLimits
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesLimits {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesLimits {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesLimits(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesLimits {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesRequests
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesRequests {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesRequests {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesRequests(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesRequests {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Represents the exit codes to check on container exits.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersRestartPolicyRulesExitCodes
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersRestartPolicyRulesExitCodes {
  /**
   * Represents the relationship between the container exit code(s) and the
   * specified values. Possible values are:
   * - In: the requirement is satisfied if the container exit code is in the
   * set of specified values.
   * - NotIn: the requirement is satisfied if the container exit code is
   * not in the set of specified values.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersRestartPolicyRulesExitCodes#operator
   */
  readonly operator: string;

  /**
   * Specifies the set of values to check for container exit codes.
   * At most 255 elements are allowed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersRestartPolicyRulesExitCodes#values
   */
  readonly values?: number[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersRestartPolicyRulesExitCodes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersRestartPolicyRulesExitCodes(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersRestartPolicyRulesExitCodes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * appArmorProfile is the AppArmor options to use by this container. If set, this profile
 * overrides the pod's appArmorProfile.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextAppArmorProfile
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextAppArmorProfile(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextAppArmorProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextCapabilities
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextCapabilities(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeLinuxOptions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeLinuxOptions(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeccompProfile
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeccompProfile(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextWindowsOptions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextWindowsOptions(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeExec
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeExec(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeGrpc
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeGrpc(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGet
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGet#port
   */
  readonly port: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGet(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeTcpSocket
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeTcpSocket#port
   */
  readonly port: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeTcpSocketPort;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeTcpSocket(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinity
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinity(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinity
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinity(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinity
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and subtracting
   * "weight" from the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinity(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * appArmorProfile is the AppArmor options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextAppArmorProfile
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextAppArmorProfile(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextAppArmorProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeLinuxOptions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeLinuxOptions(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeccompProfile
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeccompProfile(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSysctls
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSysctls#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSysctls(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextWindowsOptions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextWindowsOptions(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
 * awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAwsElasticBlockStore
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAwsElasticBlockStore(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAwsElasticBlockStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 * Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
 * are redirected to the disk.csi.azure.com CSI driver.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureDisk
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureDisk(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingMode': obj.cachingMode,
    'diskName': obj.diskName,
    'diskURI': obj.diskUri,
    'fsType': obj.fsType,
    'kind': obj.kind,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 * Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
 * are redirected to the file.csi.azure.com CSI driver.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureFile
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureFile#shareName
   */
  readonly shareName: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureFile(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'secretName': obj.secretName,
    'shareName': obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
 * Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfs
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfs#secretRef
   */
  readonly secretRef?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfs#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfs(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitors': obj.monitors?.map(y => y),
    'path': obj.path,
    'readOnly': obj.readOnly,
    'secretFile': obj.secretFile,
    'secretRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfsSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine.
 * Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
 * are redirected to the cinder.csi.openstack.org CSI driver.
 * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinder
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinder {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect
   * to OpenStack.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinder#secretRef
   */
  readonly secretRef?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinder#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinder(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinderSecretRef(obj.secretRef),
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMap
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMap#items
   */
  readonly items?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMap(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsi
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsi {
  /**
   * driver is the name of the CSI driver that handles this volume.
   * Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs".
   * If not provided, the empty value is passed to the associated CSI driver
   * which will determine the default filesystem to apply.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * NodePublishVolume and NodeUnpublishVolume calls.
   * This field is optional, and  may be empty if no secret is required. If the
   * secret object contains more than one secret, all secret references are passed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume.
   * Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI
   * driver. Consult your driver's documentation for supported values.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsi(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'nodePublishSecretRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    'readOnly': obj.readOnly,
    'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApi
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a
   * Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApi#items
   */
  readonly items?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItems[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApi(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEmptyDir
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEmptyDirSizeLimit;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEmptyDir(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver.
 * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
 * and deleted when the pod is removed.
 *
 * Use this if:
 * a) the volume is only needed while the pod runs,
 * b) features of normal volumes like restoring from snapshot or capacity
 * tracking are needed,
 * c) the storage driver is specified through a storage class, and
 * d) the storage driver supports dynamic volume provisioning through
 * a PersistentVolumeClaim (see EphemeralVolumeSource for more
 * information on the connection between this volume type
 * and PersistentVolumeClaim).
 *
 * Use PersistentVolumeClaim or one of the vendor-specific
 * APIs for volumes that persist for longer than the lifecycle
 * of an individual pod.
 *
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
 * be used that way - see the documentation of the driver for
 * more information.
 *
 * A pod can use both types of ephemeral volumes and
 * persistent volumes at the same time.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeral
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume.
   * The pod in which this EphemeralVolumeSource is embedded will be the
   * owner of the PVC, i.e. the PVC will be deleted together with the
   * pod.  The name of the PVC will be `<pod name>-<volume name>` where
   * `<volume name>` is the name from the `PodSpec.Volumes` array
   * entry. Pod validation will reject the pod if the concatenated name
   * is not valid for a PVC (for example, too long).
   *
   * An existing PVC with that name that is not owned by the pod
   * will *not* be used for the pod to avoid using an unrelated
   * volume by mistake. Starting the pod is then blocked until
   * the unrelated PVC is removed. If such a pre-created PVC is
   * meant to be used by the pod, the PVC has to updated with an
   * owner reference to the pod once the pod exists. Normally
   * this should not be necessary, but it may be useful when
   * manually reconstructing a broken cluster.
   *
   * This field is read-only and no changes will be made by Kubernetes
   * to the PVC after it has been created.
   *
   * Required, must not be nil.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplate;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeral(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFc
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFc {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids)
   * Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFc#wwids
   */
  readonly wwids?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFc(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'lun': obj.lun,
    'readOnly': obj.readOnly,
    'targetWWNs': obj.targetWwNs?.map(y => y),
    'wwids': obj.wwids?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flexVolume represents a generic volume resource that is
 * provisioned/attached using an exec based plugin.
 * Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolume
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing
   * sensitive information to pass to the plugin scripts. This may be
   * empty if no secret object is specified. If the secret object
   * contains more than one secret, all secrets are passed to the plugin
   * scripts.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolume#secretRef
   */
  readonly secretRef?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolumeSecretRef;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolume(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readOnly': obj.readOnly,
    'secretRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
 * Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlocker
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
   * should be considered as deprecated
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlocker(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlocker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetName': obj.datasetName,
    'datasetUUID': obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
 * gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGcePersistentDisk
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGcePersistentDisk(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGcePersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'pdName': obj.pdName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gitRepo represents a git repository at a particular revision.
 * Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
 * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
 * into the Pod's container.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGitRepo
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGitRepo {
  /**
   * directory is the target directory name.
   * Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
   * git repository.  Otherwise, if specified, the volume will contain the git repository in
   * the subdirectory with the given name.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGitRepo#revision
   */
  readonly revision?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGitRepo(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGitRepo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
    'repository': obj.repository,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
 * Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGlusterfs
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGlusterfs(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGlusterfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints,
    'path': obj.path,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host
 * machine that is directly exposed to the container. This is generally
 * used for system agents or other privileged things that are allowed
 * to see the host machine. Most containers will NOT need this.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesHostPath
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesHostPath {
  /**
   * path of the directory on the host.
   * If the path is a symlink, it will follow the link to the real path.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume
   * Defaults to ""
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesHostPath#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesHostPath(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesHostPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
 * The volume is resolved at pod startup depending on which PullPolicy value is provided:
 *
 * - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
 * - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
 * - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
 *
 * The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
 * A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
 * The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
 * The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
 * The volume will be mounted read-only (ro) and non-executable files (noexec).
 * Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath) before 1.33.
 * The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesImage
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesImage {
  /**
   * Policy for pulling OCI objects. Possible values are:
   * Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
   * Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
   * IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Required: Image or artifact reference to be used.
   * Behaves in the same way as pod.spec.containers[*].image.
   * Pull secrets will be assembled in the same way as for the container image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesImage#reference
   */
  readonly reference?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesImage(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pullPolicy': obj.pullPolicy,
    'reference': obj.reference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes/#iscsi
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsi
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name.
   * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
   * <target portal>:<volume name> will be created for the connection.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport.
   * Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   *
   * @default false.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsi#secretRef
   */
  readonly secretRef?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsi(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chapAuthDiscovery': obj.chapAuthDiscovery,
    'chapAuthSession': obj.chapAuthSession,
    'fsType': obj.fsType,
    'initiatorName': obj.initiatorName,
    'iqn': obj.iqn,
    'iscsiInterface': obj.iscsiInterface,
    'lun': obj.lun,
    'portals': obj.portals?.map(y => y),
    'readOnly': obj.readOnly,
    'secretRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsiSecretRef(obj.secretRef),
    'targetPortal': obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesNfs
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesNfs {
  /**
   * path that is exported by the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesNfs#server
   */
  readonly server: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesNfs(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesNfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'readOnly': obj.readOnly,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a
 * PersistentVolumeClaim in the same namespace.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPersistentVolumeClaim
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts.
   * Default false.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPersistentVolumeClaim(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
 * Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPhotonPersistentDisk
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPhotonPersistentDisk(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPhotonPersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'pdID': obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
 * Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
 * are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
 * is on.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPortworxVolume
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPortworxVolume {
  /**
   * fSType represents the filesystem type to mount
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPortworxVolume(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPortworxVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjected
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections. Each entry in this list
   * handles one source.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjected#sources
   */
  readonly sources?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSources[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjected(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjected | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
 * Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesQuobyte
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesQuobyte {
  /**
   * group to map volume access to
   * Default is no group
   *
   * @default no group
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions.
   * Defaults to false.
   *
   * @default false.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services
   * specified as a string as host:port pair (multiple entries are separated with commas)
   * which acts as the central registry for volumes
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend
   * Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to
   * Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesQuobyte#volume
   */
  readonly volume: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesQuobyte(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesQuobyte | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'readOnly': obj.readOnly,
    'registry': obj.registry,
    'tenant': obj.tenant,
    'user': obj.user,
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
 * Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbd
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser.
   * Default is /etc/ceph/keyring.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name.
   * Default is rbd.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided
   * overrides keyring.
   * Default is nil.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbd#secretRef
   */
  readonly secretRef?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbdSecretRef;

  /**
   * user is the rados user name.
   * Default is admin.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbd#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbd(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'image': obj.image,
    'keyring': obj.keyring,
    'monitors': obj.monitors?.map(y => y),
    'pool': obj.pool,
    'readOnly': obj.readOnly,
    'secretRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbdSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 * Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIo
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIo {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * Default is "xfs".
   *
   * @default xfs".
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other
   * sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIo#secretRef
   */
  readonly secretRef: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
   * Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system
   * that is associated with this volume source.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIo(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'gateway': obj.gateway,
    'protectionDomain': obj.protectionDomain,
    'readOnly': obj.readOnly,
    'secretRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIoSecretRef(obj.secretRef),
    'sslEnabled': obj.sslEnabled,
    'storageMode': obj.storageMode,
    'storagePool': obj.storagePool,
    'system': obj.system,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret represents a secret that should populate this volume.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecret
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values
   * for mode bits. Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecret#items
   */
  readonly items?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecret#secretName
   */
  readonly secretName?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecret(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 * Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageos
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageos {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API
   * credentials.  If not specified, default values will be attempted.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageos#secretRef
   */
  readonly secretRef?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume
   * names are only unique within a namespace.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no
   * namespace is specified then the Pod's namespace will be used.  This allows the
   * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
   * Set VolumeName to any name to override the default behaviour.
   * Set to "default" if you are not using namespaces within StorageOS.
   * Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageos(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageosSecretRef(obj.secretRef),
    'volumeName': obj.volumeName,
    'volumeNamespace': obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
 * Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
 * are redirected to the csi.vsphere.vmware.com CSI driver.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesVsphereVolume
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesVsphereVolume {
  /**
   * fsType is filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesVsphereVolume(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesVsphereVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'storagePolicyID': obj.storagePolicyId,
    'storagePolicyName': obj.storagePolicyName,
    'volumePath': obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The maximum number of pods that can be scheduled above the desired number of
 * pods.
 * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
 * This can not be 0 if MaxUnavailable is 0.
 * Absolute number is calculated from percentage by rounding up.
 * Defaults to 25%.
 * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
 * the rolling update starts, such that the total number of old and new pods do not exceed
 * 130% of desired pods. Once old pods have been killed,
 * new ReplicaSet can be scaled up further, ensuring that total number of pods running
 * at any time during the update is at most 130% of desired pods.
 *
 * @default 25%.
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdateMaxSurge
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdateMaxSurge {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdateMaxSurge {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdateMaxSurge(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdateMaxSurge {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdateMaxSurge(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of pods that can be unavailable during the update.
 * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
 * Absolute number is calculated from percentage by rounding down.
 * This can not be 0 if MaxSurge is 0.
 * Defaults to 25%.
 * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
 * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
 * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
 * that the total number of pods available at all times during the update is at
 * least 70% of desired pods.
 *
 * @default 25%.
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdateMaxUnavailable
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdateMaxUnavailable {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdateMaxUnavailable {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdateMaxUnavailable(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdateMaxUnavailable {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdateMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HPAScalingPolicy is a single policy which must hold true for a specified past interval.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDownPolicies
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDownPolicies {
  /**
   * periodSeconds specifies the window of time for which the policy should hold true.
   * PeriodSeconds must be greater than zero and less than or equal to 1800 (30 min).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDownPolicies#periodSeconds
   */
  readonly periodSeconds: number;

  /**
   * type is used to specify the scaling policy.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDownPolicies#type
   */
  readonly type: string;

  /**
   * value contains the amount of change which is permitted by the policy.
   * It must be greater than zero
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDownPolicies#value
   */
  readonly value: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDownPolicies' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDownPolicies(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDownPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'periodSeconds': obj.periodSeconds,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * tolerance is the tolerance on the ratio between the current and desired
 * metric value under which no updates are made to the desired number of
 * replicas (e.g. 0.01 for 1%). Must be greater than or equal to zero. If not
 * set, the default cluster-wide tolerance is applied (by default 10%).
 *
 * For example, if autoscaling is configured with a memory consumption target of 100Mi,
 * and scale-down and scale-up tolerances of 5% and 1% respectively, scaling will be
 * triggered when the actual consumption falls below 95Mi or exceeds 101Mi.
 *
 * This is an alpha field and requires enabling the HPAConfigurableTolerance
 * feature gate.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDownTolerance
 */
export class EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDownTolerance {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDownTolerance {
    return new EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDownTolerance(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDownTolerance {
    return new EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDownTolerance(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HPAScalingPolicy is a single policy which must hold true for a specified past interval.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUpPolicies
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUpPolicies {
  /**
   * periodSeconds specifies the window of time for which the policy should hold true.
   * PeriodSeconds must be greater than zero and less than or equal to 1800 (30 min).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUpPolicies#periodSeconds
   */
  readonly periodSeconds: number;

  /**
   * type is used to specify the scaling policy.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUpPolicies#type
   */
  readonly type: string;

  /**
   * value contains the amount of change which is permitted by the policy.
   * It must be greater than zero
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUpPolicies#value
   */
  readonly value: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUpPolicies' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUpPolicies(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUpPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'periodSeconds': obj.periodSeconds,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * tolerance is the tolerance on the ratio between the current and desired
 * metric value under which no updates are made to the desired number of
 * replicas (e.g. 0.01 for 1%). Must be greater than or equal to zero. If not
 * set, the default cluster-wide tolerance is applied (by default 10%).
 *
 * For example, if autoscaling is configured with a memory consumption target of 100Mi,
 * and scale-down and scale-up tolerances of 5% and 1% respectively, scaling will be
 * triggered when the actual consumption falls below 95Mi or exceeds 101Mi.
 *
 * This is an alpha field and requires enabling the HPAConfigurableTolerance
 * feature gate.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUpTolerance
 */
export class EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUpTolerance {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUpTolerance {
    return new EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUpTolerance(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUpTolerance {
    return new EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUpTolerance(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * target specifies the target value for the given metric
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTarget
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTarget {
  /**
   * averageUtilization is the target value of the average of the
   * resource metric across all relevant pods, represented as a percentage of
   * the requested value of the resource for the pods.
   * Currently only valid for Resource metric source type
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTarget#averageUtilization
   */
  readonly averageUtilization?: number;

  /**
   * averageValue is the target value of the average of the
   * metric across all relevant pods (as a quantity)
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTarget#averageValue
   */
  readonly averageValue?: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTargetAverageValue;

  /**
   * type represents whether the metric type is Utilization, Value, or AverageValue
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTarget#type
   */
  readonly type: string;

  /**
   * value is the target value of the metric (as a quantity).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTarget#value
   */
  readonly value?: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTargetValue;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTarget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTarget(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'averageUtilization': obj.averageUtilization,
    'averageValue': obj.averageValue?.value,
    'type': obj.type,
    'value': obj.value?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * metric identifies the target metric by name and selector
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetric
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetric {
  /**
   * name is the name of the given metric
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetric#name
   */
  readonly name: string;

  /**
   * selector is the string-encoded form of a standard kubernetes label selector for the given metric
   * When set, it is passed as an additional parameter to the metrics server for more specific metrics scoping.
   * When unset, just the metricName will be used to gather metrics.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetric#selector
   */
  readonly selector?: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelector;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetric' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetric(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetric | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'selector': toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * target specifies the target value for the given metric
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTarget
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTarget {
  /**
   * averageUtilization is the target value of the average of the
   * resource metric across all relevant pods, represented as a percentage of
   * the requested value of the resource for the pods.
   * Currently only valid for Resource metric source type
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTarget#averageUtilization
   */
  readonly averageUtilization?: number;

  /**
   * averageValue is the target value of the average of the
   * metric across all relevant pods (as a quantity)
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTarget#averageValue
   */
  readonly averageValue?: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTargetAverageValue;

  /**
   * type represents whether the metric type is Utilization, Value, or AverageValue
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTarget#type
   */
  readonly type: string;

  /**
   * value is the target value of the metric (as a quantity).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTarget#value
   */
  readonly value?: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTargetValue;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTarget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTarget(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'averageUtilization': obj.averageUtilization,
    'averageValue': obj.averageValue?.value,
    'type': obj.type,
    'value': obj.value?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * describedObject specifies the descriptions of a object,such as kind,name apiVersion
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectDescribedObject
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectDescribedObject {
  /**
   * apiVersion is the API version of the referent
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectDescribedObject#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * kind is the kind of the referent; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectDescribedObject#kind
   */
  readonly kind: string;

  /**
   * name is the name of the referent; More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectDescribedObject#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectDescribedObject' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectDescribedObject(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectDescribedObject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * metric identifies the target metric by name and selector
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetric
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetric {
  /**
   * name is the name of the given metric
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetric#name
   */
  readonly name: string;

  /**
   * selector is the string-encoded form of a standard kubernetes label selector for the given metric
   * When set, it is passed as an additional parameter to the metrics server for more specific metrics scoping.
   * When unset, just the metricName will be used to gather metrics.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetric#selector
   */
  readonly selector?: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelector;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetric' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetric(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetric | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'selector': toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * target specifies the target value for the given metric
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTarget
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTarget {
  /**
   * averageUtilization is the target value of the average of the
   * resource metric across all relevant pods, represented as a percentage of
   * the requested value of the resource for the pods.
   * Currently only valid for Resource metric source type
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTarget#averageUtilization
   */
  readonly averageUtilization?: number;

  /**
   * averageValue is the target value of the average of the
   * metric across all relevant pods (as a quantity)
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTarget#averageValue
   */
  readonly averageValue?: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTargetAverageValue;

  /**
   * type represents whether the metric type is Utilization, Value, or AverageValue
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTarget#type
   */
  readonly type: string;

  /**
   * value is the target value of the metric (as a quantity).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTarget#value
   */
  readonly value?: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTargetValue;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTarget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTarget(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'averageUtilization': obj.averageUtilization,
    'averageValue': obj.averageValue?.value,
    'type': obj.type,
    'value': obj.value?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * metric identifies the target metric by name and selector
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetric
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetric {
  /**
   * name is the name of the given metric
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetric#name
   */
  readonly name: string;

  /**
   * selector is the string-encoded form of a standard kubernetes label selector for the given metric
   * When set, it is passed as an additional parameter to the metrics server for more specific metrics scoping.
   * When unset, just the metricName will be used to gather metrics.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetric#selector
   */
  readonly selector?: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelector;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetric' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetric(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetric | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'selector': toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * target specifies the target value for the given metric
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTarget
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTarget {
  /**
   * averageUtilization is the target value of the average of the
   * resource metric across all relevant pods, represented as a percentage of
   * the requested value of the resource for the pods.
   * Currently only valid for Resource metric source type
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTarget#averageUtilization
   */
  readonly averageUtilization?: number;

  /**
   * averageValue is the target value of the average of the
   * metric across all relevant pods (as a quantity)
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTarget#averageValue
   */
  readonly averageValue?: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTargetAverageValue;

  /**
   * type represents whether the metric type is Utilization, Value, or AverageValue
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTarget#type
   */
  readonly type: string;

  /**
   * value is the target value of the metric (as a quantity).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTarget#value
   */
  readonly value?: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTargetValue;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTarget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTarget(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'averageUtilization': obj.averageUtilization,
    'averageValue': obj.averageValue?.value,
    'type': obj.type,
    'value': obj.value?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * target specifies the target value for the given metric
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTarget
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTarget {
  /**
   * averageUtilization is the target value of the average of the
   * resource metric across all relevant pods, represented as a percentage of
   * the requested value of the resource for the pods.
   * Currently only valid for Resource metric source type
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTarget#averageUtilization
   */
  readonly averageUtilization?: number;

  /**
   * averageValue is the target value of the average of the
   * metric across all relevant pods (as a quantity)
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTarget#averageValue
   */
  readonly averageValue?: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTargetAverageValue;

  /**
   * type represents whether the metric type is Utilization, Value, or AverageValue
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTarget#type
   */
  readonly type: string;

  /**
   * value is the target value of the metric (as a quantity).
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTarget#value
   */
  readonly value?: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTargetValue;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTarget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTarget(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'averageUtilization': obj.averageUtilization,
    'averageValue': obj.averageValue?.value,
    'type': obj.type,
    'value': obj.value?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendRef references a Kubernetes object that represents the
 * backend server to which the authorization request will be sent.
 *
 * Deprecated: Use BackendRefs instead.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRef
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRef {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRef#group
   */
  readonly group?: string;

  /**
   * Kind is the Kubernetes resource kind of the referent. For example
   * "Service".
   *
   * Defaults to "Service" when not specified.
   *
   * ExternalName services can refer to CNAME DNS records that may live
   * outside of the cluster and as such are difficult to reason about in
   * terms of conformance. They also may not be safe to forward to (see
   * CVE-2021-25740 for more information). Implementations SHOULD NOT
   * support ExternalName Services.
   *
   * Support: Core (Services with a type other than ExternalName)
   *
   * Support: Implementation-specific (Services with type ExternalName)
   *
   * @default Service" when not specified.
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRef#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the backend. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRef#namespace
   */
  readonly namespace?: string;

  /**
   * Port specifies the destination port number to use for this resource.
   * Port is required when the referent is a Kubernetes Service. In this
   * case, the port number is the service port number, not the target port.
   * For other resources, destination port might be derived from the referent
   * resource or this field.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRef#port
   */
  readonly port?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRef(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendRef defines how an ObjectReference that is specific to BackendRef.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRefs
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRefs {
  /**
   * Fallback indicates whether the backend is designated as a fallback.
   * Multiple fallback backends can be configured.
   * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
   * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
   * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
   * the health of the active backends falls below 72%.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRefs#fallback
   */
  readonly fallback?: boolean;

  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRefs#group
   */
  readonly group?: string;

  /**
   * Kind is the Kubernetes resource kind of the referent. For example
   * "Service".
   *
   * Defaults to "Service" when not specified.
   *
   * ExternalName services can refer to CNAME DNS records that may live
   * outside of the cluster and as such are difficult to reason about in
   * terms of conformance. They also may not be safe to forward to (see
   * CVE-2021-25740 for more information). Implementations SHOULD NOT
   * support ExternalName Services.
   *
   * Support: Core (Services with a type other than ExternalName)
   *
   * Support: Implementation-specific (Services with type ExternalName)
   *
   * @default Service" when not specified.
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRefs#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRefs#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the backend. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRefs#namespace
   */
  readonly namespace?: string;

  /**
   * Port specifies the destination port number to use for this resource.
   * Port is required when the referent is a Kubernetes Service. In this
   * case, the port number is the service port number, not the target port.
   * For other resources, destination port might be derived from the referent
   * resource or this field.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRefs#port
   */
  readonly port?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRefs(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fallback': obj.fallback,
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendSettings holds configuration for managing the connection
 * to the backend.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettings
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettings {
  /**
   * Circuit Breaker settings for the upstream connections and requests.
   * If not set, circuit breakers will be enabled with the default thresholds
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettings#circuitBreaker
   */
  readonly circuitBreaker?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreaker;

  /**
   * Connection includes backend connection settings.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettings#connection
   */
  readonly connection?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnection;

  /**
   * DNS includes dns resolution settings.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettings#dns
   */
  readonly dns?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsDns;

  /**
   * HealthCheck allows gateway to perform active health checking on backends.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettings#healthCheck
   */
  readonly healthCheck?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheck;

  /**
   * HTTP2 provides HTTP/2 configuration for backend connections.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettings#http2
   */
  readonly http2?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2;

  /**
   * LoadBalancer policy to apply when routing traffic from the gateway to
   * the backend endpoints. Defaults to `LeastRequest`.
   *
   * @default LeastRequest`.
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettings#loadBalancer
   */
  readonly loadBalancer?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancer;

  /**
   * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettings#proxyProtocol
   */
  readonly proxyProtocol?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsProxyProtocol;

  /**
   * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
   * If not set, retry will be disabled.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettings#retry
   */
  readonly retry?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetry;

  /**
   * TcpKeepalive settings associated with the upstream client connection.
   * Disabled by default.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettings#tcpKeepalive
   */
  readonly tcpKeepalive?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTcpKeepalive;

  /**
   * Timeout settings for the backend connections.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettings#timeout
   */
  readonly timeout?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeout;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettings(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'circuitBreaker': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreaker(obj.circuitBreaker),
    'connection': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnection(obj.connection),
    'dns': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsDns(obj.dns),
    'healthCheck': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheck(obj.healthCheck),
    'http2': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2(obj.http2),
    'loadBalancer': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancer(obj.loadBalancer),
    'proxyProtocol': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsProxyProtocol(obj.proxyProtocol),
    'retry': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetry(obj.retry),
    'tcpKeepalive': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTcpKeepalive(obj.tcpKeepalive),
    'timeout': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeout(obj.timeout),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP defines additional configuration specific to HTTP access logs.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsHttp
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsHttp {
  /**
   * RequestHeaders defines request headers to include in log entries sent to the access log service.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsHttp#requestHeaders
   */
  readonly requestHeaders?: string[];

  /**
   * ResponseHeaders defines response headers to include in log entries sent to the access log service.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsHttp#responseHeaders
   */
  readonly responseHeaders?: string[];

  /**
   * ResponseTrailers defines response trailers to include in log entries sent to the access log service.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsHttp#responseTrailers
   */
  readonly responseTrailers?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsHttp(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestHeaders': obj.requestHeaders?.map(y => y),
    'responseHeaders': obj.responseHeaders?.map(y => y),
    'responseTrailers': obj.responseTrailers?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type defines the type of accesslog. Supported types are "HTTP" and "TCP".
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsType
 */
export enum EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsType {
  /** HTTP */
  HTTP = "HTTP",
  /** TCP */
  TCP = "TCP",
}

/**
 * BackendRef references a Kubernetes object that represents the
 * backend server to which the authorization request will be sent.
 *
 * Deprecated: Use BackendRefs instead.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRef
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRef {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRef#group
   */
  readonly group?: string;

  /**
   * Kind is the Kubernetes resource kind of the referent. For example
   * "Service".
   *
   * Defaults to "Service" when not specified.
   *
   * ExternalName services can refer to CNAME DNS records that may live
   * outside of the cluster and as such are difficult to reason about in
   * terms of conformance. They also may not be safe to forward to (see
   * CVE-2021-25740 for more information). Implementations SHOULD NOT
   * support ExternalName Services.
   *
   * Support: Core (Services with a type other than ExternalName)
   *
   * Support: Implementation-specific (Services with type ExternalName)
   *
   * @default Service" when not specified.
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRef#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the backend. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRef#namespace
   */
  readonly namespace?: string;

  /**
   * Port specifies the destination port number to use for this resource.
   * Port is required when the referent is a Kubernetes Service. In this
   * case, the port number is the service port number, not the target port.
   * For other resources, destination port might be derived from the referent
   * resource or this field.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRef#port
   */
  readonly port?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRef(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendRef defines how an ObjectReference that is specific to BackendRef.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRefs
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRefs {
  /**
   * Fallback indicates whether the backend is designated as a fallback.
   * Multiple fallback backends can be configured.
   * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
   * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
   * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
   * the health of the active backends falls below 72%.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRefs#fallback
   */
  readonly fallback?: boolean;

  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRefs#group
   */
  readonly group?: string;

  /**
   * Kind is the Kubernetes resource kind of the referent. For example
   * "Service".
   *
   * Defaults to "Service" when not specified.
   *
   * ExternalName services can refer to CNAME DNS records that may live
   * outside of the cluster and as such are difficult to reason about in
   * terms of conformance. They also may not be safe to forward to (see
   * CVE-2021-25740 for more information). Implementations SHOULD NOT
   * support ExternalName Services.
   *
   * Support: Core (Services with a type other than ExternalName)
   *
   * Support: Implementation-specific (Services with type ExternalName)
   *
   * @default Service" when not specified.
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRefs#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRefs#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the backend. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRefs#namespace
   */
  readonly namespace?: string;

  /**
   * Port specifies the destination port number to use for this resource.
   * Port is required when the referent is a Kubernetes Service. In this
   * case, the port number is the service port number, not the target port.
   * For other resources, destination port might be derived from the referent
   * resource or this field.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRefs#port
   */
  readonly port?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRefs(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fallback': obj.fallback,
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendSettings holds configuration for managing the connection
 * to the backend.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettings
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettings {
  /**
   * Circuit Breaker settings for the upstream connections and requests.
   * If not set, circuit breakers will be enabled with the default thresholds
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettings#circuitBreaker
   */
  readonly circuitBreaker?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreaker;

  /**
   * Connection includes backend connection settings.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettings#connection
   */
  readonly connection?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnection;

  /**
   * DNS includes dns resolution settings.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettings#dns
   */
  readonly dns?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsDns;

  /**
   * HealthCheck allows gateway to perform active health checking on backends.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettings#healthCheck
   */
  readonly healthCheck?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheck;

  /**
   * HTTP2 provides HTTP/2 configuration for backend connections.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettings#http2
   */
  readonly http2?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2;

  /**
   * LoadBalancer policy to apply when routing traffic from the gateway to
   * the backend endpoints. Defaults to `LeastRequest`.
   *
   * @default LeastRequest`.
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettings#loadBalancer
   */
  readonly loadBalancer?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancer;

  /**
   * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettings#proxyProtocol
   */
  readonly proxyProtocol?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsProxyProtocol;

  /**
   * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
   * If not set, retry will be disabled.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettings#retry
   */
  readonly retry?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetry;

  /**
   * TcpKeepalive settings associated with the upstream client connection.
   * Disabled by default.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettings#tcpKeepalive
   */
  readonly tcpKeepalive?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTcpKeepalive;

  /**
   * Timeout settings for the backend connections.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettings#timeout
   */
  readonly timeout?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeout;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettings(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'circuitBreaker': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreaker(obj.circuitBreaker),
    'connection': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnection(obj.connection),
    'dns': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsDns(obj.dns),
    'healthCheck': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheck(obj.healthCheck),
    'http2': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2(obj.http2),
    'loadBalancer': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancer(obj.loadBalancer),
    'proxyProtocol': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsProxyProtocol(obj.proxyProtocol),
    'retry': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetry(obj.retry),
    'tcpKeepalive': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTcpKeepalive(obj.tcpKeepalive),
    'timeout': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeout(obj.timeout),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Circuit Breaker settings for the upstream connections and requests.
 * If not set, circuit breakers will be enabled with the default thresholds
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreaker
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreaker {
  /**
   * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreaker#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreaker#maxParallelRequests
   */
  readonly maxParallelRequests?: number;

  /**
   * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreaker#maxParallelRetries
   */
  readonly maxParallelRetries?: number;

  /**
   * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreaker#maxPendingRequests
   */
  readonly maxPendingRequests?: number;

  /**
   * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
   * Default: unlimited.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreaker#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreaker#perEndpoint
   */
  readonly perEndpoint?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpoint;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreaker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreaker(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreaker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
    'maxParallelRequests': obj.maxParallelRequests,
    'maxParallelRetries': obj.maxParallelRetries,
    'maxPendingRequests': obj.maxPendingRequests,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'perEndpoint': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpoint(obj.perEndpoint),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Connection includes backend connection settings.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnection
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnection {
  /**
   * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
   * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
   * If unspecified, an implementation defined default is applied (32768 bytes).
   * For example, 20Mi, 1Gi, 256Ki etc.
   * Note: that when the suffix is not provided, the value is interpreted as bytes.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnection#bufferLimit
   */
  readonly bufferLimit?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionBufferLimit;

  /**
   * Preconnect configures proactive upstream connections to reduce latency by establishing
   * connections before they’re needed and avoiding connection establishment overhead.
   *
   * If unset, Envoy will fetch connections as needed to serve in-flight requests.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnection#preconnect
   */
  readonly preconnect?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionPreconnect;

  /**
   * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
   * to backend.
   * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
   * For example, 20Mi, 1Gi, 256Ki etc.
   * Note that when the suffix is not provided, the value is interpreted as bytes.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnection#socketBufferLimit
   */
  readonly socketBufferLimit?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionSocketBufferLimit;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnection(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bufferLimit': obj.bufferLimit?.value,
    'preconnect': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionPreconnect(obj.preconnect),
    'socketBufferLimit': obj.socketBufferLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DNS includes dns resolution settings.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsDns
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsDns {
  /**
   * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
   * Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsDns#dnsRefreshRate
   */
  readonly dnsRefreshRate?: string;

  /**
   * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
   * If set, this configuration overrides other defaults.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsDns#lookupFamily
   */
  readonly lookupFamily?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsDnsLookupFamily;

  /**
   * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
   * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
   * Defaults to true.
   *
   * @default true.
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsDns#respectDnsTtl
   */
  readonly respectDnsTtl?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsDns' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsDns(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsDns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsRefreshRate': obj.dnsRefreshRate,
    'lookupFamily': obj.lookupFamily,
    'respectDnsTtl': obj.respectDnsTtl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HealthCheck allows gateway to perform active health checking on backends.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheck
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheck {
  /**
   * Active health check configuration
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheck#active
   */
  readonly active?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActive;

  /**
   * When number of unhealthy endpoints for a backend reaches this threshold
   * Envoy will disregard health status and balance across all endpoints.
   * It's designed to prevent a situation in which host failures cascade throughout the cluster
   * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheck#panicThreshold
   */
  readonly panicThreshold?: number;

  /**
   * Passive passive check configuration
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheck#passive
   */
  readonly passive?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckPassive;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheck(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'active': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActive(obj.active),
    'panicThreshold': obj.panicThreshold,
    'passive': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckPassive(obj.passive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP2 provides HTTP/2 configuration for backend connections.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2 {
  /**
   * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
   * If not set, the default value is 1 MiB.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2#initialConnectionWindowSize
   */
  readonly initialConnectionWindowSize?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2InitialConnectionWindowSize;

  /**
   * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
   * If not set, the default value is 64 KiB(64*1024).
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2#initialStreamWindowSize
   */
  readonly initialStreamWindowSize?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2InitialStreamWindowSize;

  /**
   * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
   * If not set, the default value is 100.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
   * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
   * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
   * Default: TerminateConnection
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2#onInvalidMessage
   */
  readonly onInvalidMessage?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'initialConnectionWindowSize': obj.initialConnectionWindowSize?.value,
    'initialStreamWindowSize': obj.initialStreamWindowSize?.value,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'onInvalidMessage': obj.onInvalidMessage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LoadBalancer policy to apply when routing traffic from the gateway to
 * the backend endpoints. Defaults to `LeastRequest`.
 *
 * @default LeastRequest`.
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancer
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancer {
  /**
   * ConsistentHash defines the configuration when the load balancer type is
   * set to ConsistentHash
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancer#consistentHash
   */
  readonly consistentHash?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash;

  /**
   * EndpointOverride defines the configuration for endpoint override.
   * When specified, the load balancer will attempt to route requests to endpoints
   * based on the override information extracted from request headers or metadata.
   * If the override endpoints are not available, the configured load balancer policy will be used as fallback.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancer#endpointOverride
   */
  readonly endpointOverride?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverride;

  /**
   * SlowStart defines the configuration related to the slow start load balancer policy.
   * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
   * Currently this is only supported for RoundRobin and LeastRequest load balancers
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancer#slowStart
   */
  readonly slowStart?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStart;

  /**
   * Type decides the type of Load Balancer policy.
   * Valid LoadBalancerType values are
   * "ConsistentHash",
   * "LeastRequest",
   * "Random",
   * "RoundRobin".
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancer#type
   */
  readonly type: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerType;

  /**
   * ZoneAware defines the configuration related to the distribution of requests between locality zones.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancer#zoneAware
   */
  readonly zoneAware?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAware;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancer(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash(obj.consistentHash),
    'endpointOverride': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverride(obj.endpointOverride),
    'slowStart': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStart(obj.slowStart),
    'type': obj.type,
    'zoneAware': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAware(obj.zoneAware),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsProxyProtocol
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsProxyProtocol {
  /**
   * Version of ProxyProtol
   * Valid ProxyProtocolVersion values are
   * "V1"
   * "V2"
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsProxyProtocol#version
   */
  readonly version: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsProxyProtocolVersion;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsProxyProtocol' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsProxyProtocol(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsProxyProtocol | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
 * If not set, retry will be disabled.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetry
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetry {
  /**
   * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
   * that should be sent to the same priority before switching to a different one.
   * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetry#numAttemptsPerPriority
   */
  readonly numAttemptsPerPriority?: number;

  /**
   * NumRetries is the number of retries to be attempted. Defaults to 2.
   *
   * @default 2.
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetry#numRetries
   */
  readonly numRetries?: number;

  /**
   * PerRetry is the retry policy to be applied per retry attempt.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetry#perRetry
   */
  readonly perRetry?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetry;

  /**
   * RetryOn specifies the retry trigger condition.
   *
   * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetry#retryOn
   */
  readonly retryOn?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryRetryOn;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetry(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'numAttemptsPerPriority': obj.numAttemptsPerPriority,
    'numRetries': obj.numRetries,
    'perRetry': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetry(obj.perRetry),
    'retryOn': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryRetryOn(obj.retryOn),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TcpKeepalive settings associated with the upstream client connection.
 * Disabled by default.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTcpKeepalive
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTcpKeepalive {
  /**
   * The duration a connection needs to be idle before keep-alive
   * probes start being sent.
   * The duration format is
   * Defaults to `7200s`.
   *
   * @default 7200s`.
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTcpKeepalive#idleTime
   */
  readonly idleTime?: string;

  /**
   * The duration between keep-alive probes.
   * Defaults to `75s`.
   *
   * @default 75s`.
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * The total number of unacknowledged probes to send before deciding
   * the connection is dead.
   * Defaults to 9.
   *
   * @default 9.
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTcpKeepalive#probes
   */
  readonly probes?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTcpKeepalive(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idleTime': obj.idleTime,
    'interval': obj.interval,
    'probes': obj.probes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for the backend connections.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeout
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeout {
  /**
   * Timeout settings for HTTP.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeout#http
   */
  readonly http?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutHttp;

  /**
   * Timeout settings for TCP.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeout#tcp
   */
  readonly tcp?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutTcp;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeout' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeout(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutHttp(obj.http),
    'tcp': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreakerPerEndpoint
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreakerPerEndpoint {
  /**
   * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreakerPerEndpoint#maxConnections
   */
  readonly maxConnections?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreakerPerEndpoint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreakerPerEndpoint(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreakerPerEndpoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
 * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
 * If unspecified, an implementation defined default is applied (32768 bytes).
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note: that when the suffix is not provided, the value is interpreted as bytes.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionBufferLimit
 */
export class EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionBufferLimit {
  public static fromNumber(value: number): EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionBufferLimit {
    return new EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionBufferLimit(value);
  }
  public static fromString(value: string): EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionBufferLimit {
    return new EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionBufferLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Preconnect configures proactive upstream connections to reduce latency by establishing
 * connections before they’re needed and avoiding connection establishment overhead.
 *
 * If unset, Envoy will fetch connections as needed to serve in-flight requests.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionPreconnect
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionPreconnect {
  /**
   * PerEndpointPercent configures how many additional connections to maintain per
   * upstream endpoint, useful for high-QPS or latency sensitive services. Expressed as a
   * percentage of the connections required by active streams
   * (e.g. 100 = preconnect disabled, 105 = 1.05x connections per-endpoint, 200 = 2.00×).
   *
   * Allowed value range is between 100-300. When both PerEndpointPercent and
   * PredictivePercent are set, Envoy ensures both are satisfied (max of the two).
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionPreconnect#perEndpointPercent
   */
  readonly perEndpointPercent?: number;

  /**
   * PredictivePercent configures how many additional connections to maintain
   * across the cluster by anticipating which upstream endpoint the load balancer
   * will select next, useful for low-QPS services. Relies on deterministic
   * loadbalancing and is only supported with Random or RoundRobin.
   * Expressed as a percentage of the connections required by active streams
   * (e.g. 100 = 1.0 (no preconnect), 105 = 1.05× connections across the cluster, 200 = 2.00×).
   *
   * Minimum allowed value is 100. When both PerEndpointPercent and PredictivePercent are
   * set Envoy ensures both are satisfied per host (max of the two).
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionPreconnect#predictivePercent
   */
  readonly predictivePercent?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionPreconnect' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionPreconnect(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionPreconnect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'perEndpointPercent': obj.perEndpointPercent,
    'predictivePercent': obj.predictivePercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
 * to backend.
 * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note that when the suffix is not provided, the value is interpreted as bytes.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionSocketBufferLimit
 */
export class EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionSocketBufferLimit {
  public static fromNumber(value: number): EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionSocketBufferLimit {
    return new EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionSocketBufferLimit(value);
  }
  public static fromString(value: string): EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionSocketBufferLimit {
    return new EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionSocketBufferLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
 * If set, this configuration overrides other defaults.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsDnsLookupFamily
 */
export enum EnvoyProxySpecTelemetryTracingProviderBackendSettingsDnsLookupFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
  /** IPv4Preferred */
  I_PV4_PREFERRED = "IPv4Preferred",
  /** IPv6Preferred */
  I_PV6_PREFERRED = "IPv6Preferred",
  /** IPv4AndIPv6 */
  I_PV4_AND_I_PV6 = "IPv4AndIPv6",
}

/**
 * Active health check configuration
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActive
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActive {
  /**
   * GRPC defines the configuration of the GRPC health checker.
   * It's optional, and can only be used if the specified type is GRPC.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActive#grpc
   */
  readonly grpc?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveGrpc;

  /**
   * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActive#healthyThreshold
   */
  readonly healthyThreshold?: number;

  /**
   * HTTP defines the configuration of http health checker.
   * It's required while the health checker type is HTTP.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActive#http
   */
  readonly http?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttp;

  /**
   * InitialJitter defines the maximum time Envoy will wait before the first health check.
   * Envoy will randomly select a value between 0 and the initial jitter value.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActive#initialJitter
   */
  readonly initialJitter?: string;

  /**
   * Interval defines the time between active health checks.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActive#interval
   */
  readonly interval?: string;

  /**
   * TCP defines the configuration of tcp health checker.
   * It's required while the health checker type is TCP.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActive#tcp
   */
  readonly tcp?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcp;

  /**
   * Timeout defines the time to wait for a health check response.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActive#timeout
   */
  readonly timeout?: string;

  /**
   * Type defines the type of health checker.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActive#type
   */
  readonly type: string;

  /**
   * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActive#unhealthyThreshold
   */
  readonly unhealthyThreshold?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActive(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpc': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveGrpc(obj.grpc),
    'healthyThreshold': obj.healthyThreshold,
    'http': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttp(obj.http),
    'initialJitter': obj.initialJitter,
    'interval': obj.interval,
    'tcp': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcp(obj.tcp),
    'timeout': obj.timeout,
    'type': obj.type,
    'unhealthyThreshold': obj.unhealthyThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Passive passive check configuration
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckPassive
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckPassive {
  /**
   * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckPassive#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckPassive#consecutive5XxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckPassive#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
   * Parameter takes effect only when split_external_local_origin_errors is set to true.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckPassive#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * FailurePercentageThreshold sets the failure percentage threshold for outlier detection.
   * If the failure percentage of a given host is greater than or equal to this value, it will be ejected.
   * Defaults to 85.
   *
   * @default 85.
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckPassive#failurePercentageThreshold
   */
  readonly failurePercentageThreshold?: number;

  /**
   * Interval defines the time between passive health checks.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckPassive#interval
   */
  readonly interval?: string;

  /**
   * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckPassive#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckPassive#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckPassive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckPassive(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckPassive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5XxErrors': obj.consecutive5XxErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'failurePercentageThreshold': obj.failurePercentageThreshold,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
 * If not set, the default value is 1 MiB.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2InitialConnectionWindowSize
 */
export class EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2InitialConnectionWindowSize {
  public static fromNumber(value: number): EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2InitialConnectionWindowSize {
    return new EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2InitialConnectionWindowSize(value);
  }
  public static fromString(value: string): EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2InitialConnectionWindowSize {
    return new EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2InitialConnectionWindowSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
 * If not set, the default value is 64 KiB(64*1024).
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2InitialStreamWindowSize
 */
export class EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2InitialStreamWindowSize {
  public static fromNumber(value: number): EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2InitialStreamWindowSize {
    return new EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2InitialStreamWindowSize(value);
  }
  public static fromString(value: string): EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2InitialStreamWindowSize {
    return new EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2InitialStreamWindowSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ConsistentHash defines the configuration when the load balancer type is
 * set to ConsistentHash
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHash
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHash {
  /**
   * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHash#cookie
   */
  readonly cookie?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashCookie;

  /**
   * Header configures the header hash policy when the consistent hash type is set to Header.
   *
   * Deprecated: use Headers instead
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHash#header
   */
  readonly header?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashHeader;

  /**
   * Headers configures the header hash policy for each header, when the consistent hash type is set to Headers.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHash#headers
   */
  readonly headers?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashHeaders[];

  /**
   * The table size for consistent hashing, must be prime number limited to 5000011.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHash#tableSize
   */
  readonly tableSize?: number;

  /**
   * ConsistentHashType defines the type of input to hash on. Valid Type values are
   * "SourceIP",
   * "Header",
   * "Headers",
   * "Cookie".
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHash#type
   */
  readonly type: EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashType;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHash(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookie': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashCookie(obj.cookie),
    'header': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashHeader(obj.header),
    'headers': obj.headers?.map(y => toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashHeaders(y)),
    'tableSize': obj.tableSize,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EndpointOverride defines the configuration for endpoint override.
 * When specified, the load balancer will attempt to route requests to endpoints
 * based on the override information extracted from request headers or metadata.
 * If the override endpoints are not available, the configured load balancer policy will be used as fallback.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverride
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverride {
  /**
   * ExtractFrom defines the sources to extract endpoint override information from.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverride#extractFrom
   */
  readonly extractFrom: EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverrideExtractFrom[];
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverride' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverride(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverride | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extractFrom': obj.extractFrom?.map(y => toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverrideExtractFrom(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SlowStart defines the configuration related to the slow start load balancer policy.
 * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
 * Currently this is only supported for RoundRobin and LeastRequest load balancers
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerSlowStart
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerSlowStart {
  /**
   * Window defines the duration of the warm up period for newly added host.
   * During slow start window, traffic sent to the newly added hosts will gradually increase.
   * Currently only supports linear growth of traffic. For additional details,
   * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerSlowStart#window
   */
  readonly window: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerSlowStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerSlowStart(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerSlowStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'window': obj.window,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type decides the type of Load Balancer policy.
 * Valid LoadBalancerType values are
 * "ConsistentHash",
 * "LeastRequest",
 * "Random",
 * "RoundRobin".
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerType
 */
export enum EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerType {
  /** ConsistentHash */
  CONSISTENT_HASH = "ConsistentHash",
  /** LeastRequest */
  LEAST_REQUEST = "LeastRequest",
  /** Random */
  RANDOM = "Random",
  /** RoundRobin */
  ROUND_ROBIN = "RoundRobin",
}

/**
 * ZoneAware defines the configuration related to the distribution of requests between locality zones.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAware
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAware {
  /**
   * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAware#preferLocal
   */
  readonly preferLocal?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocal;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAware' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAware(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAware | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferLocal': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocal(obj.preferLocal),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Version of ProxyProtol
 * Valid ProxyProtocolVersion values are
 * "V1"
 * "V2"
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsProxyProtocolVersion
 */
export enum EnvoyProxySpecTelemetryTracingProviderBackendSettingsProxyProtocolVersion {
  /** V1 */
  V1 = "V1",
  /** V2 */
  V2 = "V2",
}

/**
 * PerRetry is the retry policy to be applied per retry attempt.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetry
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetry {
  /**
   * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
   * back-off algorithm for retries. For additional details,
   * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetry#backOff
   */
  readonly backOff?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetryBackOff;

  /**
   * Timeout is the timeout per retry attempt.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetry#timeout
   */
  readonly timeout?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetry(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backOff': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetryBackOff(obj.backOff),
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RetryOn specifies the retry trigger condition.
 *
 * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryRetryOn
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryRetryOn {
  /**
   * HttpStatusCodes specifies the http status codes to be retried.
   * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryRetryOn#httpStatusCodes
   */
  readonly httpStatusCodes?: number[];

  /**
   * Triggers specifies the retry trigger condition(Http/Grpc).
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryRetryOn#triggers
   */
  readonly triggers?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryRetryOnTriggers[];
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryRetryOn' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryRetryOn(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryRetryOn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpStatusCodes': obj.httpStatusCodes?.map(y => y),
    'triggers': obj.triggers?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for HTTP.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutHttp
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutHttp {
  /**
   * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
   * Default: 1 hour.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutHttp#connectionIdleTimeout
   */
  readonly connectionIdleTimeout?: string;

  /**
   * The maximum duration of an HTTP connection.
   * Default: unlimited.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutHttp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * MaxStreamDuration is the maximum duration for a stream to complete. This timeout measures the time
   * from when the request is sent until the response stream is fully consumed and does not apply to
   * non-streaming requests.
   * When set to "0s", no max duration is applied and streams can run indefinitely.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutHttp#maxStreamDuration
   */
  readonly maxStreamDuration?: string;

  /**
   * RequestTimeout is the time until which entire response is received from the upstream.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutHttp#requestTimeout
   */
  readonly requestTimeout?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutHttp(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionIdleTimeout': obj.connectionIdleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxStreamDuration': obj.maxStreamDuration,
    'requestTimeout': obj.requestTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for TCP.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutTcp
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutTcp {
  /**
   * The timeout for network connection establishment, including TCP and TLS handshakes.
   * Default: 10 seconds.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutTcp#connectTimeout
   */
  readonly connectTimeout?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutTcp(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromConfigMapKeyRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromConfigMapKeyRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFieldRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFieldRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FileKeyRef selects a key of the env file.
 * Requires the EnvFiles feature gate to be enabled.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFileKeyRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFileKeyRef {
  /**
   * The key within the env file. An invalid key will prevent the pod from starting.
   * The keys defined within a source may consist of any printable ASCII characters except '='.
   * During Alpha stage of the EnvFiles feature gate, the key size is limited to 128 characters.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFileKeyRef#key
   */
  readonly key: string;

  /**
   * Specify whether the file or its key must be defined. If the file or key
   * does not exist, then the env var is not published.
   * If optional is set to true and the specified key does not exist,
   * the environment variable will not be set in the Pod's containers.
   *
   * If optional is set to false and the specified key does not exist,
   * an error will be returned during Pod creation.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFileKeyRef#optional
   */
  readonly optional?: boolean;

  /**
   * The path within the volume from which to select the file.
   * Must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFileKeyRef#path
   */
  readonly path: string;

  /**
   * The name of the volume mount containing the env file.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFileKeyRef#volumeName
   */
  readonly volumeName: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFileKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFileKeyRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFileKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'optional': obj.optional,
    'path': obj.path,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromResourceFieldRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromResourceFieldRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromSecretKeyRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromSecretKeyRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
 * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfsSecretRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfsSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfsSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfsSecretRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect
 * to OpenStack.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinderSecretRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinderSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinderSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinderSecretRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMapItems
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMapItems(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing
 * sensitive information to pass to the CSI driver to complete the CSI
 * NodePublishVolume and NodeUnpublishVolume calls.
 * This field is optional, and  may be empty if no secret is required. If the
 * secret object contains more than one secret, all secret references are passed.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsiNodePublishSecretRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsiNodePublishSecretRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsiNodePublishSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItems
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItems(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEmptyDirSizeLimit
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEmptyDirSizeLimit {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEmptyDirSizeLimit {
    return new EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEmptyDirSizeLimit {
    return new EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume.
 * The pod in which this EphemeralVolumeSource is embedded will be the
 * owner of the PVC, i.e. the PVC will be deleted together with the
 * pod.  The name of the PVC will be `<pod name>-<volume name>` where
 * `<volume name>` is the name from the `PodSpec.Volumes` array
 * entry. Pod validation will reject the pod if the concatenated name
 * is not valid for a PVC (for example, too long).
 *
 * An existing PVC with that name that is not owned by the pod
 * will *not* be used for the pod to avoid using an unrelated
 * volume by mistake. Starting the pod is then blocked until
 * the unrelated PVC is removed. If such a pre-created PVC is
 * meant to be used by the pod, the PVC has to updated with an
 * owner reference to the pod once the pod exists. Normally
 * this should not be necessary, but it may be useful when
 * manually reconstructing a broken cluster.
 *
 * This field is read-only and no changes will be made by Kubernetes
 * to the PVC after it has been created.
 *
 * Required, must not be nil.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplate
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC
   * when creating it. No other fields are allowed and will be rejected during
   * validation.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is
   * copied unchanged into the PVC that gets created from this
   * template. The same fields as in a PersistentVolumeClaim
   * are also valid here.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpec;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplate(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing
 * sensitive information to pass to the plugin scripts. This may be
 * empty if no secret object is specified. If the secret object
 * contains more than one secret, all secrets are passed to the plugin
 * scripts.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolumeSecretRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolumeSecretRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolumeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsiSecretRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsiSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsiSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsiSecretRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsiSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Projection that may be projected along with other supported volume types.
 * Exactly one of these fields must be set.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSources
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSources {
  /**
   * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
   * of ClusterTrustBundle objects in an auto-updating file.
   *
   * Alpha, gated by the ClusterTrustBundleProjection feature gate.
   *
   * ClusterTrustBundle objects can either be selected by name, or by the
   * combination of signer name and a label selector.
   *
   * Kubelet performs aggressive normalization of the PEM contents written
   * into the pod filesystem.  Esoteric PEM features such as inter-block
   * comments and block headers are stripped.  Certificates are deduplicated.
   * The ordering of certificates within the file is arbitrary, and Kubelet
   * may change the order over time.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSources#clusterTrustBundle
   */
  readonly clusterTrustBundle?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundle;

  /**
   * configMap information about the configMap data to project
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSources#configMap
   */
  readonly configMap?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApi;

  /**
   * Projects an auto-rotating credential bundle (private key and certificate
   * chain) that the pod can use either as a TLS client or server.
   *
   * Kubelet generates a private key and uses it to send a
   * PodCertificateRequest to the named signer.  Once the signer approves the
   * request and issues a certificate chain, Kubelet writes the key and
   * certificate chain to the pod filesystem.  The pod does not start until
   * certificates have been issued for each podCertificate projected volume
   * source in its spec.
   *
   * Kubelet will begin trying to rotate the certificate at the time indicated
   * by the signer using the PodCertificateRequest.Status.BeginRefreshAt
   * timestamp.
   *
   * Kubelet can write a single file, indicated by the credentialBundlePath
   * field, or separate files, indicated by the keyPath and
   * certificateChainPath fields.
   *
   * The credential bundle is a single file in PEM format.  The first PEM
   * entry is the private key (in PKCS#8 format), and the remaining PEM
   * entries are the certificate chain issued by the signer (typically,
   * signers will return their certificate chain in leaf-to-root order).
   *
   * Prefer using the credential bundle format, since your application code
   * can read it atomically.  If you use keyPath and certificateChainPath,
   * your application must make two separate file reads. If these coincide
   * with a certificate rotation, it is possible that the private key and leaf
   * certificate you read may not correspond to each other.  Your application
   * will need to check for this condition, and re-read until they are
   * consistent.
   *
   * The named signer controls chooses the format of the certificate it
   * issues; consult the signer implementation's documentation to learn how to
   * use the certificates it issues.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSources#podCertificate
   */
  readonly podCertificate?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesPodCertificate;

  /**
   * secret information about the secret data to project
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSources#secret
   */
  readonly secret?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesServiceAccountToken;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSources(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterTrustBundle': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundle(obj.clusterTrustBundle),
    'configMap': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApi(obj.downwardApi),
    'podCertificate': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesPodCertificate(obj.podCertificate),
    'secret': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided
 * overrides keyring.
 * Default is nil.
 * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil.
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbdSecretRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbdSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbdSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbdSecretRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other
 * sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIoSecretRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIoSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIoSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIoSecretRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIoSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecretItems
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecretItems(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API
 * credentials.  If not specified, default values will be attempted.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageosSecretRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageosSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageosSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageosSecretRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageosSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromConfigMapKeyRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromConfigMapKeyRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFieldRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFieldRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FileKeyRef selects a key of the env file.
 * Requires the EnvFiles feature gate to be enabled.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFileKeyRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFileKeyRef {
  /**
   * The key within the env file. An invalid key will prevent the pod from starting.
   * The keys defined within a source may consist of any printable ASCII characters except '='.
   * During Alpha stage of the EnvFiles feature gate, the key size is limited to 128 characters.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFileKeyRef#key
   */
  readonly key: string;

  /**
   * Specify whether the file or its key must be defined. If the file or key
   * does not exist, then the env var is not published.
   * If optional is set to true and the specified key does not exist,
   * the environment variable will not be set in the Pod's containers.
   *
   * If optional is set to false and the specified key does not exist,
   * an error will be returned during Pod creation.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFileKeyRef#optional
   */
  readonly optional?: boolean;

  /**
   * The path within the volume from which to select the file.
   * Must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFileKeyRef#path
   */
  readonly path: string;

  /**
   * The name of the volume mount containing the env file.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFileKeyRef#volumeName
   */
  readonly volumeName: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFileKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFileKeyRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFileKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'optional': obj.optional,
    'path': obj.path,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromResourceFieldRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromResourceFieldRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromSecretKeyRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromSecretKeyRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromConfigMapKeyRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromConfigMapKeyRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFieldRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFieldRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FileKeyRef selects a key of the env file.
 * Requires the EnvFiles feature gate to be enabled.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFileKeyRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFileKeyRef {
  /**
   * The key within the env file. An invalid key will prevent the pod from starting.
   * The keys defined within a source may consist of any printable ASCII characters except '='.
   * During Alpha stage of the EnvFiles feature gate, the key size is limited to 128 characters.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFileKeyRef#key
   */
  readonly key: string;

  /**
   * Specify whether the file or its key must be defined. If the file or key
   * does not exist, then the env var is not published.
   * If optional is set to true and the specified key does not exist,
   * the environment variable will not be set in the Pod's containers.
   *
   * If optional is set to false and the specified key does not exist,
   * an error will be returned during Pod creation.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFileKeyRef#optional
   */
  readonly optional?: boolean;

  /**
   * The path within the volume from which to select the file.
   * Must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFileKeyRef#path
   */
  readonly path: string;

  /**
   * The name of the volume mount containing the env file.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFileKeyRef#volumeName
   */
  readonly volumeName: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFileKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFileKeyRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFileKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'optional': obj.optional,
    'path': obj.path,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromResourceFieldRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromResourceFieldRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromSecretKeyRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromSecretKeyRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartExec
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartExec(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGet
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGet#port
   */
  readonly port: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGet(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartSleep
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartSleep(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartSleep | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartTcpSocket
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartTcpSocketPort;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartTcpSocket(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopExec
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopExec(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGet
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGet#port
   */
  readonly port: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGet(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopSleep
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopSleep(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopSleep | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopTcpSocket
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopTcpSocketPort;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopTcpSocket(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGetHttpHeaders
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGetHttpHeaders(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGetPort
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGetPort {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGetPort {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeTcpSocketPort
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeTcpSocketPort {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeTcpSocketPort {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGetHttpHeaders
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGetHttpHeaders(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGetPort
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGetPort {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGetPort {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeTcpSocketPort
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeTcpSocketPort {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeTcpSocketPort {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGetHttpHeaders
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGetHttpHeaders(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGetPort
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGetPort {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGetPort {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeTcpSocketPort
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeTcpSocketPort {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeTcpSocketPort {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
 * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfsSecretRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfsSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfsSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfsSecretRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect
 * to OpenStack.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinderSecretRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinderSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinderSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinderSecretRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMapItems
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMapItems(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing
 * sensitive information to pass to the CSI driver to complete the CSI
 * NodePublishVolume and NodeUnpublishVolume calls.
 * This field is optional, and  may be empty if no secret is required. If the
 * secret object contains more than one secret, all secret references are passed.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsiNodePublishSecretRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsiNodePublishSecretRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsiNodePublishSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItems
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItems(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEmptyDirSizeLimit
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEmptyDirSizeLimit {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEmptyDirSizeLimit {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEmptyDirSizeLimit {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume.
 * The pod in which this EphemeralVolumeSource is embedded will be the
 * owner of the PVC, i.e. the PVC will be deleted together with the
 * pod.  The name of the PVC will be `<pod name>-<volume name>` where
 * `<volume name>` is the name from the `PodSpec.Volumes` array
 * entry. Pod validation will reject the pod if the concatenated name
 * is not valid for a PVC (for example, too long).
 *
 * An existing PVC with that name that is not owned by the pod
 * will *not* be used for the pod to avoid using an unrelated
 * volume by mistake. Starting the pod is then blocked until
 * the unrelated PVC is removed. If such a pre-created PVC is
 * meant to be used by the pod, the PVC has to updated with an
 * owner reference to the pod once the pod exists. Normally
 * this should not be necessary, but it may be useful when
 * manually reconstructing a broken cluster.
 *
 * This field is read-only and no changes will be made by Kubernetes
 * to the PVC after it has been created.
 *
 * Required, must not be nil.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplate
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC
   * when creating it. No other fields are allowed and will be rejected during
   * validation.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is
   * copied unchanged into the PVC that gets created from this
   * template. The same fields as in a PersistentVolumeClaim
   * are also valid here.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpec;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplate(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing
 * sensitive information to pass to the plugin scripts. This may be
 * empty if no secret object is specified. If the secret object
 * contains more than one secret, all secrets are passed to the plugin
 * scripts.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolumeSecretRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolumeSecretRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolumeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsiSecretRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsiSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsiSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsiSecretRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsiSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Projection that may be projected along with other supported volume types.
 * Exactly one of these fields must be set.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSources
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSources {
  /**
   * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
   * of ClusterTrustBundle objects in an auto-updating file.
   *
   * Alpha, gated by the ClusterTrustBundleProjection feature gate.
   *
   * ClusterTrustBundle objects can either be selected by name, or by the
   * combination of signer name and a label selector.
   *
   * Kubelet performs aggressive normalization of the PEM contents written
   * into the pod filesystem.  Esoteric PEM features such as inter-block
   * comments and block headers are stripped.  Certificates are deduplicated.
   * The ordering of certificates within the file is arbitrary, and Kubelet
   * may change the order over time.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSources#clusterTrustBundle
   */
  readonly clusterTrustBundle?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundle;

  /**
   * configMap information about the configMap data to project
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSources#configMap
   */
  readonly configMap?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApi;

  /**
   * Projects an auto-rotating credential bundle (private key and certificate
   * chain) that the pod can use either as a TLS client or server.
   *
   * Kubelet generates a private key and uses it to send a
   * PodCertificateRequest to the named signer.  Once the signer approves the
   * request and issues a certificate chain, Kubelet writes the key and
   * certificate chain to the pod filesystem.  The pod does not start until
   * certificates have been issued for each podCertificate projected volume
   * source in its spec.
   *
   * Kubelet will begin trying to rotate the certificate at the time indicated
   * by the signer using the PodCertificateRequest.Status.BeginRefreshAt
   * timestamp.
   *
   * Kubelet can write a single file, indicated by the credentialBundlePath
   * field, or separate files, indicated by the keyPath and
   * certificateChainPath fields.
   *
   * The credential bundle is a single file in PEM format.  The first PEM
   * entry is the private key (in PKCS#8 format), and the remaining PEM
   * entries are the certificate chain issued by the signer (typically,
   * signers will return their certificate chain in leaf-to-root order).
   *
   * Prefer using the credential bundle format, since your application code
   * can read it atomically.  If you use keyPath and certificateChainPath,
   * your application must make two separate file reads. If these coincide
   * with a certificate rotation, it is possible that the private key and leaf
   * certificate you read may not correspond to each other.  Your application
   * will need to check for this condition, and re-read until they are
   * consistent.
   *
   * The named signer controls chooses the format of the certificate it
   * issues; consult the signer implementation's documentation to learn how to
   * use the certificates it issues.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSources#podCertificate
   */
  readonly podCertificate?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesPodCertificate;

  /**
   * secret information about the secret data to project
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSources#secret
   */
  readonly secret?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesServiceAccountToken;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSources(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterTrustBundle': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundle(obj.clusterTrustBundle),
    'configMap': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApi(obj.downwardApi),
    'podCertificate': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesPodCertificate(obj.podCertificate),
    'secret': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided
 * overrides keyring.
 * Default is nil.
 * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil.
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbdSecretRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbdSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbdSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbdSecretRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other
 * sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIoSecretRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIoSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIoSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIoSecretRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIoSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecretItems
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecretItems(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API
 * credentials.  If not specified, default values will be attempted.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageosSecretRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageosSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageosSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageosSecretRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageosSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * averageValue is the target value of the average of the
 * metric across all relevant pods (as a quantity)
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTargetAverageValue
 */
export class EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTargetAverageValue {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTargetAverageValue {
    return new EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTargetAverageValue(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTargetAverageValue {
    return new EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTargetAverageValue(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * value is the target value of the metric (as a quantity).
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTargetValue
 */
export class EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTargetValue {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTargetValue {
    return new EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTargetValue(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTargetValue {
    return new EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTargetValue(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * selector is the string-encoded form of a standard kubernetes label selector for the given metric
 * When set, it is passed as an additional parameter to the metrics server for more specific metrics scoping.
 * When unset, just the metricName will be used to gather metrics.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * averageValue is the target value of the average of the
 * metric across all relevant pods (as a quantity)
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTargetAverageValue
 */
export class EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTargetAverageValue {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTargetAverageValue {
    return new EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTargetAverageValue(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTargetAverageValue {
    return new EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTargetAverageValue(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * value is the target value of the metric (as a quantity).
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTargetValue
 */
export class EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTargetValue {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTargetValue {
    return new EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTargetValue(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTargetValue {
    return new EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTargetValue(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * selector is the string-encoded form of a standard kubernetes label selector for the given metric
 * When set, it is passed as an additional parameter to the metrics server for more specific metrics scoping.
 * When unset, just the metricName will be used to gather metrics.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * averageValue is the target value of the average of the
 * metric across all relevant pods (as a quantity)
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTargetAverageValue
 */
export class EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTargetAverageValue {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTargetAverageValue {
    return new EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTargetAverageValue(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTargetAverageValue {
    return new EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTargetAverageValue(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * value is the target value of the metric (as a quantity).
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTargetValue
 */
export class EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTargetValue {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTargetValue {
    return new EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTargetValue(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTargetValue {
    return new EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTargetValue(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * selector is the string-encoded form of a standard kubernetes label selector for the given metric
 * When set, it is passed as an additional parameter to the metrics server for more specific metrics scoping.
 * When unset, just the metricName will be used to gather metrics.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * averageValue is the target value of the average of the
 * metric across all relevant pods (as a quantity)
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTargetAverageValue
 */
export class EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTargetAverageValue {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTargetAverageValue {
    return new EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTargetAverageValue(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTargetAverageValue {
    return new EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTargetAverageValue(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * value is the target value of the metric (as a quantity).
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTargetValue
 */
export class EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTargetValue {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTargetValue {
    return new EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTargetValue(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTargetValue {
    return new EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTargetValue(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * averageValue is the target value of the average of the
 * metric across all relevant pods (as a quantity)
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTargetAverageValue
 */
export class EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTargetAverageValue {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTargetAverageValue {
    return new EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTargetAverageValue(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTargetAverageValue {
    return new EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTargetAverageValue(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * value is the target value of the metric (as a quantity).
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTargetValue
 */
export class EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTargetValue {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTargetValue {
    return new EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTargetValue(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTargetValue {
    return new EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTargetValue(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Circuit Breaker settings for the upstream connections and requests.
 * If not set, circuit breakers will be enabled with the default thresholds
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreaker
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreaker {
  /**
   * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreaker#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreaker#maxParallelRequests
   */
  readonly maxParallelRequests?: number;

  /**
   * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreaker#maxParallelRetries
   */
  readonly maxParallelRetries?: number;

  /**
   * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreaker#maxPendingRequests
   */
  readonly maxPendingRequests?: number;

  /**
   * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
   * Default: unlimited.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreaker#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreaker#perEndpoint
   */
  readonly perEndpoint?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreakerPerEndpoint;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreaker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreaker(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreaker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
    'maxParallelRequests': obj.maxParallelRequests,
    'maxParallelRetries': obj.maxParallelRetries,
    'maxPendingRequests': obj.maxPendingRequests,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'perEndpoint': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreakerPerEndpoint(obj.perEndpoint),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Connection includes backend connection settings.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnection
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnection {
  /**
   * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
   * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
   * If unspecified, an implementation defined default is applied (32768 bytes).
   * For example, 20Mi, 1Gi, 256Ki etc.
   * Note: that when the suffix is not provided, the value is interpreted as bytes.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnection#bufferLimit
   */
  readonly bufferLimit?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionBufferLimit;

  /**
   * Preconnect configures proactive upstream connections to reduce latency by establishing
   * connections before they’re needed and avoiding connection establishment overhead.
   *
   * If unset, Envoy will fetch connections as needed to serve in-flight requests.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnection#preconnect
   */
  readonly preconnect?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionPreconnect;

  /**
   * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
   * to backend.
   * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
   * For example, 20Mi, 1Gi, 256Ki etc.
   * Note that when the suffix is not provided, the value is interpreted as bytes.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnection#socketBufferLimit
   */
  readonly socketBufferLimit?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionSocketBufferLimit;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnection(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bufferLimit': obj.bufferLimit?.value,
    'preconnect': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionPreconnect(obj.preconnect),
    'socketBufferLimit': obj.socketBufferLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DNS includes dns resolution settings.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsDns
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsDns {
  /**
   * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
   * Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsDns#dnsRefreshRate
   */
  readonly dnsRefreshRate?: string;

  /**
   * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
   * If set, this configuration overrides other defaults.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsDns#lookupFamily
   */
  readonly lookupFamily?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsDnsLookupFamily;

  /**
   * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
   * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
   * Defaults to true.
   *
   * @default true.
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsDns#respectDnsTtl
   */
  readonly respectDnsTtl?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsDns' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsDns(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsDns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsRefreshRate': obj.dnsRefreshRate,
    'lookupFamily': obj.lookupFamily,
    'respectDnsTtl': obj.respectDnsTtl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HealthCheck allows gateway to perform active health checking on backends.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheck
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheck {
  /**
   * Active health check configuration
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheck#active
   */
  readonly active?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActive;

  /**
   * When number of unhealthy endpoints for a backend reaches this threshold
   * Envoy will disregard health status and balance across all endpoints.
   * It's designed to prevent a situation in which host failures cascade throughout the cluster
   * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheck#panicThreshold
   */
  readonly panicThreshold?: number;

  /**
   * Passive passive check configuration
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheck#passive
   */
  readonly passive?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckPassive;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheck(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'active': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActive(obj.active),
    'panicThreshold': obj.panicThreshold,
    'passive': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckPassive(obj.passive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP2 provides HTTP/2 configuration for backend connections.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2 {
  /**
   * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
   * If not set, the default value is 1 MiB.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2#initialConnectionWindowSize
   */
  readonly initialConnectionWindowSize?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2InitialConnectionWindowSize;

  /**
   * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
   * If not set, the default value is 64 KiB(64*1024).
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2#initialStreamWindowSize
   */
  readonly initialStreamWindowSize?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2InitialStreamWindowSize;

  /**
   * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
   * If not set, the default value is 100.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
   * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
   * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
   * Default: TerminateConnection
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2#onInvalidMessage
   */
  readonly onInvalidMessage?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'initialConnectionWindowSize': obj.initialConnectionWindowSize?.value,
    'initialStreamWindowSize': obj.initialStreamWindowSize?.value,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'onInvalidMessage': obj.onInvalidMessage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LoadBalancer policy to apply when routing traffic from the gateway to
 * the backend endpoints. Defaults to `LeastRequest`.
 *
 * @default LeastRequest`.
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancer
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancer {
  /**
   * ConsistentHash defines the configuration when the load balancer type is
   * set to ConsistentHash
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancer#consistentHash
   */
  readonly consistentHash?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHash;

  /**
   * EndpointOverride defines the configuration for endpoint override.
   * When specified, the load balancer will attempt to route requests to endpoints
   * based on the override information extracted from request headers or metadata.
   * If the override endpoints are not available, the configured load balancer policy will be used as fallback.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancer#endpointOverride
   */
  readonly endpointOverride?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverride;

  /**
   * SlowStart defines the configuration related to the slow start load balancer policy.
   * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
   * Currently this is only supported for RoundRobin and LeastRequest load balancers
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancer#slowStart
   */
  readonly slowStart?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerSlowStart;

  /**
   * Type decides the type of Load Balancer policy.
   * Valid LoadBalancerType values are
   * "ConsistentHash",
   * "LeastRequest",
   * "Random",
   * "RoundRobin".
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancer#type
   */
  readonly type: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerType;

  /**
   * ZoneAware defines the configuration related to the distribution of requests between locality zones.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancer#zoneAware
   */
  readonly zoneAware?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAware;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancer(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHash(obj.consistentHash),
    'endpointOverride': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverride(obj.endpointOverride),
    'slowStart': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerSlowStart(obj.slowStart),
    'type': obj.type,
    'zoneAware': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAware(obj.zoneAware),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsProxyProtocol
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsProxyProtocol {
  /**
   * Version of ProxyProtol
   * Valid ProxyProtocolVersion values are
   * "V1"
   * "V2"
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsProxyProtocol#version
   */
  readonly version: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsProxyProtocolVersion;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsProxyProtocol' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsProxyProtocol(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsProxyProtocol | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
 * If not set, retry will be disabled.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetry
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetry {
  /**
   * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
   * that should be sent to the same priority before switching to a different one.
   * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetry#numAttemptsPerPriority
   */
  readonly numAttemptsPerPriority?: number;

  /**
   * NumRetries is the number of retries to be attempted. Defaults to 2.
   *
   * @default 2.
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetry#numRetries
   */
  readonly numRetries?: number;

  /**
   * PerRetry is the retry policy to be applied per retry attempt.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetry#perRetry
   */
  readonly perRetry?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetry;

  /**
   * RetryOn specifies the retry trigger condition.
   *
   * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetry#retryOn
   */
  readonly retryOn?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryRetryOn;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetry(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'numAttemptsPerPriority': obj.numAttemptsPerPriority,
    'numRetries': obj.numRetries,
    'perRetry': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetry(obj.perRetry),
    'retryOn': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryRetryOn(obj.retryOn),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TcpKeepalive settings associated with the upstream client connection.
 * Disabled by default.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTcpKeepalive
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTcpKeepalive {
  /**
   * The duration a connection needs to be idle before keep-alive
   * probes start being sent.
   * The duration format is
   * Defaults to `7200s`.
   *
   * @default 7200s`.
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTcpKeepalive#idleTime
   */
  readonly idleTime?: string;

  /**
   * The duration between keep-alive probes.
   * Defaults to `75s`.
   *
   * @default 75s`.
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * The total number of unacknowledged probes to send before deciding
   * the connection is dead.
   * Defaults to 9.
   *
   * @default 9.
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTcpKeepalive#probes
   */
  readonly probes?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTcpKeepalive(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idleTime': obj.idleTime,
    'interval': obj.interval,
    'probes': obj.probes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for the backend connections.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeout
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeout {
  /**
   * Timeout settings for HTTP.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeout#http
   */
  readonly http?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutHttp;

  /**
   * Timeout settings for TCP.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeout#tcp
   */
  readonly tcp?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutTcp;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeout' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeout(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutHttp(obj.http),
    'tcp': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Circuit Breaker settings for the upstream connections and requests.
 * If not set, circuit breakers will be enabled with the default thresholds
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreaker
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreaker {
  /**
   * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreaker#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreaker#maxParallelRequests
   */
  readonly maxParallelRequests?: number;

  /**
   * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreaker#maxParallelRetries
   */
  readonly maxParallelRetries?: number;

  /**
   * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreaker#maxPendingRequests
   */
  readonly maxPendingRequests?: number;

  /**
   * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
   * Default: unlimited.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreaker#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreaker#perEndpoint
   */
  readonly perEndpoint?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpoint;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreaker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreaker(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreaker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
    'maxParallelRequests': obj.maxParallelRequests,
    'maxParallelRetries': obj.maxParallelRetries,
    'maxPendingRequests': obj.maxPendingRequests,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'perEndpoint': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpoint(obj.perEndpoint),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Connection includes backend connection settings.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnection
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnection {
  /**
   * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
   * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
   * If unspecified, an implementation defined default is applied (32768 bytes).
   * For example, 20Mi, 1Gi, 256Ki etc.
   * Note: that when the suffix is not provided, the value is interpreted as bytes.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnection#bufferLimit
   */
  readonly bufferLimit?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionBufferLimit;

  /**
   * Preconnect configures proactive upstream connections to reduce latency by establishing
   * connections before they’re needed and avoiding connection establishment overhead.
   *
   * If unset, Envoy will fetch connections as needed to serve in-flight requests.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnection#preconnect
   */
  readonly preconnect?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionPreconnect;

  /**
   * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
   * to backend.
   * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
   * For example, 20Mi, 1Gi, 256Ki etc.
   * Note that when the suffix is not provided, the value is interpreted as bytes.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnection#socketBufferLimit
   */
  readonly socketBufferLimit?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionSocketBufferLimit;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnection(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bufferLimit': obj.bufferLimit?.value,
    'preconnect': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionPreconnect(obj.preconnect),
    'socketBufferLimit': obj.socketBufferLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DNS includes dns resolution settings.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsDns
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsDns {
  /**
   * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
   * Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsDns#dnsRefreshRate
   */
  readonly dnsRefreshRate?: string;

  /**
   * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
   * If set, this configuration overrides other defaults.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsDns#lookupFamily
   */
  readonly lookupFamily?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsDnsLookupFamily;

  /**
   * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
   * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
   * Defaults to true.
   *
   * @default true.
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsDns#respectDnsTtl
   */
  readonly respectDnsTtl?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsDns' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsDns(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsDns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsRefreshRate': obj.dnsRefreshRate,
    'lookupFamily': obj.lookupFamily,
    'respectDnsTtl': obj.respectDnsTtl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HealthCheck allows gateway to perform active health checking on backends.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheck
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheck {
  /**
   * Active health check configuration
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheck#active
   */
  readonly active?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActive;

  /**
   * When number of unhealthy endpoints for a backend reaches this threshold
   * Envoy will disregard health status and balance across all endpoints.
   * It's designed to prevent a situation in which host failures cascade throughout the cluster
   * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheck#panicThreshold
   */
  readonly panicThreshold?: number;

  /**
   * Passive passive check configuration
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheck#passive
   */
  readonly passive?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckPassive;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheck(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'active': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActive(obj.active),
    'panicThreshold': obj.panicThreshold,
    'passive': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckPassive(obj.passive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP2 provides HTTP/2 configuration for backend connections.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2 {
  /**
   * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
   * If not set, the default value is 1 MiB.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2#initialConnectionWindowSize
   */
  readonly initialConnectionWindowSize?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2InitialConnectionWindowSize;

  /**
   * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
   * If not set, the default value is 64 KiB(64*1024).
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2#initialStreamWindowSize
   */
  readonly initialStreamWindowSize?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2InitialStreamWindowSize;

  /**
   * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
   * If not set, the default value is 100.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
   * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
   * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
   * Default: TerminateConnection
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2#onInvalidMessage
   */
  readonly onInvalidMessage?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'initialConnectionWindowSize': obj.initialConnectionWindowSize?.value,
    'initialStreamWindowSize': obj.initialStreamWindowSize?.value,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'onInvalidMessage': obj.onInvalidMessage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LoadBalancer policy to apply when routing traffic from the gateway to
 * the backend endpoints. Defaults to `LeastRequest`.
 *
 * @default LeastRequest`.
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancer
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancer {
  /**
   * ConsistentHash defines the configuration when the load balancer type is
   * set to ConsistentHash
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancer#consistentHash
   */
  readonly consistentHash?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash;

  /**
   * EndpointOverride defines the configuration for endpoint override.
   * When specified, the load balancer will attempt to route requests to endpoints
   * based on the override information extracted from request headers or metadata.
   * If the override endpoints are not available, the configured load balancer policy will be used as fallback.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancer#endpointOverride
   */
  readonly endpointOverride?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverride;

  /**
   * SlowStart defines the configuration related to the slow start load balancer policy.
   * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
   * Currently this is only supported for RoundRobin and LeastRequest load balancers
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancer#slowStart
   */
  readonly slowStart?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStart;

  /**
   * Type decides the type of Load Balancer policy.
   * Valid LoadBalancerType values are
   * "ConsistentHash",
   * "LeastRequest",
   * "Random",
   * "RoundRobin".
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancer#type
   */
  readonly type: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerType;

  /**
   * ZoneAware defines the configuration related to the distribution of requests between locality zones.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancer#zoneAware
   */
  readonly zoneAware?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAware;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancer(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash(obj.consistentHash),
    'endpointOverride': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverride(obj.endpointOverride),
    'slowStart': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStart(obj.slowStart),
    'type': obj.type,
    'zoneAware': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAware(obj.zoneAware),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsProxyProtocol
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsProxyProtocol {
  /**
   * Version of ProxyProtol
   * Valid ProxyProtocolVersion values are
   * "V1"
   * "V2"
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsProxyProtocol#version
   */
  readonly version: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsProxyProtocolVersion;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsProxyProtocol' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsProxyProtocol(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsProxyProtocol | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
 * If not set, retry will be disabled.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetry
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetry {
  /**
   * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
   * that should be sent to the same priority before switching to a different one.
   * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetry#numAttemptsPerPriority
   */
  readonly numAttemptsPerPriority?: number;

  /**
   * NumRetries is the number of retries to be attempted. Defaults to 2.
   *
   * @default 2.
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetry#numRetries
   */
  readonly numRetries?: number;

  /**
   * PerRetry is the retry policy to be applied per retry attempt.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetry#perRetry
   */
  readonly perRetry?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetry;

  /**
   * RetryOn specifies the retry trigger condition.
   *
   * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetry#retryOn
   */
  readonly retryOn?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryRetryOn;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetry(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'numAttemptsPerPriority': obj.numAttemptsPerPriority,
    'numRetries': obj.numRetries,
    'perRetry': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetry(obj.perRetry),
    'retryOn': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryRetryOn(obj.retryOn),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TcpKeepalive settings associated with the upstream client connection.
 * Disabled by default.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTcpKeepalive
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTcpKeepalive {
  /**
   * The duration a connection needs to be idle before keep-alive
   * probes start being sent.
   * The duration format is
   * Defaults to `7200s`.
   *
   * @default 7200s`.
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTcpKeepalive#idleTime
   */
  readonly idleTime?: string;

  /**
   * The duration between keep-alive probes.
   * Defaults to `75s`.
   *
   * @default 75s`.
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * The total number of unacknowledged probes to send before deciding
   * the connection is dead.
   * Defaults to 9.
   *
   * @default 9.
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTcpKeepalive#probes
   */
  readonly probes?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTcpKeepalive(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idleTime': obj.idleTime,
    'interval': obj.interval,
    'probes': obj.probes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for the backend connections.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeout
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeout {
  /**
   * Timeout settings for HTTP.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeout#http
   */
  readonly http?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutHttp;

  /**
   * Timeout settings for TCP.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeout#tcp
   */
  readonly tcp?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutTcp;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeout' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeout(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutHttp(obj.http),
    'tcp': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpoint
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpoint {
  /**
   * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpoint#maxConnections
   */
  readonly maxConnections?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpoint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpoint(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
 * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
 * If unspecified, an implementation defined default is applied (32768 bytes).
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note: that when the suffix is not provided, the value is interpreted as bytes.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionBufferLimit
 */
export class EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionBufferLimit {
  public static fromNumber(value: number): EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionBufferLimit {
    return new EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionBufferLimit(value);
  }
  public static fromString(value: string): EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionBufferLimit {
    return new EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionBufferLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Preconnect configures proactive upstream connections to reduce latency by establishing
 * connections before they’re needed and avoiding connection establishment overhead.
 *
 * If unset, Envoy will fetch connections as needed to serve in-flight requests.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionPreconnect
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionPreconnect {
  /**
   * PerEndpointPercent configures how many additional connections to maintain per
   * upstream endpoint, useful for high-QPS or latency sensitive services. Expressed as a
   * percentage of the connections required by active streams
   * (e.g. 100 = preconnect disabled, 105 = 1.05x connections per-endpoint, 200 = 2.00×).
   *
   * Allowed value range is between 100-300. When both PerEndpointPercent and
   * PredictivePercent are set, Envoy ensures both are satisfied (max of the two).
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionPreconnect#perEndpointPercent
   */
  readonly perEndpointPercent?: number;

  /**
   * PredictivePercent configures how many additional connections to maintain
   * across the cluster by anticipating which upstream endpoint the load balancer
   * will select next, useful for low-QPS services. Relies on deterministic
   * loadbalancing and is only supported with Random or RoundRobin.
   * Expressed as a percentage of the connections required by active streams
   * (e.g. 100 = 1.0 (no preconnect), 105 = 1.05× connections across the cluster, 200 = 2.00×).
   *
   * Minimum allowed value is 100. When both PerEndpointPercent and PredictivePercent are
   * set Envoy ensures both are satisfied per host (max of the two).
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionPreconnect#predictivePercent
   */
  readonly predictivePercent?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionPreconnect' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionPreconnect(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionPreconnect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'perEndpointPercent': obj.perEndpointPercent,
    'predictivePercent': obj.predictivePercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
 * to backend.
 * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note that when the suffix is not provided, the value is interpreted as bytes.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionSocketBufferLimit
 */
export class EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionSocketBufferLimit {
  public static fromNumber(value: number): EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionSocketBufferLimit {
    return new EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionSocketBufferLimit(value);
  }
  public static fromString(value: string): EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionSocketBufferLimit {
    return new EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionSocketBufferLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
 * If set, this configuration overrides other defaults.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsDnsLookupFamily
 */
export enum EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsDnsLookupFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
  /** IPv4Preferred */
  I_PV4_PREFERRED = "IPv4Preferred",
  /** IPv6Preferred */
  I_PV6_PREFERRED = "IPv6Preferred",
  /** IPv4AndIPv6 */
  I_PV4_AND_I_PV6 = "IPv4AndIPv6",
}

/**
 * Active health check configuration
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActive
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActive {
  /**
   * GRPC defines the configuration of the GRPC health checker.
   * It's optional, and can only be used if the specified type is GRPC.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActive#grpc
   */
  readonly grpc?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpc;

  /**
   * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActive#healthyThreshold
   */
  readonly healthyThreshold?: number;

  /**
   * HTTP defines the configuration of http health checker.
   * It's required while the health checker type is HTTP.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActive#http
   */
  readonly http?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp;

  /**
   * InitialJitter defines the maximum time Envoy will wait before the first health check.
   * Envoy will randomly select a value between 0 and the initial jitter value.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActive#initialJitter
   */
  readonly initialJitter?: string;

  /**
   * Interval defines the time between active health checks.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActive#interval
   */
  readonly interval?: string;

  /**
   * TCP defines the configuration of tcp health checker.
   * It's required while the health checker type is TCP.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActive#tcp
   */
  readonly tcp?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp;

  /**
   * Timeout defines the time to wait for a health check response.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActive#timeout
   */
  readonly timeout?: string;

  /**
   * Type defines the type of health checker.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActive#type
   */
  readonly type: string;

  /**
   * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActive#unhealthyThreshold
   */
  readonly unhealthyThreshold?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActive(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpc': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpc(obj.grpc),
    'healthyThreshold': obj.healthyThreshold,
    'http': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp(obj.http),
    'initialJitter': obj.initialJitter,
    'interval': obj.interval,
    'tcp': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp(obj.tcp),
    'timeout': obj.timeout,
    'type': obj.type,
    'unhealthyThreshold': obj.unhealthyThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Passive passive check configuration
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckPassive
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckPassive {
  /**
   * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckPassive#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckPassive#consecutive5XxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckPassive#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
   * Parameter takes effect only when split_external_local_origin_errors is set to true.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckPassive#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * FailurePercentageThreshold sets the failure percentage threshold for outlier detection.
   * If the failure percentage of a given host is greater than or equal to this value, it will be ejected.
   * Defaults to 85.
   *
   * @default 85.
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckPassive#failurePercentageThreshold
   */
  readonly failurePercentageThreshold?: number;

  /**
   * Interval defines the time between passive health checks.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckPassive#interval
   */
  readonly interval?: string;

  /**
   * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckPassive#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckPassive#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckPassive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckPassive(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckPassive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5XxErrors': obj.consecutive5XxErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'failurePercentageThreshold': obj.failurePercentageThreshold,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
 * If not set, the default value is 1 MiB.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2InitialConnectionWindowSize
 */
export class EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2InitialConnectionWindowSize {
  public static fromNumber(value: number): EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2InitialConnectionWindowSize {
    return new EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2InitialConnectionWindowSize(value);
  }
  public static fromString(value: string): EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2InitialConnectionWindowSize {
    return new EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2InitialConnectionWindowSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
 * If not set, the default value is 64 KiB(64*1024).
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2InitialStreamWindowSize
 */
export class EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2InitialStreamWindowSize {
  public static fromNumber(value: number): EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2InitialStreamWindowSize {
    return new EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2InitialStreamWindowSize(value);
  }
  public static fromString(value: string): EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2InitialStreamWindowSize {
    return new EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2InitialStreamWindowSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ConsistentHash defines the configuration when the load balancer type is
 * set to ConsistentHash
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash {
  /**
   * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash#cookie
   */
  readonly cookie?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie;

  /**
   * Header configures the header hash policy when the consistent hash type is set to Header.
   *
   * Deprecated: use Headers instead
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash#header
   */
  readonly header?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeader;

  /**
   * Headers configures the header hash policy for each header, when the consistent hash type is set to Headers.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash#headers
   */
  readonly headers?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeaders[];

  /**
   * The table size for consistent hashing, must be prime number limited to 5000011.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash#tableSize
   */
  readonly tableSize?: number;

  /**
   * ConsistentHashType defines the type of input to hash on. Valid Type values are
   * "SourceIP",
   * "Header",
   * "Headers",
   * "Cookie".
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash#type
   */
  readonly type: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashType;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookie': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie(obj.cookie),
    'header': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeader(obj.header),
    'headers': obj.headers?.map(y => toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeaders(y)),
    'tableSize': obj.tableSize,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EndpointOverride defines the configuration for endpoint override.
 * When specified, the load balancer will attempt to route requests to endpoints
 * based on the override information extracted from request headers or metadata.
 * If the override endpoints are not available, the configured load balancer policy will be used as fallback.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverride
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverride {
  /**
   * ExtractFrom defines the sources to extract endpoint override information from.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverride#extractFrom
   */
  readonly extractFrom: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFrom[];
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverride' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverride(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverride | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extractFrom': obj.extractFrom?.map(y => toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFrom(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SlowStart defines the configuration related to the slow start load balancer policy.
 * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
 * Currently this is only supported for RoundRobin and LeastRequest load balancers
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStart
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStart {
  /**
   * Window defines the duration of the warm up period for newly added host.
   * During slow start window, traffic sent to the newly added hosts will gradually increase.
   * Currently only supports linear growth of traffic. For additional details,
   * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStart#window
   */
  readonly window: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStart(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'window': obj.window,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type decides the type of Load Balancer policy.
 * Valid LoadBalancerType values are
 * "ConsistentHash",
 * "LeastRequest",
 * "Random",
 * "RoundRobin".
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerType
 */
export enum EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerType {
  /** ConsistentHash */
  CONSISTENT_HASH = "ConsistentHash",
  /** LeastRequest */
  LEAST_REQUEST = "LeastRequest",
  /** Random */
  RANDOM = "Random",
  /** RoundRobin */
  ROUND_ROBIN = "RoundRobin",
}

/**
 * ZoneAware defines the configuration related to the distribution of requests between locality zones.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAware
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAware {
  /**
   * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAware#preferLocal
   */
  readonly preferLocal?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAware' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAware(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAware | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferLocal': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal(obj.preferLocal),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Version of ProxyProtol
 * Valid ProxyProtocolVersion values are
 * "V1"
 * "V2"
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsProxyProtocolVersion
 */
export enum EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsProxyProtocolVersion {
  /** V1 */
  V1 = "V1",
  /** V2 */
  V2 = "V2",
}

/**
 * PerRetry is the retry policy to be applied per retry attempt.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetry
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetry {
  /**
   * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
   * back-off algorithm for retries. For additional details,
   * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetry#backOff
   */
  readonly backOff?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff;

  /**
   * Timeout is the timeout per retry attempt.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetry#timeout
   */
  readonly timeout?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetry(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backOff': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff(obj.backOff),
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RetryOn specifies the retry trigger condition.
 *
 * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryRetryOn
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryRetryOn {
  /**
   * HttpStatusCodes specifies the http status codes to be retried.
   * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryRetryOn#httpStatusCodes
   */
  readonly httpStatusCodes?: number[];

  /**
   * Triggers specifies the retry trigger condition(Http/Grpc).
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryRetryOn#triggers
   */
  readonly triggers?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryRetryOnTriggers[];
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryRetryOn' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryRetryOn(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryRetryOn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpStatusCodes': obj.httpStatusCodes?.map(y => y),
    'triggers': obj.triggers?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for HTTP.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutHttp
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutHttp {
  /**
   * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
   * Default: 1 hour.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutHttp#connectionIdleTimeout
   */
  readonly connectionIdleTimeout?: string;

  /**
   * The maximum duration of an HTTP connection.
   * Default: unlimited.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutHttp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * MaxStreamDuration is the maximum duration for a stream to complete. This timeout measures the time
   * from when the request is sent until the response stream is fully consumed and does not apply to
   * non-streaming requests.
   * When set to "0s", no max duration is applied and streams can run indefinitely.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutHttp#maxStreamDuration
   */
  readonly maxStreamDuration?: string;

  /**
   * RequestTimeout is the time until which entire response is received from the upstream.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutHttp#requestTimeout
   */
  readonly requestTimeout?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutHttp(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionIdleTimeout': obj.connectionIdleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxStreamDuration': obj.maxStreamDuration,
    'requestTimeout': obj.requestTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for TCP.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutTcp
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutTcp {
  /**
   * The timeout for network connection establishment, including TCP and TLS handshakes.
   * Default: 10 seconds.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutTcp#connectTimeout
   */
  readonly connectTimeout?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutTcp(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC defines the configuration of the GRPC health checker.
 * It's optional, and can only be used if the specified type is GRPC.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveGrpc
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveGrpc {
  /**
   * Service to send in the health check request.
   * If this is not specified, then the health check request applies to the entire
   * server and not to a specific service.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveGrpc(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP defines the configuration of http health checker.
 * It's required while the health checker type is HTTP.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttp
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttp {
  /**
   * ExpectedResponse defines a list of HTTP expected responses to match.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttp#expectedResponse
   */
  readonly expectedResponse?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttpExpectedResponse;

  /**
   * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
   * Defaults to 200 only
   *
   * @default 200 only
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttp#expectedStatuses
   */
  readonly expectedStatuses?: number[];

  /**
   * Hostname defines the HTTP host that will be requested during health checking.
   * Default: HTTPRoute or GRPCRoute hostname.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttp#hostname
   */
  readonly hostname?: string;

  /**
   * Method defines the HTTP method used for health checking.
   * Defaults to GET
   *
   * @default GET
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttp#method
   */
  readonly method?: string;

  /**
   * Path defines the HTTP path that will be requested during health checking.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttp#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttp(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expectedResponse': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttpExpectedResponse(obj.expectedResponse),
    'expectedStatuses': obj.expectedStatuses?.map(y => y),
    'hostname': obj.hostname,
    'method': obj.method,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCP defines the configuration of tcp health checker.
 * It's required while the health checker type is TCP.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcp
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcp {
  /**
   * Receive defines the expected response payload.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcp#receive
   */
  readonly receive?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpReceive;

  /**
   * Send defines the request payload.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcp#send
   */
  readonly send?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpSend;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcp(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'receive': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpReceive(obj.receive),
    'send': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpSend(obj.send),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashCookie
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashCookie {
  /**
   * Additional Attributes to set for the generated cookie.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashCookie#attributes
   */
  readonly attributes?: { [key: string]: string };

  /**
   * Name of the cookie to hash.
   * If this cookie does not exist in the request, Envoy will generate a cookie and set
   * the TTL on the response back to the client based on Layer 4
   * attributes of the backend endpoint, to ensure that these future requests
   * go to the same backend endpoint. Make sure to set the TTL field for this case.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashCookie#name
   */
  readonly name: string;

  /**
   * TTL of the generated cookie if the cookie is not present. This value sets the
   * Max-Age attribute value.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashCookie#ttl
   */
  readonly ttl?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashCookie' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashCookie(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributes': ((obj.attributes) === undefined) ? undefined : (Object.entries(obj.attributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Header configures the header hash policy when the consistent hash type is set to Header.
 *
 * Deprecated: use Headers instead
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashHeader
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashHeader {
  /**
   * Name of the header to hash.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashHeader#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashHeader' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashHeader(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Header defines the header hashing configuration for consistent hash based
 * load balancing.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashHeaders
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashHeaders {
  /**
   * Name of the header to hash.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashHeaders#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashHeaders(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConsistentHashType defines the type of input to hash on. Valid Type values are
 * "SourceIP",
 * "Header",
 * "Headers",
 * "Cookie".
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashType
 */
export enum EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashType {
  /** SourceIP */
  SOURCE_IP = "SourceIP",
  /** Header */
  HEADER = "Header",
  /** Headers */
  HEADERS = "Headers",
  /** Cookie */
  COOKIE = "Cookie",
}

/**
 * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverrideExtractFrom
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverrideExtractFrom {
  /**
   * Header defines the header to get the override endpoint addresses.
   * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
   * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
   * The IPv6 address is enclosed in square brackets.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverrideExtractFrom#header
   */
  readonly header?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverrideExtractFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverrideExtractFrom(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverrideExtractFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': obj.header,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocal
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocal {
  /**
   * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
   * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocal#force
   */
  readonly force?: EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForce;

  /**
   * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocal#minEndpointsThreshold
   */
  readonly minEndpointsThreshold?: number;

  /**
   * Configures percentage of requests that will be considered for zone aware routing if zone aware routing is configured. If not specified, Envoy defaults to 100%.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocal#percentageEnabled
   */
  readonly percentageEnabled?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocal' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocal(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'force': toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForce(obj.force),
    'minEndpointsThreshold': obj.minEndpointsThreshold,
    'percentageEnabled': obj.percentageEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
 * back-off algorithm for retries. For additional details,
 * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetryBackOff
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetryBackOff {
  /**
   * BaseInterval is the base interval between retries.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetryBackOff#baseInterval
   */
  readonly baseInterval?: string;

  /**
   * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
   * The default is 10 times the base_interval
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetryBackOff#maxInterval
   */
  readonly maxInterval?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetryBackOff' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetryBackOff(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetryBackOff | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseInterval': obj.baseInterval,
    'maxInterval': obj.maxInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TriggerEnum specifies the conditions that trigger retries.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryRetryOnTriggers
 */
export enum EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryRetryOnTriggers {
  /** 5xx */
  VALUE_5XX = "5xx",
  /** gateway-error */
  GATEWAY_HYPHEN_ERROR = "gateway-error",
  /** reset */
  RESET = "reset",
  /** reset-before-request */
  RESET_HYPHEN_BEFORE_HYPHEN_REQUEST = "reset-before-request",
  /** connect-failure */
  CONNECT_HYPHEN_FAILURE = "connect-failure",
  /** retriable-4xx */
  RETRIABLE_HYPHEN_4XX = "retriable-4xx",
  /** refused-stream */
  REFUSED_HYPHEN_STREAM = "refused-stream",
  /** retriable-status-codes */
  RETRIABLE_HYPHEN_STATUS_HYPHEN_CODES = "retriable-status-codes",
  /** cancelled */
  CANCELLED = "cancelled",
  /** deadline-exceeded */
  DEADLINE_HYPHEN_EXCEEDED = "deadline-exceeded",
  /** internal */
  INTERNAL = "internal",
  /** resource-exhausted */
  RESOURCE_HYPHEN_EXHAUSTED = "resource-exhausted",
  /** unavailable */
  UNAVAILABLE = "unavailable",
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromResourceFieldRefDivisor
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromResourceFieldRefDivisor {
    return new EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromResourceFieldRefDivisor {
    return new EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsFieldRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsFieldRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsResourceFieldRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsResourceFieldRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is
 * copied unchanged into the PVC that gets created from this
 * template. The same fields as in a PersistentVolumeClaim
 * are also valid here.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string or nil value indicates that no
   * VolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,
   * this field can be reset to its previous value (including nil) to cancel the modification.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpec(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
 * of ClusterTrustBundle objects in an auto-updating file.
 *
 * Alpha, gated by the ClusterTrustBundleProjection feature gate.
 *
 * ClusterTrustBundle objects can either be selected by name, or by the
 * combination of signer name and a label selector.
 *
 * Kubelet performs aggressive normalization of the PEM contents written
 * into the pod filesystem.  Esoteric PEM features such as inter-block
 * comments and block headers are stripped.  Certificates are deduplicated.
 * The ordering of certificates within the file is arbitrary, and Kubelet
 * may change the order over time.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundle
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundle {
  /**
   * Select all ClusterTrustBundles that match this label selector.  Only has
   * effect if signerName is set.  Mutually-exclusive with name.  If unset,
   * interpreted as "match nothing".  If set but empty, interpreted as "match
   * everything".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundle#labelSelector
   */
  readonly labelSelector?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelector;

  /**
   * Select a single ClusterTrustBundle by object name.  Mutually-exclusive
   * with signerName and labelSelector.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundle#name
   */
  readonly name?: string;

  /**
   * If true, don't block pod startup if the referenced ClusterTrustBundle(s)
   * aren't available.  If using name, then the named ClusterTrustBundle is
   * allowed not to exist.  If using signerName, then the combination of
   * signerName and labelSelector is allowed to match zero
   * ClusterTrustBundles.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundle#optional
   */
  readonly optional?: boolean;

  /**
   * Relative path from the volume root to write the bundle.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundle#path
   */
  readonly path: string;

  /**
   * Select all ClusterTrustBundles that match this signer name.
   * Mutually-exclusive with name.  The contents of all selected
   * ClusterTrustBundles will be unified and deduplicated.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundle#signerName
   */
  readonly signerName?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundle(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelector(obj.labelSelector),
    'name': obj.name,
    'optional': obj.optional,
    'path': obj.path,
    'signerName': obj.signerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMap
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMap(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApi
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItems[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApi(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Projects an auto-rotating credential bundle (private key and certificate
 * chain) that the pod can use either as a TLS client or server.
 *
 * Kubelet generates a private key and uses it to send a
 * PodCertificateRequest to the named signer.  Once the signer approves the
 * request and issues a certificate chain, Kubelet writes the key and
 * certificate chain to the pod filesystem.  The pod does not start until
 * certificates have been issued for each podCertificate projected volume
 * source in its spec.
 *
 * Kubelet will begin trying to rotate the certificate at the time indicated
 * by the signer using the PodCertificateRequest.Status.BeginRefreshAt
 * timestamp.
 *
 * Kubelet can write a single file, indicated by the credentialBundlePath
 * field, or separate files, indicated by the keyPath and
 * certificateChainPath fields.
 *
 * The credential bundle is a single file in PEM format.  The first PEM
 * entry is the private key (in PKCS#8 format), and the remaining PEM
 * entries are the certificate chain issued by the signer (typically,
 * signers will return their certificate chain in leaf-to-root order).
 *
 * Prefer using the credential bundle format, since your application code
 * can read it atomically.  If you use keyPath and certificateChainPath,
 * your application must make two separate file reads. If these coincide
 * with a certificate rotation, it is possible that the private key and leaf
 * certificate you read may not correspond to each other.  Your application
 * will need to check for this condition, and re-read until they are
 * consistent.
 *
 * The named signer controls chooses the format of the certificate it
 * issues; consult the signer implementation's documentation to learn how to
 * use the certificates it issues.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesPodCertificate
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesPodCertificate {
  /**
   * Write the certificate chain at this path in the projected volume.
   *
   * Most applications should use credentialBundlePath.  When using keyPath
   * and certificateChainPath, your application needs to check that the key
   * and leaf certificate are consistent, because it is possible to read the
   * files mid-rotation.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesPodCertificate#certificateChainPath
   */
  readonly certificateChainPath?: string;

  /**
   * Write the credential bundle at this path in the projected volume.
   *
   * The credential bundle is a single file that contains multiple PEM blocks.
   * The first PEM block is a PRIVATE KEY block, containing a PKCS#8 private
   * key.
   *
   * The remaining blocks are CERTIFICATE blocks, containing the issued
   * certificate chain from the signer (leaf and any intermediates).
   *
   * Using credentialBundlePath lets your Pod's application code make a single
   * atomic read that retrieves a consistent key and certificate chain.  If you
   * project them to separate files, your application code will need to
   * additionally check that the leaf certificate was issued to the key.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesPodCertificate#credentialBundlePath
   */
  readonly credentialBundlePath?: string;

  /**
   * Write the key at this path in the projected volume.
   *
   * Most applications should use credentialBundlePath.  When using keyPath
   * and certificateChainPath, your application needs to check that the key
   * and leaf certificate are consistent, because it is possible to read the
   * files mid-rotation.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesPodCertificate#keyPath
   */
  readonly keyPath?: string;

  /**
   * The type of keypair Kubelet will generate for the pod.
   *
   * Valid values are "RSA3072", "RSA4096", "ECDSAP256", "ECDSAP384",
   * "ECDSAP521", and "ED25519".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesPodCertificate#keyType
   */
  readonly keyType: string;

  /**
   * maxExpirationSeconds is the maximum lifetime permitted for the
   * certificate.
   *
   * Kubelet copies this value verbatim into the PodCertificateRequests it
   * generates for this projection.
   *
   * If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver
   * will reject values shorter than 3600 (1 hour).  The maximum allowable
   * value is 7862400 (91 days).
   *
   * The signer implementation is then free to issue a certificate with any
   * lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600
   * seconds (1 hour).  This constraint is enforced by kube-apiserver.
   * `kubernetes.io` signers will never issue certificates with a lifetime
   * longer than 24 hours.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesPodCertificate#maxExpirationSeconds
   */
  readonly maxExpirationSeconds?: number;

  /**
   * Kubelet's generated CSRs will be addressed to this signer.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesPodCertificate#signerName
   */
  readonly signerName: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesPodCertificate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesPodCertificate(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesPodCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateChainPath': obj.certificateChainPath,
    'credentialBundlePath': obj.credentialBundlePath,
    'keyPath': obj.keyPath,
    'keyType': obj.keyType,
    'maxExpirationSeconds': obj.maxExpirationSeconds,
    'signerName': obj.signerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecret
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecret#items
   */
  readonly items?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecret(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesServiceAccountToken
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token
   * must identify itself with an identifier specified in the audience of the
   * token, and otherwise should reject the token. The audience defaults to the
   * identifier of the apiserver.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service
   * account token. As the token approaches expiration, the kubelet volume
   * plugin will proactively rotate the service account token. The kubelet will
   * start trying to rotate the token if the token is older than 80 percent of
   * its time to live or if the token is older than 24 hours.Defaults to 1 hour
   * and must be at least 10 minutes.
   *
   * @default 1 hour
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the
   * token into.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesServiceAccountToken(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromResourceFieldRefDivisor
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromResourceFieldRefDivisor {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromResourceFieldRefDivisor {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromResourceFieldRefDivisor
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromResourceFieldRefDivisor {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromResourceFieldRefDivisor {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGetHttpHeaders(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGetPort
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGetPort {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGetPort {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartTcpSocketPort
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartTcpSocketPort {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartTcpSocketPort {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGetHttpHeaders(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGetPort
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGetPort {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGetPort {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopTcpSocketPort
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopTcpSocketPort {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopTcpSocketPort {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'mismatchLabelKeys': obj.mismatchLabelKeys?.map(y => y),
    'namespaceSelector': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsFieldRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsFieldRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsResourceFieldRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsResourceFieldRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is
 * copied unchanged into the PVC that gets created from this
 * template. The same fields as in a PersistentVolumeClaim
 * are also valid here.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string or nil value indicates that no
   * VolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,
   * this field can be reset to its previous value (including nil) to cancel the modification.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpec(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeAttributesClassName': obj.volumeAttributesClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
 * of ClusterTrustBundle objects in an auto-updating file.
 *
 * Alpha, gated by the ClusterTrustBundleProjection feature gate.
 *
 * ClusterTrustBundle objects can either be selected by name, or by the
 * combination of signer name and a label selector.
 *
 * Kubelet performs aggressive normalization of the PEM contents written
 * into the pod filesystem.  Esoteric PEM features such as inter-block
 * comments and block headers are stripped.  Certificates are deduplicated.
 * The ordering of certificates within the file is arbitrary, and Kubelet
 * may change the order over time.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundle
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundle {
  /**
   * Select all ClusterTrustBundles that match this label selector.  Only has
   * effect if signerName is set.  Mutually-exclusive with name.  If unset,
   * interpreted as "match nothing".  If set but empty, interpreted as "match
   * everything".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundle#labelSelector
   */
  readonly labelSelector?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelector;

  /**
   * Select a single ClusterTrustBundle by object name.  Mutually-exclusive
   * with signerName and labelSelector.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundle#name
   */
  readonly name?: string;

  /**
   * If true, don't block pod startup if the referenced ClusterTrustBundle(s)
   * aren't available.  If using name, then the named ClusterTrustBundle is
   * allowed not to exist.  If using signerName, then the combination of
   * signerName and labelSelector is allowed to match zero
   * ClusterTrustBundles.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundle#optional
   */
  readonly optional?: boolean;

  /**
   * Relative path from the volume root to write the bundle.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundle#path
   */
  readonly path: string;

  /**
   * Select all ClusterTrustBundles that match this signer name.
   * Mutually-exclusive with name.  The contents of all selected
   * ClusterTrustBundles will be unified and deduplicated.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundle#signerName
   */
  readonly signerName?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundle(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelector(obj.labelSelector),
    'name': obj.name,
    'optional': obj.optional,
    'path': obj.path,
    'signerName': obj.signerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMap
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMap(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApi
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItems[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApi(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Projects an auto-rotating credential bundle (private key and certificate
 * chain) that the pod can use either as a TLS client or server.
 *
 * Kubelet generates a private key and uses it to send a
 * PodCertificateRequest to the named signer.  Once the signer approves the
 * request and issues a certificate chain, Kubelet writes the key and
 * certificate chain to the pod filesystem.  The pod does not start until
 * certificates have been issued for each podCertificate projected volume
 * source in its spec.
 *
 * Kubelet will begin trying to rotate the certificate at the time indicated
 * by the signer using the PodCertificateRequest.Status.BeginRefreshAt
 * timestamp.
 *
 * Kubelet can write a single file, indicated by the credentialBundlePath
 * field, or separate files, indicated by the keyPath and
 * certificateChainPath fields.
 *
 * The credential bundle is a single file in PEM format.  The first PEM
 * entry is the private key (in PKCS#8 format), and the remaining PEM
 * entries are the certificate chain issued by the signer (typically,
 * signers will return their certificate chain in leaf-to-root order).
 *
 * Prefer using the credential bundle format, since your application code
 * can read it atomically.  If you use keyPath and certificateChainPath,
 * your application must make two separate file reads. If these coincide
 * with a certificate rotation, it is possible that the private key and leaf
 * certificate you read may not correspond to each other.  Your application
 * will need to check for this condition, and re-read until they are
 * consistent.
 *
 * The named signer controls chooses the format of the certificate it
 * issues; consult the signer implementation's documentation to learn how to
 * use the certificates it issues.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesPodCertificate
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesPodCertificate {
  /**
   * Write the certificate chain at this path in the projected volume.
   *
   * Most applications should use credentialBundlePath.  When using keyPath
   * and certificateChainPath, your application needs to check that the key
   * and leaf certificate are consistent, because it is possible to read the
   * files mid-rotation.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesPodCertificate#certificateChainPath
   */
  readonly certificateChainPath?: string;

  /**
   * Write the credential bundle at this path in the projected volume.
   *
   * The credential bundle is a single file that contains multiple PEM blocks.
   * The first PEM block is a PRIVATE KEY block, containing a PKCS#8 private
   * key.
   *
   * The remaining blocks are CERTIFICATE blocks, containing the issued
   * certificate chain from the signer (leaf and any intermediates).
   *
   * Using credentialBundlePath lets your Pod's application code make a single
   * atomic read that retrieves a consistent key and certificate chain.  If you
   * project them to separate files, your application code will need to
   * additionally check that the leaf certificate was issued to the key.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesPodCertificate#credentialBundlePath
   */
  readonly credentialBundlePath?: string;

  /**
   * Write the key at this path in the projected volume.
   *
   * Most applications should use credentialBundlePath.  When using keyPath
   * and certificateChainPath, your application needs to check that the key
   * and leaf certificate are consistent, because it is possible to read the
   * files mid-rotation.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesPodCertificate#keyPath
   */
  readonly keyPath?: string;

  /**
   * The type of keypair Kubelet will generate for the pod.
   *
   * Valid values are "RSA3072", "RSA4096", "ECDSAP256", "ECDSAP384",
   * "ECDSAP521", and "ED25519".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesPodCertificate#keyType
   */
  readonly keyType: string;

  /**
   * maxExpirationSeconds is the maximum lifetime permitted for the
   * certificate.
   *
   * Kubelet copies this value verbatim into the PodCertificateRequests it
   * generates for this projection.
   *
   * If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver
   * will reject values shorter than 3600 (1 hour).  The maximum allowable
   * value is 7862400 (91 days).
   *
   * The signer implementation is then free to issue a certificate with any
   * lifetime *shorter* than MaxExpirationSeconds, but no shorter than 3600
   * seconds (1 hour).  This constraint is enforced by kube-apiserver.
   * `kubernetes.io` signers will never issue certificates with a lifetime
   * longer than 24 hours.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesPodCertificate#maxExpirationSeconds
   */
  readonly maxExpirationSeconds?: number;

  /**
   * Kubelet's generated CSRs will be addressed to this signer.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesPodCertificate#signerName
   */
  readonly signerName: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesPodCertificate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesPodCertificate(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesPodCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateChainPath': obj.certificateChainPath,
    'credentialBundlePath': obj.credentialBundlePath,
    'keyPath': obj.keyPath,
    'keyType': obj.keyType,
    'maxExpirationSeconds': obj.maxExpirationSeconds,
    'signerName': obj.signerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecret
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecret#items
   */
  readonly items?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecret(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesServiceAccountToken
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token
   * must identify itself with an identifier specified in the audience of the
   * token, and otherwise should reject the token. The audience defaults to the
   * identifier of the apiserver.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service
   * account token. As the token approaches expiration, the kubelet volume
   * plugin will proactively rotate the service account token. The kubelet will
   * start trying to rotate the token if the token is older than 80 percent of
   * its time to live or if the token is older than 24 hours.Defaults to 1 hour
   * and must be at least 10 minutes.
   *
   * @default 1 hour
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the
   * token into.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesServiceAccountToken(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreakerPerEndpoint
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreakerPerEndpoint {
  /**
   * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreakerPerEndpoint#maxConnections
   */
  readonly maxConnections?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreakerPerEndpoint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreakerPerEndpoint(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreakerPerEndpoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
 * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
 * If unspecified, an implementation defined default is applied (32768 bytes).
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note: that when the suffix is not provided, the value is interpreted as bytes.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionBufferLimit
 */
export class EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionBufferLimit {
  public static fromNumber(value: number): EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionBufferLimit {
    return new EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionBufferLimit(value);
  }
  public static fromString(value: string): EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionBufferLimit {
    return new EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionBufferLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Preconnect configures proactive upstream connections to reduce latency by establishing
 * connections before they’re needed and avoiding connection establishment overhead.
 *
 * If unset, Envoy will fetch connections as needed to serve in-flight requests.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionPreconnect
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionPreconnect {
  /**
   * PerEndpointPercent configures how many additional connections to maintain per
   * upstream endpoint, useful for high-QPS or latency sensitive services. Expressed as a
   * percentage of the connections required by active streams
   * (e.g. 100 = preconnect disabled, 105 = 1.05x connections per-endpoint, 200 = 2.00×).
   *
   * Allowed value range is between 100-300. When both PerEndpointPercent and
   * PredictivePercent are set, Envoy ensures both are satisfied (max of the two).
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionPreconnect#perEndpointPercent
   */
  readonly perEndpointPercent?: number;

  /**
   * PredictivePercent configures how many additional connections to maintain
   * across the cluster by anticipating which upstream endpoint the load balancer
   * will select next, useful for low-QPS services. Relies on deterministic
   * loadbalancing and is only supported with Random or RoundRobin.
   * Expressed as a percentage of the connections required by active streams
   * (e.g. 100 = 1.0 (no preconnect), 105 = 1.05× connections across the cluster, 200 = 2.00×).
   *
   * Minimum allowed value is 100. When both PerEndpointPercent and PredictivePercent are
   * set Envoy ensures both are satisfied per host (max of the two).
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionPreconnect#predictivePercent
   */
  readonly predictivePercent?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionPreconnect' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionPreconnect(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionPreconnect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'perEndpointPercent': obj.perEndpointPercent,
    'predictivePercent': obj.predictivePercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
 * to backend.
 * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note that when the suffix is not provided, the value is interpreted as bytes.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionSocketBufferLimit
 */
export class EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionSocketBufferLimit {
  public static fromNumber(value: number): EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionSocketBufferLimit {
    return new EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionSocketBufferLimit(value);
  }
  public static fromString(value: string): EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionSocketBufferLimit {
    return new EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionSocketBufferLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
 * If set, this configuration overrides other defaults.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsDnsLookupFamily
 */
export enum EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsDnsLookupFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
  /** IPv4Preferred */
  I_PV4_PREFERRED = "IPv4Preferred",
  /** IPv6Preferred */
  I_PV6_PREFERRED = "IPv6Preferred",
  /** IPv4AndIPv6 */
  I_PV4_AND_I_PV6 = "IPv4AndIPv6",
}

/**
 * Active health check configuration
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActive
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActive {
  /**
   * GRPC defines the configuration of the GRPC health checker.
   * It's optional, and can only be used if the specified type is GRPC.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActive#grpc
   */
  readonly grpc?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveGrpc;

  /**
   * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActive#healthyThreshold
   */
  readonly healthyThreshold?: number;

  /**
   * HTTP defines the configuration of http health checker.
   * It's required while the health checker type is HTTP.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActive#http
   */
  readonly http?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttp;

  /**
   * InitialJitter defines the maximum time Envoy will wait before the first health check.
   * Envoy will randomly select a value between 0 and the initial jitter value.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActive#initialJitter
   */
  readonly initialJitter?: string;

  /**
   * Interval defines the time between active health checks.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActive#interval
   */
  readonly interval?: string;

  /**
   * TCP defines the configuration of tcp health checker.
   * It's required while the health checker type is TCP.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActive#tcp
   */
  readonly tcp?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcp;

  /**
   * Timeout defines the time to wait for a health check response.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActive#timeout
   */
  readonly timeout?: string;

  /**
   * Type defines the type of health checker.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActive#type
   */
  readonly type: string;

  /**
   * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActive#unhealthyThreshold
   */
  readonly unhealthyThreshold?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActive(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpc': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveGrpc(obj.grpc),
    'healthyThreshold': obj.healthyThreshold,
    'http': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttp(obj.http),
    'initialJitter': obj.initialJitter,
    'interval': obj.interval,
    'tcp': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcp(obj.tcp),
    'timeout': obj.timeout,
    'type': obj.type,
    'unhealthyThreshold': obj.unhealthyThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Passive passive check configuration
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckPassive
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckPassive {
  /**
   * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckPassive#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckPassive#consecutive5XxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckPassive#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
   * Parameter takes effect only when split_external_local_origin_errors is set to true.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckPassive#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * FailurePercentageThreshold sets the failure percentage threshold for outlier detection.
   * If the failure percentage of a given host is greater than or equal to this value, it will be ejected.
   * Defaults to 85.
   *
   * @default 85.
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckPassive#failurePercentageThreshold
   */
  readonly failurePercentageThreshold?: number;

  /**
   * Interval defines the time between passive health checks.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckPassive#interval
   */
  readonly interval?: string;

  /**
   * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckPassive#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckPassive#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckPassive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckPassive(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckPassive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5XxErrors': obj.consecutive5XxErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'failurePercentageThreshold': obj.failurePercentageThreshold,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
 * If not set, the default value is 1 MiB.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2InitialConnectionWindowSize
 */
export class EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2InitialConnectionWindowSize {
  public static fromNumber(value: number): EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2InitialConnectionWindowSize {
    return new EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2InitialConnectionWindowSize(value);
  }
  public static fromString(value: string): EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2InitialConnectionWindowSize {
    return new EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2InitialConnectionWindowSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
 * If not set, the default value is 64 KiB(64*1024).
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2InitialStreamWindowSize
 */
export class EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2InitialStreamWindowSize {
  public static fromNumber(value: number): EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2InitialStreamWindowSize {
    return new EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2InitialStreamWindowSize(value);
  }
  public static fromString(value: string): EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2InitialStreamWindowSize {
    return new EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2InitialStreamWindowSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ConsistentHash defines the configuration when the load balancer type is
 * set to ConsistentHash
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHash
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHash {
  /**
   * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHash#cookie
   */
  readonly cookie?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashCookie;

  /**
   * Header configures the header hash policy when the consistent hash type is set to Header.
   *
   * Deprecated: use Headers instead
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHash#header
   */
  readonly header?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashHeader;

  /**
   * Headers configures the header hash policy for each header, when the consistent hash type is set to Headers.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHash#headers
   */
  readonly headers?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashHeaders[];

  /**
   * The table size for consistent hashing, must be prime number limited to 5000011.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHash#tableSize
   */
  readonly tableSize?: number;

  /**
   * ConsistentHashType defines the type of input to hash on. Valid Type values are
   * "SourceIP",
   * "Header",
   * "Headers",
   * "Cookie".
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHash#type
   */
  readonly type: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashType;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHash(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookie': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashCookie(obj.cookie),
    'header': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashHeader(obj.header),
    'headers': obj.headers?.map(y => toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashHeaders(y)),
    'tableSize': obj.tableSize,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EndpointOverride defines the configuration for endpoint override.
 * When specified, the load balancer will attempt to route requests to endpoints
 * based on the override information extracted from request headers or metadata.
 * If the override endpoints are not available, the configured load balancer policy will be used as fallback.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverride
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverride {
  /**
   * ExtractFrom defines the sources to extract endpoint override information from.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverride#extractFrom
   */
  readonly extractFrom: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverrideExtractFrom[];
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverride' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverride(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverride | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extractFrom': obj.extractFrom?.map(y => toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverrideExtractFrom(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SlowStart defines the configuration related to the slow start load balancer policy.
 * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
 * Currently this is only supported for RoundRobin and LeastRequest load balancers
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerSlowStart
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerSlowStart {
  /**
   * Window defines the duration of the warm up period for newly added host.
   * During slow start window, traffic sent to the newly added hosts will gradually increase.
   * Currently only supports linear growth of traffic. For additional details,
   * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerSlowStart#window
   */
  readonly window: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerSlowStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerSlowStart(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerSlowStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'window': obj.window,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type decides the type of Load Balancer policy.
 * Valid LoadBalancerType values are
 * "ConsistentHash",
 * "LeastRequest",
 * "Random",
 * "RoundRobin".
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerType
 */
export enum EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerType {
  /** ConsistentHash */
  CONSISTENT_HASH = "ConsistentHash",
  /** LeastRequest */
  LEAST_REQUEST = "LeastRequest",
  /** Random */
  RANDOM = "Random",
  /** RoundRobin */
  ROUND_ROBIN = "RoundRobin",
}

/**
 * ZoneAware defines the configuration related to the distribution of requests between locality zones.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAware
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAware {
  /**
   * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAware#preferLocal
   */
  readonly preferLocal?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocal;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAware' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAware(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAware | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferLocal': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocal(obj.preferLocal),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Version of ProxyProtol
 * Valid ProxyProtocolVersion values are
 * "V1"
 * "V2"
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsProxyProtocolVersion
 */
export enum EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsProxyProtocolVersion {
  /** V1 */
  V1 = "V1",
  /** V2 */
  V2 = "V2",
}

/**
 * PerRetry is the retry policy to be applied per retry attempt.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetry
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetry {
  /**
   * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
   * back-off algorithm for retries. For additional details,
   * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetry#backOff
   */
  readonly backOff?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetryBackOff;

  /**
   * Timeout is the timeout per retry attempt.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetry#timeout
   */
  readonly timeout?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetry(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backOff': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetryBackOff(obj.backOff),
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RetryOn specifies the retry trigger condition.
 *
 * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryRetryOn
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryRetryOn {
  /**
   * HttpStatusCodes specifies the http status codes to be retried.
   * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryRetryOn#httpStatusCodes
   */
  readonly httpStatusCodes?: number[];

  /**
   * Triggers specifies the retry trigger condition(Http/Grpc).
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryRetryOn#triggers
   */
  readonly triggers?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryRetryOnTriggers[];
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryRetryOn' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryRetryOn(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryRetryOn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpStatusCodes': obj.httpStatusCodes?.map(y => y),
    'triggers': obj.triggers?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for HTTP.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutHttp
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutHttp {
  /**
   * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
   * Default: 1 hour.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutHttp#connectionIdleTimeout
   */
  readonly connectionIdleTimeout?: string;

  /**
   * The maximum duration of an HTTP connection.
   * Default: unlimited.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutHttp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * MaxStreamDuration is the maximum duration for a stream to complete. This timeout measures the time
   * from when the request is sent until the response stream is fully consumed and does not apply to
   * non-streaming requests.
   * When set to "0s", no max duration is applied and streams can run indefinitely.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutHttp#maxStreamDuration
   */
  readonly maxStreamDuration?: string;

  /**
   * RequestTimeout is the time until which entire response is received from the upstream.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutHttp#requestTimeout
   */
  readonly requestTimeout?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutHttp(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionIdleTimeout': obj.connectionIdleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxStreamDuration': obj.maxStreamDuration,
    'requestTimeout': obj.requestTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for TCP.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutTcp
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutTcp {
  /**
   * The timeout for network connection establishment, including TCP and TLS handshakes.
   * Default: 10 seconds.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutTcp#connectTimeout
   */
  readonly connectTimeout?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutTcp(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpoint
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpoint {
  /**
   * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpoint#maxConnections
   */
  readonly maxConnections?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpoint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpoint(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
 * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
 * If unspecified, an implementation defined default is applied (32768 bytes).
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note: that when the suffix is not provided, the value is interpreted as bytes.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionBufferLimit
 */
export class EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionBufferLimit {
  public static fromNumber(value: number): EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionBufferLimit {
    return new EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionBufferLimit(value);
  }
  public static fromString(value: string): EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionBufferLimit {
    return new EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionBufferLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Preconnect configures proactive upstream connections to reduce latency by establishing
 * connections before they’re needed and avoiding connection establishment overhead.
 *
 * If unset, Envoy will fetch connections as needed to serve in-flight requests.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionPreconnect
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionPreconnect {
  /**
   * PerEndpointPercent configures how many additional connections to maintain per
   * upstream endpoint, useful for high-QPS or latency sensitive services. Expressed as a
   * percentage of the connections required by active streams
   * (e.g. 100 = preconnect disabled, 105 = 1.05x connections per-endpoint, 200 = 2.00×).
   *
   * Allowed value range is between 100-300. When both PerEndpointPercent and
   * PredictivePercent are set, Envoy ensures both are satisfied (max of the two).
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionPreconnect#perEndpointPercent
   */
  readonly perEndpointPercent?: number;

  /**
   * PredictivePercent configures how many additional connections to maintain
   * across the cluster by anticipating which upstream endpoint the load balancer
   * will select next, useful for low-QPS services. Relies on deterministic
   * loadbalancing and is only supported with Random or RoundRobin.
   * Expressed as a percentage of the connections required by active streams
   * (e.g. 100 = 1.0 (no preconnect), 105 = 1.05× connections across the cluster, 200 = 2.00×).
   *
   * Minimum allowed value is 100. When both PerEndpointPercent and PredictivePercent are
   * set Envoy ensures both are satisfied per host (max of the two).
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionPreconnect#predictivePercent
   */
  readonly predictivePercent?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionPreconnect' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionPreconnect(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionPreconnect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'perEndpointPercent': obj.perEndpointPercent,
    'predictivePercent': obj.predictivePercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
 * to backend.
 * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note that when the suffix is not provided, the value is interpreted as bytes.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionSocketBufferLimit
 */
export class EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionSocketBufferLimit {
  public static fromNumber(value: number): EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionSocketBufferLimit {
    return new EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionSocketBufferLimit(value);
  }
  public static fromString(value: string): EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionSocketBufferLimit {
    return new EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionSocketBufferLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
 * If set, this configuration overrides other defaults.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsDnsLookupFamily
 */
export enum EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsDnsLookupFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
  /** IPv4Preferred */
  I_PV4_PREFERRED = "IPv4Preferred",
  /** IPv6Preferred */
  I_PV6_PREFERRED = "IPv6Preferred",
  /** IPv4AndIPv6 */
  I_PV4_AND_I_PV6 = "IPv4AndIPv6",
}

/**
 * Active health check configuration
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActive
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActive {
  /**
   * GRPC defines the configuration of the GRPC health checker.
   * It's optional, and can only be used if the specified type is GRPC.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActive#grpc
   */
  readonly grpc?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpc;

  /**
   * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActive#healthyThreshold
   */
  readonly healthyThreshold?: number;

  /**
   * HTTP defines the configuration of http health checker.
   * It's required while the health checker type is HTTP.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActive#http
   */
  readonly http?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp;

  /**
   * InitialJitter defines the maximum time Envoy will wait before the first health check.
   * Envoy will randomly select a value between 0 and the initial jitter value.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActive#initialJitter
   */
  readonly initialJitter?: string;

  /**
   * Interval defines the time between active health checks.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActive#interval
   */
  readonly interval?: string;

  /**
   * TCP defines the configuration of tcp health checker.
   * It's required while the health checker type is TCP.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActive#tcp
   */
  readonly tcp?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp;

  /**
   * Timeout defines the time to wait for a health check response.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActive#timeout
   */
  readonly timeout?: string;

  /**
   * Type defines the type of health checker.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActive#type
   */
  readonly type: string;

  /**
   * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActive#unhealthyThreshold
   */
  readonly unhealthyThreshold?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActive(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpc': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpc(obj.grpc),
    'healthyThreshold': obj.healthyThreshold,
    'http': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp(obj.http),
    'initialJitter': obj.initialJitter,
    'interval': obj.interval,
    'tcp': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp(obj.tcp),
    'timeout': obj.timeout,
    'type': obj.type,
    'unhealthyThreshold': obj.unhealthyThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Passive passive check configuration
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckPassive
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckPassive {
  /**
   * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckPassive#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckPassive#consecutive5XxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckPassive#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
   * Parameter takes effect only when split_external_local_origin_errors is set to true.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckPassive#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * FailurePercentageThreshold sets the failure percentage threshold for outlier detection.
   * If the failure percentage of a given host is greater than or equal to this value, it will be ejected.
   * Defaults to 85.
   *
   * @default 85.
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckPassive#failurePercentageThreshold
   */
  readonly failurePercentageThreshold?: number;

  /**
   * Interval defines the time between passive health checks.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckPassive#interval
   */
  readonly interval?: string;

  /**
   * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckPassive#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckPassive#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckPassive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckPassive(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckPassive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5XxErrors': obj.consecutive5XxErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'failurePercentageThreshold': obj.failurePercentageThreshold,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
 * If not set, the default value is 1 MiB.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2InitialConnectionWindowSize
 */
export class EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2InitialConnectionWindowSize {
  public static fromNumber(value: number): EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2InitialConnectionWindowSize {
    return new EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2InitialConnectionWindowSize(value);
  }
  public static fromString(value: string): EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2InitialConnectionWindowSize {
    return new EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2InitialConnectionWindowSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
 * If not set, the default value is 64 KiB(64*1024).
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2InitialStreamWindowSize
 */
export class EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2InitialStreamWindowSize {
  public static fromNumber(value: number): EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2InitialStreamWindowSize {
    return new EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2InitialStreamWindowSize(value);
  }
  public static fromString(value: string): EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2InitialStreamWindowSize {
    return new EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2InitialStreamWindowSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ConsistentHash defines the configuration when the load balancer type is
 * set to ConsistentHash
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash {
  /**
   * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash#cookie
   */
  readonly cookie?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie;

  /**
   * Header configures the header hash policy when the consistent hash type is set to Header.
   *
   * Deprecated: use Headers instead
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash#header
   */
  readonly header?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeader;

  /**
   * Headers configures the header hash policy for each header, when the consistent hash type is set to Headers.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash#headers
   */
  readonly headers?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeaders[];

  /**
   * The table size for consistent hashing, must be prime number limited to 5000011.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash#tableSize
   */
  readonly tableSize?: number;

  /**
   * ConsistentHashType defines the type of input to hash on. Valid Type values are
   * "SourceIP",
   * "Header",
   * "Headers",
   * "Cookie".
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash#type
   */
  readonly type: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashType;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookie': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie(obj.cookie),
    'header': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeader(obj.header),
    'headers': obj.headers?.map(y => toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeaders(y)),
    'tableSize': obj.tableSize,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EndpointOverride defines the configuration for endpoint override.
 * When specified, the load balancer will attempt to route requests to endpoints
 * based on the override information extracted from request headers or metadata.
 * If the override endpoints are not available, the configured load balancer policy will be used as fallback.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverride
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverride {
  /**
   * ExtractFrom defines the sources to extract endpoint override information from.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverride#extractFrom
   */
  readonly extractFrom: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFrom[];
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverride' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverride(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverride | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extractFrom': obj.extractFrom?.map(y => toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFrom(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SlowStart defines the configuration related to the slow start load balancer policy.
 * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
 * Currently this is only supported for RoundRobin and LeastRequest load balancers
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStart
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStart {
  /**
   * Window defines the duration of the warm up period for newly added host.
   * During slow start window, traffic sent to the newly added hosts will gradually increase.
   * Currently only supports linear growth of traffic. For additional details,
   * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStart#window
   */
  readonly window: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStart(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'window': obj.window,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type decides the type of Load Balancer policy.
 * Valid LoadBalancerType values are
 * "ConsistentHash",
 * "LeastRequest",
 * "Random",
 * "RoundRobin".
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerType
 */
export enum EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerType {
  /** ConsistentHash */
  CONSISTENT_HASH = "ConsistentHash",
  /** LeastRequest */
  LEAST_REQUEST = "LeastRequest",
  /** Random */
  RANDOM = "Random",
  /** RoundRobin */
  ROUND_ROBIN = "RoundRobin",
}

/**
 * ZoneAware defines the configuration related to the distribution of requests between locality zones.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAware
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAware {
  /**
   * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAware#preferLocal
   */
  readonly preferLocal?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAware' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAware(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAware | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferLocal': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal(obj.preferLocal),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Version of ProxyProtol
 * Valid ProxyProtocolVersion values are
 * "V1"
 * "V2"
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsProxyProtocolVersion
 */
export enum EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsProxyProtocolVersion {
  /** V1 */
  V1 = "V1",
  /** V2 */
  V2 = "V2",
}

/**
 * PerRetry is the retry policy to be applied per retry attempt.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetry
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetry {
  /**
   * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
   * back-off algorithm for retries. For additional details,
   * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetry#backOff
   */
  readonly backOff?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff;

  /**
   * Timeout is the timeout per retry attempt.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetry#timeout
   */
  readonly timeout?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetry(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backOff': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff(obj.backOff),
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RetryOn specifies the retry trigger condition.
 *
 * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryRetryOn
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryRetryOn {
  /**
   * HttpStatusCodes specifies the http status codes to be retried.
   * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryRetryOn#httpStatusCodes
   */
  readonly httpStatusCodes?: number[];

  /**
   * Triggers specifies the retry trigger condition(Http/Grpc).
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryRetryOn#triggers
   */
  readonly triggers?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryRetryOnTriggers[];
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryRetryOn' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryRetryOn(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryRetryOn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpStatusCodes': obj.httpStatusCodes?.map(y => y),
    'triggers': obj.triggers?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for HTTP.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutHttp
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutHttp {
  /**
   * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
   * Default: 1 hour.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutHttp#connectionIdleTimeout
   */
  readonly connectionIdleTimeout?: string;

  /**
   * The maximum duration of an HTTP connection.
   * Default: unlimited.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutHttp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * MaxStreamDuration is the maximum duration for a stream to complete. This timeout measures the time
   * from when the request is sent until the response stream is fully consumed and does not apply to
   * non-streaming requests.
   * When set to "0s", no max duration is applied and streams can run indefinitely.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutHttp#maxStreamDuration
   */
  readonly maxStreamDuration?: string;

  /**
   * RequestTimeout is the time until which entire response is received from the upstream.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutHttp#requestTimeout
   */
  readonly requestTimeout?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutHttp(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionIdleTimeout': obj.connectionIdleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxStreamDuration': obj.maxStreamDuration,
    'requestTimeout': obj.requestTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for TCP.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutTcp
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutTcp {
  /**
   * The timeout for network connection establishment, including TCP and TLS handshakes.
   * Default: 10 seconds.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutTcp#connectTimeout
   */
  readonly connectTimeout?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutTcp(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC defines the configuration of the GRPC health checker.
 * It's optional, and can only be used if the specified type is GRPC.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpc
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpc {
  /**
   * Service to send in the health check request.
   * If this is not specified, then the health check request applies to the entire
   * server and not to a specific service.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpc(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP defines the configuration of http health checker.
 * It's required while the health checker type is HTTP.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp {
  /**
   * ExpectedResponse defines a list of HTTP expected responses to match.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp#expectedResponse
   */
  readonly expectedResponse?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse;

  /**
   * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
   * Defaults to 200 only
   *
   * @default 200 only
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp#expectedStatuses
   */
  readonly expectedStatuses?: number[];

  /**
   * Hostname defines the HTTP host that will be requested during health checking.
   * Default: HTTPRoute or GRPCRoute hostname.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp#hostname
   */
  readonly hostname?: string;

  /**
   * Method defines the HTTP method used for health checking.
   * Defaults to GET
   *
   * @default GET
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp#method
   */
  readonly method?: string;

  /**
   * Path defines the HTTP path that will be requested during health checking.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expectedResponse': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse(obj.expectedResponse),
    'expectedStatuses': obj.expectedStatuses?.map(y => y),
    'hostname': obj.hostname,
    'method': obj.method,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCP defines the configuration of tcp health checker.
 * It's required while the health checker type is TCP.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp {
  /**
   * Receive defines the expected response payload.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp#receive
   */
  readonly receive?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive;

  /**
   * Send defines the request payload.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp#send
   */
  readonly send?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'receive': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive(obj.receive),
    'send': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend(obj.send),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie {
  /**
   * Additional Attributes to set for the generated cookie.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie#attributes
   */
  readonly attributes?: { [key: string]: string };

  /**
   * Name of the cookie to hash.
   * If this cookie does not exist in the request, Envoy will generate a cookie and set
   * the TTL on the response back to the client based on Layer 4
   * attributes of the backend endpoint, to ensure that these future requests
   * go to the same backend endpoint. Make sure to set the TTL field for this case.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie#name
   */
  readonly name: string;

  /**
   * TTL of the generated cookie if the cookie is not present. This value sets the
   * Max-Age attribute value.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie#ttl
   */
  readonly ttl?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributes': ((obj.attributes) === undefined) ? undefined : (Object.entries(obj.attributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Header configures the header hash policy when the consistent hash type is set to Header.
 *
 * Deprecated: use Headers instead
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeader
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeader {
  /**
   * Name of the header to hash.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeader#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeader' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeader(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Header defines the header hashing configuration for consistent hash based
 * load balancing.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeaders
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeaders {
  /**
   * Name of the header to hash.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeaders#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeaders(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConsistentHashType defines the type of input to hash on. Valid Type values are
 * "SourceIP",
 * "Header",
 * "Headers",
 * "Cookie".
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashType
 */
export enum EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashType {
  /** SourceIP */
  SOURCE_IP = "SourceIP",
  /** Header */
  HEADER = "Header",
  /** Headers */
  HEADERS = "Headers",
  /** Cookie */
  COOKIE = "Cookie",
}

/**
 * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFrom
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFrom {
  /**
   * Header defines the header to get the override endpoint addresses.
   * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
   * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
   * The IPv6 address is enclosed in square brackets.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFrom#header
   */
  readonly header?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFrom(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': obj.header,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal {
  /**
   * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
   * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal#force
   */
  readonly force?: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForce;

  /**
   * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal#minEndpointsThreshold
   */
  readonly minEndpointsThreshold?: number;

  /**
   * Configures percentage of requests that will be considered for zone aware routing if zone aware routing is configured. If not specified, Envoy defaults to 100%.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal#percentageEnabled
   */
  readonly percentageEnabled?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'force': toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForce(obj.force),
    'minEndpointsThreshold': obj.minEndpointsThreshold,
    'percentageEnabled': obj.percentageEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
 * back-off algorithm for retries. For additional details,
 * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff {
  /**
   * BaseInterval is the base interval between retries.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff#baseInterval
   */
  readonly baseInterval?: string;

  /**
   * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
   * The default is 10 times the base_interval
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff#maxInterval
   */
  readonly maxInterval?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseInterval': obj.baseInterval,
    'maxInterval': obj.maxInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TriggerEnum specifies the conditions that trigger retries.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryRetryOnTriggers
 */
export enum EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryRetryOnTriggers {
  /** 5xx */
  VALUE_5XX = "5xx",
  /** gateway-error */
  GATEWAY_HYPHEN_ERROR = "gateway-error",
  /** reset */
  RESET = "reset",
  /** reset-before-request */
  RESET_HYPHEN_BEFORE_HYPHEN_REQUEST = "reset-before-request",
  /** connect-failure */
  CONNECT_HYPHEN_FAILURE = "connect-failure",
  /** retriable-4xx */
  RETRIABLE_HYPHEN_4XX = "retriable-4xx",
  /** refused-stream */
  REFUSED_HYPHEN_STREAM = "refused-stream",
  /** retriable-status-codes */
  RETRIABLE_HYPHEN_STATUS_HYPHEN_CODES = "retriable-status-codes",
  /** cancelled */
  CANCELLED = "cancelled",
  /** deadline-exceeded */
  DEADLINE_HYPHEN_EXCEEDED = "deadline-exceeded",
  /** internal */
  INTERNAL = "internal",
  /** resource-exhausted */
  RESOURCE_HYPHEN_EXHAUSTED = "resource-exhausted",
  /** unavailable */
  UNAVAILABLE = "unavailable",
}

/**
 * ExpectedResponse defines a list of HTTP expected responses to match.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttpExpectedResponse
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttpExpectedResponse {
  /**
   * Binary payload base64 encoded.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttpExpectedResponse#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttpExpectedResponse#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttpExpectedResponse#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttpExpectedResponse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttpExpectedResponse(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttpExpectedResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Receive defines the expected response payload.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpReceive
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpReceive {
  /**
   * Binary payload base64 encoded.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpReceive#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpReceive#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpReceive#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpReceive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpReceive(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpReceive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Send defines the request payload.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpSend
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpSend {
  /**
   * Binary payload base64 encoded.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpSend#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpSend#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpSend#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpSend' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpSend(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpSend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
 * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
 *
 * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForce
 */
export interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForce {
  /**
   * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
   * override. This is useful for protecting zones with fewer endpoints.
   *
   * @schema EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForce#minEndpointsInZoneThreshold
   */
  readonly minEndpointsInZoneThreshold?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForce' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForce(obj: EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForce | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minEndpointsInZoneThreshold': obj.minEndpointsInZoneThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResources(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Select all ClusterTrustBundles that match this label selector.  Only has
 * effect if signerName is set.  Mutually-exclusive with name.  If unset,
 * interpreted as "match nothing".  If set but empty, interpreted as "match
 * everything".
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMapItems
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMapItems(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItems
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItems(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecretItems
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecretItems(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResources(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Select all ClusterTrustBundles that match this label selector.  Only has
 * effect if signerName is set.  Mutually-exclusive with name.  If unset,
 * interpreted as "match nothing".  If set but empty, interpreted as "match
 * everything".
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelector
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelector(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMapItems
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMapItems(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItems
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItems(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecretItems
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecretItems(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC defines the configuration of the GRPC health checker.
 * It's optional, and can only be used if the specified type is GRPC.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveGrpc
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveGrpc {
  /**
   * Service to send in the health check request.
   * If this is not specified, then the health check request applies to the entire
   * server and not to a specific service.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveGrpc(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP defines the configuration of http health checker.
 * It's required while the health checker type is HTTP.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttp
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttp {
  /**
   * ExpectedResponse defines a list of HTTP expected responses to match.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttp#expectedResponse
   */
  readonly expectedResponse?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttpExpectedResponse;

  /**
   * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
   * Defaults to 200 only
   *
   * @default 200 only
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttp#expectedStatuses
   */
  readonly expectedStatuses?: number[];

  /**
   * Hostname defines the HTTP host that will be requested during health checking.
   * Default: HTTPRoute or GRPCRoute hostname.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttp#hostname
   */
  readonly hostname?: string;

  /**
   * Method defines the HTTP method used for health checking.
   * Defaults to GET
   *
   * @default GET
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttp#method
   */
  readonly method?: string;

  /**
   * Path defines the HTTP path that will be requested during health checking.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttp#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttp(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expectedResponse': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttpExpectedResponse(obj.expectedResponse),
    'expectedStatuses': obj.expectedStatuses?.map(y => y),
    'hostname': obj.hostname,
    'method': obj.method,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCP defines the configuration of tcp health checker.
 * It's required while the health checker type is TCP.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcp
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcp {
  /**
   * Receive defines the expected response payload.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcp#receive
   */
  readonly receive?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpReceive;

  /**
   * Send defines the request payload.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcp#send
   */
  readonly send?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpSend;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcp(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'receive': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpReceive(obj.receive),
    'send': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpSend(obj.send),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashCookie
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashCookie {
  /**
   * Additional Attributes to set for the generated cookie.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashCookie#attributes
   */
  readonly attributes?: { [key: string]: string };

  /**
   * Name of the cookie to hash.
   * If this cookie does not exist in the request, Envoy will generate a cookie and set
   * the TTL on the response back to the client based on Layer 4
   * attributes of the backend endpoint, to ensure that these future requests
   * go to the same backend endpoint. Make sure to set the TTL field for this case.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashCookie#name
   */
  readonly name: string;

  /**
   * TTL of the generated cookie if the cookie is not present. This value sets the
   * Max-Age attribute value.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashCookie#ttl
   */
  readonly ttl?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashCookie' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashCookie(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributes': ((obj.attributes) === undefined) ? undefined : (Object.entries(obj.attributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Header configures the header hash policy when the consistent hash type is set to Header.
 *
 * Deprecated: use Headers instead
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashHeader
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashHeader {
  /**
   * Name of the header to hash.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashHeader#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashHeader' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashHeader(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Header defines the header hashing configuration for consistent hash based
 * load balancing.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashHeaders
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashHeaders {
  /**
   * Name of the header to hash.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashHeaders#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashHeaders(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConsistentHashType defines the type of input to hash on. Valid Type values are
 * "SourceIP",
 * "Header",
 * "Headers",
 * "Cookie".
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashType
 */
export enum EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashType {
  /** SourceIP */
  SOURCE_IP = "SourceIP",
  /** Header */
  HEADER = "Header",
  /** Headers */
  HEADERS = "Headers",
  /** Cookie */
  COOKIE = "Cookie",
}

/**
 * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverrideExtractFrom
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverrideExtractFrom {
  /**
   * Header defines the header to get the override endpoint addresses.
   * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
   * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
   * The IPv6 address is enclosed in square brackets.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverrideExtractFrom#header
   */
  readonly header?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverrideExtractFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverrideExtractFrom(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverrideExtractFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': obj.header,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocal
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocal {
  /**
   * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
   * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocal#force
   */
  readonly force?: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocalForce;

  /**
   * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocal#minEndpointsThreshold
   */
  readonly minEndpointsThreshold?: number;

  /**
   * Configures percentage of requests that will be considered for zone aware routing if zone aware routing is configured. If not specified, Envoy defaults to 100%.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocal#percentageEnabled
   */
  readonly percentageEnabled?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocal' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocal(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'force': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocalForce(obj.force),
    'minEndpointsThreshold': obj.minEndpointsThreshold,
    'percentageEnabled': obj.percentageEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
 * back-off algorithm for retries. For additional details,
 * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetryBackOff
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetryBackOff {
  /**
   * BaseInterval is the base interval between retries.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetryBackOff#baseInterval
   */
  readonly baseInterval?: string;

  /**
   * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
   * The default is 10 times the base_interval
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetryBackOff#maxInterval
   */
  readonly maxInterval?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetryBackOff' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetryBackOff(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetryBackOff | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseInterval': obj.baseInterval,
    'maxInterval': obj.maxInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TriggerEnum specifies the conditions that trigger retries.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryRetryOnTriggers
 */
export enum EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryRetryOnTriggers {
  /** 5xx */
  VALUE_5XX = "5xx",
  /** gateway-error */
  GATEWAY_HYPHEN_ERROR = "gateway-error",
  /** reset */
  RESET = "reset",
  /** reset-before-request */
  RESET_HYPHEN_BEFORE_HYPHEN_REQUEST = "reset-before-request",
  /** connect-failure */
  CONNECT_HYPHEN_FAILURE = "connect-failure",
  /** retriable-4xx */
  RETRIABLE_HYPHEN_4XX = "retriable-4xx",
  /** refused-stream */
  REFUSED_HYPHEN_STREAM = "refused-stream",
  /** retriable-status-codes */
  RETRIABLE_HYPHEN_STATUS_HYPHEN_CODES = "retriable-status-codes",
  /** cancelled */
  CANCELLED = "cancelled",
  /** deadline-exceeded */
  DEADLINE_HYPHEN_EXCEEDED = "deadline-exceeded",
  /** internal */
  INTERNAL = "internal",
  /** resource-exhausted */
  RESOURCE_HYPHEN_EXHAUSTED = "resource-exhausted",
  /** unavailable */
  UNAVAILABLE = "unavailable",
}

/**
 * GRPC defines the configuration of the GRPC health checker.
 * It's optional, and can only be used if the specified type is GRPC.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpc
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpc {
  /**
   * Service to send in the health check request.
   * If this is not specified, then the health check request applies to the entire
   * server and not to a specific service.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpc(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP defines the configuration of http health checker.
 * It's required while the health checker type is HTTP.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp {
  /**
   * ExpectedResponse defines a list of HTTP expected responses to match.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp#expectedResponse
   */
  readonly expectedResponse?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse;

  /**
   * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
   * Defaults to 200 only
   *
   * @default 200 only
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp#expectedStatuses
   */
  readonly expectedStatuses?: number[];

  /**
   * Hostname defines the HTTP host that will be requested during health checking.
   * Default: HTTPRoute or GRPCRoute hostname.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp#hostname
   */
  readonly hostname?: string;

  /**
   * Method defines the HTTP method used for health checking.
   * Defaults to GET
   *
   * @default GET
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp#method
   */
  readonly method?: string;

  /**
   * Path defines the HTTP path that will be requested during health checking.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expectedResponse': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse(obj.expectedResponse),
    'expectedStatuses': obj.expectedStatuses?.map(y => y),
    'hostname': obj.hostname,
    'method': obj.method,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCP defines the configuration of tcp health checker.
 * It's required while the health checker type is TCP.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp {
  /**
   * Receive defines the expected response payload.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp#receive
   */
  readonly receive?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive;

  /**
   * Send defines the request payload.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp#send
   */
  readonly send?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'receive': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive(obj.receive),
    'send': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend(obj.send),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie {
  /**
   * Additional Attributes to set for the generated cookie.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie#attributes
   */
  readonly attributes?: { [key: string]: string };

  /**
   * Name of the cookie to hash.
   * If this cookie does not exist in the request, Envoy will generate a cookie and set
   * the TTL on the response back to the client based on Layer 4
   * attributes of the backend endpoint, to ensure that these future requests
   * go to the same backend endpoint. Make sure to set the TTL field for this case.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie#name
   */
  readonly name: string;

  /**
   * TTL of the generated cookie if the cookie is not present. This value sets the
   * Max-Age attribute value.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie#ttl
   */
  readonly ttl?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributes': ((obj.attributes) === undefined) ? undefined : (Object.entries(obj.attributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Header configures the header hash policy when the consistent hash type is set to Header.
 *
 * Deprecated: use Headers instead
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeader
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeader {
  /**
   * Name of the header to hash.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeader#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeader' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeader(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Header defines the header hashing configuration for consistent hash based
 * load balancing.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeaders
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeaders {
  /**
   * Name of the header to hash.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeaders#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeaders(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConsistentHashType defines the type of input to hash on. Valid Type values are
 * "SourceIP",
 * "Header",
 * "Headers",
 * "Cookie".
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashType
 */
export enum EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashType {
  /** SourceIP */
  SOURCE_IP = "SourceIP",
  /** Header */
  HEADER = "Header",
  /** Headers */
  HEADERS = "Headers",
  /** Cookie */
  COOKIE = "Cookie",
}

/**
 * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFrom
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFrom {
  /**
   * Header defines the header to get the override endpoint addresses.
   * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
   * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
   * The IPv6 address is enclosed in square brackets.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFrom#header
   */
  readonly header?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFrom(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': obj.header,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal {
  /**
   * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
   * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal#force
   */
  readonly force?: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForce;

  /**
   * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal#minEndpointsThreshold
   */
  readonly minEndpointsThreshold?: number;

  /**
   * Configures percentage of requests that will be considered for zone aware routing if zone aware routing is configured. If not specified, Envoy defaults to 100%.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal#percentageEnabled
   */
  readonly percentageEnabled?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'force': toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForce(obj.force),
    'minEndpointsThreshold': obj.minEndpointsThreshold,
    'percentageEnabled': obj.percentageEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
 * back-off algorithm for retries. For additional details,
 * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff {
  /**
   * BaseInterval is the base interval between retries.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff#baseInterval
   */
  readonly baseInterval?: string;

  /**
   * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
   * The default is 10 times the base_interval
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff#maxInterval
   */
  readonly maxInterval?: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseInterval': obj.baseInterval,
    'maxInterval': obj.maxInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TriggerEnum specifies the conditions that trigger retries.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryRetryOnTriggers
 */
export enum EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryRetryOnTriggers {
  /** 5xx */
  VALUE_5XX = "5xx",
  /** gateway-error */
  GATEWAY_HYPHEN_ERROR = "gateway-error",
  /** reset */
  RESET = "reset",
  /** reset-before-request */
  RESET_HYPHEN_BEFORE_HYPHEN_REQUEST = "reset-before-request",
  /** connect-failure */
  CONNECT_HYPHEN_FAILURE = "connect-failure",
  /** retriable-4xx */
  RETRIABLE_HYPHEN_4XX = "retriable-4xx",
  /** refused-stream */
  REFUSED_HYPHEN_STREAM = "refused-stream",
  /** retriable-status-codes */
  RETRIABLE_HYPHEN_STATUS_HYPHEN_CODES = "retriable-status-codes",
  /** cancelled */
  CANCELLED = "cancelled",
  /** deadline-exceeded */
  DEADLINE_HYPHEN_EXCEEDED = "deadline-exceeded",
  /** internal */
  INTERNAL = "internal",
  /** resource-exhausted */
  RESOURCE_HYPHEN_EXHAUSTED = "resource-exhausted",
  /** unavailable */
  UNAVAILABLE = "unavailable",
}

/**
 * ExpectedResponse defines a list of HTTP expected responses to match.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse {
  /**
   * Binary payload base64 encoded.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Receive defines the expected response payload.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive {
  /**
   * Binary payload base64 encoded.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Send defines the request payload.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend {
  /**
   * Binary payload base64 encoded.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
 * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
 *
 * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForce
 */
export interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForce {
  /**
   * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
   * override. This is useful for protecting zones with fewer endpoints.
   *
   * @schema EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForce#minEndpointsInZoneThreshold
   */
  readonly minEndpointsInZoneThreshold?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForce' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForce(obj: EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForce | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minEndpointsInZoneThreshold': obj.minEndpointsInZoneThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsFieldRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsFieldRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj: EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExpectedResponse defines a list of HTTP expected responses to match.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttpExpectedResponse
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttpExpectedResponse {
  /**
   * Binary payload base64 encoded.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttpExpectedResponse#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttpExpectedResponse#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttpExpectedResponse#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttpExpectedResponse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttpExpectedResponse(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttpExpectedResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Receive defines the expected response payload.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpReceive
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpReceive {
  /**
   * Binary payload base64 encoded.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpReceive#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpReceive#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpReceive#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpReceive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpReceive(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpReceive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Send defines the request payload.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpSend
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpSend {
  /**
   * Binary payload base64 encoded.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpSend#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpSend#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpSend#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpSend' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpSend(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpSend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
 * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocalForce
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocalForce {
  /**
   * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
   * override. This is useful for protecting zones with fewer endpoints.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocalForce#minEndpointsInZoneThreshold
   */
  readonly minEndpointsInZoneThreshold?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocalForce' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocalForce(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocalForce | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minEndpointsInZoneThreshold': obj.minEndpointsInZoneThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExpectedResponse defines a list of HTTP expected responses to match.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse {
  /**
   * Binary payload base64 encoded.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Receive defines the expected response payload.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive {
  /**
   * Binary payload base64 encoded.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Send defines the request payload.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend {
  /**
   * Binary payload base64 encoded.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
 * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
 *
 * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForce
 */
export interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForce {
  /**
   * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
   * override. This is useful for protecting zones with fewer endpoints.
   *
   * @schema EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForce#minEndpointsInZoneThreshold
   */
  readonly minEndpointsInZoneThreshold?: number;
}

/**
 * Converts an object of type 'EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForce' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForce(obj: EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForce | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minEndpointsInZoneThreshold': obj.minEndpointsInZoneThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}


/**
 * HTTPRouteFilter is a custom Envoy Gateway HTTPRouteFilter which provides extended
traffic processing options such as path regex rewrite, direct response and more.
 *
 * @schema HTTPRouteFilter
 */
export class HttpRouteFilter extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HTTPRouteFilter"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'gateway.envoyproxy.io/v1alpha1',
    kind: 'HTTPRouteFilter',
  }

  /**
   * Renders a Kubernetes manifest for "HTTPRouteFilter".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HttpRouteFilterProps): any {
    return {
      ...HttpRouteFilter.GVK,
      ...toJson_HttpRouteFilterProps(props),
    };
  }

  /**
   * Defines a "HTTPRouteFilter" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HttpRouteFilterProps) {
    super(scope, id, {
      ...HttpRouteFilter.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...HttpRouteFilter.GVK,
      ...toJson_HttpRouteFilterProps(resolved),
    };
  }
}

/**
 * HTTPRouteFilter is a custom Envoy Gateway HTTPRouteFilter which provides extended
 * traffic processing options such as path regex rewrite, direct response and more.
 *
 * @schema HTTPRouteFilter
 */
export interface HttpRouteFilterProps {
  /**
   * @schema HTTPRouteFilter#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec defines the desired state of HTTPRouteFilter.
   *
   * @schema HTTPRouteFilter#spec
   */
  readonly spec: HttpRouteFilterSpec;
}

/**
 * Converts an object of type 'HttpRouteFilterProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteFilterProps(obj: HttpRouteFilterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HttpRouteFilterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec defines the desired state of HTTPRouteFilter.
 *
 * @schema HttpRouteFilterSpec
 */
export interface HttpRouteFilterSpec {
  /**
   * HTTPCredentialInjectionFilter defines the configuration to inject credentials into the request.
   * This is useful when the backend service requires credentials in the request, and the original
   * request does not contain them. The filter can inject credentials into the request before forwarding
   * it to the backend service.
   *
   * @schema HttpRouteFilterSpec#credentialInjection
   */
  readonly credentialInjection?: HttpRouteFilterSpecCredentialInjection;

  /**
   * HTTPDirectResponseFilter defines the configuration to return a fixed response.
   *
   * @schema HttpRouteFilterSpec#directResponse
   */
  readonly directResponse?: HttpRouteFilterSpecDirectResponse;

  /**
   * HTTPURLRewriteFilter define rewrites of HTTP URL components such as path and host
   *
   * @schema HttpRouteFilterSpec#urlRewrite
   */
  readonly urlRewrite?: HttpRouteFilterSpecUrlRewrite;
}

/**
 * Converts an object of type 'HttpRouteFilterSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteFilterSpec(obj: HttpRouteFilterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentialInjection': toJson_HttpRouteFilterSpecCredentialInjection(obj.credentialInjection),
    'directResponse': toJson_HttpRouteFilterSpecDirectResponse(obj.directResponse),
    'urlRewrite': toJson_HttpRouteFilterSpecUrlRewrite(obj.urlRewrite),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPCredentialInjectionFilter defines the configuration to inject credentials into the request.
 * This is useful when the backend service requires credentials in the request, and the original
 * request does not contain them. The filter can inject credentials into the request before forwarding
 * it to the backend service.
 *
 * @schema HttpRouteFilterSpecCredentialInjection
 */
export interface HttpRouteFilterSpecCredentialInjection {
  /**
   * Credential is the credential to be injected.
   *
   * @schema HttpRouteFilterSpecCredentialInjection#credential
   */
  readonly credential: HttpRouteFilterSpecCredentialInjectionCredential;

  /**
   * Header is the name of the header where the credentials are injected.
   * If not specified, the credentials are injected into the Authorization header.
   *
   * @schema HttpRouteFilterSpecCredentialInjection#header
   */
  readonly header?: string;

  /**
   * Whether to overwrite the value or not if the injected headers already exist.
   * If not specified, the default value is false.
   *
   * @schema HttpRouteFilterSpecCredentialInjection#overwrite
   */
  readonly overwrite?: boolean;
}

/**
 * Converts an object of type 'HttpRouteFilterSpecCredentialInjection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteFilterSpecCredentialInjection(obj: HttpRouteFilterSpecCredentialInjection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credential': toJson_HttpRouteFilterSpecCredentialInjectionCredential(obj.credential),
    'header': obj.header,
    'overwrite': obj.overwrite,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPDirectResponseFilter defines the configuration to return a fixed response.
 *
 * @schema HttpRouteFilterSpecDirectResponse
 */
export interface HttpRouteFilterSpecDirectResponse {
  /**
   * Body of the direct response.
   *
   * @schema HttpRouteFilterSpecDirectResponse#body
   */
  readonly body?: HttpRouteFilterSpecDirectResponseBody;

  /**
   * Content Type of the direct response. This will be set in the Content-Type header.
   *
   * @schema HttpRouteFilterSpecDirectResponse#contentType
   */
  readonly contentType?: string;

  /**
   * Header defines the headers of the direct response.
   *
   * @schema HttpRouteFilterSpecDirectResponse#header
   */
  readonly header?: HttpRouteFilterSpecDirectResponseHeader;

  /**
   * Status Code of the HTTP response
   * If unset, defaults to 200.
   *
   * @schema HttpRouteFilterSpecDirectResponse#statusCode
   */
  readonly statusCode?: number;
}

/**
 * Converts an object of type 'HttpRouteFilterSpecDirectResponse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteFilterSpecDirectResponse(obj: HttpRouteFilterSpecDirectResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': toJson_HttpRouteFilterSpecDirectResponseBody(obj.body),
    'contentType': obj.contentType,
    'header': toJson_HttpRouteFilterSpecDirectResponseHeader(obj.header),
    'statusCode': obj.statusCode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPURLRewriteFilter define rewrites of HTTP URL components such as path and host
 *
 * @schema HttpRouteFilterSpecUrlRewrite
 */
export interface HttpRouteFilterSpecUrlRewrite {
  /**
   * Hostname is the value to be used to replace the Host header value during
   * forwarding.
   *
   * @schema HttpRouteFilterSpecUrlRewrite#hostname
   */
  readonly hostname?: HttpRouteFilterSpecUrlRewriteHostname;

  /**
   * Path defines a path rewrite.
   *
   * @schema HttpRouteFilterSpecUrlRewrite#path
   */
  readonly path?: HttpRouteFilterSpecUrlRewritePath;
}

/**
 * Converts an object of type 'HttpRouteFilterSpecUrlRewrite' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteFilterSpecUrlRewrite(obj: HttpRouteFilterSpecUrlRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostname': toJson_HttpRouteFilterSpecUrlRewriteHostname(obj.hostname),
    'path': toJson_HttpRouteFilterSpecUrlRewritePath(obj.path),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Credential is the credential to be injected.
 *
 * @schema HttpRouteFilterSpecCredentialInjectionCredential
 */
export interface HttpRouteFilterSpecCredentialInjectionCredential {
  /**
   * ValueRef is a reference to the secret containing the credentials to be injected.
   * This is an Opaque secret. The credential should be stored in the key
   * "credential", and the value should be the credential to be injected.
   * For example, for basic authentication, the value should be "Basic <base64 encoded username:password>".
   * for bearer token, the value should be "Bearer <token>".
   * Note: The secret must be in the same namespace as the HTTPRouteFilter.
   *
   * @schema HttpRouteFilterSpecCredentialInjectionCredential#valueRef
   */
  readonly valueRef: HttpRouteFilterSpecCredentialInjectionCredentialValueRef;
}

/**
 * Converts an object of type 'HttpRouteFilterSpecCredentialInjectionCredential' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteFilterSpecCredentialInjectionCredential(obj: HttpRouteFilterSpecCredentialInjectionCredential | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'valueRef': toJson_HttpRouteFilterSpecCredentialInjectionCredentialValueRef(obj.valueRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Body of the direct response.
 *
 * @schema HttpRouteFilterSpecDirectResponseBody
 */
export interface HttpRouteFilterSpecDirectResponseBody {
  /**
   * Inline contains the value as an inline string.
   *
   * @schema HttpRouteFilterSpecDirectResponseBody#inline
   */
  readonly inline?: string;

  /**
   * Type is the type of method to use to read the body value.
   * Valid values are Inline and ValueRef, default is Inline.
   *
   * @schema HttpRouteFilterSpecDirectResponseBody#type
   */
  readonly type: string;

  /**
   * ValueRef contains the contents of the body
   * specified as a local object reference.
   * Only a reference to ConfigMap is supported.
   *
   * The value of key `response.body` in the ConfigMap will be used as the response body.
   * If the key is not found, the first value in the ConfigMap will be used.
   *
   * @schema HttpRouteFilterSpecDirectResponseBody#valueRef
   */
  readonly valueRef?: HttpRouteFilterSpecDirectResponseBodyValueRef;
}

/**
 * Converts an object of type 'HttpRouteFilterSpecDirectResponseBody' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteFilterSpecDirectResponseBody(obj: HttpRouteFilterSpecDirectResponseBody | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inline': obj.inline,
    'type': obj.type,
    'valueRef': toJson_HttpRouteFilterSpecDirectResponseBodyValueRef(obj.valueRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Header defines the headers of the direct response.
 *
 * @schema HttpRouteFilterSpecDirectResponseHeader
 */
export interface HttpRouteFilterSpecDirectResponseHeader {
  /**
   * Add adds the given header(s) (name, value) to the request
   * before the action. It appends to any existing values associated
   * with the header name.
   *
   * Input:
   * GET /foo HTTP/1.1
   * my-header: foo
   *
   * Config:
   * add:
   * - name: "my-header"
   * value: "bar,baz"
   *
   * Output:
   * GET /foo HTTP/1.1
   * my-header: foo,bar,baz
   *
   * @schema HttpRouteFilterSpecDirectResponseHeader#add
   */
  readonly add?: HttpRouteFilterSpecDirectResponseHeaderAdd[];

  /**
   * Remove the given header(s) from the HTTP request before the action. The
   * value of Remove is a list of HTTP header names. Note that the header
   * names are case-insensitive (see
   * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
   *
   * Input:
   * GET /foo HTTP/1.1
   * my-header1: foo
   * my-header2: bar
   * my-header3: baz
   *
   * Config:
   * remove: ["my-header1", "my-header3"]
   *
   * Output:
   * GET /foo HTTP/1.1
   * my-header2: bar
   *
   * @schema HttpRouteFilterSpecDirectResponseHeader#remove
   */
  readonly remove?: string[];

  /**
   * Set overwrites the request with the given header (name, value)
   * before the action.
   *
   * Input:
   * GET /foo HTTP/1.1
   * my-header: foo
   *
   * Config:
   * set:
   * - name: "my-header"
   * value: "bar"
   *
   * Output:
   * GET /foo HTTP/1.1
   * my-header: bar
   *
   * @schema HttpRouteFilterSpecDirectResponseHeader#set
   */
  readonly set?: HttpRouteFilterSpecDirectResponseHeaderSet[];
}

/**
 * Converts an object of type 'HttpRouteFilterSpecDirectResponseHeader' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteFilterSpecDirectResponseHeader(obj: HttpRouteFilterSpecDirectResponseHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => toJson_HttpRouteFilterSpecDirectResponseHeaderAdd(y)),
    'remove': obj.remove?.map(y => y),
    'set': obj.set?.map(y => toJson_HttpRouteFilterSpecDirectResponseHeaderSet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Hostname is the value to be used to replace the Host header value during
 * forwarding.
 *
 * @schema HttpRouteFilterSpecUrlRewriteHostname
 */
export interface HttpRouteFilterSpecUrlRewriteHostname {
  /**
   * Header is the name of the header whose value would be used to rewrite the Host header
   *
   * @schema HttpRouteFilterSpecUrlRewriteHostname#header
   */
  readonly header?: string;

  /**
   * HTTPPathModifierType defines the type of Hostname rewrite.
   *
   * @schema HttpRouteFilterSpecUrlRewriteHostname#type
   */
  readonly type: HttpRouteFilterSpecUrlRewriteHostnameType;
}

/**
 * Converts an object of type 'HttpRouteFilterSpecUrlRewriteHostname' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteFilterSpecUrlRewriteHostname(obj: HttpRouteFilterSpecUrlRewriteHostname | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': obj.header,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Path defines a path rewrite.
 *
 * @schema HttpRouteFilterSpecUrlRewritePath
 */
export interface HttpRouteFilterSpecUrlRewritePath {
  /**
   * ReplaceRegexMatch defines a path regex rewrite. The path portions matched by the regex pattern are replaced by the defined substitution.
   * https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/v3/route_components.proto#envoy-v3-api-field-config-route-v3-routeaction-regex-rewrite
   * Some examples:
   * (1) replaceRegexMatch:
   * pattern: ^/service/([^/]+)(/.*)$
   * substitution: \2/instance/\1
   * Would transform /service/foo/v1/api into /v1/api/instance/foo.
   * (2) replaceRegexMatch:
   * pattern: one
   * substitution: two
   * Would transform /xxx/one/yyy/one/zzz into /xxx/two/yyy/two/zzz.
   * (3) replaceRegexMatch:
   * pattern: ^(.*?)one(.*)$
   * substitution: \1two\2
   * Would transform /xxx/one/yyy/one/zzz into /xxx/two/yyy/one/zzz.
   * (3) replaceRegexMatch:
   * pattern: (?i)/xxx/
   * substitution: /yyy/
   * Would transform path /aaa/XxX/bbb into /aaa/yyy/bbb (case-insensitive).
   *
   * @schema HttpRouteFilterSpecUrlRewritePath#replaceRegexMatch
   */
  readonly replaceRegexMatch?: HttpRouteFilterSpecUrlRewritePathReplaceRegexMatch;

  /**
   * HTTPPathModifierType defines the type of path redirect or rewrite.
   *
   * @schema HttpRouteFilterSpecUrlRewritePath#type
   */
  readonly type: HttpRouteFilterSpecUrlRewritePathType;
}

/**
 * Converts an object of type 'HttpRouteFilterSpecUrlRewritePath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteFilterSpecUrlRewritePath(obj: HttpRouteFilterSpecUrlRewritePath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'replaceRegexMatch': toJson_HttpRouteFilterSpecUrlRewritePathReplaceRegexMatch(obj.replaceRegexMatch),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ValueRef is a reference to the secret containing the credentials to be injected.
 * This is an Opaque secret. The credential should be stored in the key
 * "credential", and the value should be the credential to be injected.
 * For example, for basic authentication, the value should be "Basic <base64 encoded username:password>".
 * for bearer token, the value should be "Bearer <token>".
 * Note: The secret must be in the same namespace as the HTTPRouteFilter.
 *
 * @schema HttpRouteFilterSpecCredentialInjectionCredentialValueRef
 */
export interface HttpRouteFilterSpecCredentialInjectionCredentialValueRef {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema HttpRouteFilterSpecCredentialInjectionCredentialValueRef#group
   */
  readonly group?: string;

  /**
   * Kind is kind of the referent. For example "Secret".
   *
   * @schema HttpRouteFilterSpecCredentialInjectionCredentialValueRef#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema HttpRouteFilterSpecCredentialInjectionCredentialValueRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the referenced object. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema HttpRouteFilterSpecCredentialInjectionCredentialValueRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'HttpRouteFilterSpecCredentialInjectionCredentialValueRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteFilterSpecCredentialInjectionCredentialValueRef(obj: HttpRouteFilterSpecCredentialInjectionCredentialValueRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ValueRef contains the contents of the body
 * specified as a local object reference.
 * Only a reference to ConfigMap is supported.
 *
 * The value of key `response.body` in the ConfigMap will be used as the response body.
 * If the key is not found, the first value in the ConfigMap will be used.
 *
 * @schema HttpRouteFilterSpecDirectResponseBodyValueRef
 */
export interface HttpRouteFilterSpecDirectResponseBodyValueRef {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema HttpRouteFilterSpecDirectResponseBodyValueRef#group
   */
  readonly group: string;

  /**
   * Kind is kind of the referent. For example "HTTPRoute" or "Service".
   *
   * @schema HttpRouteFilterSpecDirectResponseBodyValueRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of the referent.
   *
   * @schema HttpRouteFilterSpecDirectResponseBodyValueRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'HttpRouteFilterSpecDirectResponseBodyValueRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteFilterSpecDirectResponseBodyValueRef(obj: HttpRouteFilterSpecDirectResponseBodyValueRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
 *
 * @schema HttpRouteFilterSpecDirectResponseHeaderAdd
 */
export interface HttpRouteFilterSpecDirectResponseHeaderAdd {
  /**
   * Name is the name of the HTTP Header to be matched. Name matching MUST be
   * case-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
   *
   * If multiple entries specify equivalent header names, the first entry with
   * an equivalent name MUST be considered for a match. Subsequent entries
   * with an equivalent header name MUST be ignored. Due to the
   * case-insensitivity of header names, "foo" and "Foo" are considered
   * equivalent.
   *
   * @schema HttpRouteFilterSpecDirectResponseHeaderAdd#name
   */
  readonly name: string;

  /**
   * Value is the value of HTTP Header to be matched.
   *
   * @schema HttpRouteFilterSpecDirectResponseHeaderAdd#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'HttpRouteFilterSpecDirectResponseHeaderAdd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteFilterSpecDirectResponseHeaderAdd(obj: HttpRouteFilterSpecDirectResponseHeaderAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
 *
 * @schema HttpRouteFilterSpecDirectResponseHeaderSet
 */
export interface HttpRouteFilterSpecDirectResponseHeaderSet {
  /**
   * Name is the name of the HTTP Header to be matched. Name matching MUST be
   * case-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
   *
   * If multiple entries specify equivalent header names, the first entry with
   * an equivalent name MUST be considered for a match. Subsequent entries
   * with an equivalent header name MUST be ignored. Due to the
   * case-insensitivity of header names, "foo" and "Foo" are considered
   * equivalent.
   *
   * @schema HttpRouteFilterSpecDirectResponseHeaderSet#name
   */
  readonly name: string;

  /**
   * Value is the value of HTTP Header to be matched.
   *
   * @schema HttpRouteFilterSpecDirectResponseHeaderSet#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'HttpRouteFilterSpecDirectResponseHeaderSet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteFilterSpecDirectResponseHeaderSet(obj: HttpRouteFilterSpecDirectResponseHeaderSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPPathModifierType defines the type of Hostname rewrite.
 *
 * @schema HttpRouteFilterSpecUrlRewriteHostnameType
 */
export enum HttpRouteFilterSpecUrlRewriteHostnameType {
  /** Header */
  HEADER = "Header",
  /** Backend */
  BACKEND = "Backend",
}

/**
 * ReplaceRegexMatch defines a path regex rewrite. The path portions matched by the regex pattern are replaced by the defined substitution.
 * https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/v3/route_components.proto#envoy-v3-api-field-config-route-v3-routeaction-regex-rewrite
 * Some examples:
 * (1) replaceRegexMatch:
 * pattern: ^/service/([^/]+)(/.*)$
 * substitution: \2/instance/\1
 * Would transform /service/foo/v1/api into /v1/api/instance/foo.
 * (2) replaceRegexMatch:
 * pattern: one
 * substitution: two
 * Would transform /xxx/one/yyy/one/zzz into /xxx/two/yyy/two/zzz.
 * (3) replaceRegexMatch:
 * pattern: ^(.*?)one(.*)$
 * substitution: \1two\2
 * Would transform /xxx/one/yyy/one/zzz into /xxx/two/yyy/one/zzz.
 * (3) replaceRegexMatch:
 * pattern: (?i)/xxx/
 * substitution: /yyy/
 * Would transform path /aaa/XxX/bbb into /aaa/yyy/bbb (case-insensitive).
 *
 * @schema HttpRouteFilterSpecUrlRewritePathReplaceRegexMatch
 */
export interface HttpRouteFilterSpecUrlRewritePathReplaceRegexMatch {
  /**
   * Pattern matches a regular expression against the value of the HTTP Path.The regex string must
   * adhere to the syntax documented in https://github.com/google/re2/wiki/Syntax.
   *
   * @schema HttpRouteFilterSpecUrlRewritePathReplaceRegexMatch#pattern
   */
  readonly pattern: string;

  /**
   * Substitution is an expression that replaces the matched portion.The expression may include numbered
   * capture groups that adhere to syntax documented in https://github.com/google/re2/wiki/Syntax.
   *
   * @schema HttpRouteFilterSpecUrlRewritePathReplaceRegexMatch#substitution
   */
  readonly substitution: string;
}

/**
 * Converts an object of type 'HttpRouteFilterSpecUrlRewritePathReplaceRegexMatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteFilterSpecUrlRewritePathReplaceRegexMatch(obj: HttpRouteFilterSpecUrlRewritePathReplaceRegexMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pattern': obj.pattern,
    'substitution': obj.substitution,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPPathModifierType defines the type of path redirect or rewrite.
 *
 * @schema HttpRouteFilterSpecUrlRewritePathType
 */
export enum HttpRouteFilterSpecUrlRewritePathType {
  /** ReplaceRegexMatch */
  REPLACE_REGEX_MATCH = "ReplaceRegexMatch",
}


/**
 * SecurityPolicy allows the user to configure various security settings for a
Gateway.
 *
 * @schema SecurityPolicy
 */
export class SecurityPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SecurityPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'gateway.envoyproxy.io/v1alpha1',
    kind: 'SecurityPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "SecurityPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecurityPolicyProps): any {
    return {
      ...SecurityPolicy.GVK,
      ...toJson_SecurityPolicyProps(props),
    };
  }

  /**
   * Defines a "SecurityPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SecurityPolicyProps) {
    super(scope, id, {
      ...SecurityPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...SecurityPolicy.GVK,
      ...toJson_SecurityPolicyProps(resolved),
    };
  }
}

/**
 * SecurityPolicy allows the user to configure various security settings for a
 * Gateway.
 *
 * @schema SecurityPolicy
 */
export interface SecurityPolicyProps {
  /**
   * @schema SecurityPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec defines the desired state of SecurityPolicy.
   *
   * @schema SecurityPolicy#spec
   */
  readonly spec: SecurityPolicySpec;
}

/**
 * Converts an object of type 'SecurityPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicyProps(obj: SecurityPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SecurityPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec defines the desired state of SecurityPolicy.
 *
 * @schema SecurityPolicySpec
 */
export interface SecurityPolicySpec {
  /**
   * APIKeyAuth defines the configuration for the API Key Authentication.
   *
   * @schema SecurityPolicySpec#apiKeyAuth
   */
  readonly apiKeyAuth?: SecurityPolicySpecApiKeyAuth;

  /**
   * Authorization defines the authorization configuration.
   *
   * @schema SecurityPolicySpec#authorization
   */
  readonly authorization?: SecurityPolicySpecAuthorization;

  /**
   * BasicAuth defines the configuration for the HTTP Basic Authentication.
   *
   * @schema SecurityPolicySpec#basicAuth
   */
  readonly basicAuth?: SecurityPolicySpecBasicAuth;

  /**
   * CORS defines the configuration for Cross-Origin Resource Sharing (CORS).
   *
   * @schema SecurityPolicySpec#cors
   */
  readonly cors?: SecurityPolicySpecCors;

  /**
   * ExtAuth defines the configuration for External Authorization.
   *
   * @schema SecurityPolicySpec#extAuth
   */
  readonly extAuth?: SecurityPolicySpecExtAuth;

  /**
   * JWT defines the configuration for JSON Web Token (JWT) authentication.
   *
   * @schema SecurityPolicySpec#jwt
   */
  readonly jwt?: SecurityPolicySpecJwt;

  /**
   * OIDC defines the configuration for the OpenID Connect (OIDC) authentication.
   *
   * @schema SecurityPolicySpec#oidc
   */
  readonly oidc?: SecurityPolicySpecOidc;

  /**
   * TargetRef is the name of the resource this policy is being attached to.
   * This policy and the TargetRef MUST be in the same namespace for this
   * Policy to have effect
   *
   * Deprecated: use targetRefs/targetSelectors instead
   *
   * @schema SecurityPolicySpec#targetRef
   */
  readonly targetRef?: SecurityPolicySpecTargetRef;

  /**
   * TargetRefs are the names of the Gateway resources this policy
   * is being attached to.
   *
   * @schema SecurityPolicySpec#targetRefs
   */
  readonly targetRefs?: SecurityPolicySpecTargetRefs[];

  /**
   * TargetSelectors allow targeting resources for this policy based on labels
   *
   * @schema SecurityPolicySpec#targetSelectors
   */
  readonly targetSelectors?: SecurityPolicySpecTargetSelectors[];
}

/**
 * Converts an object of type 'SecurityPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpec(obj: SecurityPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKeyAuth': toJson_SecurityPolicySpecApiKeyAuth(obj.apiKeyAuth),
    'authorization': toJson_SecurityPolicySpecAuthorization(obj.authorization),
    'basicAuth': toJson_SecurityPolicySpecBasicAuth(obj.basicAuth),
    'cors': toJson_SecurityPolicySpecCors(obj.cors),
    'extAuth': toJson_SecurityPolicySpecExtAuth(obj.extAuth),
    'jwt': toJson_SecurityPolicySpecJwt(obj.jwt),
    'oidc': toJson_SecurityPolicySpecOidc(obj.oidc),
    'targetRef': toJson_SecurityPolicySpecTargetRef(obj.targetRef),
    'targetRefs': obj.targetRefs?.map(y => toJson_SecurityPolicySpecTargetRefs(y)),
    'targetSelectors': obj.targetSelectors?.map(y => toJson_SecurityPolicySpecTargetSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * APIKeyAuth defines the configuration for the API Key Authentication.
 *
 * @schema SecurityPolicySpecApiKeyAuth
 */
export interface SecurityPolicySpecApiKeyAuth {
  /**
   * CredentialRefs is the Kubernetes secret which contains the API keys.
   * This is an Opaque secret.
   * Each API key is stored in the key representing the client id.
   * If the secrets have a key for a duplicated client, the first one will be used.
   *
   * @schema SecurityPolicySpecApiKeyAuth#credentialRefs
   */
  readonly credentialRefs: SecurityPolicySpecApiKeyAuthCredentialRefs[];

  /**
   * ExtractFrom is where to fetch the key from the coming request.
   * The value from the first source that has a key will be used.
   *
   * @schema SecurityPolicySpecApiKeyAuth#extractFrom
   */
  readonly extractFrom: SecurityPolicySpecApiKeyAuthExtractFrom[];

  /**
   * ForwardClientIDHeader is the name of the header to forward the client identity to the backend
   * service. The header will be added to the request with the client id as the value.
   *
   * @schema SecurityPolicySpecApiKeyAuth#forwardClientIDHeader
   */
  readonly forwardClientIdHeader?: string;

  /**
   * Sanitize indicates whether to remove the API key from the request before forwarding it to the backend service.
   *
   * @schema SecurityPolicySpecApiKeyAuth#sanitize
   */
  readonly sanitize?: boolean;
}

/**
 * Converts an object of type 'SecurityPolicySpecApiKeyAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecApiKeyAuth(obj: SecurityPolicySpecApiKeyAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentialRefs': obj.credentialRefs?.map(y => toJson_SecurityPolicySpecApiKeyAuthCredentialRefs(y)),
    'extractFrom': obj.extractFrom?.map(y => toJson_SecurityPolicySpecApiKeyAuthExtractFrom(y)),
    'forwardClientIDHeader': obj.forwardClientIdHeader,
    'sanitize': obj.sanitize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authorization defines the authorization configuration.
 *
 * @schema SecurityPolicySpecAuthorization
 */
export interface SecurityPolicySpecAuthorization {
  /**
   * DefaultAction defines the default action to be taken if no rules match.
   * If not specified, the default action is Deny.
   *
   * @schema SecurityPolicySpecAuthorization#defaultAction
   */
  readonly defaultAction?: SecurityPolicySpecAuthorizationDefaultAction;

  /**
   * Rules defines a list of authorization rules.
   * These rules are evaluated in order, the first matching rule will be applied,
   * and the rest will be skipped.
   *
   * For example, if there are two rules: the first rule allows the request
   * and the second rule denies it, when a request matches both rules, it will be allowed.
   *
   * @schema SecurityPolicySpecAuthorization#rules
   */
  readonly rules?: SecurityPolicySpecAuthorizationRules[];
}

/**
 * Converts an object of type 'SecurityPolicySpecAuthorization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecAuthorization(obj: SecurityPolicySpecAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultAction': obj.defaultAction,
    'rules': obj.rules?.map(y => toJson_SecurityPolicySpecAuthorizationRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BasicAuth defines the configuration for the HTTP Basic Authentication.
 *
 * @schema SecurityPolicySpecBasicAuth
 */
export interface SecurityPolicySpecBasicAuth {
  /**
   * This field specifies the header name to forward a successfully authenticated user to
   * the backend. The header will be added to the request with the username as the value.
   *
   * If it is not specified, the username will not be forwarded.
   *
   * @schema SecurityPolicySpecBasicAuth#forwardUsernameHeader
   */
  readonly forwardUsernameHeader?: string;

  /**
   * The Kubernetes secret which contains the username-password pairs in
   * htpasswd format, used to verify user credentials in the "Authorization"
   * header.
   *
   * This is an Opaque secret. The username-password pairs should be stored in
   * the key ".htpasswd". As the key name indicates, the value needs to be the
   * htpasswd format, for example: "user1:{SHA}hashed_user1_password".
   * Right now, only SHA hash algorithm is supported.
   * Reference to https://httpd.apache.org/docs/2.4/programs/htpasswd.html
   * for more details.
   *
   * Note: The secret must be in the same namespace as the SecurityPolicy.
   *
   * @schema SecurityPolicySpecBasicAuth#users
   */
  readonly users: SecurityPolicySpecBasicAuthUsers;
}

/**
 * Converts an object of type 'SecurityPolicySpecBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecBasicAuth(obj: SecurityPolicySpecBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forwardUsernameHeader': obj.forwardUsernameHeader,
    'users': toJson_SecurityPolicySpecBasicAuthUsers(obj.users),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CORS defines the configuration for Cross-Origin Resource Sharing (CORS).
 *
 * @schema SecurityPolicySpecCors
 */
export interface SecurityPolicySpecCors {
  /**
   * AllowCredentials indicates whether a request can include user credentials
   * like cookies, authentication headers, or TLS client certificates.
   * It specifies the value in the Access-Control-Allow-Credentials CORS response header.
   *
   * @schema SecurityPolicySpecCors#allowCredentials
   */
  readonly allowCredentials?: boolean;

  /**
   * AllowHeaders defines the headers that are allowed to be sent with requests.
   * It specifies the allowed headers in the Access-Control-Allow-Headers CORS response header..
   * The value "*" allows any header to be sent.
   *
   * @schema SecurityPolicySpecCors#allowHeaders
   */
  readonly allowHeaders?: string[];

  /**
   * AllowMethods defines the methods that are allowed to make requests.
   * It specifies the allowed methods in the Access-Control-Allow-Methods CORS response header..
   * The value "*" allows any method to be used.
   *
   * @schema SecurityPolicySpecCors#allowMethods
   */
  readonly allowMethods?: string[];

  /**
   * AllowOrigins defines the origins that are allowed to make requests.
   * It specifies the allowed origins in the Access-Control-Allow-Origin CORS response header.
   * The value "*" allows any origin to make requests.
   *
   * @schema SecurityPolicySpecCors#allowOrigins
   */
  readonly allowOrigins?: string[];

  /**
   * ExposeHeaders defines which response headers should be made accessible to
   * scripts running in the browser.
   * It specifies the headers in the Access-Control-Expose-Headers CORS response header..
   * The value "*" allows any header to be exposed.
   *
   * @schema SecurityPolicySpecCors#exposeHeaders
   */
  readonly exposeHeaders?: string[];

  /**
   * MaxAge defines how long the results of a preflight request can be cached.
   * It specifies the value in the Access-Control-Max-Age CORS response header..
   *
   * @schema SecurityPolicySpecCors#maxAge
   */
  readonly maxAge?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecCors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecCors(obj: SecurityPolicySpecCors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowCredentials': obj.allowCredentials,
    'allowHeaders': obj.allowHeaders?.map(y => y),
    'allowMethods': obj.allowMethods?.map(y => y),
    'allowOrigins': obj.allowOrigins?.map(y => y),
    'exposeHeaders': obj.exposeHeaders?.map(y => y),
    'maxAge': obj.maxAge,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExtAuth defines the configuration for External Authorization.
 *
 * @schema SecurityPolicySpecExtAuth
 */
export interface SecurityPolicySpecExtAuth {
  /**
   * BodyToExtAuth defines the Body to Ext Auth configuration.
   *
   * @schema SecurityPolicySpecExtAuth#bodyToExtAuth
   */
  readonly bodyToExtAuth?: SecurityPolicySpecExtAuthBodyToExtAuth;

  /**
   * FailOpen is a switch used to control the behavior when a response from the External Authorization service cannot be obtained.
   * If FailOpen is set to true, the system allows the traffic to pass through.
   * Otherwise, if it is set to false or not set (defaulting to false),
   * the system blocks the traffic and returns a HTTP 5xx error, reflecting a fail-closed approach.
   * This setting determines whether to prioritize accessibility over strict security in case of authorization service failure.
   *
   * If set to true, the External Authorization will also be bypassed if its configuration is invalid.
   *
   * @schema SecurityPolicySpecExtAuth#failOpen
   */
  readonly failOpen?: boolean;

  /**
   * GRPC defines the gRPC External Authorization service.
   * Either GRPCService or HTTPService must be specified,
   * and only one of them can be provided.
   *
   * @schema SecurityPolicySpecExtAuth#grpc
   */
  readonly grpc?: SecurityPolicySpecExtAuthGrpc;

  /**
   * HeadersToExtAuth defines the client request headers that will be included
   * in the request to the external authorization service.
   * Note: If not specified, the default behavior for gRPC and HTTP external
   * authorization services is different due to backward compatibility reasons.
   * All headers will be included in the check request to a gRPC authorization server.
   * Only the following headers will be included in the check request to an HTTP
   * authorization server: Host, Method, Path, Content-Length, and Authorization.
   * And these headers will always be included to the check request to an HTTP
   * authorization server by default, no matter whether they are specified
   * in HeadersToExtAuth or not.
   *
   * @schema SecurityPolicySpecExtAuth#headersToExtAuth
   */
  readonly headersToExtAuth?: string[];

  /**
   * HTTP defines the HTTP External Authorization service.
   * Either GRPCService or HTTPService must be specified,
   * and only one of them can be provided.
   *
   * @schema SecurityPolicySpecExtAuth#http
   */
  readonly http?: SecurityPolicySpecExtAuthHttp;

  /**
   * RecomputeRoute clears the route cache and recalculates the routing decision.
   * This field must be enabled if the headers added or modified by the ExtAuth are used for
   * route matching decisions. If the recomputation selects a new route, features targeting
   * the new matched route will be applied.
   *
   * @schema SecurityPolicySpecExtAuth#recomputeRoute
   */
  readonly recomputeRoute?: boolean;

  /**
   * Timeout defines the timeout for requests to the external authorization service.
   * If not specified, defaults to 10 seconds.
   *
   * @schema SecurityPolicySpecExtAuth#timeout
   */
  readonly timeout?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuth(obj: SecurityPolicySpecExtAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bodyToExtAuth': toJson_SecurityPolicySpecExtAuthBodyToExtAuth(obj.bodyToExtAuth),
    'failOpen': obj.failOpen,
    'grpc': toJson_SecurityPolicySpecExtAuthGrpc(obj.grpc),
    'headersToExtAuth': obj.headersToExtAuth?.map(y => y),
    'http': toJson_SecurityPolicySpecExtAuthHttp(obj.http),
    'recomputeRoute': obj.recomputeRoute,
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * JWT defines the configuration for JSON Web Token (JWT) authentication.
 *
 * @schema SecurityPolicySpecJwt
 */
export interface SecurityPolicySpecJwt {
  /**
   * Optional determines whether a missing JWT is acceptable, defaulting to false if not specified.
   * Note: Even if optional is set to true, JWT authentication will still fail if an invalid JWT is presented.
   *
   * @schema SecurityPolicySpecJwt#optional
   */
  readonly optional?: boolean;

  /**
   * Providers defines the JSON Web Token (JWT) authentication provider type.
   * When multiple JWT providers are specified, the JWT is considered valid if
   * any of the providers successfully validate the JWT. For additional details,
   * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/jwt_authn_filter.html.
   *
   * @schema SecurityPolicySpecJwt#providers
   */
  readonly providers: SecurityPolicySpecJwtProviders[];
}

/**
 * Converts an object of type 'SecurityPolicySpecJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwt(obj: SecurityPolicySpecJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'optional': obj.optional,
    'providers': obj.providers?.map(y => toJson_SecurityPolicySpecJwtProviders(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OIDC defines the configuration for the OpenID Connect (OIDC) authentication.
 *
 * @schema SecurityPolicySpecOidc
 */
export interface SecurityPolicySpecOidc {
  /**
   * The client ID to be used in the OIDC
   * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
   *
   * Only one of clientID or clientIDRef must be set.
   *
   * @schema SecurityPolicySpecOidc#clientID
   */
  readonly clientId?: string;

  /**
   * The Kubernetes secret which contains the client ID to be used in the
   * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
   * Exactly one of clientID or clientIDRef must be set.
   * This is an Opaque secret. The client ID should be stored in the key "client-id".
   *
   * Only one of clientID or clientIDRef must be set.
   *
   * @schema SecurityPolicySpecOidc#clientIDRef
   */
  readonly clientIdRef?: SecurityPolicySpecOidcClientIdRef;

  /**
   * The Kubernetes secret which contains the OIDC client secret to be used in the
   * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
   *
   * This is an Opaque secret. The client secret should be stored in the key
   * "client-secret".
   *
   * @schema SecurityPolicySpecOidc#clientSecret
   */
  readonly clientSecret: SecurityPolicySpecOidcClientSecret;

  /**
   * CookieConfigs allows setting the SameSite attribute for OIDC cookies.
   * By default, its unset.
   *
   * @schema SecurityPolicySpecOidc#cookieConfig
   */
  readonly cookieConfig?: SecurityPolicySpecOidcCookieConfig;

  /**
   * The optional domain to set the access and ID token cookies on.
   * If not set, the cookies will default to the host of the request, not including the subdomains.
   * If set, the cookies will be set on the specified domain and all subdomains.
   * This means that requests to any subdomain will not require reauthentication after users log in to the parent domain.
   *
   * @schema SecurityPolicySpecOidc#cookieDomain
   */
  readonly cookieDomain?: string;

  /**
   * The optional cookie name overrides to be used for Bearer and IdToken cookies in the
   * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
   * If not specified, uses a randomly generated suffix
   *
   * @schema SecurityPolicySpecOidc#cookieNames
   */
  readonly cookieNames?: SecurityPolicySpecOidcCookieNames;

  /**
   * CSRFTokenTTL defines how long the CSRF token generated during the OAuth2 authorization flow remains valid.
   *
   * This duration determines the lifetime of the CSRF cookie, which is validated against the CSRF token
   * in the "state" parameter when the provider redirects back to the callback endpoint.
   *
   * If omitted, Envoy Gateway defaults the token expiration to 10 minutes.
   *
   * @schema SecurityPolicySpecOidc#csrfTokenTTL
   */
  readonly csrfTokenTtl?: string;

  /**
   * DefaultRefreshTokenTTL is the default lifetime of the refresh token.
   * This field is only used when the exp (expiration time) claim is omitted in
   * the refresh token or the refresh token is not JWT.
   *
   * If not specified, defaults to 604800s (one week).
   * Note: this field is only applicable when the "refreshToken" field is set to true.
   *
   * @schema SecurityPolicySpecOidc#defaultRefreshTokenTTL
   */
  readonly defaultRefreshTokenTtl?: string;

  /**
   * DefaultTokenTTL is the default lifetime of the id token and access token.
   * Please note that Envoy will always use the expiry time from the response
   * of the authorization server if it is provided. This field is only used when
   * the expiry time is not provided by the authorization.
   *
   * If not specified, defaults to 0. In this case, the "expires_in" field in
   * the authorization response must be set by the authorization server, or the
   * OAuth flow will fail.
   *
   * @schema SecurityPolicySpecOidc#defaultTokenTTL
   */
  readonly defaultTokenTtl?: string;

  /**
   * Any request that matches any of the provided matchers (with either tokens that are expired or missing tokens) will not be redirected to the OIDC Provider.
   * This behavior can be useful for AJAX or machine requests.
   *
   * @schema SecurityPolicySpecOidc#denyRedirect
   */
  readonly denyRedirect?: SecurityPolicySpecOidcDenyRedirect;

  /**
   * Disable token encryption. When set to true, both the access token and the ID token will be stored in plain text.
   * This option should only be used in secure environments where token encryption is not required.
   * Default is false (tokens are encrypted).
   *
   * @default false (tokens are encrypted).
   * @schema SecurityPolicySpecOidc#disableTokenEncryption
   */
  readonly disableTokenEncryption?: boolean;

  /**
   * ForwardAccessToken indicates whether the Envoy should forward the access token
   * via the Authorization header Bearer scheme to the upstream.
   * If not specified, defaults to false.
   *
   * @schema SecurityPolicySpecOidc#forwardAccessToken
   */
  readonly forwardAccessToken?: boolean;

  /**
   * The path to log a user out, clearing their credential cookies.
   *
   * If not specified, uses a default logout path "/logout"
   *
   * @schema SecurityPolicySpecOidc#logoutPath
   */
  readonly logoutPath?: string;

  /**
   * Skips OIDC authentication when the request contains a header that will be extracted by the JWT filter. Unless
   * explicitly stated otherwise in the extractFrom field, this will be the "Authorization: Bearer ..." header.
   *
   * The passThroughAuthHeader option is typically used for non-browser clients that may not be able to handle OIDC
   * redirects and wish to directly supply a token instead.
   *
   * If not specified, defaults to false.
   *
   * @schema SecurityPolicySpecOidc#passThroughAuthHeader
   */
  readonly passThroughAuthHeader?: boolean;

  /**
   * The OIDC Provider configuration.
   *
   * @schema SecurityPolicySpecOidc#provider
   */
  readonly provider: SecurityPolicySpecOidcProvider;

  /**
   * The redirect URL to be used in the OIDC
   * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
   * If not specified, uses the default redirect URI "%REQ(x-forwarded-proto)%://%REQ(:authority)%/oauth2/callback"
   *
   * @schema SecurityPolicySpecOidc#redirectURL
   */
  readonly redirectUrl?: string;

  /**
   * RefreshToken indicates whether the Envoy should automatically refresh the
   * id token and access token when they expire.
   * When set to true, the Envoy will use the refresh token to get a new id token
   * and access token when they expire.
   *
   * If not specified, defaults to true.
   *
   * @schema SecurityPolicySpecOidc#refreshToken
   */
  readonly refreshToken?: boolean;

  /**
   * The OIDC resources to be used in the
   * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
   *
   * @schema SecurityPolicySpecOidc#resources
   */
  readonly resources?: string[];

  /**
   * The OIDC scopes to be used in the
   * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
   * The "openid" scope is always added to the list of scopes if not already
   * specified.
   *
   * @schema SecurityPolicySpecOidc#scopes
   */
  readonly scopes?: string[];
}

/**
 * Converts an object of type 'SecurityPolicySpecOidc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidc(obj: SecurityPolicySpecOidc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientID': obj.clientId,
    'clientIDRef': toJson_SecurityPolicySpecOidcClientIdRef(obj.clientIdRef),
    'clientSecret': toJson_SecurityPolicySpecOidcClientSecret(obj.clientSecret),
    'cookieConfig': toJson_SecurityPolicySpecOidcCookieConfig(obj.cookieConfig),
    'cookieDomain': obj.cookieDomain,
    'cookieNames': toJson_SecurityPolicySpecOidcCookieNames(obj.cookieNames),
    'csrfTokenTTL': obj.csrfTokenTtl,
    'defaultRefreshTokenTTL': obj.defaultRefreshTokenTtl,
    'defaultTokenTTL': obj.defaultTokenTtl,
    'denyRedirect': toJson_SecurityPolicySpecOidcDenyRedirect(obj.denyRedirect),
    'disableTokenEncryption': obj.disableTokenEncryption,
    'forwardAccessToken': obj.forwardAccessToken,
    'logoutPath': obj.logoutPath,
    'passThroughAuthHeader': obj.passThroughAuthHeader,
    'provider': toJson_SecurityPolicySpecOidcProvider(obj.provider),
    'redirectURL': obj.redirectUrl,
    'refreshToken': obj.refreshToken,
    'resources': obj.resources?.map(y => y),
    'scopes': obj.scopes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TargetRef is the name of the resource this policy is being attached to.
 * This policy and the TargetRef MUST be in the same namespace for this
 * Policy to have effect
 *
 * Deprecated: use targetRefs/targetSelectors instead
 *
 * @schema SecurityPolicySpecTargetRef
 */
export interface SecurityPolicySpecTargetRef {
  /**
   * Group is the group of the target resource.
   *
   * @schema SecurityPolicySpecTargetRef#group
   */
  readonly group: string;

  /**
   * Kind is kind of the target resource.
   *
   * @schema SecurityPolicySpecTargetRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of the target resource.
   *
   * @schema SecurityPolicySpecTargetRef#name
   */
  readonly name: string;

  /**
   * SectionName is the name of a section within the target resource. When
   * unspecified, this targetRef targets the entire resource. In the following
   * resources, SectionName is interpreted as the following:
   *
   * * Gateway: Listener name
   * * HTTPRoute: HTTPRouteRule name
   * * Service: Port name
   *
   * If a SectionName is specified, but does not exist on the targeted object,
   * the Policy must fail to attach, and the policy implementation should record
   * a `ResolvedRefs` or similar Condition in the Policy's status.
   *
   * @schema SecurityPolicySpecTargetRef#sectionName
   */
  readonly sectionName?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecTargetRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecTargetRef(obj: SecurityPolicySpecTargetRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'sectionName': obj.sectionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalPolicyTargetReferenceWithSectionName identifies an API object to apply a
 * direct policy to. This should be used as part of Policy resources that can
 * target single resources. For more information on how this policy attachment
 * mode works, and a sample Policy resource, refer to the policy attachment
 * documentation for Gateway API.
 *
 * Note: This should only be used for direct policy attachment when references
 * to SectionName are actually needed. In all other cases,
 * LocalPolicyTargetReference should be used.
 *
 * @schema SecurityPolicySpecTargetRefs
 */
export interface SecurityPolicySpecTargetRefs {
  /**
   * Group is the group of the target resource.
   *
   * @schema SecurityPolicySpecTargetRefs#group
   */
  readonly group: string;

  /**
   * Kind is kind of the target resource.
   *
   * @schema SecurityPolicySpecTargetRefs#kind
   */
  readonly kind: string;

  /**
   * Name is the name of the target resource.
   *
   * @schema SecurityPolicySpecTargetRefs#name
   */
  readonly name: string;

  /**
   * SectionName is the name of a section within the target resource. When
   * unspecified, this targetRef targets the entire resource. In the following
   * resources, SectionName is interpreted as the following:
   *
   * * Gateway: Listener name
   * * HTTPRoute: HTTPRouteRule name
   * * Service: Port name
   *
   * If a SectionName is specified, but does not exist on the targeted object,
   * the Policy must fail to attach, and the policy implementation should record
   * a `ResolvedRefs` or similar Condition in the Policy's status.
   *
   * @schema SecurityPolicySpecTargetRefs#sectionName
   */
  readonly sectionName?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecTargetRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecTargetRefs(obj: SecurityPolicySpecTargetRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'sectionName': obj.sectionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SecurityPolicySpecTargetSelectors
 */
export interface SecurityPolicySpecTargetSelectors {
  /**
   * Group is the group that this selector targets. Defaults to gateway.networking.k8s.io
   *
   * @default gateway.networking.k8s.io
   * @schema SecurityPolicySpecTargetSelectors#group
   */
  readonly group?: string;

  /**
   * Kind is the resource kind that this selector targets.
   *
   * @schema SecurityPolicySpecTargetSelectors#kind
   */
  readonly kind: string;

  /**
   * MatchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema SecurityPolicySpecTargetSelectors#matchExpressions
   */
  readonly matchExpressions?: SecurityPolicySpecTargetSelectorsMatchExpressions[];

  /**
   * MatchLabels are the set of label selectors for identifying the targeted resource
   *
   * @schema SecurityPolicySpecTargetSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'SecurityPolicySpecTargetSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecTargetSelectors(obj: SecurityPolicySpecTargetSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'matchExpressions': obj.matchExpressions?.map(y => toJson_SecurityPolicySpecTargetSelectorsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretObjectReference identifies an API object including its namespace,
 * defaulting to Secret.
 *
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 *
 * References to objects with invalid Group and Kind are not valid, and must
 * be rejected by the implementation, with appropriate Conditions set
 * on the containing object.
 *
 * @schema SecurityPolicySpecApiKeyAuthCredentialRefs
 */
export interface SecurityPolicySpecApiKeyAuthCredentialRefs {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema SecurityPolicySpecApiKeyAuthCredentialRefs#group
   */
  readonly group?: string;

  /**
   * Kind is kind of the referent. For example "Secret".
   *
   * @schema SecurityPolicySpecApiKeyAuthCredentialRefs#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema SecurityPolicySpecApiKeyAuthCredentialRefs#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the referenced object. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema SecurityPolicySpecApiKeyAuthCredentialRefs#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecApiKeyAuthCredentialRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecApiKeyAuthCredentialRefs(obj: SecurityPolicySpecApiKeyAuthCredentialRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExtractFrom is where to fetch the key from the coming request.
 * Only one of header, param or cookie is supposed to be specified.
 *
 * @schema SecurityPolicySpecApiKeyAuthExtractFrom
 */
export interface SecurityPolicySpecApiKeyAuthExtractFrom {
  /**
   * Cookies is the names of the cookie to fetch the key from.
   * If multiple cookies are specified, envoy will look for the api key in the order of the list.
   * This field is optional, but only one of headers, params or cookies is supposed to be specified.
   *
   * @schema SecurityPolicySpecApiKeyAuthExtractFrom#cookies
   */
  readonly cookies?: string[];

  /**
   * Headers is the names of the header to fetch the key from.
   * If multiple headers are specified, envoy will look for the api key in the order of the list.
   * This field is optional, but only one of headers, params or cookies is supposed to be specified.
   *
   * @schema SecurityPolicySpecApiKeyAuthExtractFrom#headers
   */
  readonly headers?: string[];

  /**
   * Params is the names of the query parameter to fetch the key from.
   * If multiple params are specified, envoy will look for the api key in the order of the list.
   * This field is optional, but only one of headers, params or cookies is supposed to be specified.
   *
   * @schema SecurityPolicySpecApiKeyAuthExtractFrom#params
   */
  readonly params?: string[];
}

/**
 * Converts an object of type 'SecurityPolicySpecApiKeyAuthExtractFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecApiKeyAuthExtractFrom(obj: SecurityPolicySpecApiKeyAuthExtractFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookies': obj.cookies?.map(y => y),
    'headers': obj.headers?.map(y => y),
    'params': obj.params?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DefaultAction defines the default action to be taken if no rules match.
 * If not specified, the default action is Deny.
 *
 * @schema SecurityPolicySpecAuthorizationDefaultAction
 */
export enum SecurityPolicySpecAuthorizationDefaultAction {
  /** Allow */
  ALLOW = "Allow",
  /** Deny */
  DENY = "Deny",
}

/**
 * AuthorizationRule defines a single authorization rule.
 *
 * @schema SecurityPolicySpecAuthorizationRules
 */
export interface SecurityPolicySpecAuthorizationRules {
  /**
   * Action defines the action to be taken if the rule matches.
   *
   * @schema SecurityPolicySpecAuthorizationRules#action
   */
  readonly action: SecurityPolicySpecAuthorizationRulesAction;

  /**
   * Name is a user-friendly name for the rule.
   * If not specified, Envoy Gateway will generate a unique name for the rule.
   *
   * @schema SecurityPolicySpecAuthorizationRules#name
   */
  readonly name?: string;

  /**
   * Operation specifies the operation of a request, such as HTTP methods.
   * If not specified, all operations are matched on.
   *
   * @schema SecurityPolicySpecAuthorizationRules#operation
   */
  readonly operation?: SecurityPolicySpecAuthorizationRulesOperation;

  /**
   * Principal specifies the client identity of a request.
   * If there are multiple principal types, all principals must match for the rule to match.
   * For example, if there are two principals: one for client IP and one for JWT claim,
   * the rule will match only if both the client IP and the JWT claim match.
   *
   * @schema SecurityPolicySpecAuthorizationRules#principal
   */
  readonly principal: SecurityPolicySpecAuthorizationRulesPrincipal;
}

/**
 * Converts an object of type 'SecurityPolicySpecAuthorizationRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecAuthorizationRules(obj: SecurityPolicySpecAuthorizationRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'name': obj.name,
    'operation': toJson_SecurityPolicySpecAuthorizationRulesOperation(obj.operation),
    'principal': toJson_SecurityPolicySpecAuthorizationRulesPrincipal(obj.principal),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Kubernetes secret which contains the username-password pairs in
 * htpasswd format, used to verify user credentials in the "Authorization"
 * header.
 *
 * This is an Opaque secret. The username-password pairs should be stored in
 * the key ".htpasswd". As the key name indicates, the value needs to be the
 * htpasswd format, for example: "user1:{SHA}hashed_user1_password".
 * Right now, only SHA hash algorithm is supported.
 * Reference to https://httpd.apache.org/docs/2.4/programs/htpasswd.html
 * for more details.
 *
 * Note: The secret must be in the same namespace as the SecurityPolicy.
 *
 * @schema SecurityPolicySpecBasicAuthUsers
 */
export interface SecurityPolicySpecBasicAuthUsers {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema SecurityPolicySpecBasicAuthUsers#group
   */
  readonly group?: string;

  /**
   * Kind is kind of the referent. For example "Secret".
   *
   * @schema SecurityPolicySpecBasicAuthUsers#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema SecurityPolicySpecBasicAuthUsers#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the referenced object. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema SecurityPolicySpecBasicAuthUsers#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecBasicAuthUsers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecBasicAuthUsers(obj: SecurityPolicySpecBasicAuthUsers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BodyToExtAuth defines the Body to Ext Auth configuration.
 *
 * @schema SecurityPolicySpecExtAuthBodyToExtAuth
 */
export interface SecurityPolicySpecExtAuthBodyToExtAuth {
  /**
   * MaxRequestBytes is the maximum size of a message body that the filter will hold in memory.
   * Envoy will return HTTP 413 and will not initiate the authorization process when buffer
   * reaches the number set in this field.
   * Note that this setting will have precedence over failOpen mode.
   *
   * @schema SecurityPolicySpecExtAuthBodyToExtAuth#maxRequestBytes
   */
  readonly maxRequestBytes: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthBodyToExtAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthBodyToExtAuth(obj: SecurityPolicySpecExtAuthBodyToExtAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxRequestBytes': obj.maxRequestBytes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC defines the gRPC External Authorization service.
 * Either GRPCService or HTTPService must be specified,
 * and only one of them can be provided.
 *
 * @schema SecurityPolicySpecExtAuthGrpc
 */
export interface SecurityPolicySpecExtAuthGrpc {
  /**
   * BackendRef references a Kubernetes object that represents the
   * backend server to which the authorization request will be sent.
   *
   * Deprecated: Use BackendRefs instead.
   *
   * @schema SecurityPolicySpecExtAuthGrpc#backendRef
   */
  readonly backendRef?: SecurityPolicySpecExtAuthGrpcBackendRef;

  /**
   * BackendRefs references a Kubernetes object that represents the
   * backend server to which the authorization request will be sent.
   *
   * @schema SecurityPolicySpecExtAuthGrpc#backendRefs
   */
  readonly backendRefs?: SecurityPolicySpecExtAuthGrpcBackendRefs[];

  /**
   * BackendSettings holds configuration for managing the connection
   * to the backend.
   *
   * @schema SecurityPolicySpecExtAuthGrpc#backendSettings
   */
  readonly backendSettings?: SecurityPolicySpecExtAuthGrpcBackendSettings;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpc(obj: SecurityPolicySpecExtAuthGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendRef': toJson_SecurityPolicySpecExtAuthGrpcBackendRef(obj.backendRef),
    'backendRefs': obj.backendRefs?.map(y => toJson_SecurityPolicySpecExtAuthGrpcBackendRefs(y)),
    'backendSettings': toJson_SecurityPolicySpecExtAuthGrpcBackendSettings(obj.backendSettings),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP defines the HTTP External Authorization service.
 * Either GRPCService or HTTPService must be specified,
 * and only one of them can be provided.
 *
 * @schema SecurityPolicySpecExtAuthHttp
 */
export interface SecurityPolicySpecExtAuthHttp {
  /**
   * BackendRef references a Kubernetes object that represents the
   * backend server to which the authorization request will be sent.
   *
   * Deprecated: Use BackendRefs instead.
   *
   * @schema SecurityPolicySpecExtAuthHttp#backendRef
   */
  readonly backendRef?: SecurityPolicySpecExtAuthHttpBackendRef;

  /**
   * BackendRefs references a Kubernetes object that represents the
   * backend server to which the authorization request will be sent.
   *
   * @schema SecurityPolicySpecExtAuthHttp#backendRefs
   */
  readonly backendRefs?: SecurityPolicySpecExtAuthHttpBackendRefs[];

  /**
   * BackendSettings holds configuration for managing the connection
   * to the backend.
   *
   * @schema SecurityPolicySpecExtAuthHttp#backendSettings
   */
  readonly backendSettings?: SecurityPolicySpecExtAuthHttpBackendSettings;

  /**
   * HeadersToBackend are the authorization response headers that will be added
   * to the original client request before sending it to the backend server.
   * Note that coexisting headers will be overridden.
   * If not specified, no authorization response headers will be added to the
   * original client request.
   *
   * @schema SecurityPolicySpecExtAuthHttp#headersToBackend
   */
  readonly headersToBackend?: string[];

  /**
   * Path is the path of the HTTP External Authorization service.
   * If path is specified, the authorization request will be sent to that path,
   * or else the authorization request will use the path of the original request.
   *
   * Please note that the original request path will be appended to the path specified here.
   * For example, if the original request path is "/hello", and the path specified here is "/auth",
   * then the path of the authorization request will be "/auth/hello". If the path is not specified,
   * the path of the authorization request will be "/hello".
   *
   * @schema SecurityPolicySpecExtAuthHttp#path
   */
  readonly path?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttp(obj: SecurityPolicySpecExtAuthHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendRef': toJson_SecurityPolicySpecExtAuthHttpBackendRef(obj.backendRef),
    'backendRefs': obj.backendRefs?.map(y => toJson_SecurityPolicySpecExtAuthHttpBackendRefs(y)),
    'backendSettings': toJson_SecurityPolicySpecExtAuthHttpBackendSettings(obj.backendSettings),
    'headersToBackend': obj.headersToBackend?.map(y => y),
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * JWTProvider defines how a JSON Web Token (JWT) can be verified.
 *
 * @schema SecurityPolicySpecJwtProviders
 */
export interface SecurityPolicySpecJwtProviders {
  /**
   * Audiences is a list of JWT audiences allowed access. For additional details, see
   * https://tools.ietf.org/html/rfc7519#section-4.1.3. If not provided, JWT audiences
   * are not checked.
   *
   * @schema SecurityPolicySpecJwtProviders#audiences
   */
  readonly audiences?: string[];

  /**
   * ClaimToHeaders is a list of JWT claims that must be extracted into HTTP request headers
   * For examples, following config:
   * The claim must be of type; string, int, double, bool. Array type claims are not supported
   *
   * @schema SecurityPolicySpecJwtProviders#claimToHeaders
   */
  readonly claimToHeaders?: SecurityPolicySpecJwtProvidersClaimToHeaders[];

  /**
   * ExtractFrom defines different ways to extract the JWT token from HTTP request.
   * If empty, it defaults to extract JWT token from the Authorization HTTP request header using Bearer schema
   * or access_token from query parameters.
   *
   * @schema SecurityPolicySpecJwtProviders#extractFrom
   */
  readonly extractFrom?: SecurityPolicySpecJwtProvidersExtractFrom;

  /**
   * Issuer is the principal that issued the JWT and takes the form of a URL or email address.
   * For additional details, see https://tools.ietf.org/html/rfc7519#section-4.1.1 for
   * URL format and https://rfc-editor.org/rfc/rfc5322.html for email format. If not provided,
   * the JWT issuer is not checked.
   *
   * @schema SecurityPolicySpecJwtProviders#issuer
   */
  readonly issuer?: string;

  /**
   * LocalJWKS defines how to get the JSON Web Key Sets (JWKS) from a local source.
   *
   * @schema SecurityPolicySpecJwtProviders#localJWKS
   */
  readonly localJwks?: SecurityPolicySpecJwtProvidersLocalJwks;

  /**
   * Name defines a unique name for the JWT provider. A name can have a variety of forms,
   * including RFC1123 subdomains, RFC 1123 labels, or RFC 1035 labels.
   *
   * @schema SecurityPolicySpecJwtProviders#name
   */
  readonly name: string;

  /**
   * RecomputeRoute clears the route cache and recalculates the routing decision.
   * This field must be enabled if the headers generated from the claim are used for
   * route matching decisions. If the recomputation selects a new route, features targeting
   * the new matched route will be applied.
   *
   * @schema SecurityPolicySpecJwtProviders#recomputeRoute
   */
  readonly recomputeRoute?: boolean;

  /**
   * RemoteJWKS defines how to fetch and cache JSON Web Key Sets (JWKS) from a remote
   * HTTP/HTTPS endpoint.
   *
   * @schema SecurityPolicySpecJwtProviders#remoteJWKS
   */
  readonly remoteJwks?: SecurityPolicySpecJwtProvidersRemoteJwks;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProviders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProviders(obj: SecurityPolicySpecJwtProviders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'claimToHeaders': obj.claimToHeaders?.map(y => toJson_SecurityPolicySpecJwtProvidersClaimToHeaders(y)),
    'extractFrom': toJson_SecurityPolicySpecJwtProvidersExtractFrom(obj.extractFrom),
    'issuer': obj.issuer,
    'localJWKS': toJson_SecurityPolicySpecJwtProvidersLocalJwks(obj.localJwks),
    'name': obj.name,
    'recomputeRoute': obj.recomputeRoute,
    'remoteJWKS': toJson_SecurityPolicySpecJwtProvidersRemoteJwks(obj.remoteJwks),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Kubernetes secret which contains the client ID to be used in the
 * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
 * Exactly one of clientID or clientIDRef must be set.
 * This is an Opaque secret. The client ID should be stored in the key "client-id".
 *
 * Only one of clientID or clientIDRef must be set.
 *
 * @schema SecurityPolicySpecOidcClientIdRef
 */
export interface SecurityPolicySpecOidcClientIdRef {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema SecurityPolicySpecOidcClientIdRef#group
   */
  readonly group?: string;

  /**
   * Kind is kind of the referent. For example "Secret".
   *
   * @schema SecurityPolicySpecOidcClientIdRef#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema SecurityPolicySpecOidcClientIdRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the referenced object. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema SecurityPolicySpecOidcClientIdRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcClientIdRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcClientIdRef(obj: SecurityPolicySpecOidcClientIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Kubernetes secret which contains the OIDC client secret to be used in the
 * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
 *
 * This is an Opaque secret. The client secret should be stored in the key
 * "client-secret".
 *
 * @schema SecurityPolicySpecOidcClientSecret
 */
export interface SecurityPolicySpecOidcClientSecret {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema SecurityPolicySpecOidcClientSecret#group
   */
  readonly group?: string;

  /**
   * Kind is kind of the referent. For example "Secret".
   *
   * @schema SecurityPolicySpecOidcClientSecret#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema SecurityPolicySpecOidcClientSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the referenced object. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema SecurityPolicySpecOidcClientSecret#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcClientSecret(obj: SecurityPolicySpecOidcClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CookieConfigs allows setting the SameSite attribute for OIDC cookies.
 * By default, its unset.
 *
 * @schema SecurityPolicySpecOidcCookieConfig
 */
export interface SecurityPolicySpecOidcCookieConfig {
  /**
   * @schema SecurityPolicySpecOidcCookieConfig#sameSite
   */
  readonly sameSite?: SecurityPolicySpecOidcCookieConfigSameSite;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcCookieConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcCookieConfig(obj: SecurityPolicySpecOidcCookieConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sameSite': obj.sameSite,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The optional cookie name overrides to be used for Bearer and IdToken cookies in the
 * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
 * If not specified, uses a randomly generated suffix
 *
 * @schema SecurityPolicySpecOidcCookieNames
 */
export interface SecurityPolicySpecOidcCookieNames {
  /**
   * The name of the cookie used to store the AccessToken in the
   * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
   * If not specified, defaults to "AccessToken-(randomly generated uid)"
   *
   * @schema SecurityPolicySpecOidcCookieNames#accessToken
   */
  readonly accessToken?: string;

  /**
   * The name of the cookie used to store the IdToken in the
   * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
   * If not specified, defaults to "IdToken-(randomly generated uid)"
   *
   * @schema SecurityPolicySpecOidcCookieNames#idToken
   */
  readonly idToken?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcCookieNames' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcCookieNames(obj: SecurityPolicySpecOidcCookieNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessToken': obj.accessToken,
    'idToken': obj.idToken,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Any request that matches any of the provided matchers (with either tokens that are expired or missing tokens) will not be redirected to the OIDC Provider.
 * This behavior can be useful for AJAX or machine requests.
 *
 * @schema SecurityPolicySpecOidcDenyRedirect
 */
export interface SecurityPolicySpecOidcDenyRedirect {
  /**
   * Defines the headers to match against the request to deny redirect to the OIDC Provider.
   *
   * @schema SecurityPolicySpecOidcDenyRedirect#headers
   */
  readonly headers: SecurityPolicySpecOidcDenyRedirectHeaders[];
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcDenyRedirect' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcDenyRedirect(obj: SecurityPolicySpecOidcDenyRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headers': obj.headers?.map(y => toJson_SecurityPolicySpecOidcDenyRedirectHeaders(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The OIDC Provider configuration.
 *
 * @schema SecurityPolicySpecOidcProvider
 */
export interface SecurityPolicySpecOidcProvider {
  /**
   * The OIDC Provider's [authorization endpoint](https://openid.net/specs/openid-connect-core-1_0.html#AuthorizationEndpoint).
   * If not provided, EG will try to discover it from the provider's [Well-Known Configuration Endpoint](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse).
   *
   * @schema SecurityPolicySpecOidcProvider#authorizationEndpoint
   */
  readonly authorizationEndpoint?: string;

  /**
   * BackendRef references a Kubernetes object that represents the
   * backend server to which the authorization request will be sent.
   *
   * Deprecated: Use BackendRefs instead.
   *
   * @schema SecurityPolicySpecOidcProvider#backendRef
   */
  readonly backendRef?: SecurityPolicySpecOidcProviderBackendRef;

  /**
   * BackendRefs references a Kubernetes object that represents the
   * backend server to which the authorization request will be sent.
   *
   * @schema SecurityPolicySpecOidcProvider#backendRefs
   */
  readonly backendRefs?: SecurityPolicySpecOidcProviderBackendRefs[];

  /**
   * BackendSettings holds configuration for managing the connection
   * to the backend.
   *
   * @schema SecurityPolicySpecOidcProvider#backendSettings
   */
  readonly backendSettings?: SecurityPolicySpecOidcProviderBackendSettings;

  /**
   * The OIDC Provider's [end session endpoint](https://openid.net/specs/openid-connect-core-1_0.html#RPLogout).
   *
   * If the end session endpoint is provided, EG will use it to log out the user from the OIDC Provider when the user accesses the logout path.
   * EG will also try to discover the end session endpoint from the provider's [Well-Known Configuration Endpoint](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse) when authorizationEndpoint or tokenEndpoint is not provided.
   *
   * @schema SecurityPolicySpecOidcProvider#endSessionEndpoint
   */
  readonly endSessionEndpoint?: string;

  /**
   * The OIDC Provider's [issuer identifier](https://openid.net/specs/openid-connect-discovery-1_0.html#IssuerDiscovery).
   * Issuer MUST be a URI RFC 3986 [RFC3986] with a scheme component that MUST
   * be https, a host component, and optionally, port and path components and
   * no query or fragment components.
   *
   * @schema SecurityPolicySpecOidcProvider#issuer
   */
  readonly issuer: string;

  /**
   * The OIDC Provider's [token endpoint](https://openid.net/specs/openid-connect-core-1_0.html#TokenEndpoint).
   * If not provided, EG will try to discover it from the provider's [Well-Known Configuration Endpoint](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse).
   *
   * @schema SecurityPolicySpecOidcProvider#tokenEndpoint
   */
  readonly tokenEndpoint?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProvider(obj: SecurityPolicySpecOidcProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizationEndpoint': obj.authorizationEndpoint,
    'backendRef': toJson_SecurityPolicySpecOidcProviderBackendRef(obj.backendRef),
    'backendRefs': obj.backendRefs?.map(y => toJson_SecurityPolicySpecOidcProviderBackendRefs(y)),
    'backendSettings': toJson_SecurityPolicySpecOidcProviderBackendSettings(obj.backendSettings),
    'endSessionEndpoint': obj.endSessionEndpoint,
    'issuer': obj.issuer,
    'tokenEndpoint': obj.tokenEndpoint,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema SecurityPolicySpecTargetSelectorsMatchExpressions
 */
export interface SecurityPolicySpecTargetSelectorsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema SecurityPolicySpecTargetSelectorsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema SecurityPolicySpecTargetSelectorsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema SecurityPolicySpecTargetSelectorsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'SecurityPolicySpecTargetSelectorsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecTargetSelectorsMatchExpressions(obj: SecurityPolicySpecTargetSelectorsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Action defines the action to be taken if the rule matches.
 *
 * @schema SecurityPolicySpecAuthorizationRulesAction
 */
export enum SecurityPolicySpecAuthorizationRulesAction {
  /** Allow */
  ALLOW = "Allow",
  /** Deny */
  DENY = "Deny",
}

/**
 * Operation specifies the operation of a request, such as HTTP methods.
 * If not specified, all operations are matched on.
 *
 * @schema SecurityPolicySpecAuthorizationRulesOperation
 */
export interface SecurityPolicySpecAuthorizationRulesOperation {
  /**
   * Methods are the HTTP methods of the request.
   * If multiple methods are specified, all specified methods are allowed or denied, based on the action of the rule.
   *
   * @schema SecurityPolicySpecAuthorizationRulesOperation#methods
   */
  readonly methods: SecurityPolicySpecAuthorizationRulesOperationMethods[];
}

/**
 * Converts an object of type 'SecurityPolicySpecAuthorizationRulesOperation' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecAuthorizationRulesOperation(obj: SecurityPolicySpecAuthorizationRulesOperation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'methods': obj.methods?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Principal specifies the client identity of a request.
 * If there are multiple principal types, all principals must match for the rule to match.
 * For example, if there are two principals: one for client IP and one for JWT claim,
 * the rule will match only if both the client IP and the JWT claim match.
 *
 * @schema SecurityPolicySpecAuthorizationRulesPrincipal
 */
export interface SecurityPolicySpecAuthorizationRulesPrincipal {
  /**
   * ClientCIDRs are the IP CIDR ranges of the client.
   * Valid examples are "192.168.1.0/24" or "2001:db8::/64"
   *
   * If multiple CIDR ranges are specified, one of the CIDR ranges must match
   * the client IP for the rule to match.
   *
   * The client IP is inferred from the X-Forwarded-For header, a custom header,
   * or the proxy protocol.
   * You can use the `ClientIPDetection` or the `ProxyProtocol` field in
   * the `ClientTrafficPolicy` to configure how the client IP is detected.
   *
   * For TCPRoute targets (raw TCP connections), HTTP headers such as
   * X-Forwarded-For are not available. The client IP is obtained from the
   * TCP connection's peer address. If intermediaries (load balancers, NAT)
   * terminate or proxy TCP, the original client IP will only be available
   * if the intermediary preserves the source address (for example by
   * enabling the PROXY protocol or avoiding SNAT). Ensure your L4 proxy is
   * configured to preserve the source IP to enable correct client-IP
   * matching for TCPRoute targets.
   *
   * @schema SecurityPolicySpecAuthorizationRulesPrincipal#clientCIDRs
   */
  readonly clientCidRs?: string[];

  /**
   * Headers authorize the request based on user identity extracted from custom headers.
   * If multiple headers are specified, all headers must match for the rule to match.
   *
   * @schema SecurityPolicySpecAuthorizationRulesPrincipal#headers
   */
  readonly headers?: SecurityPolicySpecAuthorizationRulesPrincipalHeaders[];

  /**
   * JWT authorize the request based on the JWT claims and scopes.
   * Note: in order to use JWT claims for authorization, you must configure the
   * JWT authentication in the same `SecurityPolicy`.
   *
   * @schema SecurityPolicySpecAuthorizationRulesPrincipal#jwt
   */
  readonly jwt?: SecurityPolicySpecAuthorizationRulesPrincipalJwt;
}

/**
 * Converts an object of type 'SecurityPolicySpecAuthorizationRulesPrincipal' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecAuthorizationRulesPrincipal(obj: SecurityPolicySpecAuthorizationRulesPrincipal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCIDRs': obj.clientCidRs?.map(y => y),
    'headers': obj.headers?.map(y => toJson_SecurityPolicySpecAuthorizationRulesPrincipalHeaders(y)),
    'jwt': toJson_SecurityPolicySpecAuthorizationRulesPrincipalJwt(obj.jwt),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendRef references a Kubernetes object that represents the
 * backend server to which the authorization request will be sent.
 *
 * Deprecated: Use BackendRefs instead.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendRef
 */
export interface SecurityPolicySpecExtAuthGrpcBackendRef {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendRef#group
   */
  readonly group?: string;

  /**
   * Kind is the Kubernetes resource kind of the referent. For example
   * "Service".
   *
   * Defaults to "Service" when not specified.
   *
   * ExternalName services can refer to CNAME DNS records that may live
   * outside of the cluster and as such are difficult to reason about in
   * terms of conformance. They also may not be safe to forward to (see
   * CVE-2021-25740 for more information). Implementations SHOULD NOT
   * support ExternalName Services.
   *
   * Support: Core (Services with a type other than ExternalName)
   *
   * Support: Implementation-specific (Services with type ExternalName)
   *
   * @default Service" when not specified.
   * @schema SecurityPolicySpecExtAuthGrpcBackendRef#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the backend. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendRef#namespace
   */
  readonly namespace?: string;

  /**
   * Port specifies the destination port number to use for this resource.
   * Port is required when the referent is a Kubernetes Service. In this
   * case, the port number is the service port number, not the target port.
   * For other resources, destination port might be derived from the referent
   * resource or this field.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendRef#port
   */
  readonly port?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendRef(obj: SecurityPolicySpecExtAuthGrpcBackendRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendRef defines how an ObjectReference that is specific to BackendRef.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendRefs
 */
export interface SecurityPolicySpecExtAuthGrpcBackendRefs {
  /**
   * Fallback indicates whether the backend is designated as a fallback.
   * Multiple fallback backends can be configured.
   * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
   * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
   * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
   * the health of the active backends falls below 72%.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendRefs#fallback
   */
  readonly fallback?: boolean;

  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendRefs#group
   */
  readonly group?: string;

  /**
   * Kind is the Kubernetes resource kind of the referent. For example
   * "Service".
   *
   * Defaults to "Service" when not specified.
   *
   * ExternalName services can refer to CNAME DNS records that may live
   * outside of the cluster and as such are difficult to reason about in
   * terms of conformance. They also may not be safe to forward to (see
   * CVE-2021-25740 for more information). Implementations SHOULD NOT
   * support ExternalName Services.
   *
   * Support: Core (Services with a type other than ExternalName)
   *
   * Support: Implementation-specific (Services with type ExternalName)
   *
   * @default Service" when not specified.
   * @schema SecurityPolicySpecExtAuthGrpcBackendRefs#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendRefs#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the backend. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendRefs#namespace
   */
  readonly namespace?: string;

  /**
   * Port specifies the destination port number to use for this resource.
   * Port is required when the referent is a Kubernetes Service. In this
   * case, the port number is the service port number, not the target port.
   * For other resources, destination port might be derived from the referent
   * resource or this field.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendRefs#port
   */
  readonly port?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendRefs(obj: SecurityPolicySpecExtAuthGrpcBackendRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fallback': obj.fallback,
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendSettings holds configuration for managing the connection
 * to the backend.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettings
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettings {
  /**
   * Circuit Breaker settings for the upstream connections and requests.
   * If not set, circuit breakers will be enabled with the default thresholds
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettings#circuitBreaker
   */
  readonly circuitBreaker?: SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreaker;

  /**
   * Connection includes backend connection settings.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettings#connection
   */
  readonly connection?: SecurityPolicySpecExtAuthGrpcBackendSettingsConnection;

  /**
   * DNS includes dns resolution settings.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettings#dns
   */
  readonly dns?: SecurityPolicySpecExtAuthGrpcBackendSettingsDns;

  /**
   * HealthCheck allows gateway to perform active health checking on backends.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettings#healthCheck
   */
  readonly healthCheck?: SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheck;

  /**
   * HTTP2 provides HTTP/2 configuration for backend connections.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettings#http2
   */
  readonly http2?: SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2;

  /**
   * LoadBalancer policy to apply when routing traffic from the gateway to
   * the backend endpoints. Defaults to `LeastRequest`.
   *
   * @default LeastRequest`.
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettings#loadBalancer
   */
  readonly loadBalancer?: SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancer;

  /**
   * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettings#proxyProtocol
   */
  readonly proxyProtocol?: SecurityPolicySpecExtAuthGrpcBackendSettingsProxyProtocol;

  /**
   * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
   * If not set, retry will be disabled.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettings#retry
   */
  readonly retry?: SecurityPolicySpecExtAuthGrpcBackendSettingsRetry;

  /**
   * TcpKeepalive settings associated with the upstream client connection.
   * Disabled by default.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettings#tcpKeepalive
   */
  readonly tcpKeepalive?: SecurityPolicySpecExtAuthGrpcBackendSettingsTcpKeepalive;

  /**
   * Timeout settings for the backend connections.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettings#timeout
   */
  readonly timeout?: SecurityPolicySpecExtAuthGrpcBackendSettingsTimeout;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettings(obj: SecurityPolicySpecExtAuthGrpcBackendSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'circuitBreaker': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreaker(obj.circuitBreaker),
    'connection': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsConnection(obj.connection),
    'dns': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsDns(obj.dns),
    'healthCheck': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheck(obj.healthCheck),
    'http2': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2(obj.http2),
    'loadBalancer': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancer(obj.loadBalancer),
    'proxyProtocol': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsProxyProtocol(obj.proxyProtocol),
    'retry': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsRetry(obj.retry),
    'tcpKeepalive': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsTcpKeepalive(obj.tcpKeepalive),
    'timeout': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsTimeout(obj.timeout),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendRef references a Kubernetes object that represents the
 * backend server to which the authorization request will be sent.
 *
 * Deprecated: Use BackendRefs instead.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendRef
 */
export interface SecurityPolicySpecExtAuthHttpBackendRef {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendRef#group
   */
  readonly group?: string;

  /**
   * Kind is the Kubernetes resource kind of the referent. For example
   * "Service".
   *
   * Defaults to "Service" when not specified.
   *
   * ExternalName services can refer to CNAME DNS records that may live
   * outside of the cluster and as such are difficult to reason about in
   * terms of conformance. They also may not be safe to forward to (see
   * CVE-2021-25740 for more information). Implementations SHOULD NOT
   * support ExternalName Services.
   *
   * Support: Core (Services with a type other than ExternalName)
   *
   * Support: Implementation-specific (Services with type ExternalName)
   *
   * @default Service" when not specified.
   * @schema SecurityPolicySpecExtAuthHttpBackendRef#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the backend. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendRef#namespace
   */
  readonly namespace?: string;

  /**
   * Port specifies the destination port number to use for this resource.
   * Port is required when the referent is a Kubernetes Service. In this
   * case, the port number is the service port number, not the target port.
   * For other resources, destination port might be derived from the referent
   * resource or this field.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendRef#port
   */
  readonly port?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendRef(obj: SecurityPolicySpecExtAuthHttpBackendRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendRef defines how an ObjectReference that is specific to BackendRef.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendRefs
 */
export interface SecurityPolicySpecExtAuthHttpBackendRefs {
  /**
   * Fallback indicates whether the backend is designated as a fallback.
   * Multiple fallback backends can be configured.
   * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
   * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
   * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
   * the health of the active backends falls below 72%.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendRefs#fallback
   */
  readonly fallback?: boolean;

  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendRefs#group
   */
  readonly group?: string;

  /**
   * Kind is the Kubernetes resource kind of the referent. For example
   * "Service".
   *
   * Defaults to "Service" when not specified.
   *
   * ExternalName services can refer to CNAME DNS records that may live
   * outside of the cluster and as such are difficult to reason about in
   * terms of conformance. They also may not be safe to forward to (see
   * CVE-2021-25740 for more information). Implementations SHOULD NOT
   * support ExternalName Services.
   *
   * Support: Core (Services with a type other than ExternalName)
   *
   * Support: Implementation-specific (Services with type ExternalName)
   *
   * @default Service" when not specified.
   * @schema SecurityPolicySpecExtAuthHttpBackendRefs#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendRefs#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the backend. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendRefs#namespace
   */
  readonly namespace?: string;

  /**
   * Port specifies the destination port number to use for this resource.
   * Port is required when the referent is a Kubernetes Service. In this
   * case, the port number is the service port number, not the target port.
   * For other resources, destination port might be derived from the referent
   * resource or this field.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendRefs#port
   */
  readonly port?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendRefs(obj: SecurityPolicySpecExtAuthHttpBackendRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fallback': obj.fallback,
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendSettings holds configuration for managing the connection
 * to the backend.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettings
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettings {
  /**
   * Circuit Breaker settings for the upstream connections and requests.
   * If not set, circuit breakers will be enabled with the default thresholds
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettings#circuitBreaker
   */
  readonly circuitBreaker?: SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreaker;

  /**
   * Connection includes backend connection settings.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettings#connection
   */
  readonly connection?: SecurityPolicySpecExtAuthHttpBackendSettingsConnection;

  /**
   * DNS includes dns resolution settings.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettings#dns
   */
  readonly dns?: SecurityPolicySpecExtAuthHttpBackendSettingsDns;

  /**
   * HealthCheck allows gateway to perform active health checking on backends.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettings#healthCheck
   */
  readonly healthCheck?: SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheck;

  /**
   * HTTP2 provides HTTP/2 configuration for backend connections.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettings#http2
   */
  readonly http2?: SecurityPolicySpecExtAuthHttpBackendSettingsHttp2;

  /**
   * LoadBalancer policy to apply when routing traffic from the gateway to
   * the backend endpoints. Defaults to `LeastRequest`.
   *
   * @default LeastRequest`.
   * @schema SecurityPolicySpecExtAuthHttpBackendSettings#loadBalancer
   */
  readonly loadBalancer?: SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancer;

  /**
   * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettings#proxyProtocol
   */
  readonly proxyProtocol?: SecurityPolicySpecExtAuthHttpBackendSettingsProxyProtocol;

  /**
   * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
   * If not set, retry will be disabled.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettings#retry
   */
  readonly retry?: SecurityPolicySpecExtAuthHttpBackendSettingsRetry;

  /**
   * TcpKeepalive settings associated with the upstream client connection.
   * Disabled by default.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettings#tcpKeepalive
   */
  readonly tcpKeepalive?: SecurityPolicySpecExtAuthHttpBackendSettingsTcpKeepalive;

  /**
   * Timeout settings for the backend connections.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettings#timeout
   */
  readonly timeout?: SecurityPolicySpecExtAuthHttpBackendSettingsTimeout;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettings(obj: SecurityPolicySpecExtAuthHttpBackendSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'circuitBreaker': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreaker(obj.circuitBreaker),
    'connection': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsConnection(obj.connection),
    'dns': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsDns(obj.dns),
    'healthCheck': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheck(obj.healthCheck),
    'http2': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsHttp2(obj.http2),
    'loadBalancer': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancer(obj.loadBalancer),
    'proxyProtocol': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsProxyProtocol(obj.proxyProtocol),
    'retry': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsRetry(obj.retry),
    'tcpKeepalive': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsTcpKeepalive(obj.tcpKeepalive),
    'timeout': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsTimeout(obj.timeout),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClaimToHeader defines a configuration to convert JWT claims into HTTP headers
 *
 * @schema SecurityPolicySpecJwtProvidersClaimToHeaders
 */
export interface SecurityPolicySpecJwtProvidersClaimToHeaders {
  /**
   * Claim is the JWT Claim that should be saved into the header : it can be a nested claim of type
   * (eg. "claim.nested.key", "sub"). The nested claim name must use dot "."
   * to separate the JSON name path.
   *
   * @schema SecurityPolicySpecJwtProvidersClaimToHeaders#claim
   */
  readonly claim: string;

  /**
   * Header defines the name of the HTTP request header that the JWT Claim will be saved into.
   *
   * @schema SecurityPolicySpecJwtProvidersClaimToHeaders#header
   */
  readonly header: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersClaimToHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersClaimToHeaders(obj: SecurityPolicySpecJwtProvidersClaimToHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claim': obj.claim,
    'header': obj.header,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExtractFrom defines different ways to extract the JWT token from HTTP request.
 * If empty, it defaults to extract JWT token from the Authorization HTTP request header using Bearer schema
 * or access_token from query parameters.
 *
 * @schema SecurityPolicySpecJwtProvidersExtractFrom
 */
export interface SecurityPolicySpecJwtProvidersExtractFrom {
  /**
   * Cookies represents a list of cookie names to extract the JWT token from.
   *
   * @schema SecurityPolicySpecJwtProvidersExtractFrom#cookies
   */
  readonly cookies?: string[];

  /**
   * Headers represents a list of HTTP request headers to extract the JWT token from.
   *
   * @schema SecurityPolicySpecJwtProvidersExtractFrom#headers
   */
  readonly headers?: SecurityPolicySpecJwtProvidersExtractFromHeaders[];

  /**
   * Params represents a list of query parameters to extract the JWT token from.
   *
   * @schema SecurityPolicySpecJwtProvidersExtractFrom#params
   */
  readonly params?: string[];
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersExtractFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersExtractFrom(obj: SecurityPolicySpecJwtProvidersExtractFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookies': obj.cookies?.map(y => y),
    'headers': obj.headers?.map(y => toJson_SecurityPolicySpecJwtProvidersExtractFromHeaders(y)),
    'params': obj.params?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalJWKS defines how to get the JSON Web Key Sets (JWKS) from a local source.
 *
 * @schema SecurityPolicySpecJwtProvidersLocalJwks
 */
export interface SecurityPolicySpecJwtProvidersLocalJwks {
  /**
   * Inline contains the value as an inline string.
   *
   * @schema SecurityPolicySpecJwtProvidersLocalJwks#inline
   */
  readonly inline?: string;

  /**
   * Type is the type of method to use to read the body value.
   * Valid values are Inline and ValueRef, default is Inline.
   *
   * @schema SecurityPolicySpecJwtProvidersLocalJwks#type
   */
  readonly type: SecurityPolicySpecJwtProvidersLocalJwksType;

  /**
   * ValueRef is a reference to a local ConfigMap that contains the JSON Web Key Sets (JWKS).
   *
   * The value of key `jwks` in the ConfigMap will be used.
   * If the key is not found, the first value in the ConfigMap will be used.
   *
   * @schema SecurityPolicySpecJwtProvidersLocalJwks#valueRef
   */
  readonly valueRef?: SecurityPolicySpecJwtProvidersLocalJwksValueRef;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersLocalJwks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersLocalJwks(obj: SecurityPolicySpecJwtProvidersLocalJwks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inline': obj.inline,
    'type': obj.type,
    'valueRef': toJson_SecurityPolicySpecJwtProvidersLocalJwksValueRef(obj.valueRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RemoteJWKS defines how to fetch and cache JSON Web Key Sets (JWKS) from a remote
 * HTTP/HTTPS endpoint.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwks
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwks {
  /**
   * BackendRef references a Kubernetes object that represents the
   * backend server to which the authorization request will be sent.
   *
   * Deprecated: Use BackendRefs instead.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwks#backendRef
   */
  readonly backendRef?: SecurityPolicySpecJwtProvidersRemoteJwksBackendRef;

  /**
   * BackendRefs references a Kubernetes object that represents the
   * backend server to which the authorization request will be sent.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwks#backendRefs
   */
  readonly backendRefs?: SecurityPolicySpecJwtProvidersRemoteJwksBackendRefs[];

  /**
   * BackendSettings holds configuration for managing the connection
   * to the backend.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwks#backendSettings
   */
  readonly backendSettings?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettings;

  /**
   * Duration is a string value representing a duration in time. The format is as specified
   * in GEP-2257, a strict subset of the syntax parsed by Golang time.ParseDuration.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwks#cacheDuration
   */
  readonly cacheDuration?: string;

  /**
   * URI is the HTTPS URI to fetch the JWKS. Envoy's system trust bundle is used to validate the server certificate.
   * If a custom trust bundle is needed, it can be specified in a BackendTLSConfig resource and target the BackendRefs.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwks#uri
   */
  readonly uri: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwks(obj: SecurityPolicySpecJwtProvidersRemoteJwks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendRef': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendRef(obj.backendRef),
    'backendRefs': obj.backendRefs?.map(y => toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendRefs(y)),
    'backendSettings': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettings(obj.backendSettings),
    'cacheDuration': obj.cacheDuration,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SecurityPolicySpecOidcCookieConfigSameSite
 */
export enum SecurityPolicySpecOidcCookieConfigSameSite {
  /** Lax */
  LAX = "Lax",
  /** Strict */
  STRICT = "Strict",
  /** None */
  NONE = "None",
}

/**
 * OIDCDenyRedirectHeader defines how a header is matched
 *
 * @schema SecurityPolicySpecOidcDenyRedirectHeaders
 */
export interface SecurityPolicySpecOidcDenyRedirectHeaders {
  /**
   * Specifies the name of the header in the request.
   *
   * @schema SecurityPolicySpecOidcDenyRedirectHeaders#name
   */
  readonly name: string;

  /**
   * Type specifies how to match against a string.
   *
   * @schema SecurityPolicySpecOidcDenyRedirectHeaders#type
   */
  readonly type?: SecurityPolicySpecOidcDenyRedirectHeadersType;

  /**
   * Value specifies the string value that the match must have.
   *
   * @schema SecurityPolicySpecOidcDenyRedirectHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcDenyRedirectHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcDenyRedirectHeaders(obj: SecurityPolicySpecOidcDenyRedirectHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendRef references a Kubernetes object that represents the
 * backend server to which the authorization request will be sent.
 *
 * Deprecated: Use BackendRefs instead.
 *
 * @schema SecurityPolicySpecOidcProviderBackendRef
 */
export interface SecurityPolicySpecOidcProviderBackendRef {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema SecurityPolicySpecOidcProviderBackendRef#group
   */
  readonly group?: string;

  /**
   * Kind is the Kubernetes resource kind of the referent. For example
   * "Service".
   *
   * Defaults to "Service" when not specified.
   *
   * ExternalName services can refer to CNAME DNS records that may live
   * outside of the cluster and as such are difficult to reason about in
   * terms of conformance. They also may not be safe to forward to (see
   * CVE-2021-25740 for more information). Implementations SHOULD NOT
   * support ExternalName Services.
   *
   * Support: Core (Services with a type other than ExternalName)
   *
   * Support: Implementation-specific (Services with type ExternalName)
   *
   * @default Service" when not specified.
   * @schema SecurityPolicySpecOidcProviderBackendRef#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema SecurityPolicySpecOidcProviderBackendRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the backend. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema SecurityPolicySpecOidcProviderBackendRef#namespace
   */
  readonly namespace?: string;

  /**
   * Port specifies the destination port number to use for this resource.
   * Port is required when the referent is a Kubernetes Service. In this
   * case, the port number is the service port number, not the target port.
   * For other resources, destination port might be derived from the referent
   * resource or this field.
   *
   * @schema SecurityPolicySpecOidcProviderBackendRef#port
   */
  readonly port?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendRef(obj: SecurityPolicySpecOidcProviderBackendRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendRef defines how an ObjectReference that is specific to BackendRef.
 *
 * @schema SecurityPolicySpecOidcProviderBackendRefs
 */
export interface SecurityPolicySpecOidcProviderBackendRefs {
  /**
   * Fallback indicates whether the backend is designated as a fallback.
   * Multiple fallback backends can be configured.
   * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
   * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
   * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
   * the health of the active backends falls below 72%.
   *
   * @schema SecurityPolicySpecOidcProviderBackendRefs#fallback
   */
  readonly fallback?: boolean;

  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema SecurityPolicySpecOidcProviderBackendRefs#group
   */
  readonly group?: string;

  /**
   * Kind is the Kubernetes resource kind of the referent. For example
   * "Service".
   *
   * Defaults to "Service" when not specified.
   *
   * ExternalName services can refer to CNAME DNS records that may live
   * outside of the cluster and as such are difficult to reason about in
   * terms of conformance. They also may not be safe to forward to (see
   * CVE-2021-25740 for more information). Implementations SHOULD NOT
   * support ExternalName Services.
   *
   * Support: Core (Services with a type other than ExternalName)
   *
   * Support: Implementation-specific (Services with type ExternalName)
   *
   * @default Service" when not specified.
   * @schema SecurityPolicySpecOidcProviderBackendRefs#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema SecurityPolicySpecOidcProviderBackendRefs#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the backend. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema SecurityPolicySpecOidcProviderBackendRefs#namespace
   */
  readonly namespace?: string;

  /**
   * Port specifies the destination port number to use for this resource.
   * Port is required when the referent is a Kubernetes Service. In this
   * case, the port number is the service port number, not the target port.
   * For other resources, destination port might be derived from the referent
   * resource or this field.
   *
   * @schema SecurityPolicySpecOidcProviderBackendRefs#port
   */
  readonly port?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendRefs(obj: SecurityPolicySpecOidcProviderBackendRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fallback': obj.fallback,
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendSettings holds configuration for managing the connection
 * to the backend.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettings
 */
export interface SecurityPolicySpecOidcProviderBackendSettings {
  /**
   * Circuit Breaker settings for the upstream connections and requests.
   * If not set, circuit breakers will be enabled with the default thresholds
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettings#circuitBreaker
   */
  readonly circuitBreaker?: SecurityPolicySpecOidcProviderBackendSettingsCircuitBreaker;

  /**
   * Connection includes backend connection settings.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettings#connection
   */
  readonly connection?: SecurityPolicySpecOidcProviderBackendSettingsConnection;

  /**
   * DNS includes dns resolution settings.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettings#dns
   */
  readonly dns?: SecurityPolicySpecOidcProviderBackendSettingsDns;

  /**
   * HealthCheck allows gateway to perform active health checking on backends.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettings#healthCheck
   */
  readonly healthCheck?: SecurityPolicySpecOidcProviderBackendSettingsHealthCheck;

  /**
   * HTTP2 provides HTTP/2 configuration for backend connections.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettings#http2
   */
  readonly http2?: SecurityPolicySpecOidcProviderBackendSettingsHttp2;

  /**
   * LoadBalancer policy to apply when routing traffic from the gateway to
   * the backend endpoints. Defaults to `LeastRequest`.
   *
   * @default LeastRequest`.
   * @schema SecurityPolicySpecOidcProviderBackendSettings#loadBalancer
   */
  readonly loadBalancer?: SecurityPolicySpecOidcProviderBackendSettingsLoadBalancer;

  /**
   * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettings#proxyProtocol
   */
  readonly proxyProtocol?: SecurityPolicySpecOidcProviderBackendSettingsProxyProtocol;

  /**
   * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
   * If not set, retry will be disabled.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettings#retry
   */
  readonly retry?: SecurityPolicySpecOidcProviderBackendSettingsRetry;

  /**
   * TcpKeepalive settings associated with the upstream client connection.
   * Disabled by default.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettings#tcpKeepalive
   */
  readonly tcpKeepalive?: SecurityPolicySpecOidcProviderBackendSettingsTcpKeepalive;

  /**
   * Timeout settings for the backend connections.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettings#timeout
   */
  readonly timeout?: SecurityPolicySpecOidcProviderBackendSettingsTimeout;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettings(obj: SecurityPolicySpecOidcProviderBackendSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'circuitBreaker': toJson_SecurityPolicySpecOidcProviderBackendSettingsCircuitBreaker(obj.circuitBreaker),
    'connection': toJson_SecurityPolicySpecOidcProviderBackendSettingsConnection(obj.connection),
    'dns': toJson_SecurityPolicySpecOidcProviderBackendSettingsDns(obj.dns),
    'healthCheck': toJson_SecurityPolicySpecOidcProviderBackendSettingsHealthCheck(obj.healthCheck),
    'http2': toJson_SecurityPolicySpecOidcProviderBackendSettingsHttp2(obj.http2),
    'loadBalancer': toJson_SecurityPolicySpecOidcProviderBackendSettingsLoadBalancer(obj.loadBalancer),
    'proxyProtocol': toJson_SecurityPolicySpecOidcProviderBackendSettingsProxyProtocol(obj.proxyProtocol),
    'retry': toJson_SecurityPolicySpecOidcProviderBackendSettingsRetry(obj.retry),
    'tcpKeepalive': toJson_SecurityPolicySpecOidcProviderBackendSettingsTcpKeepalive(obj.tcpKeepalive),
    'timeout': toJson_SecurityPolicySpecOidcProviderBackendSettingsTimeout(obj.timeout),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPMethod describes how to select a HTTP route by matching the HTTP
 * method as defined by
 * [RFC 7231](https://datatracker.ietf.org/doc/html/rfc7231#section-4) and
 * [RFC 5789](https://datatracker.ietf.org/doc/html/rfc5789#section-2).
 * The value is expected in upper case.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * @schema SecurityPolicySpecAuthorizationRulesOperationMethods
 */
export enum SecurityPolicySpecAuthorizationRulesOperationMethods {
  /** GET */
  GET = "GET",
  /** HEAD */
  HEAD = "HEAD",
  /** POST */
  POST = "POST",
  /** PUT */
  PUT = "PUT",
  /** DELETE */
  DELETE = "DELETE",
  /** CONNECT */
  CONNECT = "CONNECT",
  /** OPTIONS */
  OPTIONS = "OPTIONS",
  /** TRACE */
  TRACE = "TRACE",
  /** PATCH */
  PATCH = "PATCH",
}

/**
 * AuthorizationHeaderMatch specifies how to match against the value of an HTTP header within a authorization rule.
 *
 * @schema SecurityPolicySpecAuthorizationRulesPrincipalHeaders
 */
export interface SecurityPolicySpecAuthorizationRulesPrincipalHeaders {
  /**
   * Name of the HTTP header.
   * The header name is case-insensitive unless PreserveHeaderCase is set to true.
   * For example, "Foo" and "foo" are considered the same header.
   *
   * @schema SecurityPolicySpecAuthorizationRulesPrincipalHeaders#name
   */
  readonly name: string;

  /**
   * Values are the values that the header must match.
   * If multiple values are specified, the rule will match if any of the values match.
   *
   * @schema SecurityPolicySpecAuthorizationRulesPrincipalHeaders#values
   */
  readonly values: string[];
}

/**
 * Converts an object of type 'SecurityPolicySpecAuthorizationRulesPrincipalHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecAuthorizationRulesPrincipalHeaders(obj: SecurityPolicySpecAuthorizationRulesPrincipalHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * JWT authorize the request based on the JWT claims and scopes.
 * Note: in order to use JWT claims for authorization, you must configure the
 * JWT authentication in the same `SecurityPolicy`.
 *
 * @schema SecurityPolicySpecAuthorizationRulesPrincipalJwt
 */
export interface SecurityPolicySpecAuthorizationRulesPrincipalJwt {
  /**
   * Claims are the claims in a JWT token.
   *
   * If multiple claims are specified, all claims must match for the rule to match.
   * For example, if there are two claims: one for the audience and one for the issuer,
   * the rule will match only if both the audience and the issuer match.
   *
   * @schema SecurityPolicySpecAuthorizationRulesPrincipalJwt#claims
   */
  readonly claims?: SecurityPolicySpecAuthorizationRulesPrincipalJwtClaims[];

  /**
   * Provider is the name of the JWT provider that used to verify the JWT token.
   * In order to use JWT claims for authorization, you must configure the JWT
   * authentication with the same provider in the same `SecurityPolicy`.
   *
   * @schema SecurityPolicySpecAuthorizationRulesPrincipalJwt#provider
   */
  readonly provider: string;

  /**
   * Scopes are a special type of claim in a JWT token that represents the permissions of the client.
   *
   * The value of the scopes field should be a space delimited string that is expected in the scope parameter,
   * as defined in RFC 6749: https://datatracker.ietf.org/doc/html/rfc6749#page-23.
   *
   * If multiple scopes are specified, all scopes must match for the rule to match.
   *
   * @schema SecurityPolicySpecAuthorizationRulesPrincipalJwt#scopes
   */
  readonly scopes?: string[];
}

/**
 * Converts an object of type 'SecurityPolicySpecAuthorizationRulesPrincipalJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecAuthorizationRulesPrincipalJwt(obj: SecurityPolicySpecAuthorizationRulesPrincipalJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_SecurityPolicySpecAuthorizationRulesPrincipalJwtClaims(y)),
    'provider': obj.provider,
    'scopes': obj.scopes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Circuit Breaker settings for the upstream connections and requests.
 * If not set, circuit breakers will be enabled with the default thresholds
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreaker
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreaker {
  /**
   * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreaker#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreaker#maxParallelRequests
   */
  readonly maxParallelRequests?: number;

  /**
   * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreaker#maxParallelRetries
   */
  readonly maxParallelRetries?: number;

  /**
   * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreaker#maxPendingRequests
   */
  readonly maxPendingRequests?: number;

  /**
   * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
   * Default: unlimited.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreaker#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreaker#perEndpoint
   */
  readonly perEndpoint?: SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreakerPerEndpoint;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreaker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreaker(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreaker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
    'maxParallelRequests': obj.maxParallelRequests,
    'maxParallelRetries': obj.maxParallelRetries,
    'maxPendingRequests': obj.maxPendingRequests,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'perEndpoint': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreakerPerEndpoint(obj.perEndpoint),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Connection includes backend connection settings.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsConnection
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsConnection {
  /**
   * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
   * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
   * If unspecified, an implementation defined default is applied (32768 bytes).
   * For example, 20Mi, 1Gi, 256Ki etc.
   * Note: that when the suffix is not provided, the value is interpreted as bytes.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsConnection#bufferLimit
   */
  readonly bufferLimit?: SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionBufferLimit;

  /**
   * Preconnect configures proactive upstream connections to reduce latency by establishing
   * connections before they’re needed and avoiding connection establishment overhead.
   *
   * If unset, Envoy will fetch connections as needed to serve in-flight requests.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsConnection#preconnect
   */
  readonly preconnect?: SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionPreconnect;

  /**
   * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
   * to backend.
   * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
   * For example, 20Mi, 1Gi, 256Ki etc.
   * Note that when the suffix is not provided, the value is interpreted as bytes.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsConnection#socketBufferLimit
   */
  readonly socketBufferLimit?: SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionSocketBufferLimit;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsConnection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsConnection(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsConnection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bufferLimit': obj.bufferLimit?.value,
    'preconnect': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionPreconnect(obj.preconnect),
    'socketBufferLimit': obj.socketBufferLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DNS includes dns resolution settings.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsDns
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsDns {
  /**
   * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
   * Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsDns#dnsRefreshRate
   */
  readonly dnsRefreshRate?: string;

  /**
   * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
   * If set, this configuration overrides other defaults.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsDns#lookupFamily
   */
  readonly lookupFamily?: SecurityPolicySpecExtAuthGrpcBackendSettingsDnsLookupFamily;

  /**
   * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
   * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
   * Defaults to true.
   *
   * @default true.
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsDns#respectDnsTtl
   */
  readonly respectDnsTtl?: boolean;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsDns' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsDns(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsDns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsRefreshRate': obj.dnsRefreshRate,
    'lookupFamily': obj.lookupFamily,
    'respectDnsTtl': obj.respectDnsTtl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HealthCheck allows gateway to perform active health checking on backends.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheck
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheck {
  /**
   * Active health check configuration
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheck#active
   */
  readonly active?: SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActive;

  /**
   * When number of unhealthy endpoints for a backend reaches this threshold
   * Envoy will disregard health status and balance across all endpoints.
   * It's designed to prevent a situation in which host failures cascade throughout the cluster
   * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheck#panicThreshold
   */
  readonly panicThreshold?: number;

  /**
   * Passive passive check configuration
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheck#passive
   */
  readonly passive?: SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckPassive;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheck(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'active': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActive(obj.active),
    'panicThreshold': obj.panicThreshold,
    'passive': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckPassive(obj.passive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP2 provides HTTP/2 configuration for backend connections.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2 {
  /**
   * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
   * If not set, the default value is 1 MiB.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2#initialConnectionWindowSize
   */
  readonly initialConnectionWindowSize?: SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2InitialConnectionWindowSize;

  /**
   * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
   * If not set, the default value is 64 KiB(64*1024).
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2#initialStreamWindowSize
   */
  readonly initialStreamWindowSize?: SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2InitialStreamWindowSize;

  /**
   * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
   * If not set, the default value is 100.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
   * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
   * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
   * Default: TerminateConnection
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2#onInvalidMessage
   */
  readonly onInvalidMessage?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'initialConnectionWindowSize': obj.initialConnectionWindowSize?.value,
    'initialStreamWindowSize': obj.initialStreamWindowSize?.value,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'onInvalidMessage': obj.onInvalidMessage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LoadBalancer policy to apply when routing traffic from the gateway to
 * the backend endpoints. Defaults to `LeastRequest`.
 *
 * @default LeastRequest`.
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancer
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancer {
  /**
   * ConsistentHash defines the configuration when the load balancer type is
   * set to ConsistentHash
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancer#consistentHash
   */
  readonly consistentHash?: SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHash;

  /**
   * EndpointOverride defines the configuration for endpoint override.
   * When specified, the load balancer will attempt to route requests to endpoints
   * based on the override information extracted from request headers or metadata.
   * If the override endpoints are not available, the configured load balancer policy will be used as fallback.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancer#endpointOverride
   */
  readonly endpointOverride?: SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverride;

  /**
   * SlowStart defines the configuration related to the slow start load balancer policy.
   * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
   * Currently this is only supported for RoundRobin and LeastRequest load balancers
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancer#slowStart
   */
  readonly slowStart?: SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerSlowStart;

  /**
   * Type decides the type of Load Balancer policy.
   * Valid LoadBalancerType values are
   * "ConsistentHash",
   * "LeastRequest",
   * "Random",
   * "RoundRobin".
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancer#type
   */
  readonly type: SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerType;

  /**
   * ZoneAware defines the configuration related to the distribution of requests between locality zones.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancer#zoneAware
   */
  readonly zoneAware?: SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAware;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancer(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHash(obj.consistentHash),
    'endpointOverride': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverride(obj.endpointOverride),
    'slowStart': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerSlowStart(obj.slowStart),
    'type': obj.type,
    'zoneAware': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAware(obj.zoneAware),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsProxyProtocol
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsProxyProtocol {
  /**
   * Version of ProxyProtol
   * Valid ProxyProtocolVersion values are
   * "V1"
   * "V2"
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsProxyProtocol#version
   */
  readonly version: SecurityPolicySpecExtAuthGrpcBackendSettingsProxyProtocolVersion;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsProxyProtocol' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsProxyProtocol(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsProxyProtocol | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
 * If not set, retry will be disabled.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsRetry
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsRetry {
  /**
   * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
   * that should be sent to the same priority before switching to a different one.
   * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsRetry#numAttemptsPerPriority
   */
  readonly numAttemptsPerPriority?: number;

  /**
   * NumRetries is the number of retries to be attempted. Defaults to 2.
   *
   * @default 2.
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsRetry#numRetries
   */
  readonly numRetries?: number;

  /**
   * PerRetry is the retry policy to be applied per retry attempt.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsRetry#perRetry
   */
  readonly perRetry?: SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetry;

  /**
   * RetryOn specifies the retry trigger condition.
   *
   * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsRetry#retryOn
   */
  readonly retryOn?: SecurityPolicySpecExtAuthGrpcBackendSettingsRetryRetryOn;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsRetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsRetry(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'numAttemptsPerPriority': obj.numAttemptsPerPriority,
    'numRetries': obj.numRetries,
    'perRetry': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetry(obj.perRetry),
    'retryOn': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsRetryRetryOn(obj.retryOn),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TcpKeepalive settings associated with the upstream client connection.
 * Disabled by default.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsTcpKeepalive
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsTcpKeepalive {
  /**
   * The duration a connection needs to be idle before keep-alive
   * probes start being sent.
   * The duration format is
   * Defaults to `7200s`.
   *
   * @default 7200s`.
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsTcpKeepalive#idleTime
   */
  readonly idleTime?: string;

  /**
   * The duration between keep-alive probes.
   * Defaults to `75s`.
   *
   * @default 75s`.
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * The total number of unacknowledged probes to send before deciding
   * the connection is dead.
   * Defaults to 9.
   *
   * @default 9.
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsTcpKeepalive#probes
   */
  readonly probes?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsTcpKeepalive(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idleTime': obj.idleTime,
    'interval': obj.interval,
    'probes': obj.probes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for the backend connections.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsTimeout
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsTimeout {
  /**
   * Timeout settings for HTTP.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsTimeout#http
   */
  readonly http?: SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutHttp;

  /**
   * Timeout settings for TCP.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsTimeout#tcp
   */
  readonly tcp?: SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutTcp;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsTimeout' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsTimeout(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutHttp(obj.http),
    'tcp': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Circuit Breaker settings for the upstream connections and requests.
 * If not set, circuit breakers will be enabled with the default thresholds
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreaker
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreaker {
  /**
   * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreaker#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreaker#maxParallelRequests
   */
  readonly maxParallelRequests?: number;

  /**
   * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreaker#maxParallelRetries
   */
  readonly maxParallelRetries?: number;

  /**
   * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreaker#maxPendingRequests
   */
  readonly maxPendingRequests?: number;

  /**
   * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
   * Default: unlimited.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreaker#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreaker#perEndpoint
   */
  readonly perEndpoint?: SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreakerPerEndpoint;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreaker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreaker(obj: SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreaker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
    'maxParallelRequests': obj.maxParallelRequests,
    'maxParallelRetries': obj.maxParallelRetries,
    'maxPendingRequests': obj.maxPendingRequests,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'perEndpoint': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreakerPerEndpoint(obj.perEndpoint),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Connection includes backend connection settings.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsConnection
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsConnection {
  /**
   * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
   * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
   * If unspecified, an implementation defined default is applied (32768 bytes).
   * For example, 20Mi, 1Gi, 256Ki etc.
   * Note: that when the suffix is not provided, the value is interpreted as bytes.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsConnection#bufferLimit
   */
  readonly bufferLimit?: SecurityPolicySpecExtAuthHttpBackendSettingsConnectionBufferLimit;

  /**
   * Preconnect configures proactive upstream connections to reduce latency by establishing
   * connections before they’re needed and avoiding connection establishment overhead.
   *
   * If unset, Envoy will fetch connections as needed to serve in-flight requests.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsConnection#preconnect
   */
  readonly preconnect?: SecurityPolicySpecExtAuthHttpBackendSettingsConnectionPreconnect;

  /**
   * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
   * to backend.
   * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
   * For example, 20Mi, 1Gi, 256Ki etc.
   * Note that when the suffix is not provided, the value is interpreted as bytes.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsConnection#socketBufferLimit
   */
  readonly socketBufferLimit?: SecurityPolicySpecExtAuthHttpBackendSettingsConnectionSocketBufferLimit;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsConnection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsConnection(obj: SecurityPolicySpecExtAuthHttpBackendSettingsConnection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bufferLimit': obj.bufferLimit?.value,
    'preconnect': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsConnectionPreconnect(obj.preconnect),
    'socketBufferLimit': obj.socketBufferLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DNS includes dns resolution settings.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsDns
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsDns {
  /**
   * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
   * Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsDns#dnsRefreshRate
   */
  readonly dnsRefreshRate?: string;

  /**
   * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
   * If set, this configuration overrides other defaults.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsDns#lookupFamily
   */
  readonly lookupFamily?: SecurityPolicySpecExtAuthHttpBackendSettingsDnsLookupFamily;

  /**
   * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
   * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
   * Defaults to true.
   *
   * @default true.
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsDns#respectDnsTtl
   */
  readonly respectDnsTtl?: boolean;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsDns' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsDns(obj: SecurityPolicySpecExtAuthHttpBackendSettingsDns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsRefreshRate': obj.dnsRefreshRate,
    'lookupFamily': obj.lookupFamily,
    'respectDnsTtl': obj.respectDnsTtl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HealthCheck allows gateway to perform active health checking on backends.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheck
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheck {
  /**
   * Active health check configuration
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheck#active
   */
  readonly active?: SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActive;

  /**
   * When number of unhealthy endpoints for a backend reaches this threshold
   * Envoy will disregard health status and balance across all endpoints.
   * It's designed to prevent a situation in which host failures cascade throughout the cluster
   * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheck#panicThreshold
   */
  readonly panicThreshold?: number;

  /**
   * Passive passive check configuration
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheck#passive
   */
  readonly passive?: SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckPassive;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheck(obj: SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'active': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActive(obj.active),
    'panicThreshold': obj.panicThreshold,
    'passive': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckPassive(obj.passive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP2 provides HTTP/2 configuration for backend connections.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHttp2
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsHttp2 {
  /**
   * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
   * If not set, the default value is 1 MiB.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHttp2#initialConnectionWindowSize
   */
  readonly initialConnectionWindowSize?: SecurityPolicySpecExtAuthHttpBackendSettingsHttp2InitialConnectionWindowSize;

  /**
   * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
   * If not set, the default value is 64 KiB(64*1024).
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHttp2#initialStreamWindowSize
   */
  readonly initialStreamWindowSize?: SecurityPolicySpecExtAuthHttpBackendSettingsHttp2InitialStreamWindowSize;

  /**
   * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
   * If not set, the default value is 100.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHttp2#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
   * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
   * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
   * Default: TerminateConnection
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHttp2#onInvalidMessage
   */
  readonly onInvalidMessage?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsHttp2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsHttp2(obj: SecurityPolicySpecExtAuthHttpBackendSettingsHttp2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'initialConnectionWindowSize': obj.initialConnectionWindowSize?.value,
    'initialStreamWindowSize': obj.initialStreamWindowSize?.value,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'onInvalidMessage': obj.onInvalidMessage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LoadBalancer policy to apply when routing traffic from the gateway to
 * the backend endpoints. Defaults to `LeastRequest`.
 *
 * @default LeastRequest`.
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancer
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancer {
  /**
   * ConsistentHash defines the configuration when the load balancer type is
   * set to ConsistentHash
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancer#consistentHash
   */
  readonly consistentHash?: SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHash;

  /**
   * EndpointOverride defines the configuration for endpoint override.
   * When specified, the load balancer will attempt to route requests to endpoints
   * based on the override information extracted from request headers or metadata.
   * If the override endpoints are not available, the configured load balancer policy will be used as fallback.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancer#endpointOverride
   */
  readonly endpointOverride?: SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverride;

  /**
   * SlowStart defines the configuration related to the slow start load balancer policy.
   * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
   * Currently this is only supported for RoundRobin and LeastRequest load balancers
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancer#slowStart
   */
  readonly slowStart?: SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerSlowStart;

  /**
   * Type decides the type of Load Balancer policy.
   * Valid LoadBalancerType values are
   * "ConsistentHash",
   * "LeastRequest",
   * "Random",
   * "RoundRobin".
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancer#type
   */
  readonly type: SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerType;

  /**
   * ZoneAware defines the configuration related to the distribution of requests between locality zones.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancer#zoneAware
   */
  readonly zoneAware?: SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAware;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancer(obj: SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHash(obj.consistentHash),
    'endpointOverride': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverride(obj.endpointOverride),
    'slowStart': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerSlowStart(obj.slowStart),
    'type': obj.type,
    'zoneAware': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAware(obj.zoneAware),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsProxyProtocol
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsProxyProtocol {
  /**
   * Version of ProxyProtol
   * Valid ProxyProtocolVersion values are
   * "V1"
   * "V2"
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsProxyProtocol#version
   */
  readonly version: SecurityPolicySpecExtAuthHttpBackendSettingsProxyProtocolVersion;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsProxyProtocol' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsProxyProtocol(obj: SecurityPolicySpecExtAuthHttpBackendSettingsProxyProtocol | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
 * If not set, retry will be disabled.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsRetry
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsRetry {
  /**
   * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
   * that should be sent to the same priority before switching to a different one.
   * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsRetry#numAttemptsPerPriority
   */
  readonly numAttemptsPerPriority?: number;

  /**
   * NumRetries is the number of retries to be attempted. Defaults to 2.
   *
   * @default 2.
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsRetry#numRetries
   */
  readonly numRetries?: number;

  /**
   * PerRetry is the retry policy to be applied per retry attempt.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsRetry#perRetry
   */
  readonly perRetry?: SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetry;

  /**
   * RetryOn specifies the retry trigger condition.
   *
   * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsRetry#retryOn
   */
  readonly retryOn?: SecurityPolicySpecExtAuthHttpBackendSettingsRetryRetryOn;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsRetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsRetry(obj: SecurityPolicySpecExtAuthHttpBackendSettingsRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'numAttemptsPerPriority': obj.numAttemptsPerPriority,
    'numRetries': obj.numRetries,
    'perRetry': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetry(obj.perRetry),
    'retryOn': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsRetryRetryOn(obj.retryOn),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TcpKeepalive settings associated with the upstream client connection.
 * Disabled by default.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsTcpKeepalive
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsTcpKeepalive {
  /**
   * The duration a connection needs to be idle before keep-alive
   * probes start being sent.
   * The duration format is
   * Defaults to `7200s`.
   *
   * @default 7200s`.
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsTcpKeepalive#idleTime
   */
  readonly idleTime?: string;

  /**
   * The duration between keep-alive probes.
   * Defaults to `75s`.
   *
   * @default 75s`.
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * The total number of unacknowledged probes to send before deciding
   * the connection is dead.
   * Defaults to 9.
   *
   * @default 9.
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsTcpKeepalive#probes
   */
  readonly probes?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsTcpKeepalive(obj: SecurityPolicySpecExtAuthHttpBackendSettingsTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idleTime': obj.idleTime,
    'interval': obj.interval,
    'probes': obj.probes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for the backend connections.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsTimeout
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsTimeout {
  /**
   * Timeout settings for HTTP.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsTimeout#http
   */
  readonly http?: SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutHttp;

  /**
   * Timeout settings for TCP.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsTimeout#tcp
   */
  readonly tcp?: SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutTcp;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsTimeout' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsTimeout(obj: SecurityPolicySpecExtAuthHttpBackendSettingsTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutHttp(obj.http),
    'tcp': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * JWTHeaderExtractor defines an HTTP header location to extract JWT token
 *
 * @schema SecurityPolicySpecJwtProvidersExtractFromHeaders
 */
export interface SecurityPolicySpecJwtProvidersExtractFromHeaders {
  /**
   * Name is the HTTP header name to retrieve the token
   *
   * @schema SecurityPolicySpecJwtProvidersExtractFromHeaders#name
   */
  readonly name: string;

  /**
   * ValuePrefix is the prefix that should be stripped before extracting the token.
   * The format would be used by Envoy like "{ValuePrefix}<TOKEN>".
   * For example, "Authorization: Bearer <TOKEN>", then the ValuePrefix="Bearer " with a space at the end.
   *
   * @schema SecurityPolicySpecJwtProvidersExtractFromHeaders#valuePrefix
   */
  readonly valuePrefix?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersExtractFromHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersExtractFromHeaders(obj: SecurityPolicySpecJwtProvidersExtractFromHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'valuePrefix': obj.valuePrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type is the type of method to use to read the body value.
 * Valid values are Inline and ValueRef, default is Inline.
 *
 * @schema SecurityPolicySpecJwtProvidersLocalJwksType
 */
export enum SecurityPolicySpecJwtProvidersLocalJwksType {
  /** Inline */
  INLINE = "Inline",
  /** ValueRef */
  VALUE_REF = "ValueRef",
}

/**
 * ValueRef is a reference to a local ConfigMap that contains the JSON Web Key Sets (JWKS).
 *
 * The value of key `jwks` in the ConfigMap will be used.
 * If the key is not found, the first value in the ConfigMap will be used.
 *
 * @schema SecurityPolicySpecJwtProvidersLocalJwksValueRef
 */
export interface SecurityPolicySpecJwtProvidersLocalJwksValueRef {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema SecurityPolicySpecJwtProvidersLocalJwksValueRef#group
   */
  readonly group: string;

  /**
   * Kind is kind of the referent. For example "HTTPRoute" or "Service".
   *
   * @schema SecurityPolicySpecJwtProvidersLocalJwksValueRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of the referent.
   *
   * @schema SecurityPolicySpecJwtProvidersLocalJwksValueRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersLocalJwksValueRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersLocalJwksValueRef(obj: SecurityPolicySpecJwtProvidersLocalJwksValueRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendRef references a Kubernetes object that represents the
 * backend server to which the authorization request will be sent.
 *
 * Deprecated: Use BackendRefs instead.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendRef
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendRef {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendRef#group
   */
  readonly group?: string;

  /**
   * Kind is the Kubernetes resource kind of the referent. For example
   * "Service".
   *
   * Defaults to "Service" when not specified.
   *
   * ExternalName services can refer to CNAME DNS records that may live
   * outside of the cluster and as such are difficult to reason about in
   * terms of conformance. They also may not be safe to forward to (see
   * CVE-2021-25740 for more information). Implementations SHOULD NOT
   * support ExternalName Services.
   *
   * Support: Core (Services with a type other than ExternalName)
   *
   * Support: Implementation-specific (Services with type ExternalName)
   *
   * @default Service" when not specified.
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendRef#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the backend. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendRef#namespace
   */
  readonly namespace?: string;

  /**
   * Port specifies the destination port number to use for this resource.
   * Port is required when the referent is a Kubernetes Service. In this
   * case, the port number is the service port number, not the target port.
   * For other resources, destination port might be derived from the referent
   * resource or this field.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendRef#port
   */
  readonly port?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendRef(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendRef defines how an ObjectReference that is specific to BackendRef.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendRefs
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendRefs {
  /**
   * Fallback indicates whether the backend is designated as a fallback.
   * Multiple fallback backends can be configured.
   * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
   * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
   * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
   * the health of the active backends falls below 72%.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendRefs#fallback
   */
  readonly fallback?: boolean;

  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendRefs#group
   */
  readonly group?: string;

  /**
   * Kind is the Kubernetes resource kind of the referent. For example
   * "Service".
   *
   * Defaults to "Service" when not specified.
   *
   * ExternalName services can refer to CNAME DNS records that may live
   * outside of the cluster and as such are difficult to reason about in
   * terms of conformance. They also may not be safe to forward to (see
   * CVE-2021-25740 for more information). Implementations SHOULD NOT
   * support ExternalName Services.
   *
   * Support: Core (Services with a type other than ExternalName)
   *
   * Support: Implementation-specific (Services with type ExternalName)
   *
   * @default Service" when not specified.
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendRefs#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendRefs#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the backend. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendRefs#namespace
   */
  readonly namespace?: string;

  /**
   * Port specifies the destination port number to use for this resource.
   * Port is required when the referent is a Kubernetes Service. In this
   * case, the port number is the service port number, not the target port.
   * For other resources, destination port might be derived from the referent
   * resource or this field.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendRefs#port
   */
  readonly port?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendRefs(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fallback': obj.fallback,
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackendSettings holds configuration for managing the connection
 * to the backend.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettings
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettings {
  /**
   * Circuit Breaker settings for the upstream connections and requests.
   * If not set, circuit breakers will be enabled with the default thresholds
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettings#circuitBreaker
   */
  readonly circuitBreaker?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsCircuitBreaker;

  /**
   * Connection includes backend connection settings.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettings#connection
   */
  readonly connection?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnection;

  /**
   * DNS includes dns resolution settings.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettings#dns
   */
  readonly dns?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsDns;

  /**
   * HealthCheck allows gateway to perform active health checking on backends.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettings#healthCheck
   */
  readonly healthCheck?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheck;

  /**
   * HTTP2 provides HTTP/2 configuration for backend connections.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettings#http2
   */
  readonly http2?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2;

  /**
   * LoadBalancer policy to apply when routing traffic from the gateway to
   * the backend endpoints. Defaults to `LeastRequest`.
   *
   * @default LeastRequest`.
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettings#loadBalancer
   */
  readonly loadBalancer?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancer;

  /**
   * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettings#proxyProtocol
   */
  readonly proxyProtocol?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsProxyProtocol;

  /**
   * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
   * If not set, retry will be disabled.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettings#retry
   */
  readonly retry?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetry;

  /**
   * TcpKeepalive settings associated with the upstream client connection.
   * Disabled by default.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettings#tcpKeepalive
   */
  readonly tcpKeepalive?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTcpKeepalive;

  /**
   * Timeout settings for the backend connections.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettings#timeout
   */
  readonly timeout?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeout;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettings(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'circuitBreaker': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsCircuitBreaker(obj.circuitBreaker),
    'connection': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnection(obj.connection),
    'dns': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsDns(obj.dns),
    'healthCheck': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheck(obj.healthCheck),
    'http2': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2(obj.http2),
    'loadBalancer': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancer(obj.loadBalancer),
    'proxyProtocol': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsProxyProtocol(obj.proxyProtocol),
    'retry': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetry(obj.retry),
    'tcpKeepalive': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTcpKeepalive(obj.tcpKeepalive),
    'timeout': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeout(obj.timeout),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type specifies how to match against a string.
 *
 * @schema SecurityPolicySpecOidcDenyRedirectHeadersType
 */
export enum SecurityPolicySpecOidcDenyRedirectHeadersType {
  /** Exact */
  EXACT = "Exact",
  /** Prefix */
  PREFIX = "Prefix",
  /** Suffix */
  SUFFIX = "Suffix",
  /** RegularExpression */
  REGULAR_EXPRESSION = "RegularExpression",
}

/**
 * Circuit Breaker settings for the upstream connections and requests.
 * If not set, circuit breakers will be enabled with the default thresholds
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsCircuitBreaker
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsCircuitBreaker {
  /**
   * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsCircuitBreaker#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsCircuitBreaker#maxParallelRequests
   */
  readonly maxParallelRequests?: number;

  /**
   * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsCircuitBreaker#maxParallelRetries
   */
  readonly maxParallelRetries?: number;

  /**
   * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsCircuitBreaker#maxPendingRequests
   */
  readonly maxPendingRequests?: number;

  /**
   * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
   * Default: unlimited.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsCircuitBreaker#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsCircuitBreaker#perEndpoint
   */
  readonly perEndpoint?: SecurityPolicySpecOidcProviderBackendSettingsCircuitBreakerPerEndpoint;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsCircuitBreaker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsCircuitBreaker(obj: SecurityPolicySpecOidcProviderBackendSettingsCircuitBreaker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
    'maxParallelRequests': obj.maxParallelRequests,
    'maxParallelRetries': obj.maxParallelRetries,
    'maxPendingRequests': obj.maxPendingRequests,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'perEndpoint': toJson_SecurityPolicySpecOidcProviderBackendSettingsCircuitBreakerPerEndpoint(obj.perEndpoint),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Connection includes backend connection settings.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsConnection
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsConnection {
  /**
   * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
   * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
   * If unspecified, an implementation defined default is applied (32768 bytes).
   * For example, 20Mi, 1Gi, 256Ki etc.
   * Note: that when the suffix is not provided, the value is interpreted as bytes.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsConnection#bufferLimit
   */
  readonly bufferLimit?: SecurityPolicySpecOidcProviderBackendSettingsConnectionBufferLimit;

  /**
   * Preconnect configures proactive upstream connections to reduce latency by establishing
   * connections before they’re needed and avoiding connection establishment overhead.
   *
   * If unset, Envoy will fetch connections as needed to serve in-flight requests.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsConnection#preconnect
   */
  readonly preconnect?: SecurityPolicySpecOidcProviderBackendSettingsConnectionPreconnect;

  /**
   * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
   * to backend.
   * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
   * For example, 20Mi, 1Gi, 256Ki etc.
   * Note that when the suffix is not provided, the value is interpreted as bytes.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsConnection#socketBufferLimit
   */
  readonly socketBufferLimit?: SecurityPolicySpecOidcProviderBackendSettingsConnectionSocketBufferLimit;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsConnection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsConnection(obj: SecurityPolicySpecOidcProviderBackendSettingsConnection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bufferLimit': obj.bufferLimit?.value,
    'preconnect': toJson_SecurityPolicySpecOidcProviderBackendSettingsConnectionPreconnect(obj.preconnect),
    'socketBufferLimit': obj.socketBufferLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DNS includes dns resolution settings.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsDns
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsDns {
  /**
   * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
   * Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema SecurityPolicySpecOidcProviderBackendSettingsDns#dnsRefreshRate
   */
  readonly dnsRefreshRate?: string;

  /**
   * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
   * If set, this configuration overrides other defaults.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsDns#lookupFamily
   */
  readonly lookupFamily?: SecurityPolicySpecOidcProviderBackendSettingsDnsLookupFamily;

  /**
   * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
   * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
   * Defaults to true.
   *
   * @default true.
   * @schema SecurityPolicySpecOidcProviderBackendSettingsDns#respectDnsTtl
   */
  readonly respectDnsTtl?: boolean;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsDns' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsDns(obj: SecurityPolicySpecOidcProviderBackendSettingsDns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsRefreshRate': obj.dnsRefreshRate,
    'lookupFamily': obj.lookupFamily,
    'respectDnsTtl': obj.respectDnsTtl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HealthCheck allows gateway to perform active health checking on backends.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheck
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheck {
  /**
   * Active health check configuration
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheck#active
   */
  readonly active?: SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActive;

  /**
   * When number of unhealthy endpoints for a backend reaches this threshold
   * Envoy will disregard health status and balance across all endpoints.
   * It's designed to prevent a situation in which host failures cascade throughout the cluster
   * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheck#panicThreshold
   */
  readonly panicThreshold?: number;

  /**
   * Passive passive check configuration
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheck#passive
   */
  readonly passive?: SecurityPolicySpecOidcProviderBackendSettingsHealthCheckPassive;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsHealthCheck(obj: SecurityPolicySpecOidcProviderBackendSettingsHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'active': toJson_SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActive(obj.active),
    'panicThreshold': obj.panicThreshold,
    'passive': toJson_SecurityPolicySpecOidcProviderBackendSettingsHealthCheckPassive(obj.passive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP2 provides HTTP/2 configuration for backend connections.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsHttp2
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsHttp2 {
  /**
   * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
   * If not set, the default value is 1 MiB.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHttp2#initialConnectionWindowSize
   */
  readonly initialConnectionWindowSize?: SecurityPolicySpecOidcProviderBackendSettingsHttp2InitialConnectionWindowSize;

  /**
   * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
   * If not set, the default value is 64 KiB(64*1024).
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHttp2#initialStreamWindowSize
   */
  readonly initialStreamWindowSize?: SecurityPolicySpecOidcProviderBackendSettingsHttp2InitialStreamWindowSize;

  /**
   * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
   * If not set, the default value is 100.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHttp2#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
   * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
   * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
   * Default: TerminateConnection
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHttp2#onInvalidMessage
   */
  readonly onInvalidMessage?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsHttp2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsHttp2(obj: SecurityPolicySpecOidcProviderBackendSettingsHttp2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'initialConnectionWindowSize': obj.initialConnectionWindowSize?.value,
    'initialStreamWindowSize': obj.initialStreamWindowSize?.value,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'onInvalidMessage': obj.onInvalidMessage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LoadBalancer policy to apply when routing traffic from the gateway to
 * the backend endpoints. Defaults to `LeastRequest`.
 *
 * @default LeastRequest`.
 * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancer
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancer {
  /**
   * ConsistentHash defines the configuration when the load balancer type is
   * set to ConsistentHash
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancer#consistentHash
   */
  readonly consistentHash?: SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHash;

  /**
   * EndpointOverride defines the configuration for endpoint override.
   * When specified, the load balancer will attempt to route requests to endpoints
   * based on the override information extracted from request headers or metadata.
   * If the override endpoints are not available, the configured load balancer policy will be used as fallback.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancer#endpointOverride
   */
  readonly endpointOverride?: SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverride;

  /**
   * SlowStart defines the configuration related to the slow start load balancer policy.
   * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
   * Currently this is only supported for RoundRobin and LeastRequest load balancers
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancer#slowStart
   */
  readonly slowStart?: SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerSlowStart;

  /**
   * Type decides the type of Load Balancer policy.
   * Valid LoadBalancerType values are
   * "ConsistentHash",
   * "LeastRequest",
   * "Random",
   * "RoundRobin".
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancer#type
   */
  readonly type: SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerType;

  /**
   * ZoneAware defines the configuration related to the distribution of requests between locality zones.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancer#zoneAware
   */
  readonly zoneAware?: SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAware;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsLoadBalancer(obj: SecurityPolicySpecOidcProviderBackendSettingsLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHash(obj.consistentHash),
    'endpointOverride': toJson_SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverride(obj.endpointOverride),
    'slowStart': toJson_SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerSlowStart(obj.slowStart),
    'type': obj.type,
    'zoneAware': toJson_SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAware(obj.zoneAware),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsProxyProtocol
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsProxyProtocol {
  /**
   * Version of ProxyProtol
   * Valid ProxyProtocolVersion values are
   * "V1"
   * "V2"
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsProxyProtocol#version
   */
  readonly version: SecurityPolicySpecOidcProviderBackendSettingsProxyProtocolVersion;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsProxyProtocol' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsProxyProtocol(obj: SecurityPolicySpecOidcProviderBackendSettingsProxyProtocol | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
 * If not set, retry will be disabled.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsRetry
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsRetry {
  /**
   * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
   * that should be sent to the same priority before switching to a different one.
   * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsRetry#numAttemptsPerPriority
   */
  readonly numAttemptsPerPriority?: number;

  /**
   * NumRetries is the number of retries to be attempted. Defaults to 2.
   *
   * @default 2.
   * @schema SecurityPolicySpecOidcProviderBackendSettingsRetry#numRetries
   */
  readonly numRetries?: number;

  /**
   * PerRetry is the retry policy to be applied per retry attempt.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsRetry#perRetry
   */
  readonly perRetry?: SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetry;

  /**
   * RetryOn specifies the retry trigger condition.
   *
   * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsRetry#retryOn
   */
  readonly retryOn?: SecurityPolicySpecOidcProviderBackendSettingsRetryRetryOn;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsRetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsRetry(obj: SecurityPolicySpecOidcProviderBackendSettingsRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'numAttemptsPerPriority': obj.numAttemptsPerPriority,
    'numRetries': obj.numRetries,
    'perRetry': toJson_SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetry(obj.perRetry),
    'retryOn': toJson_SecurityPolicySpecOidcProviderBackendSettingsRetryRetryOn(obj.retryOn),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TcpKeepalive settings associated with the upstream client connection.
 * Disabled by default.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsTcpKeepalive
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsTcpKeepalive {
  /**
   * The duration a connection needs to be idle before keep-alive
   * probes start being sent.
   * The duration format is
   * Defaults to `7200s`.
   *
   * @default 7200s`.
   * @schema SecurityPolicySpecOidcProviderBackendSettingsTcpKeepalive#idleTime
   */
  readonly idleTime?: string;

  /**
   * The duration between keep-alive probes.
   * Defaults to `75s`.
   *
   * @default 75s`.
   * @schema SecurityPolicySpecOidcProviderBackendSettingsTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * The total number of unacknowledged probes to send before deciding
   * the connection is dead.
   * Defaults to 9.
   *
   * @default 9.
   * @schema SecurityPolicySpecOidcProviderBackendSettingsTcpKeepalive#probes
   */
  readonly probes?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsTcpKeepalive(obj: SecurityPolicySpecOidcProviderBackendSettingsTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idleTime': obj.idleTime,
    'interval': obj.interval,
    'probes': obj.probes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for the backend connections.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsTimeout
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsTimeout {
  /**
   * Timeout settings for HTTP.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsTimeout#http
   */
  readonly http?: SecurityPolicySpecOidcProviderBackendSettingsTimeoutHttp;

  /**
   * Timeout settings for TCP.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsTimeout#tcp
   */
  readonly tcp?: SecurityPolicySpecOidcProviderBackendSettingsTimeoutTcp;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsTimeout' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsTimeout(obj: SecurityPolicySpecOidcProviderBackendSettingsTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_SecurityPolicySpecOidcProviderBackendSettingsTimeoutHttp(obj.http),
    'tcp': toJson_SecurityPolicySpecOidcProviderBackendSettingsTimeoutTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * JWTClaim specifies a claim in a JWT token.
 *
 * @schema SecurityPolicySpecAuthorizationRulesPrincipalJwtClaims
 */
export interface SecurityPolicySpecAuthorizationRulesPrincipalJwtClaims {
  /**
   * Name is the name of the claim.
   * If it is a nested claim, use a dot (.) separated string as the name to
   * represent the full path to the claim.
   * For example, if the claim is in the "department" field in the "organization" field,
   * the name should be "organization.department".
   *
   * @schema SecurityPolicySpecAuthorizationRulesPrincipalJwtClaims#name
   */
  readonly name: string;

  /**
   * ValueType is the type of the claim value.
   * Only String and StringArray types are supported for now.
   *
   * @schema SecurityPolicySpecAuthorizationRulesPrincipalJwtClaims#valueType
   */
  readonly valueType?: SecurityPolicySpecAuthorizationRulesPrincipalJwtClaimsValueType;

  /**
   * Values are the values that the claim must match.
   * If the claim is a string type, the specified value must match exactly.
   * If the claim is a string array type, the specified value must match one of the values in the array.
   * If multiple values are specified, one of the values must match for the rule to match.
   *
   * @schema SecurityPolicySpecAuthorizationRulesPrincipalJwtClaims#values
   */
  readonly values: string[];
}

/**
 * Converts an object of type 'SecurityPolicySpecAuthorizationRulesPrincipalJwtClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecAuthorizationRulesPrincipalJwtClaims(obj: SecurityPolicySpecAuthorizationRulesPrincipalJwtClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'valueType': obj.valueType,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreakerPerEndpoint
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreakerPerEndpoint {
  /**
   * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreakerPerEndpoint#maxConnections
   */
  readonly maxConnections?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreakerPerEndpoint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreakerPerEndpoint(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreakerPerEndpoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
 * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
 * If unspecified, an implementation defined default is applied (32768 bytes).
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note: that when the suffix is not provided, the value is interpreted as bytes.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionBufferLimit
 */
export class SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionBufferLimit {
  public static fromNumber(value: number): SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionBufferLimit {
    return new SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionBufferLimit(value);
  }
  public static fromString(value: string): SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionBufferLimit {
    return new SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionBufferLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Preconnect configures proactive upstream connections to reduce latency by establishing
 * connections before they’re needed and avoiding connection establishment overhead.
 *
 * If unset, Envoy will fetch connections as needed to serve in-flight requests.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionPreconnect
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionPreconnect {
  /**
   * PerEndpointPercent configures how many additional connections to maintain per
   * upstream endpoint, useful for high-QPS or latency sensitive services. Expressed as a
   * percentage of the connections required by active streams
   * (e.g. 100 = preconnect disabled, 105 = 1.05x connections per-endpoint, 200 = 2.00×).
   *
   * Allowed value range is between 100-300. When both PerEndpointPercent and
   * PredictivePercent are set, Envoy ensures both are satisfied (max of the two).
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionPreconnect#perEndpointPercent
   */
  readonly perEndpointPercent?: number;

  /**
   * PredictivePercent configures how many additional connections to maintain
   * across the cluster by anticipating which upstream endpoint the load balancer
   * will select next, useful for low-QPS services. Relies on deterministic
   * loadbalancing and is only supported with Random or RoundRobin.
   * Expressed as a percentage of the connections required by active streams
   * (e.g. 100 = 1.0 (no preconnect), 105 = 1.05× connections across the cluster, 200 = 2.00×).
   *
   * Minimum allowed value is 100. When both PerEndpointPercent and PredictivePercent are
   * set Envoy ensures both are satisfied per host (max of the two).
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionPreconnect#predictivePercent
   */
  readonly predictivePercent?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionPreconnect' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionPreconnect(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionPreconnect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'perEndpointPercent': obj.perEndpointPercent,
    'predictivePercent': obj.predictivePercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
 * to backend.
 * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note that when the suffix is not provided, the value is interpreted as bytes.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionSocketBufferLimit
 */
export class SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionSocketBufferLimit {
  public static fromNumber(value: number): SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionSocketBufferLimit {
    return new SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionSocketBufferLimit(value);
  }
  public static fromString(value: string): SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionSocketBufferLimit {
    return new SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionSocketBufferLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
 * If set, this configuration overrides other defaults.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsDnsLookupFamily
 */
export enum SecurityPolicySpecExtAuthGrpcBackendSettingsDnsLookupFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
  /** IPv4Preferred */
  I_PV4_PREFERRED = "IPv4Preferred",
  /** IPv6Preferred */
  I_PV6_PREFERRED = "IPv6Preferred",
  /** IPv4AndIPv6 */
  I_PV4_AND_I_PV6 = "IPv4AndIPv6",
}

/**
 * Active health check configuration
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActive
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActive {
  /**
   * GRPC defines the configuration of the GRPC health checker.
   * It's optional, and can only be used if the specified type is GRPC.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActive#grpc
   */
  readonly grpc?: SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveGrpc;

  /**
   * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActive#healthyThreshold
   */
  readonly healthyThreshold?: number;

  /**
   * HTTP defines the configuration of http health checker.
   * It's required while the health checker type is HTTP.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActive#http
   */
  readonly http?: SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttp;

  /**
   * InitialJitter defines the maximum time Envoy will wait before the first health check.
   * Envoy will randomly select a value between 0 and the initial jitter value.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActive#initialJitter
   */
  readonly initialJitter?: string;

  /**
   * Interval defines the time between active health checks.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActive#interval
   */
  readonly interval?: string;

  /**
   * TCP defines the configuration of tcp health checker.
   * It's required while the health checker type is TCP.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActive#tcp
   */
  readonly tcp?: SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcp;

  /**
   * Timeout defines the time to wait for a health check response.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActive#timeout
   */
  readonly timeout?: string;

  /**
   * Type defines the type of health checker.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActive#type
   */
  readonly type: string;

  /**
   * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActive#unhealthyThreshold
   */
  readonly unhealthyThreshold?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActive(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpc': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveGrpc(obj.grpc),
    'healthyThreshold': obj.healthyThreshold,
    'http': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttp(obj.http),
    'initialJitter': obj.initialJitter,
    'interval': obj.interval,
    'tcp': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcp(obj.tcp),
    'timeout': obj.timeout,
    'type': obj.type,
    'unhealthyThreshold': obj.unhealthyThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Passive passive check configuration
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckPassive
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckPassive {
  /**
   * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckPassive#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckPassive#consecutive5XxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckPassive#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
   * Parameter takes effect only when split_external_local_origin_errors is set to true.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckPassive#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * FailurePercentageThreshold sets the failure percentage threshold for outlier detection.
   * If the failure percentage of a given host is greater than or equal to this value, it will be ejected.
   * Defaults to 85.
   *
   * @default 85.
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckPassive#failurePercentageThreshold
   */
  readonly failurePercentageThreshold?: number;

  /**
   * Interval defines the time between passive health checks.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckPassive#interval
   */
  readonly interval?: string;

  /**
   * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckPassive#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckPassive#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckPassive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckPassive(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckPassive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5XxErrors': obj.consecutive5XxErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'failurePercentageThreshold': obj.failurePercentageThreshold,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
 * If not set, the default value is 1 MiB.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2InitialConnectionWindowSize
 */
export class SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2InitialConnectionWindowSize {
  public static fromNumber(value: number): SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2InitialConnectionWindowSize {
    return new SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2InitialConnectionWindowSize(value);
  }
  public static fromString(value: string): SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2InitialConnectionWindowSize {
    return new SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2InitialConnectionWindowSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
 * If not set, the default value is 64 KiB(64*1024).
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2InitialStreamWindowSize
 */
export class SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2InitialStreamWindowSize {
  public static fromNumber(value: number): SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2InitialStreamWindowSize {
    return new SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2InitialStreamWindowSize(value);
  }
  public static fromString(value: string): SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2InitialStreamWindowSize {
    return new SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2InitialStreamWindowSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ConsistentHash defines the configuration when the load balancer type is
 * set to ConsistentHash
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHash
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHash {
  /**
   * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHash#cookie
   */
  readonly cookie?: SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashCookie;

  /**
   * Header configures the header hash policy when the consistent hash type is set to Header.
   *
   * Deprecated: use Headers instead
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHash#header
   */
  readonly header?: SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashHeader;

  /**
   * Headers configures the header hash policy for each header, when the consistent hash type is set to Headers.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHash#headers
   */
  readonly headers?: SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashHeaders[];

  /**
   * The table size for consistent hashing, must be prime number limited to 5000011.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHash#tableSize
   */
  readonly tableSize?: number;

  /**
   * ConsistentHashType defines the type of input to hash on. Valid Type values are
   * "SourceIP",
   * "Header",
   * "Headers",
   * "Cookie".
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHash#type
   */
  readonly type: SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashType;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHash(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookie': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashCookie(obj.cookie),
    'header': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashHeader(obj.header),
    'headers': obj.headers?.map(y => toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashHeaders(y)),
    'tableSize': obj.tableSize,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EndpointOverride defines the configuration for endpoint override.
 * When specified, the load balancer will attempt to route requests to endpoints
 * based on the override information extracted from request headers or metadata.
 * If the override endpoints are not available, the configured load balancer policy will be used as fallback.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverride
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverride {
  /**
   * ExtractFrom defines the sources to extract endpoint override information from.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverride#extractFrom
   */
  readonly extractFrom: SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverrideExtractFrom[];
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverride' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverride(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverride | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extractFrom': obj.extractFrom?.map(y => toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverrideExtractFrom(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SlowStart defines the configuration related to the slow start load balancer policy.
 * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
 * Currently this is only supported for RoundRobin and LeastRequest load balancers
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerSlowStart
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerSlowStart {
  /**
   * Window defines the duration of the warm up period for newly added host.
   * During slow start window, traffic sent to the newly added hosts will gradually increase.
   * Currently only supports linear growth of traffic. For additional details,
   * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerSlowStart#window
   */
  readonly window: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerSlowStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerSlowStart(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerSlowStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'window': obj.window,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type decides the type of Load Balancer policy.
 * Valid LoadBalancerType values are
 * "ConsistentHash",
 * "LeastRequest",
 * "Random",
 * "RoundRobin".
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerType
 */
export enum SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerType {
  /** ConsistentHash */
  CONSISTENT_HASH = "ConsistentHash",
  /** LeastRequest */
  LEAST_REQUEST = "LeastRequest",
  /** Random */
  RANDOM = "Random",
  /** RoundRobin */
  ROUND_ROBIN = "RoundRobin",
}

/**
 * ZoneAware defines the configuration related to the distribution of requests between locality zones.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAware
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAware {
  /**
   * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAware#preferLocal
   */
  readonly preferLocal?: SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocal;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAware' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAware(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAware | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferLocal': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocal(obj.preferLocal),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Version of ProxyProtol
 * Valid ProxyProtocolVersion values are
 * "V1"
 * "V2"
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsProxyProtocolVersion
 */
export enum SecurityPolicySpecExtAuthGrpcBackendSettingsProxyProtocolVersion {
  /** V1 */
  V1 = "V1",
  /** V2 */
  V2 = "V2",
}

/**
 * PerRetry is the retry policy to be applied per retry attempt.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetry
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetry {
  /**
   * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
   * back-off algorithm for retries. For additional details,
   * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetry#backOff
   */
  readonly backOff?: SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetryBackOff;

  /**
   * Timeout is the timeout per retry attempt.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetry#timeout
   */
  readonly timeout?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetry(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backOff': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetryBackOff(obj.backOff),
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RetryOn specifies the retry trigger condition.
 *
 * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsRetryRetryOn
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsRetryRetryOn {
  /**
   * HttpStatusCodes specifies the http status codes to be retried.
   * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsRetryRetryOn#httpStatusCodes
   */
  readonly httpStatusCodes?: number[];

  /**
   * Triggers specifies the retry trigger condition(Http/Grpc).
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsRetryRetryOn#triggers
   */
  readonly triggers?: SecurityPolicySpecExtAuthGrpcBackendSettingsRetryRetryOnTriggers[];
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsRetryRetryOn' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsRetryRetryOn(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsRetryRetryOn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpStatusCodes': obj.httpStatusCodes?.map(y => y),
    'triggers': obj.triggers?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for HTTP.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutHttp
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutHttp {
  /**
   * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
   * Default: 1 hour.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutHttp#connectionIdleTimeout
   */
  readonly connectionIdleTimeout?: string;

  /**
   * The maximum duration of an HTTP connection.
   * Default: unlimited.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutHttp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * MaxStreamDuration is the maximum duration for a stream to complete. This timeout measures the time
   * from when the request is sent until the response stream is fully consumed and does not apply to
   * non-streaming requests.
   * When set to "0s", no max duration is applied and streams can run indefinitely.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutHttp#maxStreamDuration
   */
  readonly maxStreamDuration?: string;

  /**
   * RequestTimeout is the time until which entire response is received from the upstream.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutHttp#requestTimeout
   */
  readonly requestTimeout?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutHttp(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionIdleTimeout': obj.connectionIdleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxStreamDuration': obj.maxStreamDuration,
    'requestTimeout': obj.requestTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for TCP.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutTcp
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutTcp {
  /**
   * The timeout for network connection establishment, including TCP and TLS handshakes.
   * Default: 10 seconds.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutTcp#connectTimeout
   */
  readonly connectTimeout?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutTcp(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreakerPerEndpoint
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreakerPerEndpoint {
  /**
   * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreakerPerEndpoint#maxConnections
   */
  readonly maxConnections?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreakerPerEndpoint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreakerPerEndpoint(obj: SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreakerPerEndpoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
 * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
 * If unspecified, an implementation defined default is applied (32768 bytes).
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note: that when the suffix is not provided, the value is interpreted as bytes.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsConnectionBufferLimit
 */
export class SecurityPolicySpecExtAuthHttpBackendSettingsConnectionBufferLimit {
  public static fromNumber(value: number): SecurityPolicySpecExtAuthHttpBackendSettingsConnectionBufferLimit {
    return new SecurityPolicySpecExtAuthHttpBackendSettingsConnectionBufferLimit(value);
  }
  public static fromString(value: string): SecurityPolicySpecExtAuthHttpBackendSettingsConnectionBufferLimit {
    return new SecurityPolicySpecExtAuthHttpBackendSettingsConnectionBufferLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Preconnect configures proactive upstream connections to reduce latency by establishing
 * connections before they’re needed and avoiding connection establishment overhead.
 *
 * If unset, Envoy will fetch connections as needed to serve in-flight requests.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsConnectionPreconnect
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsConnectionPreconnect {
  /**
   * PerEndpointPercent configures how many additional connections to maintain per
   * upstream endpoint, useful for high-QPS or latency sensitive services. Expressed as a
   * percentage of the connections required by active streams
   * (e.g. 100 = preconnect disabled, 105 = 1.05x connections per-endpoint, 200 = 2.00×).
   *
   * Allowed value range is between 100-300. When both PerEndpointPercent and
   * PredictivePercent are set, Envoy ensures both are satisfied (max of the two).
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsConnectionPreconnect#perEndpointPercent
   */
  readonly perEndpointPercent?: number;

  /**
   * PredictivePercent configures how many additional connections to maintain
   * across the cluster by anticipating which upstream endpoint the load balancer
   * will select next, useful for low-QPS services. Relies on deterministic
   * loadbalancing and is only supported with Random or RoundRobin.
   * Expressed as a percentage of the connections required by active streams
   * (e.g. 100 = 1.0 (no preconnect), 105 = 1.05× connections across the cluster, 200 = 2.00×).
   *
   * Minimum allowed value is 100. When both PerEndpointPercent and PredictivePercent are
   * set Envoy ensures both are satisfied per host (max of the two).
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsConnectionPreconnect#predictivePercent
   */
  readonly predictivePercent?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsConnectionPreconnect' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsConnectionPreconnect(obj: SecurityPolicySpecExtAuthHttpBackendSettingsConnectionPreconnect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'perEndpointPercent': obj.perEndpointPercent,
    'predictivePercent': obj.predictivePercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
 * to backend.
 * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note that when the suffix is not provided, the value is interpreted as bytes.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsConnectionSocketBufferLimit
 */
export class SecurityPolicySpecExtAuthHttpBackendSettingsConnectionSocketBufferLimit {
  public static fromNumber(value: number): SecurityPolicySpecExtAuthHttpBackendSettingsConnectionSocketBufferLimit {
    return new SecurityPolicySpecExtAuthHttpBackendSettingsConnectionSocketBufferLimit(value);
  }
  public static fromString(value: string): SecurityPolicySpecExtAuthHttpBackendSettingsConnectionSocketBufferLimit {
    return new SecurityPolicySpecExtAuthHttpBackendSettingsConnectionSocketBufferLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
 * If set, this configuration overrides other defaults.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsDnsLookupFamily
 */
export enum SecurityPolicySpecExtAuthHttpBackendSettingsDnsLookupFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
  /** IPv4Preferred */
  I_PV4_PREFERRED = "IPv4Preferred",
  /** IPv6Preferred */
  I_PV6_PREFERRED = "IPv6Preferred",
  /** IPv4AndIPv6 */
  I_PV4_AND_I_PV6 = "IPv4AndIPv6",
}

/**
 * Active health check configuration
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActive
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActive {
  /**
   * GRPC defines the configuration of the GRPC health checker.
   * It's optional, and can only be used if the specified type is GRPC.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActive#grpc
   */
  readonly grpc?: SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveGrpc;

  /**
   * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActive#healthyThreshold
   */
  readonly healthyThreshold?: number;

  /**
   * HTTP defines the configuration of http health checker.
   * It's required while the health checker type is HTTP.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActive#http
   */
  readonly http?: SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttp;

  /**
   * InitialJitter defines the maximum time Envoy will wait before the first health check.
   * Envoy will randomly select a value between 0 and the initial jitter value.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActive#initialJitter
   */
  readonly initialJitter?: string;

  /**
   * Interval defines the time between active health checks.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActive#interval
   */
  readonly interval?: string;

  /**
   * TCP defines the configuration of tcp health checker.
   * It's required while the health checker type is TCP.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActive#tcp
   */
  readonly tcp?: SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcp;

  /**
   * Timeout defines the time to wait for a health check response.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActive#timeout
   */
  readonly timeout?: string;

  /**
   * Type defines the type of health checker.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActive#type
   */
  readonly type: string;

  /**
   * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActive#unhealthyThreshold
   */
  readonly unhealthyThreshold?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActive(obj: SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpc': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveGrpc(obj.grpc),
    'healthyThreshold': obj.healthyThreshold,
    'http': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttp(obj.http),
    'initialJitter': obj.initialJitter,
    'interval': obj.interval,
    'tcp': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcp(obj.tcp),
    'timeout': obj.timeout,
    'type': obj.type,
    'unhealthyThreshold': obj.unhealthyThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Passive passive check configuration
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckPassive
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckPassive {
  /**
   * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckPassive#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckPassive#consecutive5XxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckPassive#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
   * Parameter takes effect only when split_external_local_origin_errors is set to true.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckPassive#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * FailurePercentageThreshold sets the failure percentage threshold for outlier detection.
   * If the failure percentage of a given host is greater than or equal to this value, it will be ejected.
   * Defaults to 85.
   *
   * @default 85.
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckPassive#failurePercentageThreshold
   */
  readonly failurePercentageThreshold?: number;

  /**
   * Interval defines the time between passive health checks.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckPassive#interval
   */
  readonly interval?: string;

  /**
   * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckPassive#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckPassive#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckPassive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckPassive(obj: SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckPassive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5XxErrors': obj.consecutive5XxErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'failurePercentageThreshold': obj.failurePercentageThreshold,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
 * If not set, the default value is 1 MiB.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHttp2InitialConnectionWindowSize
 */
export class SecurityPolicySpecExtAuthHttpBackendSettingsHttp2InitialConnectionWindowSize {
  public static fromNumber(value: number): SecurityPolicySpecExtAuthHttpBackendSettingsHttp2InitialConnectionWindowSize {
    return new SecurityPolicySpecExtAuthHttpBackendSettingsHttp2InitialConnectionWindowSize(value);
  }
  public static fromString(value: string): SecurityPolicySpecExtAuthHttpBackendSettingsHttp2InitialConnectionWindowSize {
    return new SecurityPolicySpecExtAuthHttpBackendSettingsHttp2InitialConnectionWindowSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
 * If not set, the default value is 64 KiB(64*1024).
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHttp2InitialStreamWindowSize
 */
export class SecurityPolicySpecExtAuthHttpBackendSettingsHttp2InitialStreamWindowSize {
  public static fromNumber(value: number): SecurityPolicySpecExtAuthHttpBackendSettingsHttp2InitialStreamWindowSize {
    return new SecurityPolicySpecExtAuthHttpBackendSettingsHttp2InitialStreamWindowSize(value);
  }
  public static fromString(value: string): SecurityPolicySpecExtAuthHttpBackendSettingsHttp2InitialStreamWindowSize {
    return new SecurityPolicySpecExtAuthHttpBackendSettingsHttp2InitialStreamWindowSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ConsistentHash defines the configuration when the load balancer type is
 * set to ConsistentHash
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHash
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHash {
  /**
   * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHash#cookie
   */
  readonly cookie?: SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashCookie;

  /**
   * Header configures the header hash policy when the consistent hash type is set to Header.
   *
   * Deprecated: use Headers instead
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHash#header
   */
  readonly header?: SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashHeader;

  /**
   * Headers configures the header hash policy for each header, when the consistent hash type is set to Headers.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHash#headers
   */
  readonly headers?: SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashHeaders[];

  /**
   * The table size for consistent hashing, must be prime number limited to 5000011.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHash#tableSize
   */
  readonly tableSize?: number;

  /**
   * ConsistentHashType defines the type of input to hash on. Valid Type values are
   * "SourceIP",
   * "Header",
   * "Headers",
   * "Cookie".
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHash#type
   */
  readonly type: SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashType;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHash(obj: SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookie': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashCookie(obj.cookie),
    'header': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashHeader(obj.header),
    'headers': obj.headers?.map(y => toJson_SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashHeaders(y)),
    'tableSize': obj.tableSize,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EndpointOverride defines the configuration for endpoint override.
 * When specified, the load balancer will attempt to route requests to endpoints
 * based on the override information extracted from request headers or metadata.
 * If the override endpoints are not available, the configured load balancer policy will be used as fallback.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverride
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverride {
  /**
   * ExtractFrom defines the sources to extract endpoint override information from.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverride#extractFrom
   */
  readonly extractFrom: SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverrideExtractFrom[];
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverride' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverride(obj: SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverride | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extractFrom': obj.extractFrom?.map(y => toJson_SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverrideExtractFrom(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SlowStart defines the configuration related to the slow start load balancer policy.
 * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
 * Currently this is only supported for RoundRobin and LeastRequest load balancers
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerSlowStart
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerSlowStart {
  /**
   * Window defines the duration of the warm up period for newly added host.
   * During slow start window, traffic sent to the newly added hosts will gradually increase.
   * Currently only supports linear growth of traffic. For additional details,
   * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerSlowStart#window
   */
  readonly window: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerSlowStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerSlowStart(obj: SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerSlowStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'window': obj.window,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type decides the type of Load Balancer policy.
 * Valid LoadBalancerType values are
 * "ConsistentHash",
 * "LeastRequest",
 * "Random",
 * "RoundRobin".
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerType
 */
export enum SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerType {
  /** ConsistentHash */
  CONSISTENT_HASH = "ConsistentHash",
  /** LeastRequest */
  LEAST_REQUEST = "LeastRequest",
  /** Random */
  RANDOM = "Random",
  /** RoundRobin */
  ROUND_ROBIN = "RoundRobin",
}

/**
 * ZoneAware defines the configuration related to the distribution of requests between locality zones.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAware
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAware {
  /**
   * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAware#preferLocal
   */
  readonly preferLocal?: SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocal;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAware' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAware(obj: SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAware | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferLocal': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocal(obj.preferLocal),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Version of ProxyProtol
 * Valid ProxyProtocolVersion values are
 * "V1"
 * "V2"
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsProxyProtocolVersion
 */
export enum SecurityPolicySpecExtAuthHttpBackendSettingsProxyProtocolVersion {
  /** V1 */
  V1 = "V1",
  /** V2 */
  V2 = "V2",
}

/**
 * PerRetry is the retry policy to be applied per retry attempt.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetry
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetry {
  /**
   * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
   * back-off algorithm for retries. For additional details,
   * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetry#backOff
   */
  readonly backOff?: SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetryBackOff;

  /**
   * Timeout is the timeout per retry attempt.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetry#timeout
   */
  readonly timeout?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetry(obj: SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backOff': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetryBackOff(obj.backOff),
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RetryOn specifies the retry trigger condition.
 *
 * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsRetryRetryOn
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsRetryRetryOn {
  /**
   * HttpStatusCodes specifies the http status codes to be retried.
   * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsRetryRetryOn#httpStatusCodes
   */
  readonly httpStatusCodes?: number[];

  /**
   * Triggers specifies the retry trigger condition(Http/Grpc).
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsRetryRetryOn#triggers
   */
  readonly triggers?: SecurityPolicySpecExtAuthHttpBackendSettingsRetryRetryOnTriggers[];
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsRetryRetryOn' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsRetryRetryOn(obj: SecurityPolicySpecExtAuthHttpBackendSettingsRetryRetryOn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpStatusCodes': obj.httpStatusCodes?.map(y => y),
    'triggers': obj.triggers?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for HTTP.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutHttp
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutHttp {
  /**
   * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
   * Default: 1 hour.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutHttp#connectionIdleTimeout
   */
  readonly connectionIdleTimeout?: string;

  /**
   * The maximum duration of an HTTP connection.
   * Default: unlimited.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutHttp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * MaxStreamDuration is the maximum duration for a stream to complete. This timeout measures the time
   * from when the request is sent until the response stream is fully consumed and does not apply to
   * non-streaming requests.
   * When set to "0s", no max duration is applied and streams can run indefinitely.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutHttp#maxStreamDuration
   */
  readonly maxStreamDuration?: string;

  /**
   * RequestTimeout is the time until which entire response is received from the upstream.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutHttp#requestTimeout
   */
  readonly requestTimeout?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutHttp(obj: SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionIdleTimeout': obj.connectionIdleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxStreamDuration': obj.maxStreamDuration,
    'requestTimeout': obj.requestTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for TCP.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutTcp
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutTcp {
  /**
   * The timeout for network connection establishment, including TCP and TLS handshakes.
   * Default: 10 seconds.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutTcp#connectTimeout
   */
  readonly connectTimeout?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutTcp(obj: SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Circuit Breaker settings for the upstream connections and requests.
 * If not set, circuit breakers will be enabled with the default thresholds
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsCircuitBreaker
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsCircuitBreaker {
  /**
   * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsCircuitBreaker#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsCircuitBreaker#maxParallelRequests
   */
  readonly maxParallelRequests?: number;

  /**
   * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsCircuitBreaker#maxParallelRetries
   */
  readonly maxParallelRetries?: number;

  /**
   * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsCircuitBreaker#maxPendingRequests
   */
  readonly maxPendingRequests?: number;

  /**
   * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
   * Default: unlimited.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsCircuitBreaker#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsCircuitBreaker#perEndpoint
   */
  readonly perEndpoint?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsCircuitBreakerPerEndpoint;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsCircuitBreaker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsCircuitBreaker(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsCircuitBreaker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
    'maxParallelRequests': obj.maxParallelRequests,
    'maxParallelRetries': obj.maxParallelRetries,
    'maxPendingRequests': obj.maxPendingRequests,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'perEndpoint': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsCircuitBreakerPerEndpoint(obj.perEndpoint),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Connection includes backend connection settings.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnection
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnection {
  /**
   * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
   * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
   * If unspecified, an implementation defined default is applied (32768 bytes).
   * For example, 20Mi, 1Gi, 256Ki etc.
   * Note: that when the suffix is not provided, the value is interpreted as bytes.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnection#bufferLimit
   */
  readonly bufferLimit?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnectionBufferLimit;

  /**
   * Preconnect configures proactive upstream connections to reduce latency by establishing
   * connections before they’re needed and avoiding connection establishment overhead.
   *
   * If unset, Envoy will fetch connections as needed to serve in-flight requests.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnection#preconnect
   */
  readonly preconnect?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnectionPreconnect;

  /**
   * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
   * to backend.
   * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
   * For example, 20Mi, 1Gi, 256Ki etc.
   * Note that when the suffix is not provided, the value is interpreted as bytes.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnection#socketBufferLimit
   */
  readonly socketBufferLimit?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnectionSocketBufferLimit;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnection(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bufferLimit': obj.bufferLimit?.value,
    'preconnect': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnectionPreconnect(obj.preconnect),
    'socketBufferLimit': obj.socketBufferLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DNS includes dns resolution settings.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsDns
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsDns {
  /**
   * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
   * Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsDns#dnsRefreshRate
   */
  readonly dnsRefreshRate?: string;

  /**
   * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
   * If set, this configuration overrides other defaults.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsDns#lookupFamily
   */
  readonly lookupFamily?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsDnsLookupFamily;

  /**
   * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
   * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
   * Defaults to true.
   *
   * @default true.
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsDns#respectDnsTtl
   */
  readonly respectDnsTtl?: boolean;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsDns' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsDns(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsDns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsRefreshRate': obj.dnsRefreshRate,
    'lookupFamily': obj.lookupFamily,
    'respectDnsTtl': obj.respectDnsTtl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HealthCheck allows gateway to perform active health checking on backends.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheck
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheck {
  /**
   * Active health check configuration
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheck#active
   */
  readonly active?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActive;

  /**
   * When number of unhealthy endpoints for a backend reaches this threshold
   * Envoy will disregard health status and balance across all endpoints.
   * It's designed to prevent a situation in which host failures cascade throughout the cluster
   * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheck#panicThreshold
   */
  readonly panicThreshold?: number;

  /**
   * Passive passive check configuration
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheck#passive
   */
  readonly passive?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckPassive;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheck(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'active': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActive(obj.active),
    'panicThreshold': obj.panicThreshold,
    'passive': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckPassive(obj.passive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP2 provides HTTP/2 configuration for backend connections.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2 {
  /**
   * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
   * If not set, the default value is 1 MiB.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2#initialConnectionWindowSize
   */
  readonly initialConnectionWindowSize?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2InitialConnectionWindowSize;

  /**
   * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
   * If not set, the default value is 64 KiB(64*1024).
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2#initialStreamWindowSize
   */
  readonly initialStreamWindowSize?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2InitialStreamWindowSize;

  /**
   * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
   * If not set, the default value is 100.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
   * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
   * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
   * Default: TerminateConnection
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2#onInvalidMessage
   */
  readonly onInvalidMessage?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'initialConnectionWindowSize': obj.initialConnectionWindowSize?.value,
    'initialStreamWindowSize': obj.initialStreamWindowSize?.value,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'onInvalidMessage': obj.onInvalidMessage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LoadBalancer policy to apply when routing traffic from the gateway to
 * the backend endpoints. Defaults to `LeastRequest`.
 *
 * @default LeastRequest`.
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancer
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancer {
  /**
   * ConsistentHash defines the configuration when the load balancer type is
   * set to ConsistentHash
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancer#consistentHash
   */
  readonly consistentHash?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHash;

  /**
   * EndpointOverride defines the configuration for endpoint override.
   * When specified, the load balancer will attempt to route requests to endpoints
   * based on the override information extracted from request headers or metadata.
   * If the override endpoints are not available, the configured load balancer policy will be used as fallback.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancer#endpointOverride
   */
  readonly endpointOverride?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerEndpointOverride;

  /**
   * SlowStart defines the configuration related to the slow start load balancer policy.
   * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
   * Currently this is only supported for RoundRobin and LeastRequest load balancers
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancer#slowStart
   */
  readonly slowStart?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerSlowStart;

  /**
   * Type decides the type of Load Balancer policy.
   * Valid LoadBalancerType values are
   * "ConsistentHash",
   * "LeastRequest",
   * "Random",
   * "RoundRobin".
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancer#type
   */
  readonly type: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerType;

  /**
   * ZoneAware defines the configuration related to the distribution of requests between locality zones.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancer#zoneAware
   */
  readonly zoneAware?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAware;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancer(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHash(obj.consistentHash),
    'endpointOverride': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerEndpointOverride(obj.endpointOverride),
    'slowStart': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerSlowStart(obj.slowStart),
    'type': obj.type,
    'zoneAware': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAware(obj.zoneAware),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsProxyProtocol
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsProxyProtocol {
  /**
   * Version of ProxyProtol
   * Valid ProxyProtocolVersion values are
   * "V1"
   * "V2"
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsProxyProtocol#version
   */
  readonly version: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsProxyProtocolVersion;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsProxyProtocol' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsProxyProtocol(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsProxyProtocol | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
 * If not set, retry will be disabled.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetry
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetry {
  /**
   * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
   * that should be sent to the same priority before switching to a different one.
   * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetry#numAttemptsPerPriority
   */
  readonly numAttemptsPerPriority?: number;

  /**
   * NumRetries is the number of retries to be attempted. Defaults to 2.
   *
   * @default 2.
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetry#numRetries
   */
  readonly numRetries?: number;

  /**
   * PerRetry is the retry policy to be applied per retry attempt.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetry#perRetry
   */
  readonly perRetry?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryPerRetry;

  /**
   * RetryOn specifies the retry trigger condition.
   *
   * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetry#retryOn
   */
  readonly retryOn?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryRetryOn;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetry(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'numAttemptsPerPriority': obj.numAttemptsPerPriority,
    'numRetries': obj.numRetries,
    'perRetry': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryPerRetry(obj.perRetry),
    'retryOn': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryRetryOn(obj.retryOn),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TcpKeepalive settings associated with the upstream client connection.
 * Disabled by default.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTcpKeepalive
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTcpKeepalive {
  /**
   * The duration a connection needs to be idle before keep-alive
   * probes start being sent.
   * The duration format is
   * Defaults to `7200s`.
   *
   * @default 7200s`.
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTcpKeepalive#idleTime
   */
  readonly idleTime?: string;

  /**
   * The duration between keep-alive probes.
   * Defaults to `75s`.
   *
   * @default 75s`.
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * The total number of unacknowledged probes to send before deciding
   * the connection is dead.
   * Defaults to 9.
   *
   * @default 9.
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTcpKeepalive#probes
   */
  readonly probes?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTcpKeepalive(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idleTime': obj.idleTime,
    'interval': obj.interval,
    'probes': obj.probes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for the backend connections.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeout
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeout {
  /**
   * Timeout settings for HTTP.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeout#http
   */
  readonly http?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeoutHttp;

  /**
   * Timeout settings for TCP.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeout#tcp
   */
  readonly tcp?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeoutTcp;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeout' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeout(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeoutHttp(obj.http),
    'tcp': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeoutTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsCircuitBreakerPerEndpoint
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsCircuitBreakerPerEndpoint {
  /**
   * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsCircuitBreakerPerEndpoint#maxConnections
   */
  readonly maxConnections?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsCircuitBreakerPerEndpoint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsCircuitBreakerPerEndpoint(obj: SecurityPolicySpecOidcProviderBackendSettingsCircuitBreakerPerEndpoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
 * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
 * If unspecified, an implementation defined default is applied (32768 bytes).
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note: that when the suffix is not provided, the value is interpreted as bytes.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsConnectionBufferLimit
 */
export class SecurityPolicySpecOidcProviderBackendSettingsConnectionBufferLimit {
  public static fromNumber(value: number): SecurityPolicySpecOidcProviderBackendSettingsConnectionBufferLimit {
    return new SecurityPolicySpecOidcProviderBackendSettingsConnectionBufferLimit(value);
  }
  public static fromString(value: string): SecurityPolicySpecOidcProviderBackendSettingsConnectionBufferLimit {
    return new SecurityPolicySpecOidcProviderBackendSettingsConnectionBufferLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Preconnect configures proactive upstream connections to reduce latency by establishing
 * connections before they’re needed and avoiding connection establishment overhead.
 *
 * If unset, Envoy will fetch connections as needed to serve in-flight requests.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsConnectionPreconnect
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsConnectionPreconnect {
  /**
   * PerEndpointPercent configures how many additional connections to maintain per
   * upstream endpoint, useful for high-QPS or latency sensitive services. Expressed as a
   * percentage of the connections required by active streams
   * (e.g. 100 = preconnect disabled, 105 = 1.05x connections per-endpoint, 200 = 2.00×).
   *
   * Allowed value range is between 100-300. When both PerEndpointPercent and
   * PredictivePercent are set, Envoy ensures both are satisfied (max of the two).
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsConnectionPreconnect#perEndpointPercent
   */
  readonly perEndpointPercent?: number;

  /**
   * PredictivePercent configures how many additional connections to maintain
   * across the cluster by anticipating which upstream endpoint the load balancer
   * will select next, useful for low-QPS services. Relies on deterministic
   * loadbalancing and is only supported with Random or RoundRobin.
   * Expressed as a percentage of the connections required by active streams
   * (e.g. 100 = 1.0 (no preconnect), 105 = 1.05× connections across the cluster, 200 = 2.00×).
   *
   * Minimum allowed value is 100. When both PerEndpointPercent and PredictivePercent are
   * set Envoy ensures both are satisfied per host (max of the two).
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsConnectionPreconnect#predictivePercent
   */
  readonly predictivePercent?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsConnectionPreconnect' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsConnectionPreconnect(obj: SecurityPolicySpecOidcProviderBackendSettingsConnectionPreconnect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'perEndpointPercent': obj.perEndpointPercent,
    'predictivePercent': obj.predictivePercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
 * to backend.
 * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note that when the suffix is not provided, the value is interpreted as bytes.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsConnectionSocketBufferLimit
 */
export class SecurityPolicySpecOidcProviderBackendSettingsConnectionSocketBufferLimit {
  public static fromNumber(value: number): SecurityPolicySpecOidcProviderBackendSettingsConnectionSocketBufferLimit {
    return new SecurityPolicySpecOidcProviderBackendSettingsConnectionSocketBufferLimit(value);
  }
  public static fromString(value: string): SecurityPolicySpecOidcProviderBackendSettingsConnectionSocketBufferLimit {
    return new SecurityPolicySpecOidcProviderBackendSettingsConnectionSocketBufferLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
 * If set, this configuration overrides other defaults.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsDnsLookupFamily
 */
export enum SecurityPolicySpecOidcProviderBackendSettingsDnsLookupFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
  /** IPv4Preferred */
  I_PV4_PREFERRED = "IPv4Preferred",
  /** IPv6Preferred */
  I_PV6_PREFERRED = "IPv6Preferred",
  /** IPv4AndIPv6 */
  I_PV4_AND_I_PV6 = "IPv4AndIPv6",
}

/**
 * Active health check configuration
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActive
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActive {
  /**
   * GRPC defines the configuration of the GRPC health checker.
   * It's optional, and can only be used if the specified type is GRPC.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActive#grpc
   */
  readonly grpc?: SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveGrpc;

  /**
   * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActive#healthyThreshold
   */
  readonly healthyThreshold?: number;

  /**
   * HTTP defines the configuration of http health checker.
   * It's required while the health checker type is HTTP.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActive#http
   */
  readonly http?: SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttp;

  /**
   * InitialJitter defines the maximum time Envoy will wait before the first health check.
   * Envoy will randomly select a value between 0 and the initial jitter value.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActive#initialJitter
   */
  readonly initialJitter?: string;

  /**
   * Interval defines the time between active health checks.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActive#interval
   */
  readonly interval?: string;

  /**
   * TCP defines the configuration of tcp health checker.
   * It's required while the health checker type is TCP.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActive#tcp
   */
  readonly tcp?: SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcp;

  /**
   * Timeout defines the time to wait for a health check response.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActive#timeout
   */
  readonly timeout?: string;

  /**
   * Type defines the type of health checker.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActive#type
   */
  readonly type: string;

  /**
   * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActive#unhealthyThreshold
   */
  readonly unhealthyThreshold?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActive(obj: SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpc': toJson_SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveGrpc(obj.grpc),
    'healthyThreshold': obj.healthyThreshold,
    'http': toJson_SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttp(obj.http),
    'initialJitter': obj.initialJitter,
    'interval': obj.interval,
    'tcp': toJson_SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcp(obj.tcp),
    'timeout': obj.timeout,
    'type': obj.type,
    'unhealthyThreshold': obj.unhealthyThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Passive passive check configuration
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckPassive
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckPassive {
  /**
   * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckPassive#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckPassive#consecutive5XxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckPassive#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
   * Parameter takes effect only when split_external_local_origin_errors is set to true.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckPassive#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * FailurePercentageThreshold sets the failure percentage threshold for outlier detection.
   * If the failure percentage of a given host is greater than or equal to this value, it will be ejected.
   * Defaults to 85.
   *
   * @default 85.
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckPassive#failurePercentageThreshold
   */
  readonly failurePercentageThreshold?: number;

  /**
   * Interval defines the time between passive health checks.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckPassive#interval
   */
  readonly interval?: string;

  /**
   * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckPassive#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckPassive#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsHealthCheckPassive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsHealthCheckPassive(obj: SecurityPolicySpecOidcProviderBackendSettingsHealthCheckPassive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5XxErrors': obj.consecutive5XxErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'failurePercentageThreshold': obj.failurePercentageThreshold,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
 * If not set, the default value is 1 MiB.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsHttp2InitialConnectionWindowSize
 */
export class SecurityPolicySpecOidcProviderBackendSettingsHttp2InitialConnectionWindowSize {
  public static fromNumber(value: number): SecurityPolicySpecOidcProviderBackendSettingsHttp2InitialConnectionWindowSize {
    return new SecurityPolicySpecOidcProviderBackendSettingsHttp2InitialConnectionWindowSize(value);
  }
  public static fromString(value: string): SecurityPolicySpecOidcProviderBackendSettingsHttp2InitialConnectionWindowSize {
    return new SecurityPolicySpecOidcProviderBackendSettingsHttp2InitialConnectionWindowSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
 * If not set, the default value is 64 KiB(64*1024).
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsHttp2InitialStreamWindowSize
 */
export class SecurityPolicySpecOidcProviderBackendSettingsHttp2InitialStreamWindowSize {
  public static fromNumber(value: number): SecurityPolicySpecOidcProviderBackendSettingsHttp2InitialStreamWindowSize {
    return new SecurityPolicySpecOidcProviderBackendSettingsHttp2InitialStreamWindowSize(value);
  }
  public static fromString(value: string): SecurityPolicySpecOidcProviderBackendSettingsHttp2InitialStreamWindowSize {
    return new SecurityPolicySpecOidcProviderBackendSettingsHttp2InitialStreamWindowSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ConsistentHash defines the configuration when the load balancer type is
 * set to ConsistentHash
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHash
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHash {
  /**
   * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHash#cookie
   */
  readonly cookie?: SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashCookie;

  /**
   * Header configures the header hash policy when the consistent hash type is set to Header.
   *
   * Deprecated: use Headers instead
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHash#header
   */
  readonly header?: SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashHeader;

  /**
   * Headers configures the header hash policy for each header, when the consistent hash type is set to Headers.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHash#headers
   */
  readonly headers?: SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashHeaders[];

  /**
   * The table size for consistent hashing, must be prime number limited to 5000011.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHash#tableSize
   */
  readonly tableSize?: number;

  /**
   * ConsistentHashType defines the type of input to hash on. Valid Type values are
   * "SourceIP",
   * "Header",
   * "Headers",
   * "Cookie".
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHash#type
   */
  readonly type: SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashType;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHash(obj: SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookie': toJson_SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashCookie(obj.cookie),
    'header': toJson_SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashHeader(obj.header),
    'headers': obj.headers?.map(y => toJson_SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashHeaders(y)),
    'tableSize': obj.tableSize,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EndpointOverride defines the configuration for endpoint override.
 * When specified, the load balancer will attempt to route requests to endpoints
 * based on the override information extracted from request headers or metadata.
 * If the override endpoints are not available, the configured load balancer policy will be used as fallback.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverride
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverride {
  /**
   * ExtractFrom defines the sources to extract endpoint override information from.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverride#extractFrom
   */
  readonly extractFrom: SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverrideExtractFrom[];
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverride' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverride(obj: SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverride | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extractFrom': obj.extractFrom?.map(y => toJson_SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverrideExtractFrom(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SlowStart defines the configuration related to the slow start load balancer policy.
 * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
 * Currently this is only supported for RoundRobin and LeastRequest load balancers
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerSlowStart
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerSlowStart {
  /**
   * Window defines the duration of the warm up period for newly added host.
   * During slow start window, traffic sent to the newly added hosts will gradually increase.
   * Currently only supports linear growth of traffic. For additional details,
   * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerSlowStart#window
   */
  readonly window: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerSlowStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerSlowStart(obj: SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerSlowStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'window': obj.window,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type decides the type of Load Balancer policy.
 * Valid LoadBalancerType values are
 * "ConsistentHash",
 * "LeastRequest",
 * "Random",
 * "RoundRobin".
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerType
 */
export enum SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerType {
  /** ConsistentHash */
  CONSISTENT_HASH = "ConsistentHash",
  /** LeastRequest */
  LEAST_REQUEST = "LeastRequest",
  /** Random */
  RANDOM = "Random",
  /** RoundRobin */
  ROUND_ROBIN = "RoundRobin",
}

/**
 * ZoneAware defines the configuration related to the distribution of requests between locality zones.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAware
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAware {
  /**
   * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAware#preferLocal
   */
  readonly preferLocal?: SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocal;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAware' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAware(obj: SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAware | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferLocal': toJson_SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocal(obj.preferLocal),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Version of ProxyProtol
 * Valid ProxyProtocolVersion values are
 * "V1"
 * "V2"
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsProxyProtocolVersion
 */
export enum SecurityPolicySpecOidcProviderBackendSettingsProxyProtocolVersion {
  /** V1 */
  V1 = "V1",
  /** V2 */
  V2 = "V2",
}

/**
 * PerRetry is the retry policy to be applied per retry attempt.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetry
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetry {
  /**
   * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
   * back-off algorithm for retries. For additional details,
   * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetry#backOff
   */
  readonly backOff?: SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetryBackOff;

  /**
   * Timeout is the timeout per retry attempt.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetry#timeout
   */
  readonly timeout?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetry(obj: SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backOff': toJson_SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetryBackOff(obj.backOff),
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RetryOn specifies the retry trigger condition.
 *
 * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsRetryRetryOn
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsRetryRetryOn {
  /**
   * HttpStatusCodes specifies the http status codes to be retried.
   * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsRetryRetryOn#httpStatusCodes
   */
  readonly httpStatusCodes?: number[];

  /**
   * Triggers specifies the retry trigger condition(Http/Grpc).
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsRetryRetryOn#triggers
   */
  readonly triggers?: SecurityPolicySpecOidcProviderBackendSettingsRetryRetryOnTriggers[];
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsRetryRetryOn' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsRetryRetryOn(obj: SecurityPolicySpecOidcProviderBackendSettingsRetryRetryOn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpStatusCodes': obj.httpStatusCodes?.map(y => y),
    'triggers': obj.triggers?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for HTTP.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsTimeoutHttp
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsTimeoutHttp {
  /**
   * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
   * Default: 1 hour.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsTimeoutHttp#connectionIdleTimeout
   */
  readonly connectionIdleTimeout?: string;

  /**
   * The maximum duration of an HTTP connection.
   * Default: unlimited.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsTimeoutHttp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * MaxStreamDuration is the maximum duration for a stream to complete. This timeout measures the time
   * from when the request is sent until the response stream is fully consumed and does not apply to
   * non-streaming requests.
   * When set to "0s", no max duration is applied and streams can run indefinitely.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsTimeoutHttp#maxStreamDuration
   */
  readonly maxStreamDuration?: string;

  /**
   * RequestTimeout is the time until which entire response is received from the upstream.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsTimeoutHttp#requestTimeout
   */
  readonly requestTimeout?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsTimeoutHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsTimeoutHttp(obj: SecurityPolicySpecOidcProviderBackendSettingsTimeoutHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionIdleTimeout': obj.connectionIdleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxStreamDuration': obj.maxStreamDuration,
    'requestTimeout': obj.requestTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for TCP.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsTimeoutTcp
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsTimeoutTcp {
  /**
   * The timeout for network connection establishment, including TCP and TLS handshakes.
   * Default: 10 seconds.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsTimeoutTcp#connectTimeout
   */
  readonly connectTimeout?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsTimeoutTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsTimeoutTcp(obj: SecurityPolicySpecOidcProviderBackendSettingsTimeoutTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ValueType is the type of the claim value.
 * Only String and StringArray types are supported for now.
 *
 * @schema SecurityPolicySpecAuthorizationRulesPrincipalJwtClaimsValueType
 */
export enum SecurityPolicySpecAuthorizationRulesPrincipalJwtClaimsValueType {
  /** String */
  STRING = "String",
  /** StringArray */
  STRING_ARRAY = "StringArray",
}

/**
 * GRPC defines the configuration of the GRPC health checker.
 * It's optional, and can only be used if the specified type is GRPC.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveGrpc
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveGrpc {
  /**
   * Service to send in the health check request.
   * If this is not specified, then the health check request applies to the entire
   * server and not to a specific service.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveGrpc(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP defines the configuration of http health checker.
 * It's required while the health checker type is HTTP.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttp
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttp {
  /**
   * ExpectedResponse defines a list of HTTP expected responses to match.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttp#expectedResponse
   */
  readonly expectedResponse?: SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttpExpectedResponse;

  /**
   * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
   * Defaults to 200 only
   *
   * @default 200 only
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttp#expectedStatuses
   */
  readonly expectedStatuses?: number[];

  /**
   * Hostname defines the HTTP host that will be requested during health checking.
   * Default: HTTPRoute or GRPCRoute hostname.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttp#hostname
   */
  readonly hostname?: string;

  /**
   * Method defines the HTTP method used for health checking.
   * Defaults to GET
   *
   * @default GET
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttp#method
   */
  readonly method?: string;

  /**
   * Path defines the HTTP path that will be requested during health checking.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttp#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttp(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expectedResponse': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttpExpectedResponse(obj.expectedResponse),
    'expectedStatuses': obj.expectedStatuses?.map(y => y),
    'hostname': obj.hostname,
    'method': obj.method,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCP defines the configuration of tcp health checker.
 * It's required while the health checker type is TCP.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcp
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcp {
  /**
   * Receive defines the expected response payload.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcp#receive
   */
  readonly receive?: SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpReceive;

  /**
   * Send defines the request payload.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcp#send
   */
  readonly send?: SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpSend;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcp(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'receive': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpReceive(obj.receive),
    'send': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpSend(obj.send),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashCookie
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashCookie {
  /**
   * Additional Attributes to set for the generated cookie.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashCookie#attributes
   */
  readonly attributes?: { [key: string]: string };

  /**
   * Name of the cookie to hash.
   * If this cookie does not exist in the request, Envoy will generate a cookie and set
   * the TTL on the response back to the client based on Layer 4
   * attributes of the backend endpoint, to ensure that these future requests
   * go to the same backend endpoint. Make sure to set the TTL field for this case.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashCookie#name
   */
  readonly name: string;

  /**
   * TTL of the generated cookie if the cookie is not present. This value sets the
   * Max-Age attribute value.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashCookie#ttl
   */
  readonly ttl?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashCookie' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashCookie(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributes': ((obj.attributes) === undefined) ? undefined : (Object.entries(obj.attributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Header configures the header hash policy when the consistent hash type is set to Header.
 *
 * Deprecated: use Headers instead
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashHeader
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashHeader {
  /**
   * Name of the header to hash.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashHeader#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashHeader' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashHeader(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Header defines the header hashing configuration for consistent hash based
 * load balancing.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashHeaders
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashHeaders {
  /**
   * Name of the header to hash.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashHeaders#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashHeaders(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConsistentHashType defines the type of input to hash on. Valid Type values are
 * "SourceIP",
 * "Header",
 * "Headers",
 * "Cookie".
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashType
 */
export enum SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashType {
  /** SourceIP */
  SOURCE_IP = "SourceIP",
  /** Header */
  HEADER = "Header",
  /** Headers */
  HEADERS = "Headers",
  /** Cookie */
  COOKIE = "Cookie",
}

/**
 * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverrideExtractFrom
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverrideExtractFrom {
  /**
   * Header defines the header to get the override endpoint addresses.
   * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
   * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
   * The IPv6 address is enclosed in square brackets.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverrideExtractFrom#header
   */
  readonly header?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverrideExtractFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverrideExtractFrom(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverrideExtractFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': obj.header,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocal
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocal {
  /**
   * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
   * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocal#force
   */
  readonly force?: SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocalForce;

  /**
   * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocal#minEndpointsThreshold
   */
  readonly minEndpointsThreshold?: number;

  /**
   * Configures percentage of requests that will be considered for zone aware routing if zone aware routing is configured. If not specified, Envoy defaults to 100%.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocal#percentageEnabled
   */
  readonly percentageEnabled?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocal' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocal(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'force': toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocalForce(obj.force),
    'minEndpointsThreshold': obj.minEndpointsThreshold,
    'percentageEnabled': obj.percentageEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
 * back-off algorithm for retries. For additional details,
 * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetryBackOff
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetryBackOff {
  /**
   * BaseInterval is the base interval between retries.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetryBackOff#baseInterval
   */
  readonly baseInterval?: string;

  /**
   * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
   * The default is 10 times the base_interval
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetryBackOff#maxInterval
   */
  readonly maxInterval?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetryBackOff' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetryBackOff(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetryBackOff | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseInterval': obj.baseInterval,
    'maxInterval': obj.maxInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TriggerEnum specifies the conditions that trigger retries.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsRetryRetryOnTriggers
 */
export enum SecurityPolicySpecExtAuthGrpcBackendSettingsRetryRetryOnTriggers {
  /** 5xx */
  VALUE_5XX = "5xx",
  /** gateway-error */
  GATEWAY_HYPHEN_ERROR = "gateway-error",
  /** reset */
  RESET = "reset",
  /** reset-before-request */
  RESET_HYPHEN_BEFORE_HYPHEN_REQUEST = "reset-before-request",
  /** connect-failure */
  CONNECT_HYPHEN_FAILURE = "connect-failure",
  /** retriable-4xx */
  RETRIABLE_HYPHEN_4XX = "retriable-4xx",
  /** refused-stream */
  REFUSED_HYPHEN_STREAM = "refused-stream",
  /** retriable-status-codes */
  RETRIABLE_HYPHEN_STATUS_HYPHEN_CODES = "retriable-status-codes",
  /** cancelled */
  CANCELLED = "cancelled",
  /** deadline-exceeded */
  DEADLINE_HYPHEN_EXCEEDED = "deadline-exceeded",
  /** internal */
  INTERNAL = "internal",
  /** resource-exhausted */
  RESOURCE_HYPHEN_EXHAUSTED = "resource-exhausted",
  /** unavailable */
  UNAVAILABLE = "unavailable",
}

/**
 * GRPC defines the configuration of the GRPC health checker.
 * It's optional, and can only be used if the specified type is GRPC.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveGrpc
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveGrpc {
  /**
   * Service to send in the health check request.
   * If this is not specified, then the health check request applies to the entire
   * server and not to a specific service.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveGrpc(obj: SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP defines the configuration of http health checker.
 * It's required while the health checker type is HTTP.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttp
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttp {
  /**
   * ExpectedResponse defines a list of HTTP expected responses to match.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttp#expectedResponse
   */
  readonly expectedResponse?: SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttpExpectedResponse;

  /**
   * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
   * Defaults to 200 only
   *
   * @default 200 only
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttp#expectedStatuses
   */
  readonly expectedStatuses?: number[];

  /**
   * Hostname defines the HTTP host that will be requested during health checking.
   * Default: HTTPRoute or GRPCRoute hostname.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttp#hostname
   */
  readonly hostname?: string;

  /**
   * Method defines the HTTP method used for health checking.
   * Defaults to GET
   *
   * @default GET
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttp#method
   */
  readonly method?: string;

  /**
   * Path defines the HTTP path that will be requested during health checking.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttp#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttp(obj: SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expectedResponse': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttpExpectedResponse(obj.expectedResponse),
    'expectedStatuses': obj.expectedStatuses?.map(y => y),
    'hostname': obj.hostname,
    'method': obj.method,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCP defines the configuration of tcp health checker.
 * It's required while the health checker type is TCP.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcp
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcp {
  /**
   * Receive defines the expected response payload.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcp#receive
   */
  readonly receive?: SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpReceive;

  /**
   * Send defines the request payload.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcp#send
   */
  readonly send?: SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpSend;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcp(obj: SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'receive': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpReceive(obj.receive),
    'send': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpSend(obj.send),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashCookie
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashCookie {
  /**
   * Additional Attributes to set for the generated cookie.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashCookie#attributes
   */
  readonly attributes?: { [key: string]: string };

  /**
   * Name of the cookie to hash.
   * If this cookie does not exist in the request, Envoy will generate a cookie and set
   * the TTL on the response back to the client based on Layer 4
   * attributes of the backend endpoint, to ensure that these future requests
   * go to the same backend endpoint. Make sure to set the TTL field for this case.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashCookie#name
   */
  readonly name: string;

  /**
   * TTL of the generated cookie if the cookie is not present. This value sets the
   * Max-Age attribute value.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashCookie#ttl
   */
  readonly ttl?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashCookie' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashCookie(obj: SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributes': ((obj.attributes) === undefined) ? undefined : (Object.entries(obj.attributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Header configures the header hash policy when the consistent hash type is set to Header.
 *
 * Deprecated: use Headers instead
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashHeader
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashHeader {
  /**
   * Name of the header to hash.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashHeader#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashHeader' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashHeader(obj: SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Header defines the header hashing configuration for consistent hash based
 * load balancing.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashHeaders
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashHeaders {
  /**
   * Name of the header to hash.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashHeaders#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashHeaders(obj: SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConsistentHashType defines the type of input to hash on. Valid Type values are
 * "SourceIP",
 * "Header",
 * "Headers",
 * "Cookie".
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashType
 */
export enum SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashType {
  /** SourceIP */
  SOURCE_IP = "SourceIP",
  /** Header */
  HEADER = "Header",
  /** Headers */
  HEADERS = "Headers",
  /** Cookie */
  COOKIE = "Cookie",
}

/**
 * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverrideExtractFrom
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverrideExtractFrom {
  /**
   * Header defines the header to get the override endpoint addresses.
   * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
   * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
   * The IPv6 address is enclosed in square brackets.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverrideExtractFrom#header
   */
  readonly header?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverrideExtractFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverrideExtractFrom(obj: SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverrideExtractFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': obj.header,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocal
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocal {
  /**
   * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
   * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocal#force
   */
  readonly force?: SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocalForce;

  /**
   * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocal#minEndpointsThreshold
   */
  readonly minEndpointsThreshold?: number;

  /**
   * Configures percentage of requests that will be considered for zone aware routing if zone aware routing is configured. If not specified, Envoy defaults to 100%.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocal#percentageEnabled
   */
  readonly percentageEnabled?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocal' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocal(obj: SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'force': toJson_SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocalForce(obj.force),
    'minEndpointsThreshold': obj.minEndpointsThreshold,
    'percentageEnabled': obj.percentageEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
 * back-off algorithm for retries. For additional details,
 * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetryBackOff
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetryBackOff {
  /**
   * BaseInterval is the base interval between retries.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetryBackOff#baseInterval
   */
  readonly baseInterval?: string;

  /**
   * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
   * The default is 10 times the base_interval
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetryBackOff#maxInterval
   */
  readonly maxInterval?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetryBackOff' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetryBackOff(obj: SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetryBackOff | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseInterval': obj.baseInterval,
    'maxInterval': obj.maxInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TriggerEnum specifies the conditions that trigger retries.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsRetryRetryOnTriggers
 */
export enum SecurityPolicySpecExtAuthHttpBackendSettingsRetryRetryOnTriggers {
  /** 5xx */
  VALUE_5XX = "5xx",
  /** gateway-error */
  GATEWAY_HYPHEN_ERROR = "gateway-error",
  /** reset */
  RESET = "reset",
  /** reset-before-request */
  RESET_HYPHEN_BEFORE_HYPHEN_REQUEST = "reset-before-request",
  /** connect-failure */
  CONNECT_HYPHEN_FAILURE = "connect-failure",
  /** retriable-4xx */
  RETRIABLE_HYPHEN_4XX = "retriable-4xx",
  /** refused-stream */
  REFUSED_HYPHEN_STREAM = "refused-stream",
  /** retriable-status-codes */
  RETRIABLE_HYPHEN_STATUS_HYPHEN_CODES = "retriable-status-codes",
  /** cancelled */
  CANCELLED = "cancelled",
  /** deadline-exceeded */
  DEADLINE_HYPHEN_EXCEEDED = "deadline-exceeded",
  /** internal */
  INTERNAL = "internal",
  /** resource-exhausted */
  RESOURCE_HYPHEN_EXHAUSTED = "resource-exhausted",
  /** unavailable */
  UNAVAILABLE = "unavailable",
}

/**
 * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsCircuitBreakerPerEndpoint
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsCircuitBreakerPerEndpoint {
  /**
   * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsCircuitBreakerPerEndpoint#maxConnections
   */
  readonly maxConnections?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsCircuitBreakerPerEndpoint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsCircuitBreakerPerEndpoint(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsCircuitBreakerPerEndpoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConnections': obj.maxConnections,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
 * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
 * If unspecified, an implementation defined default is applied (32768 bytes).
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note: that when the suffix is not provided, the value is interpreted as bytes.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnectionBufferLimit
 */
export class SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnectionBufferLimit {
  public static fromNumber(value: number): SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnectionBufferLimit {
    return new SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnectionBufferLimit(value);
  }
  public static fromString(value: string): SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnectionBufferLimit {
    return new SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnectionBufferLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Preconnect configures proactive upstream connections to reduce latency by establishing
 * connections before they’re needed and avoiding connection establishment overhead.
 *
 * If unset, Envoy will fetch connections as needed to serve in-flight requests.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnectionPreconnect
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnectionPreconnect {
  /**
   * PerEndpointPercent configures how many additional connections to maintain per
   * upstream endpoint, useful for high-QPS or latency sensitive services. Expressed as a
   * percentage of the connections required by active streams
   * (e.g. 100 = preconnect disabled, 105 = 1.05x connections per-endpoint, 200 = 2.00×).
   *
   * Allowed value range is between 100-300. When both PerEndpointPercent and
   * PredictivePercent are set, Envoy ensures both are satisfied (max of the two).
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnectionPreconnect#perEndpointPercent
   */
  readonly perEndpointPercent?: number;

  /**
   * PredictivePercent configures how many additional connections to maintain
   * across the cluster by anticipating which upstream endpoint the load balancer
   * will select next, useful for low-QPS services. Relies on deterministic
   * loadbalancing and is only supported with Random or RoundRobin.
   * Expressed as a percentage of the connections required by active streams
   * (e.g. 100 = 1.0 (no preconnect), 105 = 1.05× connections across the cluster, 200 = 2.00×).
   *
   * Minimum allowed value is 100. When both PerEndpointPercent and PredictivePercent are
   * set Envoy ensures both are satisfied per host (max of the two).
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnectionPreconnect#predictivePercent
   */
  readonly predictivePercent?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnectionPreconnect' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnectionPreconnect(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnectionPreconnect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'perEndpointPercent': obj.perEndpointPercent,
    'predictivePercent': obj.predictivePercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
 * to backend.
 * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
 * For example, 20Mi, 1Gi, 256Ki etc.
 * Note that when the suffix is not provided, the value is interpreted as bytes.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnectionSocketBufferLimit
 */
export class SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnectionSocketBufferLimit {
  public static fromNumber(value: number): SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnectionSocketBufferLimit {
    return new SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnectionSocketBufferLimit(value);
  }
  public static fromString(value: string): SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnectionSocketBufferLimit {
    return new SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsConnectionSocketBufferLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
 * If set, this configuration overrides other defaults.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsDnsLookupFamily
 */
export enum SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsDnsLookupFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
  /** IPv4Preferred */
  I_PV4_PREFERRED = "IPv4Preferred",
  /** IPv6Preferred */
  I_PV6_PREFERRED = "IPv6Preferred",
  /** IPv4AndIPv6 */
  I_PV4_AND_I_PV6 = "IPv4AndIPv6",
}

/**
 * Active health check configuration
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActive
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActive {
  /**
   * GRPC defines the configuration of the GRPC health checker.
   * It's optional, and can only be used if the specified type is GRPC.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActive#grpc
   */
  readonly grpc?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveGrpc;

  /**
   * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActive#healthyThreshold
   */
  readonly healthyThreshold?: number;

  /**
   * HTTP defines the configuration of http health checker.
   * It's required while the health checker type is HTTP.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActive#http
   */
  readonly http?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveHttp;

  /**
   * InitialJitter defines the maximum time Envoy will wait before the first health check.
   * Envoy will randomly select a value between 0 and the initial jitter value.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActive#initialJitter
   */
  readonly initialJitter?: string;

  /**
   * Interval defines the time between active health checks.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActive#interval
   */
  readonly interval?: string;

  /**
   * TCP defines the configuration of tcp health checker.
   * It's required while the health checker type is TCP.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActive#tcp
   */
  readonly tcp?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcp;

  /**
   * Timeout defines the time to wait for a health check response.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActive#timeout
   */
  readonly timeout?: string;

  /**
   * Type defines the type of health checker.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActive#type
   */
  readonly type: string;

  /**
   * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActive#unhealthyThreshold
   */
  readonly unhealthyThreshold?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActive(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpc': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveGrpc(obj.grpc),
    'healthyThreshold': obj.healthyThreshold,
    'http': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveHttp(obj.http),
    'initialJitter': obj.initialJitter,
    'interval': obj.interval,
    'tcp': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcp(obj.tcp),
    'timeout': obj.timeout,
    'type': obj.type,
    'unhealthyThreshold': obj.unhealthyThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Passive passive check configuration
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckPassive
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckPassive {
  /**
   * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckPassive#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckPassive#consecutive5XxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckPassive#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
   * Parameter takes effect only when split_external_local_origin_errors is set to true.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckPassive#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * FailurePercentageThreshold sets the failure percentage threshold for outlier detection.
   * If the failure percentage of a given host is greater than or equal to this value, it will be ejected.
   * Defaults to 85.
   *
   * @default 85.
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckPassive#failurePercentageThreshold
   */
  readonly failurePercentageThreshold?: number;

  /**
   * Interval defines the time between passive health checks.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckPassive#interval
   */
  readonly interval?: string;

  /**
   * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckPassive#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckPassive#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckPassive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckPassive(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckPassive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5XxErrors': obj.consecutive5XxErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'failurePercentageThreshold': obj.failurePercentageThreshold,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
 * If not set, the default value is 1 MiB.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2InitialConnectionWindowSize
 */
export class SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2InitialConnectionWindowSize {
  public static fromNumber(value: number): SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2InitialConnectionWindowSize {
    return new SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2InitialConnectionWindowSize(value);
  }
  public static fromString(value: string): SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2InitialConnectionWindowSize {
    return new SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2InitialConnectionWindowSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
 * If not set, the default value is 64 KiB(64*1024).
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2InitialStreamWindowSize
 */
export class SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2InitialStreamWindowSize {
  public static fromNumber(value: number): SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2InitialStreamWindowSize {
    return new SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2InitialStreamWindowSize(value);
  }
  public static fromString(value: string): SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2InitialStreamWindowSize {
    return new SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHttp2InitialStreamWindowSize(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ConsistentHash defines the configuration when the load balancer type is
 * set to ConsistentHash
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHash
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHash {
  /**
   * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHash#cookie
   */
  readonly cookie?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashCookie;

  /**
   * Header configures the header hash policy when the consistent hash type is set to Header.
   *
   * Deprecated: use Headers instead
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHash#header
   */
  readonly header?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashHeader;

  /**
   * Headers configures the header hash policy for each header, when the consistent hash type is set to Headers.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHash#headers
   */
  readonly headers?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashHeaders[];

  /**
   * The table size for consistent hashing, must be prime number limited to 5000011.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHash#tableSize
   */
  readonly tableSize?: number;

  /**
   * ConsistentHashType defines the type of input to hash on. Valid Type values are
   * "SourceIP",
   * "Header",
   * "Headers",
   * "Cookie".
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHash#type
   */
  readonly type: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashType;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHash(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookie': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashCookie(obj.cookie),
    'header': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashHeader(obj.header),
    'headers': obj.headers?.map(y => toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashHeaders(y)),
    'tableSize': obj.tableSize,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EndpointOverride defines the configuration for endpoint override.
 * When specified, the load balancer will attempt to route requests to endpoints
 * based on the override information extracted from request headers or metadata.
 * If the override endpoints are not available, the configured load balancer policy will be used as fallback.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerEndpointOverride
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerEndpointOverride {
  /**
   * ExtractFrom defines the sources to extract endpoint override information from.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerEndpointOverride#extractFrom
   */
  readonly extractFrom: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerEndpointOverrideExtractFrom[];
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerEndpointOverride' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerEndpointOverride(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerEndpointOverride | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extractFrom': obj.extractFrom?.map(y => toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerEndpointOverrideExtractFrom(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SlowStart defines the configuration related to the slow start load balancer policy.
 * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
 * Currently this is only supported for RoundRobin and LeastRequest load balancers
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerSlowStart
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerSlowStart {
  /**
   * Window defines the duration of the warm up period for newly added host.
   * During slow start window, traffic sent to the newly added hosts will gradually increase.
   * Currently only supports linear growth of traffic. For additional details,
   * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerSlowStart#window
   */
  readonly window: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerSlowStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerSlowStart(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerSlowStart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'window': obj.window,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type decides the type of Load Balancer policy.
 * Valid LoadBalancerType values are
 * "ConsistentHash",
 * "LeastRequest",
 * "Random",
 * "RoundRobin".
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerType
 */
export enum SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerType {
  /** ConsistentHash */
  CONSISTENT_HASH = "ConsistentHash",
  /** LeastRequest */
  LEAST_REQUEST = "LeastRequest",
  /** Random */
  RANDOM = "Random",
  /** RoundRobin */
  ROUND_ROBIN = "RoundRobin",
}

/**
 * ZoneAware defines the configuration related to the distribution of requests between locality zones.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAware
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAware {
  /**
   * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAware#preferLocal
   */
  readonly preferLocal?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAwarePreferLocal;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAware' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAware(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAware | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferLocal': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAwarePreferLocal(obj.preferLocal),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Version of ProxyProtol
 * Valid ProxyProtocolVersion values are
 * "V1"
 * "V2"
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsProxyProtocolVersion
 */
export enum SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsProxyProtocolVersion {
  /** V1 */
  V1 = "V1",
  /** V2 */
  V2 = "V2",
}

/**
 * PerRetry is the retry policy to be applied per retry attempt.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryPerRetry
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryPerRetry {
  /**
   * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
   * back-off algorithm for retries. For additional details,
   * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryPerRetry#backOff
   */
  readonly backOff?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryPerRetryBackOff;

  /**
   * Timeout is the timeout per retry attempt.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryPerRetry#timeout
   */
  readonly timeout?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryPerRetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryPerRetry(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryPerRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backOff': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryPerRetryBackOff(obj.backOff),
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RetryOn specifies the retry trigger condition.
 *
 * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryRetryOn
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryRetryOn {
  /**
   * HttpStatusCodes specifies the http status codes to be retried.
   * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryRetryOn#httpStatusCodes
   */
  readonly httpStatusCodes?: number[];

  /**
   * Triggers specifies the retry trigger condition(Http/Grpc).
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryRetryOn#triggers
   */
  readonly triggers?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryRetryOnTriggers[];
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryRetryOn' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryRetryOn(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryRetryOn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpStatusCodes': obj.httpStatusCodes?.map(y => y),
    'triggers': obj.triggers?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for HTTP.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeoutHttp
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeoutHttp {
  /**
   * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
   * Default: 1 hour.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeoutHttp#connectionIdleTimeout
   */
  readonly connectionIdleTimeout?: string;

  /**
   * The maximum duration of an HTTP connection.
   * Default: unlimited.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeoutHttp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * MaxStreamDuration is the maximum duration for a stream to complete. This timeout measures the time
   * from when the request is sent until the response stream is fully consumed and does not apply to
   * non-streaming requests.
   * When set to "0s", no max duration is applied and streams can run indefinitely.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeoutHttp#maxStreamDuration
   */
  readonly maxStreamDuration?: string;

  /**
   * RequestTimeout is the time until which entire response is received from the upstream.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeoutHttp#requestTimeout
   */
  readonly requestTimeout?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeoutHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeoutHttp(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeoutHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionIdleTimeout': obj.connectionIdleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxStreamDuration': obj.maxStreamDuration,
    'requestTimeout': obj.requestTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Timeout settings for TCP.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeoutTcp
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeoutTcp {
  /**
   * The timeout for network connection establishment, including TCP and TLS handshakes.
   * Default: 10 seconds.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeoutTcp#connectTimeout
   */
  readonly connectTimeout?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeoutTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeoutTcp(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsTimeoutTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC defines the configuration of the GRPC health checker.
 * It's optional, and can only be used if the specified type is GRPC.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveGrpc
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveGrpc {
  /**
   * Service to send in the health check request.
   * If this is not specified, then the health check request applies to the entire
   * server and not to a specific service.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveGrpc(obj: SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP defines the configuration of http health checker.
 * It's required while the health checker type is HTTP.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttp
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttp {
  /**
   * ExpectedResponse defines a list of HTTP expected responses to match.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttp#expectedResponse
   */
  readonly expectedResponse?: SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttpExpectedResponse;

  /**
   * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
   * Defaults to 200 only
   *
   * @default 200 only
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttp#expectedStatuses
   */
  readonly expectedStatuses?: number[];

  /**
   * Hostname defines the HTTP host that will be requested during health checking.
   * Default: HTTPRoute or GRPCRoute hostname.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttp#hostname
   */
  readonly hostname?: string;

  /**
   * Method defines the HTTP method used for health checking.
   * Defaults to GET
   *
   * @default GET
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttp#method
   */
  readonly method?: string;

  /**
   * Path defines the HTTP path that will be requested during health checking.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttp#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttp(obj: SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expectedResponse': toJson_SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttpExpectedResponse(obj.expectedResponse),
    'expectedStatuses': obj.expectedStatuses?.map(y => y),
    'hostname': obj.hostname,
    'method': obj.method,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCP defines the configuration of tcp health checker.
 * It's required while the health checker type is TCP.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcp
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcp {
  /**
   * Receive defines the expected response payload.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcp#receive
   */
  readonly receive?: SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpReceive;

  /**
   * Send defines the request payload.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcp#send
   */
  readonly send?: SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpSend;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcp(obj: SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'receive': toJson_SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpReceive(obj.receive),
    'send': toJson_SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpSend(obj.send),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashCookie
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashCookie {
  /**
   * Additional Attributes to set for the generated cookie.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashCookie#attributes
   */
  readonly attributes?: { [key: string]: string };

  /**
   * Name of the cookie to hash.
   * If this cookie does not exist in the request, Envoy will generate a cookie and set
   * the TTL on the response back to the client based on Layer 4
   * attributes of the backend endpoint, to ensure that these future requests
   * go to the same backend endpoint. Make sure to set the TTL field for this case.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashCookie#name
   */
  readonly name: string;

  /**
   * TTL of the generated cookie if the cookie is not present. This value sets the
   * Max-Age attribute value.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashCookie#ttl
   */
  readonly ttl?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashCookie' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashCookie(obj: SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributes': ((obj.attributes) === undefined) ? undefined : (Object.entries(obj.attributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Header configures the header hash policy when the consistent hash type is set to Header.
 *
 * Deprecated: use Headers instead
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashHeader
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashHeader {
  /**
   * Name of the header to hash.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashHeader#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashHeader' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashHeader(obj: SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Header defines the header hashing configuration for consistent hash based
 * load balancing.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashHeaders
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashHeaders {
  /**
   * Name of the header to hash.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashHeaders#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashHeaders(obj: SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConsistentHashType defines the type of input to hash on. Valid Type values are
 * "SourceIP",
 * "Header",
 * "Headers",
 * "Cookie".
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashType
 */
export enum SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashType {
  /** SourceIP */
  SOURCE_IP = "SourceIP",
  /** Header */
  HEADER = "Header",
  /** Headers */
  HEADERS = "Headers",
  /** Cookie */
  COOKIE = "Cookie",
}

/**
 * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverrideExtractFrom
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverrideExtractFrom {
  /**
   * Header defines the header to get the override endpoint addresses.
   * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
   * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
   * The IPv6 address is enclosed in square brackets.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverrideExtractFrom#header
   */
  readonly header?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverrideExtractFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverrideExtractFrom(obj: SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverrideExtractFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': obj.header,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocal
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocal {
  /**
   * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
   * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocal#force
   */
  readonly force?: SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForce;

  /**
   * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocal#minEndpointsThreshold
   */
  readonly minEndpointsThreshold?: number;

  /**
   * Configures percentage of requests that will be considered for zone aware routing if zone aware routing is configured. If not specified, Envoy defaults to 100%.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocal#percentageEnabled
   */
  readonly percentageEnabled?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocal' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocal(obj: SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'force': toJson_SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForce(obj.force),
    'minEndpointsThreshold': obj.minEndpointsThreshold,
    'percentageEnabled': obj.percentageEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
 * back-off algorithm for retries. For additional details,
 * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetryBackOff
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetryBackOff {
  /**
   * BaseInterval is the base interval between retries.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetryBackOff#baseInterval
   */
  readonly baseInterval?: string;

  /**
   * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
   * The default is 10 times the base_interval
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetryBackOff#maxInterval
   */
  readonly maxInterval?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetryBackOff' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetryBackOff(obj: SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetryBackOff | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseInterval': obj.baseInterval,
    'maxInterval': obj.maxInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TriggerEnum specifies the conditions that trigger retries.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsRetryRetryOnTriggers
 */
export enum SecurityPolicySpecOidcProviderBackendSettingsRetryRetryOnTriggers {
  /** 5xx */
  VALUE_5XX = "5xx",
  /** gateway-error */
  GATEWAY_HYPHEN_ERROR = "gateway-error",
  /** reset */
  RESET = "reset",
  /** reset-before-request */
  RESET_HYPHEN_BEFORE_HYPHEN_REQUEST = "reset-before-request",
  /** connect-failure */
  CONNECT_HYPHEN_FAILURE = "connect-failure",
  /** retriable-4xx */
  RETRIABLE_HYPHEN_4XX = "retriable-4xx",
  /** refused-stream */
  REFUSED_HYPHEN_STREAM = "refused-stream",
  /** retriable-status-codes */
  RETRIABLE_HYPHEN_STATUS_HYPHEN_CODES = "retriable-status-codes",
  /** cancelled */
  CANCELLED = "cancelled",
  /** deadline-exceeded */
  DEADLINE_HYPHEN_EXCEEDED = "deadline-exceeded",
  /** internal */
  INTERNAL = "internal",
  /** resource-exhausted */
  RESOURCE_HYPHEN_EXHAUSTED = "resource-exhausted",
  /** unavailable */
  UNAVAILABLE = "unavailable",
}

/**
 * ExpectedResponse defines a list of HTTP expected responses to match.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttpExpectedResponse
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttpExpectedResponse {
  /**
   * Binary payload base64 encoded.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttpExpectedResponse#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttpExpectedResponse#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttpExpectedResponse#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttpExpectedResponse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttpExpectedResponse(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttpExpectedResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Receive defines the expected response payload.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpReceive
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpReceive {
  /**
   * Binary payload base64 encoded.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpReceive#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpReceive#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpReceive#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpReceive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpReceive(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpReceive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Send defines the request payload.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpSend
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpSend {
  /**
   * Binary payload base64 encoded.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpSend#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpSend#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpSend#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpSend' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpSend(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpSend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
 * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
 *
 * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocalForce
 */
export interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocalForce {
  /**
   * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
   * override. This is useful for protecting zones with fewer endpoints.
   *
   * @schema SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocalForce#minEndpointsInZoneThreshold
   */
  readonly minEndpointsInZoneThreshold?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocalForce' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocalForce(obj: SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocalForce | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minEndpointsInZoneThreshold': obj.minEndpointsInZoneThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExpectedResponse defines a list of HTTP expected responses to match.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttpExpectedResponse
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttpExpectedResponse {
  /**
   * Binary payload base64 encoded.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttpExpectedResponse#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttpExpectedResponse#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttpExpectedResponse#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttpExpectedResponse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttpExpectedResponse(obj: SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttpExpectedResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Receive defines the expected response payload.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpReceive
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpReceive {
  /**
   * Binary payload base64 encoded.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpReceive#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpReceive#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpReceive#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpReceive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpReceive(obj: SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpReceive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Send defines the request payload.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpSend
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpSend {
  /**
   * Binary payload base64 encoded.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpSend#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpSend#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpSend#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpSend' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpSend(obj: SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpSend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
 * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
 *
 * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocalForce
 */
export interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocalForce {
  /**
   * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
   * override. This is useful for protecting zones with fewer endpoints.
   *
   * @schema SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocalForce#minEndpointsInZoneThreshold
   */
  readonly minEndpointsInZoneThreshold?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocalForce' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocalForce(obj: SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocalForce | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minEndpointsInZoneThreshold': obj.minEndpointsInZoneThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC defines the configuration of the GRPC health checker.
 * It's optional, and can only be used if the specified type is GRPC.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveGrpc
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveGrpc {
  /**
   * Service to send in the health check request.
   * If this is not specified, then the health check request applies to the entire
   * server and not to a specific service.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveGrpc(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP defines the configuration of http health checker.
 * It's required while the health checker type is HTTP.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveHttp
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveHttp {
  /**
   * ExpectedResponse defines a list of HTTP expected responses to match.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveHttp#expectedResponse
   */
  readonly expectedResponse?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveHttpExpectedResponse;

  /**
   * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
   * Defaults to 200 only
   *
   * @default 200 only
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveHttp#expectedStatuses
   */
  readonly expectedStatuses?: number[];

  /**
   * Hostname defines the HTTP host that will be requested during health checking.
   * Default: HTTPRoute or GRPCRoute hostname.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveHttp#hostname
   */
  readonly hostname?: string;

  /**
   * Method defines the HTTP method used for health checking.
   * Defaults to GET
   *
   * @default GET
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveHttp#method
   */
  readonly method?: string;

  /**
   * Path defines the HTTP path that will be requested during health checking.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveHttp#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveHttp(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expectedResponse': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveHttpExpectedResponse(obj.expectedResponse),
    'expectedStatuses': obj.expectedStatuses?.map(y => y),
    'hostname': obj.hostname,
    'method': obj.method,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCP defines the configuration of tcp health checker.
 * It's required while the health checker type is TCP.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcp
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcp {
  /**
   * Receive defines the expected response payload.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcp#receive
   */
  readonly receive?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcpReceive;

  /**
   * Send defines the request payload.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcp#send
   */
  readonly send?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcpSend;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcp(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'receive': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcpReceive(obj.receive),
    'send': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcpSend(obj.send),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashCookie
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashCookie {
  /**
   * Additional Attributes to set for the generated cookie.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashCookie#attributes
   */
  readonly attributes?: { [key: string]: string };

  /**
   * Name of the cookie to hash.
   * If this cookie does not exist in the request, Envoy will generate a cookie and set
   * the TTL on the response back to the client based on Layer 4
   * attributes of the backend endpoint, to ensure that these future requests
   * go to the same backend endpoint. Make sure to set the TTL field for this case.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashCookie#name
   */
  readonly name: string;

  /**
   * TTL of the generated cookie if the cookie is not present. This value sets the
   * Max-Age attribute value.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashCookie#ttl
   */
  readonly ttl?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashCookie' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashCookie(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributes': ((obj.attributes) === undefined) ? undefined : (Object.entries(obj.attributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Header configures the header hash policy when the consistent hash type is set to Header.
 *
 * Deprecated: use Headers instead
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashHeader
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashHeader {
  /**
   * Name of the header to hash.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashHeader#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashHeader' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashHeader(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Header defines the header hashing configuration for consistent hash based
 * load balancing.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashHeaders
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashHeaders {
  /**
   * Name of the header to hash.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashHeaders#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashHeaders(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConsistentHashType defines the type of input to hash on. Valid Type values are
 * "SourceIP",
 * "Header",
 * "Headers",
 * "Cookie".
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashType
 */
export enum SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerConsistentHashType {
  /** SourceIP */
  SOURCE_IP = "SourceIP",
  /** Header */
  HEADER = "Header",
  /** Headers */
  HEADERS = "Headers",
  /** Cookie */
  COOKIE = "Cookie",
}

/**
 * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerEndpointOverrideExtractFrom
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerEndpointOverrideExtractFrom {
  /**
   * Header defines the header to get the override endpoint addresses.
   * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
   * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
   * The IPv6 address is enclosed in square brackets.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerEndpointOverrideExtractFrom#header
   */
  readonly header?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerEndpointOverrideExtractFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerEndpointOverrideExtractFrom(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerEndpointOverrideExtractFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'header': obj.header,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAwarePreferLocal
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAwarePreferLocal {
  /**
   * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
   * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAwarePreferLocal#force
   */
  readonly force?: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAwarePreferLocalForce;

  /**
   * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAwarePreferLocal#minEndpointsThreshold
   */
  readonly minEndpointsThreshold?: number;

  /**
   * Configures percentage of requests that will be considered for zone aware routing if zone aware routing is configured. If not specified, Envoy defaults to 100%.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAwarePreferLocal#percentageEnabled
   */
  readonly percentageEnabled?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAwarePreferLocal' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAwarePreferLocal(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAwarePreferLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'force': toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAwarePreferLocalForce(obj.force),
    'minEndpointsThreshold': obj.minEndpointsThreshold,
    'percentageEnabled': obj.percentageEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
 * back-off algorithm for retries. For additional details,
 * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryPerRetryBackOff
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryPerRetryBackOff {
  /**
   * BaseInterval is the base interval between retries.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryPerRetryBackOff#baseInterval
   */
  readonly baseInterval?: string;

  /**
   * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
   * The default is 10 times the base_interval
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryPerRetryBackOff#maxInterval
   */
  readonly maxInterval?: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryPerRetryBackOff' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryPerRetryBackOff(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryPerRetryBackOff | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseInterval': obj.baseInterval,
    'maxInterval': obj.maxInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TriggerEnum specifies the conditions that trigger retries.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryRetryOnTriggers
 */
export enum SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsRetryRetryOnTriggers {
  /** 5xx */
  VALUE_5XX = "5xx",
  /** gateway-error */
  GATEWAY_HYPHEN_ERROR = "gateway-error",
  /** reset */
  RESET = "reset",
  /** reset-before-request */
  RESET_HYPHEN_BEFORE_HYPHEN_REQUEST = "reset-before-request",
  /** connect-failure */
  CONNECT_HYPHEN_FAILURE = "connect-failure",
  /** retriable-4xx */
  RETRIABLE_HYPHEN_4XX = "retriable-4xx",
  /** refused-stream */
  REFUSED_HYPHEN_STREAM = "refused-stream",
  /** retriable-status-codes */
  RETRIABLE_HYPHEN_STATUS_HYPHEN_CODES = "retriable-status-codes",
  /** cancelled */
  CANCELLED = "cancelled",
  /** deadline-exceeded */
  DEADLINE_HYPHEN_EXCEEDED = "deadline-exceeded",
  /** internal */
  INTERNAL = "internal",
  /** resource-exhausted */
  RESOURCE_HYPHEN_EXHAUSTED = "resource-exhausted",
  /** unavailable */
  UNAVAILABLE = "unavailable",
}

/**
 * ExpectedResponse defines a list of HTTP expected responses to match.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttpExpectedResponse
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttpExpectedResponse {
  /**
   * Binary payload base64 encoded.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttpExpectedResponse#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttpExpectedResponse#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttpExpectedResponse#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttpExpectedResponse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttpExpectedResponse(obj: SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttpExpectedResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Receive defines the expected response payload.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpReceive
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpReceive {
  /**
   * Binary payload base64 encoded.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpReceive#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpReceive#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpReceive#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpReceive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpReceive(obj: SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpReceive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Send defines the request payload.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpSend
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpSend {
  /**
   * Binary payload base64 encoded.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpSend#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpSend#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpSend#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpSend' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpSend(obj: SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpSend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
 * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
 *
 * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForce
 */
export interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForce {
  /**
   * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
   * override. This is useful for protecting zones with fewer endpoints.
   *
   * @schema SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForce#minEndpointsInZoneThreshold
   */
  readonly minEndpointsInZoneThreshold?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForce' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForce(obj: SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForce | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minEndpointsInZoneThreshold': obj.minEndpointsInZoneThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExpectedResponse defines a list of HTTP expected responses to match.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveHttpExpectedResponse
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveHttpExpectedResponse {
  /**
   * Binary payload base64 encoded.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveHttpExpectedResponse#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveHttpExpectedResponse#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveHttpExpectedResponse#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveHttpExpectedResponse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveHttpExpectedResponse(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveHttpExpectedResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Receive defines the expected response payload.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcpReceive
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcpReceive {
  /**
   * Binary payload base64 encoded.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcpReceive#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcpReceive#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcpReceive#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcpReceive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcpReceive(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcpReceive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Send defines the request payload.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcpSend
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcpSend {
  /**
   * Binary payload base64 encoded.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcpSend#binary
   */
  readonly binary?: string;

  /**
   * Text payload in plain text.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcpSend#text
   */
  readonly text?: string;

  /**
   * Type defines the type of the payload.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcpSend#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcpSend' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcpSend(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsHealthCheckActiveTcpSend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'binary': obj.binary,
    'text': obj.text,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
 * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
 *
 * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAwarePreferLocalForce
 */
export interface SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAwarePreferLocalForce {
  /**
   * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
   * override. This is useful for protecting zones with fewer endpoints.
   *
   * @schema SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAwarePreferLocalForce#minEndpointsInZoneThreshold
   */
  readonly minEndpointsInZoneThreshold?: number;
}

/**
 * Converts an object of type 'SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAwarePreferLocalForce' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAwarePreferLocalForce(obj: SecurityPolicySpecJwtProvidersRemoteJwksBackendSettingsLoadBalancerZoneAwarePreferLocalForce | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minEndpointsInZoneThreshold': obj.minEndpointsInZoneThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

