// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 *
 *
 * @schema WrappedGateway
 */
export class WrappedGateway extends ApiObject {
  /**
   * Returns the apiVersion and kind for "WrappedGateway"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'gateway-route-sync.homelab-helper.benfiola.com/v1',
    kind: 'WrappedGateway',
  }

  /**
   * Renders a Kubernetes manifest for "WrappedGateway".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WrappedGatewayProps): any {
    return {
      ...WrappedGateway.GVK,
      ...toJson_WrappedGatewayProps(props),
    };
  }

  /**
   * Defines a "WrappedGateway" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WrappedGatewayProps) {
    super(scope, id, {
      ...WrappedGateway.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...WrappedGateway.GVK,
      ...toJson_WrappedGatewayProps(resolved),
    };
  }
}

/**
 * @schema WrappedGateway
 */
export interface WrappedGatewayProps {
  /**
   * @schema WrappedGateway#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * @schema WrappedGateway#spec
   */
  readonly spec: WrappedGatewaySpec;
}

/**
 * Converts an object of type 'WrappedGatewayProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WrappedGatewayProps(obj: WrappedGatewayProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WrappedGatewaySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema WrappedGatewaySpec
 */
export interface WrappedGatewaySpec {
  /**
   * @schema WrappedGatewaySpec#addresses
   */
  readonly addresses?: WrappedGatewaySpecAddresses[];

  /**
   * GatewayBackendTLS describes backend TLS configuration for gateway.
   *
   * @schema WrappedGatewaySpec#backendTLS
   */
  readonly backendTls?: WrappedGatewaySpecBackendTls;

  /**
   * ObjectName refers to the name of a Kubernetes object.
   * Object names can have a variety of forms, including RFC 1123 subdomains,
   * RFC 1123 labels, or RFC 1035 labels.
   *
   * @schema WrappedGatewaySpec#gatewayClassName
   */
  readonly gatewayClassName: string;

  /**
   * GatewayInfrastructure defines infrastructure level attributes about a Gateway instance.
   *
   * @schema WrappedGatewaySpec#infrastructure
   */
  readonly infrastructure?: WrappedGatewaySpecInfrastructure;
}

/**
 * Converts an object of type 'WrappedGatewaySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WrappedGatewaySpec(obj: WrappedGatewaySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addresses': obj.addresses?.map(y => toJson_WrappedGatewaySpecAddresses(y)),
    'backendTLS': toJson_WrappedGatewaySpecBackendTls(obj.backendTls),
    'gatewayClassName': obj.gatewayClassName,
    'infrastructure': toJson_WrappedGatewaySpecInfrastructure(obj.infrastructure),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GatewaySpecAddress describes an address that can be bound to a Gateway.
 *
 * @schema WrappedGatewaySpecAddresses
 */
export interface WrappedGatewaySpecAddresses {
  /**
   * Type of the address.
   *
   * @schema WrappedGatewaySpecAddresses#type
   */
  readonly type?: string;

  /**
   * When a value is unspecified, an implementation SHOULD automatically
   * assign an address matching the requested type if possible.
   *
   * If an implementation does not support an empty value, they MUST set the
   * "Programmed" condition in status to False with a reason of "AddressNotAssigned".
   *
   * Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
   *
   * @schema WrappedGatewaySpecAddresses#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'WrappedGatewaySpecAddresses' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WrappedGatewaySpecAddresses(obj: WrappedGatewaySpecAddresses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GatewayBackendTLS describes backend TLS configuration for gateway.
 *
 * @schema WrappedGatewaySpecBackendTls
 */
export interface WrappedGatewaySpecBackendTls {
  /**
   * ClientCertificateRef is a reference to an object that contains a Client
   * Certificate and the associated private key.
   *
   * References to a resource in different namespace are invalid UNLESS there
   * is a ReferenceGrant in the target namespace that allows the certificate
   * to be attached. If a ReferenceGrant does not allow this reference, the
   * "ResolvedRefs" condition MUST be set to False for this listener with the
   * "RefNotPermitted" reason.
   *
   * ClientCertificateRef can reference to standard Kubernetes resources, i.e.
   * Secret, or implementation-specific custom resources.
   *
   * This setting can be overridden on the service level by use of BackendTLSPolicy.
   *
   * Support: Core
   *
   * <gateway:experimental>
   *
   * @schema WrappedGatewaySpecBackendTls#clientCertificateRef
   */
  readonly clientCertificateRef?: WrappedGatewaySpecBackendTlsClientCertificateRef;
}

/**
 * Converts an object of type 'WrappedGatewaySpecBackendTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WrappedGatewaySpecBackendTls(obj: WrappedGatewaySpecBackendTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCertificateRef': toJson_WrappedGatewaySpecBackendTlsClientCertificateRef(obj.clientCertificateRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GatewayInfrastructure defines infrastructure level attributes about a Gateway instance.
 *
 * @schema WrappedGatewaySpecInfrastructure
 */
export interface WrappedGatewaySpecInfrastructure {
  /**
   * Annotations that SHOULD be applied to any resources created in response to this Gateway.
   *
   * For implementations creating other Kubernetes objects, this should be the `metadata.annotations` field on resources.
   * For other implementations, this refers to any relevant (implementation specific) "annotations" concepts.
   *
   * An implementation may chose to add additional implementation-specific annotations as they see fit.
   *
   * Support: Extended
   *
   * @schema WrappedGatewaySpecInfrastructure#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels that SHOULD be applied to any resources created in response to this Gateway.
   *
   * For implementations creating other Kubernetes objects, this should be the `metadata.labels` field on resources.
   * For other implementations, this refers to any relevant (implementation specific) "labels" concepts.
   *
   * An implementation may chose to add additional implementation-specific labels as they see fit.
   *
   * If an implementation maps these labels to Pods, or any other resource that would need to be recreated when labels
   * change, it SHOULD clearly warn about this behavior in documentation.
   *
   * Support: Extended
   *
   * @schema WrappedGatewaySpecInfrastructure#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * ParametersRef is a reference to a resource that contains the configuration
   * parameters corresponding to the Gateway. This is optional if the
   * controller does not require any additional configuration.
   *
   * This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis
   *
   * The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
   * the merging behavior is implementation specific.
   * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
   *
   * If the referent cannot be found, refers to an unsupported kind, or when
   * the data within that resource is malformed, the Gateway SHOULD be
   * rejected with the "Accepted" status condition set to "False" and an
   * "InvalidParameters" reason.
   *
   * Support: Implementation-specific
   *
   * @schema WrappedGatewaySpecInfrastructure#parametersRef
   */
  readonly parametersRef?: WrappedGatewaySpecInfrastructureParametersRef;
}

/**
 * Converts an object of type 'WrappedGatewaySpecInfrastructure' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WrappedGatewaySpecInfrastructure(obj: WrappedGatewaySpecInfrastructure | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'parametersRef': toJson_WrappedGatewaySpecInfrastructureParametersRef(obj.parametersRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientCertificateRef is a reference to an object that contains a Client
 * Certificate and the associated private key.
 *
 * References to a resource in different namespace are invalid UNLESS there
 * is a ReferenceGrant in the target namespace that allows the certificate
 * to be attached. If a ReferenceGrant does not allow this reference, the
 * "ResolvedRefs" condition MUST be set to False for this listener with the
 * "RefNotPermitted" reason.
 *
 * ClientCertificateRef can reference to standard Kubernetes resources, i.e.
 * Secret, or implementation-specific custom resources.
 *
 * This setting can be overridden on the service level by use of BackendTLSPolicy.
 *
 * Support: Core
 *
 * <gateway:experimental>
 *
 * @schema WrappedGatewaySpecBackendTlsClientCertificateRef
 */
export interface WrappedGatewaySpecBackendTlsClientCertificateRef {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema WrappedGatewaySpecBackendTlsClientCertificateRef#group
   */
  readonly group?: string;

  /**
   * Kind is kind of the referent. For example "Secret".
   *
   * @schema WrappedGatewaySpecBackendTlsClientCertificateRef#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema WrappedGatewaySpecBackendTlsClientCertificateRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the referenced object. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema WrappedGatewaySpecBackendTlsClientCertificateRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'WrappedGatewaySpecBackendTlsClientCertificateRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WrappedGatewaySpecBackendTlsClientCertificateRef(obj: WrappedGatewaySpecBackendTlsClientCertificateRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ParametersRef is a reference to a resource that contains the configuration
 * parameters corresponding to the Gateway. This is optional if the
 * controller does not require any additional configuration.
 *
 * This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis
 *
 * The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
 * the merging behavior is implementation specific.
 * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
 *
 * If the referent cannot be found, refers to an unsupported kind, or when
 * the data within that resource is malformed, the Gateway SHOULD be
 * rejected with the "Accepted" status condition set to "False" and an
 * "InvalidParameters" reason.
 *
 * Support: Implementation-specific
 *
 * @schema WrappedGatewaySpecInfrastructureParametersRef
 */
export interface WrappedGatewaySpecInfrastructureParametersRef {
  /**
   * Group is the group of the referent.
   *
   * @schema WrappedGatewaySpecInfrastructureParametersRef#group
   */
  readonly group: string;

  /**
   * Kind is kind of the referent.
   *
   * @schema WrappedGatewaySpecInfrastructureParametersRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of the referent.
   *
   * @schema WrappedGatewaySpecInfrastructureParametersRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'WrappedGatewaySpecInfrastructureParametersRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WrappedGatewaySpecInfrastructureParametersRef(obj: WrappedGatewaySpecInfrastructureParametersRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

