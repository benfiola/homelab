// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 *
 *
 * @schema WrappedGateway
 */
export class WrappedGateway extends ApiObject {
  /**
   * Returns the apiVersion and kind for "WrappedGateway"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'gateway-route-sync.homelab-helper.benfiola.com/v1',
    kind: 'WrappedGateway',
  }

  /**
   * Renders a Kubernetes manifest for "WrappedGateway".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WrappedGatewayProps): any {
    return {
      ...WrappedGateway.GVK,
      ...toJson_WrappedGatewayProps(props),
    };
  }

  /**
   * Defines a "WrappedGateway" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WrappedGatewayProps) {
    super(scope, id, {
      ...WrappedGateway.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...WrappedGateway.GVK,
      ...toJson_WrappedGatewayProps(resolved),
    };
  }
}

/**
 * @schema WrappedGateway
 */
export interface WrappedGatewayProps {
  /**
   * @schema WrappedGateway#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * @schema WrappedGateway#spec
   */
  readonly spec: WrappedGatewaySpec;
}

/**
 * Converts an object of type 'WrappedGatewayProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WrappedGatewayProps(obj: WrappedGatewayProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WrappedGatewaySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema WrappedGatewaySpec
 */
export interface WrappedGatewaySpec {
  /**
   * @schema WrappedGatewaySpec#addresses
   */
  readonly addresses?: WrappedGatewaySpecAddresses[];

  /**
   * GatewayBackendTLS describes backend TLS configuration for gateway.
   *
   * @schema WrappedGatewaySpec#backendTLS
   */
  readonly backendTls?: WrappedGatewaySpecBackendTls;

  /**
   * ObjectName refers to the name of a Kubernetes object.
   * Object names can have a variety of forms, including RFC 1123 subdomains,
   * RFC 1123 labels, or RFC 1035 labels.
   *
   * @schema WrappedGatewaySpec#gatewayClassName
   */
  readonly gatewayClassName: string;

  /**
   * GatewayInfrastructure defines infrastructure level attributes about a Gateway instance.
   *
   * @schema WrappedGatewaySpec#infrastructure
   */
  readonly infrastructure?: WrappedGatewaySpecInfrastructure;

  /**
   * @schema WrappedGatewaySpec#listenerTemplate
   */
  readonly listenerTemplate: WrappedGatewaySpecListenerTemplate;
}

/**
 * Converts an object of type 'WrappedGatewaySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WrappedGatewaySpec(obj: WrappedGatewaySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addresses': obj.addresses?.map(y => toJson_WrappedGatewaySpecAddresses(y)),
    'backendTLS': toJson_WrappedGatewaySpecBackendTls(obj.backendTls),
    'gatewayClassName': obj.gatewayClassName,
    'infrastructure': toJson_WrappedGatewaySpecInfrastructure(obj.infrastructure),
    'listenerTemplate': toJson_WrappedGatewaySpecListenerTemplate(obj.listenerTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GatewaySpecAddress describes an address that can be bound to a Gateway.
 *
 * @schema WrappedGatewaySpecAddresses
 */
export interface WrappedGatewaySpecAddresses {
  /**
   * Type of the address.
   *
   * @schema WrappedGatewaySpecAddresses#type
   */
  readonly type?: string;

  /**
   * When a value is unspecified, an implementation SHOULD automatically
   * assign an address matching the requested type if possible.
   *
   * If an implementation does not support an empty value, they MUST set the
   * "Programmed" condition in status to False with a reason of "AddressNotAssigned".
   *
   * Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
   *
   * @schema WrappedGatewaySpecAddresses#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'WrappedGatewaySpecAddresses' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WrappedGatewaySpecAddresses(obj: WrappedGatewaySpecAddresses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GatewayBackendTLS describes backend TLS configuration for gateway.
 *
 * @schema WrappedGatewaySpecBackendTls
 */
export interface WrappedGatewaySpecBackendTls {
  /**
   * ClientCertificateRef is a reference to an object that contains a Client
   * Certificate and the associated private key.
   *
   * References to a resource in different namespace are invalid UNLESS there
   * is a ReferenceGrant in the target namespace that allows the certificate
   * to be attached. If a ReferenceGrant does not allow this reference, the
   * "ResolvedRefs" condition MUST be set to False for this listener with the
   * "RefNotPermitted" reason.
   *
   * ClientCertificateRef can reference to standard Kubernetes resources, i.e.
   * Secret, or implementation-specific custom resources.
   *
   * This setting can be overridden on the service level by use of BackendTLSPolicy.
   *
   * Support: Core
   *
   * <gateway:experimental>
   *
   * @schema WrappedGatewaySpecBackendTls#clientCertificateRef
   */
  readonly clientCertificateRef?: WrappedGatewaySpecBackendTlsClientCertificateRef;
}

/**
 * Converts an object of type 'WrappedGatewaySpecBackendTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WrappedGatewaySpecBackendTls(obj: WrappedGatewaySpecBackendTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCertificateRef': toJson_WrappedGatewaySpecBackendTlsClientCertificateRef(obj.clientCertificateRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GatewayInfrastructure defines infrastructure level attributes about a Gateway instance.
 *
 * @schema WrappedGatewaySpecInfrastructure
 */
export interface WrappedGatewaySpecInfrastructure {
  /**
   * Annotations that SHOULD be applied to any resources created in response to this Gateway.
   *
   * For implementations creating other Kubernetes objects, this should be the `metadata.annotations` field on resources.
   * For other implementations, this refers to any relevant (implementation specific) "annotations" concepts.
   *
   * An implementation may chose to add additional implementation-specific annotations as they see fit.
   *
   * Support: Extended
   *
   * @schema WrappedGatewaySpecInfrastructure#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels that SHOULD be applied to any resources created in response to this Gateway.
   *
   * For implementations creating other Kubernetes objects, this should be the `metadata.labels` field on resources.
   * For other implementations, this refers to any relevant (implementation specific) "labels" concepts.
   *
   * An implementation may chose to add additional implementation-specific labels as they see fit.
   *
   * If an implementation maps these labels to Pods, or any other resource that would need to be recreated when labels
   * change, it SHOULD clearly warn about this behavior in documentation.
   *
   * Support: Extended
   *
   * @schema WrappedGatewaySpecInfrastructure#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * ParametersRef is a reference to a resource that contains the configuration
   * parameters corresponding to the Gateway. This is optional if the
   * controller does not require any additional configuration.
   *
   * This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis
   *
   * The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
   * the merging behavior is implementation specific.
   * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
   *
   * If the referent cannot be found, refers to an unsupported kind, or when
   * the data within that resource is malformed, the Gateway SHOULD be
   * rejected with the "Accepted" status condition set to "False" and an
   * "InvalidParameters" reason.
   *
   * Support: Implementation-specific
   *
   * @schema WrappedGatewaySpecInfrastructure#parametersRef
   */
  readonly parametersRef?: WrappedGatewaySpecInfrastructureParametersRef;
}

/**
 * Converts an object of type 'WrappedGatewaySpecInfrastructure' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WrappedGatewaySpecInfrastructure(obj: WrappedGatewaySpecInfrastructure | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'parametersRef': toJson_WrappedGatewaySpecInfrastructureParametersRef(obj.parametersRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema WrappedGatewaySpecListenerTemplate
 */
export interface WrappedGatewaySpecListenerTemplate {
  /**
   * PortNumber defines a network port.
   *
   * @schema WrappedGatewaySpecListenerTemplate#port
   */
  readonly port: number;

  /**
   * ProtocolType defines the application protocol accepted by a Listener.
   * Implementations are not required to accept all the defined protocols. If an
   * implementation does not support a specified protocol, it MUST set the
   * "Accepted" condition to False for the affected Listener with a reason of
   * "UnsupportedProtocol".
   *
   * Core ProtocolType values are listed in the table below.
   *
   * Implementations can define their own protocols if a core ProtocolType does not
   * exist. Such definitions must use prefixed name, such as
   * `mycompany.com/my-custom-protocol`. Un-prefixed names are reserved for core
   * protocols. Any protocol defined by implementations will fall under
   * Implementation-specific conformance.
   *
   * Valid values include:
   *
   * * "HTTP" - Core support
   * * "example.com/bar" - Implementation-specific support
   *
   * Invalid values include:
   *
   * * "example.com" - must include path if domain is used
   * * "foo.example.com" - must include path if domain is used
   *
   * @schema WrappedGatewaySpecListenerTemplate#protocol
   */
  readonly protocol: string;

  /**
   * GatewayTLSConfig describes a TLS configuration.
   *
   * @schema WrappedGatewaySpecListenerTemplate#tls
   */
  readonly tls?: WrappedGatewaySpecListenerTemplateTls;
}

/**
 * Converts an object of type 'WrappedGatewaySpecListenerTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WrappedGatewaySpecListenerTemplate(obj: WrappedGatewaySpecListenerTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'protocol': obj.protocol,
    'tls': toJson_WrappedGatewaySpecListenerTemplateTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientCertificateRef is a reference to an object that contains a Client
 * Certificate and the associated private key.
 *
 * References to a resource in different namespace are invalid UNLESS there
 * is a ReferenceGrant in the target namespace that allows the certificate
 * to be attached. If a ReferenceGrant does not allow this reference, the
 * "ResolvedRefs" condition MUST be set to False for this listener with the
 * "RefNotPermitted" reason.
 *
 * ClientCertificateRef can reference to standard Kubernetes resources, i.e.
 * Secret, or implementation-specific custom resources.
 *
 * This setting can be overridden on the service level by use of BackendTLSPolicy.
 *
 * Support: Core
 *
 * <gateway:experimental>
 *
 * @schema WrappedGatewaySpecBackendTlsClientCertificateRef
 */
export interface WrappedGatewaySpecBackendTlsClientCertificateRef {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema WrappedGatewaySpecBackendTlsClientCertificateRef#group
   */
  readonly group?: string;

  /**
   * Kind is kind of the referent. For example "Secret".
   *
   * @schema WrappedGatewaySpecBackendTlsClientCertificateRef#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema WrappedGatewaySpecBackendTlsClientCertificateRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the referenced object. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema WrappedGatewaySpecBackendTlsClientCertificateRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'WrappedGatewaySpecBackendTlsClientCertificateRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WrappedGatewaySpecBackendTlsClientCertificateRef(obj: WrappedGatewaySpecBackendTlsClientCertificateRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ParametersRef is a reference to a resource that contains the configuration
 * parameters corresponding to the Gateway. This is optional if the
 * controller does not require any additional configuration.
 *
 * This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis
 *
 * The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
 * the merging behavior is implementation specific.
 * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
 *
 * If the referent cannot be found, refers to an unsupported kind, or when
 * the data within that resource is malformed, the Gateway SHOULD be
 * rejected with the "Accepted" status condition set to "False" and an
 * "InvalidParameters" reason.
 *
 * Support: Implementation-specific
 *
 * @schema WrappedGatewaySpecInfrastructureParametersRef
 */
export interface WrappedGatewaySpecInfrastructureParametersRef {
  /**
   * Group is the group of the referent.
   *
   * @schema WrappedGatewaySpecInfrastructureParametersRef#group
   */
  readonly group: string;

  /**
   * Kind is kind of the referent.
   *
   * @schema WrappedGatewaySpecInfrastructureParametersRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of the referent.
   *
   * @schema WrappedGatewaySpecInfrastructureParametersRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'WrappedGatewaySpecInfrastructureParametersRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WrappedGatewaySpecInfrastructureParametersRef(obj: WrappedGatewaySpecInfrastructureParametersRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GatewayTLSConfig describes a TLS configuration.
 *
 * @schema WrappedGatewaySpecListenerTemplateTls
 */
export interface WrappedGatewaySpecListenerTemplateTls {
  /**
   * CertificateRefs contains a series of references to Kubernetes objects that
   * contains TLS certificates and private keys. These certificates are used to
   * establish a TLS handshake for requests that match the hostname of the
   * associated listener.
   *
   * A single CertificateRef to a Kubernetes Secret has "Core" support.
   * Implementations MAY choose to support attaching multiple certificates to
   * a Listener, but this behavior is implementation-specific.
   *
   * References to a resource in different namespace are invalid UNLESS there
   * is a ReferenceGrant in the target namespace that allows the certificate
   * to be attached. If a ReferenceGrant does not allow this reference, the
   * "ResolvedRefs" condition MUST be set to False for this listener with the
   * "RefNotPermitted" reason.
   *
   * This field is required to have at least one element when the mode is set
   * to "Terminate" (default) and is optional otherwise.
   *
   * CertificateRefs can reference to standard Kubernetes resources, i.e.
   * Secret, or implementation-specific custom resources.
   *
   * Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
   *
   * Support: Implementation-specific (More than one reference or other resource types)
   *
   * @schema WrappedGatewaySpecListenerTemplateTls#certificateRefs
   */
  readonly certificateRefs?: WrappedGatewaySpecListenerTemplateTlsCertificateRefs[];

  /**
   * FrontendValidation holds configuration information for validating the frontend (client).
   * Setting this field will require clients to send a client certificate
   * required for validation during the TLS handshake. In browsers this may result in a dialog appearing
   * that requests a user to specify the client certificate.
   * The maximum depth of a certificate chain accepted in verification is Implementation specific.
   *
   * Support: Extended
   *
   * <gateway:experimental>
   *
   * @schema WrappedGatewaySpecListenerTemplateTls#frontendValidation
   */
  readonly frontendValidation?: WrappedGatewaySpecListenerTemplateTlsFrontendValidation;

  /**
   * Mode defines the TLS behavior for the TLS session initiated by the client.
   * There are two possible modes:
   *
   * - Terminate: The TLS session between the downstream client and the
   * Gateway is terminated at the Gateway. This mode requires certificates
   * to be specified in some way, such as populating the certificateRefs
   * field.
   * - Passthrough: The TLS session is NOT terminated by the Gateway. This
   * implies that the Gateway can't decipher the TLS stream except for
   * the ClientHello message of the TLS protocol. The certificateRefs field
   * is ignored in this mode.
   *
   * Support: Core
   *
   * @schema WrappedGatewaySpecListenerTemplateTls#mode
   */
  readonly mode?: WrappedGatewaySpecListenerTemplateTlsMode;

  /**
   * Options are a list of key/value pairs to enable extended TLS
   * configuration for each implementation. For example, configuring the
   * minimum TLS version or supported cipher suites.
   *
   * A set of common keys MAY be defined by the API in the future. To avoid
   * any ambiguity, implementation-specific definitions MUST use
   * domain-prefixed names, such as `example.com/my-custom-option`.
   * Un-prefixed names are reserved for key names defined by Gateway API.
   *
   * Support: Implementation-specific
   *
   * @schema WrappedGatewaySpecListenerTemplateTls#options
   */
  readonly options?: { [key: string]: string };
}

/**
 * Converts an object of type 'WrappedGatewaySpecListenerTemplateTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WrappedGatewaySpecListenerTemplateTls(obj: WrappedGatewaySpecListenerTemplateTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateRefs': obj.certificateRefs?.map(y => toJson_WrappedGatewaySpecListenerTemplateTlsCertificateRefs(y)),
    'frontendValidation': toJson_WrappedGatewaySpecListenerTemplateTlsFrontendValidation(obj.frontendValidation),
    'mode': obj.mode,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretObjectReference identifies an API object including its namespace,
 * defaulting to Secret.
 *
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 *
 * References to objects with invalid Group and Kind are not valid, and must
 * be rejected by the implementation, with appropriate Conditions set
 * on the containing object.
 *
 * @schema WrappedGatewaySpecListenerTemplateTlsCertificateRefs
 */
export interface WrappedGatewaySpecListenerTemplateTlsCertificateRefs {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema WrappedGatewaySpecListenerTemplateTlsCertificateRefs#group
   */
  readonly group?: string;

  /**
   * Kind is kind of the referent. For example "Secret".
   *
   * @schema WrappedGatewaySpecListenerTemplateTlsCertificateRefs#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema WrappedGatewaySpecListenerTemplateTlsCertificateRefs#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the referenced object. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema WrappedGatewaySpecListenerTemplateTlsCertificateRefs#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'WrappedGatewaySpecListenerTemplateTlsCertificateRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WrappedGatewaySpecListenerTemplateTlsCertificateRefs(obj: WrappedGatewaySpecListenerTemplateTlsCertificateRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FrontendValidation holds configuration information for validating the frontend (client).
 * Setting this field will require clients to send a client certificate
 * required for validation during the TLS handshake. In browsers this may result in a dialog appearing
 * that requests a user to specify the client certificate.
 * The maximum depth of a certificate chain accepted in verification is Implementation specific.
 *
 * Support: Extended
 *
 * <gateway:experimental>
 *
 * @schema WrappedGatewaySpecListenerTemplateTlsFrontendValidation
 */
export interface WrappedGatewaySpecListenerTemplateTlsFrontendValidation {
  /**
   * CACertificateRefs contains one or more references to
   * Kubernetes objects that contain TLS certificates of
   * the Certificate Authorities that can be used
   * as a trust anchor to validate the certificates presented by the client.
   *
   * A single CA certificate reference to a Kubernetes ConfigMap
   * has "Core" support.
   * Implementations MAY choose to support attaching multiple CA certificates to
   * a Listener, but this behavior is implementation-specific.
   *
   * Support: Core - A single reference to a Kubernetes ConfigMap
   * with the CA certificate in a key named `ca.crt`.
   *
   * Support: Implementation-specific (More than one reference, or other kinds
   * of resources).
   *
   * References to a resource in a different namespace are invalid UNLESS there
   * is a ReferenceGrant in the target namespace that allows the certificate
   * to be attached. If a ReferenceGrant does not allow this reference, the
   * "ResolvedRefs" condition MUST be set to False for this listener with the
   * "RefNotPermitted" reason.
   *
   * @schema WrappedGatewaySpecListenerTemplateTlsFrontendValidation#caCertificateRefs
   */
  readonly caCertificateRefs?: WrappedGatewaySpecListenerTemplateTlsFrontendValidationCaCertificateRefs[];
}

/**
 * Converts an object of type 'WrappedGatewaySpecListenerTemplateTlsFrontendValidation' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WrappedGatewaySpecListenerTemplateTlsFrontendValidation(obj: WrappedGatewaySpecListenerTemplateTlsFrontendValidation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificateRefs': obj.caCertificateRefs?.map(y => toJson_WrappedGatewaySpecListenerTemplateTlsFrontendValidationCaCertificateRefs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Mode defines the TLS behavior for the TLS session initiated by the client.
 * There are two possible modes:
 *
 * - Terminate: The TLS session between the downstream client and the
 * Gateway is terminated at the Gateway. This mode requires certificates
 * to be specified in some way, such as populating the certificateRefs
 * field.
 * - Passthrough: The TLS session is NOT terminated by the Gateway. This
 * implies that the Gateway can't decipher the TLS stream except for
 * the ClientHello message of the TLS protocol. The certificateRefs field
 * is ignored in this mode.
 *
 * Support: Core
 *
 * @schema WrappedGatewaySpecListenerTemplateTlsMode
 */
export enum WrappedGatewaySpecListenerTemplateTlsMode {
  /** Terminate */
  TERMINATE = "Terminate",
  /** Passthrough */
  PASSTHROUGH = "Passthrough",
}

/**
 * ObjectReference identifies an API object including its namespace.
 *
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 *
 * References to objects with invalid Group and Kind are not valid, and must
 * be rejected by the implementation, with appropriate Conditions set
 * on the containing object.
 *
 * @schema WrappedGatewaySpecListenerTemplateTlsFrontendValidationCaCertificateRefs
 */
export interface WrappedGatewaySpecListenerTemplateTlsFrontendValidationCaCertificateRefs {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When set to the empty string, core API group is inferred.
   *
   * @schema WrappedGatewaySpecListenerTemplateTlsFrontendValidationCaCertificateRefs#group
   */
  readonly group: string;

  /**
   * Kind is kind of the referent. For example "ConfigMap" or "Service".
   *
   * @schema WrappedGatewaySpecListenerTemplateTlsFrontendValidationCaCertificateRefs#kind
   */
  readonly kind: string;

  /**
   * Name is the name of the referent.
   *
   * @schema WrappedGatewaySpecListenerTemplateTlsFrontendValidationCaCertificateRefs#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the referenced object. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema WrappedGatewaySpecListenerTemplateTlsFrontendValidationCaCertificateRefs#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'WrappedGatewaySpecListenerTemplateTlsFrontendValidationCaCertificateRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WrappedGatewaySpecListenerTemplateTlsFrontendValidationCaCertificateRefs(obj: WrappedGatewaySpecListenerTemplateTlsFrontendValidationCaCertificateRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

