// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * CSISecrets is the Schema for the csisecrets API
 *
 * @schema CSISecrets
 */
export class CsiSecrets extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CSISecrets"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secrets.hashicorp.com/v1beta1',
    kind: 'CSISecrets',
  }

  /**
   * Renders a Kubernetes manifest for "CSISecrets".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CsiSecretsProps = {}): any {
    return {
      ...CsiSecrets.GVK,
      ...toJson_CsiSecretsProps(props),
    };
  }

  /**
   * Defines a "CSISecrets" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CsiSecretsProps = {}) {
    super(scope, id, {
      ...CsiSecrets.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...CsiSecrets.GVK,
      ...toJson_CsiSecretsProps(resolved),
    };
  }
}

/**
 * CSISecrets is the Schema for the csisecrets API
 *
 * @schema CSISecrets
 */
export interface CsiSecretsProps {
  /**
   * @schema CSISecrets#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CSISecretsSpec defines the desired state of CSISecrets. It contains the
   * configuration for the CSI driver to populate the secret data.
   *
   * @schema CSISecrets#spec
   */
  readonly spec?: CsiSecretsSpec;
}

/**
 * Converts an object of type 'CsiSecretsProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CsiSecretsProps(obj: CsiSecretsProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CsiSecretsSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CSISecretsSpec defines the desired state of CSISecrets. It contains the
 * configuration for the CSI driver to populate the secret data.
 *
 * @schema CsiSecretsSpec
 */
export interface CsiSecretsSpec {
  /**
   * AccessControl provides configuration for controlling access to the secret.
   *
   * @schema CsiSecretsSpec#accessControl
   */
  readonly accessControl: CsiSecretsSpecAccessControl;

  /**
   * Namespace is the Vault namespace where the secret is located.
   *
   * @schema CsiSecretsSpec#namespace
   */
  readonly namespace?: string;

  /**
   * Secrets that will be synced with the CSI driver.
   *
   * @schema CsiSecretsSpec#secrets
   */
  readonly secrets: CsiSecretsSpecSecrets;

  /**
   * SyncConfig provides configuration for syncing the secret data with the CSI driver.
   *
   * @schema CsiSecretsSpec#syncConfig
   */
  readonly syncConfig?: CsiSecretsSpecSyncConfig;

  /**
   * VaultAuthRef is the reference to the VaultAuth resource.
   *
   * @schema CsiSecretsSpec#vaultAuthRef
   */
  readonly vaultAuthRef?: CsiSecretsSpecVaultAuthRef;
}

/**
 * Converts an object of type 'CsiSecretsSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CsiSecretsSpec(obj: CsiSecretsSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessControl': toJson_CsiSecretsSpecAccessControl(obj.accessControl),
    'namespace': obj.namespace,
    'secrets': toJson_CsiSecretsSpecSecrets(obj.secrets),
    'syncConfig': toJson_CsiSecretsSpecSyncConfig(obj.syncConfig),
    'vaultAuthRef': toJson_CsiSecretsSpecVaultAuthRef(obj.vaultAuthRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessControl provides configuration for controlling access to the secret.
 *
 * @schema CsiSecretsSpecAccessControl
 */
export interface CsiSecretsSpecAccessControl {
  /**
   * MatchPolicy is the policy to use when matching the access control rules. If
   * set to "any", only one of the rules should match. If set to "all", all the
   * rules should match.
   *
   * @schema CsiSecretsSpecAccessControl#matchPolicy
   */
  readonly matchPolicy?: CsiSecretsSpecAccessControlMatchPolicy;

  /**
   * NamespacePatterns is a list of namespace name regex patterns that are allowed access.
   *
   * @schema CsiSecretsSpecAccessControl#namespacePatterns
   */
  readonly namespacePatterns?: string[];

  /**
   * PodLabels is a map of pod label key-value pairs that should be allowed access.
   *
   * @schema CsiSecretsSpecAccessControl#podLabels
   */
  readonly podLabels?: { [key: string]: string };

  /**
   * PodNamePatterns is a list of pod name regex patterns that should be allowed access.
   *
   * @schema CsiSecretsSpecAccessControl#podNamePatterns
   */
  readonly podNamePatterns?: string[];

  /**
   * ServiceAccountPattern is the name of the service account that should be used to
   * access the secret. It can be specified as a regex pattern.
   * A valid service account is always required.
   *
   * @schema CsiSecretsSpecAccessControl#serviceAccountPattern
   */
  readonly serviceAccountPattern: string;
}

/**
 * Converts an object of type 'CsiSecretsSpecAccessControl' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CsiSecretsSpecAccessControl(obj: CsiSecretsSpecAccessControl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchPolicy': obj.matchPolicy,
    'namespacePatterns': obj.namespacePatterns?.map(y => y),
    'podLabels': ((obj.podLabels) === undefined) ? undefined : (Object.entries(obj.podLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'podNamePatterns': obj.podNamePatterns?.map(y => y),
    'serviceAccountPattern': obj.serviceAccountPattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Secrets that will be synced with the CSI driver.
 *
 * @schema CsiSecretsSpecSecrets
 */
export interface CsiSecretsSpecSecrets {
  /**
   * Transformation provides configuration for transforming the secret data before
   * it is stored in the CSI volume.
   *
   * @schema CsiSecretsSpecSecrets#transformation
   */
  readonly transformation?: CsiSecretsSpecSecretsTransformation;

  /**
   * VaultAppRoleSecretIDs is a list of AppRole secret IDs to be used to populate the secret.
   *
   * @schema CsiSecretsSpecSecrets#vaultAppRoleSecretIDs
   */
  readonly vaultAppRoleSecretIDs?: CsiSecretsSpecSecretsVaultAppRoleSecretIDs[];

  /**
   * VaultStaticSecrets is a list of static secrets to be synced by the CSI driver.
   *
   * @schema CsiSecretsSpecSecrets#vaultStaticSecrets
   */
  readonly vaultStaticSecrets?: CsiSecretsSpecSecretsVaultStaticSecrets[];
}

/**
 * Converts an object of type 'CsiSecretsSpecSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CsiSecretsSpecSecrets(obj: CsiSecretsSpecSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'transformation': toJson_CsiSecretsSpecSecretsTransformation(obj.transformation),
    'vaultAppRoleSecretIDs': obj.vaultAppRoleSecretIDs?.map(y => toJson_CsiSecretsSpecSecretsVaultAppRoleSecretIDs(y)),
    'vaultStaticSecrets': obj.vaultStaticSecrets?.map(y => toJson_CsiSecretsSpecSecretsVaultStaticSecrets(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SyncConfig provides configuration for syncing the secret data with the CSI driver.
 *
 * @schema CsiSecretsSpecSyncConfig
 */
export interface CsiSecretsSpecSyncConfig {
  /**
   * ContainerState is the state of the container that the CSI driver always sync
   * on. This configuration is useful to sync when the last state of the container
   * is in the terminated state and the restart count is greater than 0.
   *
   * @schema CsiSecretsSpecSyncConfig#containerState
   */
  readonly containerState: CsiSecretsSpecSyncConfigContainerState;
}

/**
 * Converts an object of type 'CsiSecretsSpecSyncConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CsiSecretsSpecSyncConfig(obj: CsiSecretsSpecSyncConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerState': toJson_CsiSecretsSpecSyncConfigContainerState(obj.containerState),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VaultAuthRef is the reference to the VaultAuth resource.
 *
 * @schema CsiSecretsSpecVaultAuthRef
 */
export interface CsiSecretsSpecVaultAuthRef {
  /**
   * Name of the VaultAuth resource.
   *
   * @schema CsiSecretsSpecVaultAuthRef#name
   */
  readonly name: string;

  /**
   * Namespace of the VaultAuth resource.
   *
   * @schema CsiSecretsSpecVaultAuthRef#namespace
   */
  readonly namespace?: string;

  /**
   * TrustNamespace of the referring VaultAuth resource. This means that any Vault
   * credentials will be provided by resources in the same namespace as the
   * VaultAuth resource. Otherwise, the credentials will be provided by the secret
   * resource's namespace.
   *
   * @schema CsiSecretsSpecVaultAuthRef#trustNamespace
   */
  readonly trustNamespace?: boolean;
}

/**
 * Converts an object of type 'CsiSecretsSpecVaultAuthRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CsiSecretsSpecVaultAuthRef(obj: CsiSecretsSpecVaultAuthRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
    'trustNamespace': obj.trustNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MatchPolicy is the policy to use when matching the access control rules. If
 * set to "any", only one of the rules should match. If set to "all", all the
 * rules should match.
 *
 * @schema CsiSecretsSpecAccessControlMatchPolicy
 */
export enum CsiSecretsSpecAccessControlMatchPolicy {
  /** any */
  ANY = "any",
  /** all */
  ALL = "all",
}

/**
 * Transformation provides configuration for transforming the secret data before
 * it is stored in the CSI volume.
 *
 * @schema CsiSecretsSpecSecretsTransformation
 */
export interface CsiSecretsSpecSecretsTransformation {
  /**
   * ExcludeRaw data from the destination Secret. Exclusion policy can be set
   * globally by including 'exclude-raw` in the '--global-transformation-options'
   * command line flag. If set, the command line flag always takes precedence over
   * this configuration.
   *
   * @schema CsiSecretsSpecSecretsTransformation#excludeRaw
   */
  readonly excludeRaw?: boolean;

  /**
   * Excludes contains regex patterns used to filter top-level source secret data
   * fields for exclusion from the final K8s Secret data. These pattern filters are
   * never applied to templated fields as defined in Templates. They are always
   * applied before any inclusion patterns. To exclude all source secret data
   * fields, you can configure the single pattern ".*".
   *
   * @schema CsiSecretsSpecSecretsTransformation#excludes
   */
  readonly excludes?: string[];

  /**
   * Includes contains regex patterns used to filter top-level source secret data
   * fields for inclusion in the final K8s Secret data. These pattern filters are
   * never applied to templated fields as defined in Templates. They are always
   * applied last.
   *
   * @schema CsiSecretsSpecSecretsTransformation#includes
   */
  readonly includes?: string[];

  /**
   * Templates maps a template name to its Template. Templates are always included
   * in the rendered K8s Secret, and take precedence over templates defined in a
   * SecretTransformation.
   *
   * @schema CsiSecretsSpecSecretsTransformation#templates
   */
  readonly templates?: { [key: string]: CsiSecretsSpecSecretsTransformationTemplates };

  /**
   * TransformationRefs contain references to template configuration from
   * SecretTransformation.
   *
   * @schema CsiSecretsSpecSecretsTransformation#transformationRefs
   */
  readonly transformationRefs?: CsiSecretsSpecSecretsTransformationTransformationRefs[];
}

/**
 * Converts an object of type 'CsiSecretsSpecSecretsTransformation' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CsiSecretsSpecSecretsTransformation(obj: CsiSecretsSpecSecretsTransformation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'excludeRaw': obj.excludeRaw,
    'excludes': obj.excludes?.map(y => y),
    'includes': obj.includes?.map(y => y),
    'templates': ((obj.templates) === undefined) ? undefined : (Object.entries(obj.templates).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_CsiSecretsSpecSecretsTransformationTemplates(i[1]) }), {})),
    'transformationRefs': obj.transformationRefs?.map(y => toJson_CsiSecretsSpecSecretsTransformationTransformationRefs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VaultAppRoleSecretID defines the AppRole secret ID to be used to populate the secret.
 *
 * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDs
 */
export interface CsiSecretsSpecSecretsVaultAppRoleSecretIDs {
  /**
   * CIDRList is the list of CIDR blocks that access the secret ID.
   *
   * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDs#cidrList
   */
  readonly cidrList?: string[];

  /**
   * Metadata is the metadata to be associated with the secret ID. It is set on
   * the token generated by the secret ID.
   *
   * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDs#metadata
   */
  readonly metadata?: { [key: string]: string };

  /**
   * Mount path to the AppRole auth engine.
   *
   * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDs#mount
   */
  readonly mount: string;

  /**
   * NumUses is the number of times the secret ID can be used.
   *
   * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDs#numUses
   */
  readonly numUses?: number;

  /**
   * Role is the name of the AppRole.
   *
   * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDs#role
   */
  readonly role: string;

  /**
   * SyncRoleID is the flag to fetch the role ID from the AppRole auth engine.
   * Requires that the provisioning VaultAuth has the necessary permissions to fetch the role ID.
   *
   * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDs#syncRoleID
   */
  readonly syncRoleId?: boolean;

  /**
   * TokenBoundCIDRs is the list of CIDR blocks that can be used to authenticate
   * using tokens generated by this secret ID.
   *
   * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDs#tokenBoundCIDRs
   */
  readonly tokenBoundCidRs?: string[];

  /**
   * Transformation provides configuration for transforming the secret data before
   * it is stored in the CSI volume.
   *
   * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDs#transformation
   */
  readonly transformation?: CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformation;

  /**
   * TTL is the TTL for the secret ID, after which it becomes invalid.
   *
   * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDs#ttl
   */
  readonly ttl?: string;

  /**
   * WrapTTL is the TTL for the wrapped secret ID.
   *
   * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDs#wrapTTL
   */
  readonly wrapTtl?: string;
}

/**
 * Converts an object of type 'CsiSecretsSpecSecretsVaultAppRoleSecretIDs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CsiSecretsSpecSecretsVaultAppRoleSecretIDs(obj: CsiSecretsSpecSecretsVaultAppRoleSecretIDs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrList': obj.cidrList?.map(y => y),
    'metadata': ((obj.metadata) === undefined) ? undefined : (Object.entries(obj.metadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'mount': obj.mount,
    'numUses': obj.numUses,
    'role': obj.role,
    'syncRoleID': obj.syncRoleId,
    'tokenBoundCIDRs': obj.tokenBoundCidRs?.map(y => y),
    'transformation': toJson_CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformation(obj.transformation),
    'ttl': obj.ttl,
    'wrapTTL': obj.wrapTtl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema CsiSecretsSpecSecretsVaultStaticSecrets
 */
export interface CsiSecretsSpecSecretsVaultStaticSecrets {
  /**
   * Mount for the secret in Vault
   *
   * @schema CsiSecretsSpecSecretsVaultStaticSecrets#mount
   */
  readonly mount: string;

  /**
   * Path of the secret in Vault, corresponds to the `path` parameter for:
   * kv-v1: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v1#read-secret
   * kv-v2: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2#read-secret-version
   *
   * @schema CsiSecretsSpecSecretsVaultStaticSecrets#path
   */
  readonly path: string;

  /**
   * Transformation provides configuration for transforming the secret data before
   * it is stored in the CSI volume.
   *
   * @schema CsiSecretsSpecSecretsVaultStaticSecrets#transformation
   */
  readonly transformation?: CsiSecretsSpecSecretsVaultStaticSecretsTransformation;

  /**
   * Type of the Vault static secret
   *
   * @schema CsiSecretsSpecSecretsVaultStaticSecrets#type
   */
  readonly type: CsiSecretsSpecSecretsVaultStaticSecretsType;

  /**
   * Version of the secret to fetch. Only valid for type kv-v2. Corresponds to version query parameter:
   * https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2#version
   *
   * @schema CsiSecretsSpecSecretsVaultStaticSecrets#version
   */
  readonly version?: number;
}

/**
 * Converts an object of type 'CsiSecretsSpecSecretsVaultStaticSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CsiSecretsSpecSecretsVaultStaticSecrets(obj: CsiSecretsSpecSecretsVaultStaticSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mount': obj.mount,
    'path': obj.path,
    'transformation': toJson_CsiSecretsSpecSecretsVaultStaticSecretsTransformation(obj.transformation),
    'type': obj.type,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerState is the state of the container that the CSI driver always sync
 * on. This configuration is useful to sync when the last state of the container
 * is in the terminated state and the restart count is greater than 0.
 *
 * @schema CsiSecretsSpecSyncConfigContainerState
 */
export interface CsiSecretsSpecSyncConfigContainerState {
  /**
   * ImagePattern of the container. Can be expressed as a regular expression.
   *
   * @schema CsiSecretsSpecSyncConfigContainerState#imagePattern
   */
  readonly imagePattern?: string;

  /**
   * NamePattern of the container. Can be expressed as a regular expression.
   *
   * @schema CsiSecretsSpecSyncConfigContainerState#namePattern
   */
  readonly namePattern?: string;
}

/**
 * Converts an object of type 'CsiSecretsSpecSyncConfigContainerState' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CsiSecretsSpecSyncConfigContainerState(obj: CsiSecretsSpecSyncConfigContainerState | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imagePattern': obj.imagePattern,
    'namePattern': obj.namePattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Template provides templating configuration.
 *
 * @schema CsiSecretsSpecSecretsTransformationTemplates
 */
export interface CsiSecretsSpecSecretsTransformationTemplates {
  /**
   * Name of the Template
   *
   * @schema CsiSecretsSpecSecretsTransformationTemplates#name
   */
  readonly name?: string;

  /**
   * Text contains the Go text template format. The template
   * references attributes from the data structure of the source secret.
   * Refer to https://pkg.go.dev/text/template for more information.
   *
   * @schema CsiSecretsSpecSecretsTransformationTemplates#text
   */
  readonly text: string;
}

/**
 * Converts an object of type 'CsiSecretsSpecSecretsTransformationTemplates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CsiSecretsSpecSecretsTransformationTemplates(obj: CsiSecretsSpecSecretsTransformationTemplates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'text': obj.text,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TransformationRef contains the configuration for accessing templates from an
 * SecretTransformation resource. TransformationRefs can be shared across all
 * syncable secret custom resources.
 *
 * @schema CsiSecretsSpecSecretsTransformationTransformationRefs
 */
export interface CsiSecretsSpecSecretsTransformationTransformationRefs {
  /**
   * IgnoreExcludes controls whether to use the SecretTransformation's Excludes
   * data key filters.
   *
   * @schema CsiSecretsSpecSecretsTransformationTransformationRefs#ignoreExcludes
   */
  readonly ignoreExcludes?: boolean;

  /**
   * IgnoreIncludes controls whether to use the SecretTransformation's Includes
   * data key filters.
   *
   * @schema CsiSecretsSpecSecretsTransformationTransformationRefs#ignoreIncludes
   */
  readonly ignoreIncludes?: boolean;

  /**
   * Name of the SecretTransformation resource.
   *
   * @schema CsiSecretsSpecSecretsTransformationTransformationRefs#name
   */
  readonly name: string;

  /**
   * Namespace of the SecretTransformation resource.
   *
   * @schema CsiSecretsSpecSecretsTransformationTransformationRefs#namespace
   */
  readonly namespace?: string;

  /**
   * TemplateRefs map to a Template found in this TransformationRef. If empty, then
   * all templates from the SecretTransformation will be rendered to the K8s Secret.
   *
   * @schema CsiSecretsSpecSecretsTransformationTransformationRefs#templateRefs
   */
  readonly templateRefs?: CsiSecretsSpecSecretsTransformationTransformationRefsTemplateRefs[];
}

/**
 * Converts an object of type 'CsiSecretsSpecSecretsTransformationTransformationRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CsiSecretsSpecSecretsTransformationTransformationRefs(obj: CsiSecretsSpecSecretsTransformationTransformationRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreExcludes': obj.ignoreExcludes,
    'ignoreIncludes': obj.ignoreIncludes,
    'name': obj.name,
    'namespace': obj.namespace,
    'templateRefs': obj.templateRefs?.map(y => toJson_CsiSecretsSpecSecretsTransformationTransformationRefsTemplateRefs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Transformation provides configuration for transforming the secret data before
 * it is stored in the CSI volume.
 *
 * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformation
 */
export interface CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformation {
  /**
   * ExcludeRaw data from the destination Secret. Exclusion policy can be set
   * globally by including 'exclude-raw` in the '--global-transformation-options'
   * command line flag. If set, the command line flag always takes precedence over
   * this configuration.
   *
   * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformation#excludeRaw
   */
  readonly excludeRaw?: boolean;

  /**
   * Excludes contains regex patterns used to filter top-level source secret data
   * fields for exclusion from the final K8s Secret data. These pattern filters are
   * never applied to templated fields as defined in Templates. They are always
   * applied before any inclusion patterns. To exclude all source secret data
   * fields, you can configure the single pattern ".*".
   *
   * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformation#excludes
   */
  readonly excludes?: string[];

  /**
   * Includes contains regex patterns used to filter top-level source secret data
   * fields for inclusion in the final K8s Secret data. These pattern filters are
   * never applied to templated fields as defined in Templates. They are always
   * applied last.
   *
   * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformation#includes
   */
  readonly includes?: string[];

  /**
   * Templates maps a template name to its Template. Templates are always included
   * in the rendered K8s Secret, and take precedence over templates defined in a
   * SecretTransformation.
   *
   * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformation#templates
   */
  readonly templates?: { [key: string]: CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTemplates };

  /**
   * TransformationRefs contain references to template configuration from
   * SecretTransformation.
   *
   * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformation#transformationRefs
   */
  readonly transformationRefs?: CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTransformationRefs[];
}

/**
 * Converts an object of type 'CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformation' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformation(obj: CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'excludeRaw': obj.excludeRaw,
    'excludes': obj.excludes?.map(y => y),
    'includes': obj.includes?.map(y => y),
    'templates': ((obj.templates) === undefined) ? undefined : (Object.entries(obj.templates).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTemplates(i[1]) }), {})),
    'transformationRefs': obj.transformationRefs?.map(y => toJson_CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTransformationRefs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Transformation provides configuration for transforming the secret data before
 * it is stored in the CSI volume.
 *
 * @schema CsiSecretsSpecSecretsVaultStaticSecretsTransformation
 */
export interface CsiSecretsSpecSecretsVaultStaticSecretsTransformation {
  /**
   * ExcludeRaw data from the destination Secret. Exclusion policy can be set
   * globally by including 'exclude-raw` in the '--global-transformation-options'
   * command line flag. If set, the command line flag always takes precedence over
   * this configuration.
   *
   * @schema CsiSecretsSpecSecretsVaultStaticSecretsTransformation#excludeRaw
   */
  readonly excludeRaw?: boolean;

  /**
   * Excludes contains regex patterns used to filter top-level source secret data
   * fields for exclusion from the final K8s Secret data. These pattern filters are
   * never applied to templated fields as defined in Templates. They are always
   * applied before any inclusion patterns. To exclude all source secret data
   * fields, you can configure the single pattern ".*".
   *
   * @schema CsiSecretsSpecSecretsVaultStaticSecretsTransformation#excludes
   */
  readonly excludes?: string[];

  /**
   * Includes contains regex patterns used to filter top-level source secret data
   * fields for inclusion in the final K8s Secret data. These pattern filters are
   * never applied to templated fields as defined in Templates. They are always
   * applied last.
   *
   * @schema CsiSecretsSpecSecretsVaultStaticSecretsTransformation#includes
   */
  readonly includes?: string[];

  /**
   * Templates maps a template name to its Template. Templates are always included
   * in the rendered K8s Secret, and take precedence over templates defined in a
   * SecretTransformation.
   *
   * @schema CsiSecretsSpecSecretsVaultStaticSecretsTransformation#templates
   */
  readonly templates?: { [key: string]: CsiSecretsSpecSecretsVaultStaticSecretsTransformationTemplates };

  /**
   * TransformationRefs contain references to template configuration from
   * SecretTransformation.
   *
   * @schema CsiSecretsSpecSecretsVaultStaticSecretsTransformation#transformationRefs
   */
  readonly transformationRefs?: CsiSecretsSpecSecretsVaultStaticSecretsTransformationTransformationRefs[];
}

/**
 * Converts an object of type 'CsiSecretsSpecSecretsVaultStaticSecretsTransformation' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CsiSecretsSpecSecretsVaultStaticSecretsTransformation(obj: CsiSecretsSpecSecretsVaultStaticSecretsTransformation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'excludeRaw': obj.excludeRaw,
    'excludes': obj.excludes?.map(y => y),
    'includes': obj.includes?.map(y => y),
    'templates': ((obj.templates) === undefined) ? undefined : (Object.entries(obj.templates).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_CsiSecretsSpecSecretsVaultStaticSecretsTransformationTemplates(i[1]) }), {})),
    'transformationRefs': obj.transformationRefs?.map(y => toJson_CsiSecretsSpecSecretsVaultStaticSecretsTransformationTransformationRefs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type of the Vault static secret
 *
 * @schema CsiSecretsSpecSecretsVaultStaticSecretsType
 */
export enum CsiSecretsSpecSecretsVaultStaticSecretsType {
  /** kv-v1 */
  KV_HYPHEN_V1 = "kv-v1",
  /** kv-v2 */
  KV_HYPHEN_V2 = "kv-v2",
}

/**
 * TemplateRef points to templating text that is stored in a
 * SecretTransformation custom resource.
 *
 * @schema CsiSecretsSpecSecretsTransformationTransformationRefsTemplateRefs
 */
export interface CsiSecretsSpecSecretsTransformationTransformationRefsTemplateRefs {
  /**
   * KeyOverride to the rendered template in the Destination secret. If Key is
   * empty, then the Key from reference spec will be used. Set this to override the
   * Key set from the reference spec.
   *
   * @schema CsiSecretsSpecSecretsTransformationTransformationRefsTemplateRefs#keyOverride
   */
  readonly keyOverride?: string;

  /**
   * Name of the Template in SecretTransformationSpec.Templates.
   * the rendered secret data.
   *
   * @schema CsiSecretsSpecSecretsTransformationTransformationRefsTemplateRefs#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'CsiSecretsSpecSecretsTransformationTransformationRefsTemplateRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CsiSecretsSpecSecretsTransformationTransformationRefsTemplateRefs(obj: CsiSecretsSpecSecretsTransformationTransformationRefsTemplateRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyOverride': obj.keyOverride,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Template provides templating configuration.
 *
 * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTemplates
 */
export interface CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTemplates {
  /**
   * Name of the Template
   *
   * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTemplates#name
   */
  readonly name?: string;

  /**
   * Text contains the Go text template format. The template
   * references attributes from the data structure of the source secret.
   * Refer to https://pkg.go.dev/text/template for more information.
   *
   * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTemplates#text
   */
  readonly text: string;
}

/**
 * Converts an object of type 'CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTemplates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTemplates(obj: CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTemplates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'text': obj.text,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TransformationRef contains the configuration for accessing templates from an
 * SecretTransformation resource. TransformationRefs can be shared across all
 * syncable secret custom resources.
 *
 * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTransformationRefs
 */
export interface CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTransformationRefs {
  /**
   * IgnoreExcludes controls whether to use the SecretTransformation's Excludes
   * data key filters.
   *
   * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTransformationRefs#ignoreExcludes
   */
  readonly ignoreExcludes?: boolean;

  /**
   * IgnoreIncludes controls whether to use the SecretTransformation's Includes
   * data key filters.
   *
   * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTransformationRefs#ignoreIncludes
   */
  readonly ignoreIncludes?: boolean;

  /**
   * Name of the SecretTransformation resource.
   *
   * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTransformationRefs#name
   */
  readonly name: string;

  /**
   * Namespace of the SecretTransformation resource.
   *
   * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTransformationRefs#namespace
   */
  readonly namespace?: string;

  /**
   * TemplateRefs map to a Template found in this TransformationRef. If empty, then
   * all templates from the SecretTransformation will be rendered to the K8s Secret.
   *
   * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTransformationRefs#templateRefs
   */
  readonly templateRefs?: CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTransformationRefsTemplateRefs[];
}

/**
 * Converts an object of type 'CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTransformationRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTransformationRefs(obj: CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTransformationRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreExcludes': obj.ignoreExcludes,
    'ignoreIncludes': obj.ignoreIncludes,
    'name': obj.name,
    'namespace': obj.namespace,
    'templateRefs': obj.templateRefs?.map(y => toJson_CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTransformationRefsTemplateRefs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Template provides templating configuration.
 *
 * @schema CsiSecretsSpecSecretsVaultStaticSecretsTransformationTemplates
 */
export interface CsiSecretsSpecSecretsVaultStaticSecretsTransformationTemplates {
  /**
   * Name of the Template
   *
   * @schema CsiSecretsSpecSecretsVaultStaticSecretsTransformationTemplates#name
   */
  readonly name?: string;

  /**
   * Text contains the Go text template format. The template
   * references attributes from the data structure of the source secret.
   * Refer to https://pkg.go.dev/text/template for more information.
   *
   * @schema CsiSecretsSpecSecretsVaultStaticSecretsTransformationTemplates#text
   */
  readonly text: string;
}

/**
 * Converts an object of type 'CsiSecretsSpecSecretsVaultStaticSecretsTransformationTemplates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CsiSecretsSpecSecretsVaultStaticSecretsTransformationTemplates(obj: CsiSecretsSpecSecretsVaultStaticSecretsTransformationTemplates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'text': obj.text,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TransformationRef contains the configuration for accessing templates from an
 * SecretTransformation resource. TransformationRefs can be shared across all
 * syncable secret custom resources.
 *
 * @schema CsiSecretsSpecSecretsVaultStaticSecretsTransformationTransformationRefs
 */
export interface CsiSecretsSpecSecretsVaultStaticSecretsTransformationTransformationRefs {
  /**
   * IgnoreExcludes controls whether to use the SecretTransformation's Excludes
   * data key filters.
   *
   * @schema CsiSecretsSpecSecretsVaultStaticSecretsTransformationTransformationRefs#ignoreExcludes
   */
  readonly ignoreExcludes?: boolean;

  /**
   * IgnoreIncludes controls whether to use the SecretTransformation's Includes
   * data key filters.
   *
   * @schema CsiSecretsSpecSecretsVaultStaticSecretsTransformationTransformationRefs#ignoreIncludes
   */
  readonly ignoreIncludes?: boolean;

  /**
   * Name of the SecretTransformation resource.
   *
   * @schema CsiSecretsSpecSecretsVaultStaticSecretsTransformationTransformationRefs#name
   */
  readonly name: string;

  /**
   * Namespace of the SecretTransformation resource.
   *
   * @schema CsiSecretsSpecSecretsVaultStaticSecretsTransformationTransformationRefs#namespace
   */
  readonly namespace?: string;

  /**
   * TemplateRefs map to a Template found in this TransformationRef. If empty, then
   * all templates from the SecretTransformation will be rendered to the K8s Secret.
   *
   * @schema CsiSecretsSpecSecretsVaultStaticSecretsTransformationTransformationRefs#templateRefs
   */
  readonly templateRefs?: CsiSecretsSpecSecretsVaultStaticSecretsTransformationTransformationRefsTemplateRefs[];
}

/**
 * Converts an object of type 'CsiSecretsSpecSecretsVaultStaticSecretsTransformationTransformationRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CsiSecretsSpecSecretsVaultStaticSecretsTransformationTransformationRefs(obj: CsiSecretsSpecSecretsVaultStaticSecretsTransformationTransformationRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreExcludes': obj.ignoreExcludes,
    'ignoreIncludes': obj.ignoreIncludes,
    'name': obj.name,
    'namespace': obj.namespace,
    'templateRefs': obj.templateRefs?.map(y => toJson_CsiSecretsSpecSecretsVaultStaticSecretsTransformationTransformationRefsTemplateRefs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TemplateRef points to templating text that is stored in a
 * SecretTransformation custom resource.
 *
 * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTransformationRefsTemplateRefs
 */
export interface CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTransformationRefsTemplateRefs {
  /**
   * KeyOverride to the rendered template in the Destination secret. If Key is
   * empty, then the Key from reference spec will be used. Set this to override the
   * Key set from the reference spec.
   *
   * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTransformationRefsTemplateRefs#keyOverride
   */
  readonly keyOverride?: string;

  /**
   * Name of the Template in SecretTransformationSpec.Templates.
   * the rendered secret data.
   *
   * @schema CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTransformationRefsTemplateRefs#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTransformationRefsTemplateRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTransformationRefsTemplateRefs(obj: CsiSecretsSpecSecretsVaultAppRoleSecretIDsTransformationTransformationRefsTemplateRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyOverride': obj.keyOverride,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TemplateRef points to templating text that is stored in a
 * SecretTransformation custom resource.
 *
 * @schema CsiSecretsSpecSecretsVaultStaticSecretsTransformationTransformationRefsTemplateRefs
 */
export interface CsiSecretsSpecSecretsVaultStaticSecretsTransformationTransformationRefsTemplateRefs {
  /**
   * KeyOverride to the rendered template in the Destination secret. If Key is
   * empty, then the Key from reference spec will be used. Set this to override the
   * Key set from the reference spec.
   *
   * @schema CsiSecretsSpecSecretsVaultStaticSecretsTransformationTransformationRefsTemplateRefs#keyOverride
   */
  readonly keyOverride?: string;

  /**
   * Name of the Template in SecretTransformationSpec.Templates.
   * the rendered secret data.
   *
   * @schema CsiSecretsSpecSecretsVaultStaticSecretsTransformationTransformationRefsTemplateRefs#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'CsiSecretsSpecSecretsVaultStaticSecretsTransformationTransformationRefsTemplateRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CsiSecretsSpecSecretsVaultStaticSecretsTransformationTransformationRefsTemplateRefs(obj: CsiSecretsSpecSecretsVaultStaticSecretsTransformationTransformationRefsTemplateRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyOverride': obj.keyOverride,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * HCPAuth is the Schema for the hcpauths API
 *
 * @schema HCPAuth
 */
export class HcpAuth extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HCPAuth"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secrets.hashicorp.com/v1beta1',
    kind: 'HCPAuth',
  }

  /**
   * Renders a Kubernetes manifest for "HCPAuth".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HcpAuthProps = {}): any {
    return {
      ...HcpAuth.GVK,
      ...toJson_HcpAuthProps(props),
    };
  }

  /**
   * Defines a "HCPAuth" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HcpAuthProps = {}) {
    super(scope, id, {
      ...HcpAuth.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...HcpAuth.GVK,
      ...toJson_HcpAuthProps(resolved),
    };
  }
}

/**
 * HCPAuth is the Schema for the hcpauths API
 *
 * @schema HCPAuth
 */
export interface HcpAuthProps {
  /**
   * @schema HCPAuth#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HCPAuthSpec defines the desired state of HCPAuth
   *
   * @schema HCPAuth#spec
   */
  readonly spec?: HcpAuthSpec;
}

/**
 * Converts an object of type 'HcpAuthProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HcpAuthProps(obj: HcpAuthProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HcpAuthSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HCPAuthSpec defines the desired state of HCPAuth
 *
 * @schema HcpAuthSpec
 */
export interface HcpAuthSpec {
  /**
   * AllowedNamespaces Kubernetes Namespaces which are allow-listed for use with this AuthMethod.
   * This field allows administrators to customize which Kubernetes namespaces are authorized to
   * use with this AuthMethod. While Vault will still enforce its own rules, this has the added
   * configurability of restricting which HCPAuthMethods can be used by which namespaces.
   * Accepted values:
   * []{"*"} - wildcard, all namespaces.
   * []{"a", "b"} - list of namespaces.
   * unset - disallow all namespaces except the Operator's the HCPAuthMethod's namespace, this
   * is the default behavior.
   *
   * @schema HcpAuthSpec#allowedNamespaces
   */
  readonly allowedNamespaces?: string[];

  /**
   * Method to use when authenticating to Vault.
   *
   * @schema HcpAuthSpec#method
   */
  readonly method?: HcpAuthSpecMethod;

  /**
   * OrganizationID of the HCP organization.
   *
   * @schema HcpAuthSpec#organizationID
   */
  readonly organizationId: string;

  /**
   * ProjectID of the HCP project.
   *
   * @schema HcpAuthSpec#projectID
   */
  readonly projectId: string;

  /**
   * ServicePrincipal provides the necessary configuration for authenticating to
   * HCP using a service principal. For security reasons, only project-level
   * service principals should ever be used.
   *
   * @schema HcpAuthSpec#servicePrincipal
   */
  readonly servicePrincipal?: HcpAuthSpecServicePrincipal;
}

/**
 * Converts an object of type 'HcpAuthSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HcpAuthSpec(obj: HcpAuthSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedNamespaces': obj.allowedNamespaces?.map(y => y),
    'method': obj.method,
    'organizationID': obj.organizationId,
    'projectID': obj.projectId,
    'servicePrincipal': toJson_HcpAuthSpecServicePrincipal(obj.servicePrincipal),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Method to use when authenticating to Vault.
 *
 * @schema HcpAuthSpecMethod
 */
export enum HcpAuthSpecMethod {
  /** servicePrincipal */
  SERVICE_PRINCIPAL = "servicePrincipal",
}

/**
 * ServicePrincipal provides the necessary configuration for authenticating to
 * HCP using a service principal. For security reasons, only project-level
 * service principals should ever be used.
 *
 * @schema HcpAuthSpecServicePrincipal
 */
export interface HcpAuthSpecServicePrincipal {
  /**
   * SecretRef is the name of a Kubernetes secret in the consumer's
   * (VDS/VSS/PKI/HCP) namespace which provides the HCP ServicePrincipal clientID,
   * and clientSecret.
   * The secret data must have the following structure {
   * "clientID": "clientID",
   * "clientSecret": "clientSecret",
   * }
   *
   * @schema HcpAuthSpecServicePrincipal#secretRef
   */
  readonly secretRef: string;
}

/**
 * Converts an object of type 'HcpAuthSpecServicePrincipal' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HcpAuthSpecServicePrincipal(obj: HcpAuthSpecServicePrincipal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': obj.secretRef,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * HCPVaultSecretsApp is the Schema for the hcpvaultsecretsapps API
 *
 * @schema HCPVaultSecretsApp
 */
export class HcpVaultSecretsApp extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HCPVaultSecretsApp"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secrets.hashicorp.com/v1beta1',
    kind: 'HCPVaultSecretsApp',
  }

  /**
   * Renders a Kubernetes manifest for "HCPVaultSecretsApp".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HcpVaultSecretsAppProps = {}): any {
    return {
      ...HcpVaultSecretsApp.GVK,
      ...toJson_HcpVaultSecretsAppProps(props),
    };
  }

  /**
   * Defines a "HCPVaultSecretsApp" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HcpVaultSecretsAppProps = {}) {
    super(scope, id, {
      ...HcpVaultSecretsApp.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...HcpVaultSecretsApp.GVK,
      ...toJson_HcpVaultSecretsAppProps(resolved),
    };
  }
}

/**
 * HCPVaultSecretsApp is the Schema for the hcpvaultsecretsapps API
 *
 * @schema HCPVaultSecretsApp
 */
export interface HcpVaultSecretsAppProps {
  /**
   * @schema HCPVaultSecretsApp#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HCPVaultSecretsAppSpec defines the desired state of HCPVaultSecretsApp
   *
   * @schema HCPVaultSecretsApp#spec
   */
  readonly spec?: HcpVaultSecretsAppSpec;
}

/**
 * Converts an object of type 'HcpVaultSecretsAppProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HcpVaultSecretsAppProps(obj: HcpVaultSecretsAppProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HcpVaultSecretsAppSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HCPVaultSecretsAppSpec defines the desired state of HCPVaultSecretsApp
 *
 * @schema HcpVaultSecretsAppSpec
 */
export interface HcpVaultSecretsAppSpec {
  /**
   * AppName of the Vault Secrets Application that is to be synced.
   *
   * @schema HcpVaultSecretsAppSpec#appName
   */
  readonly appName: string;

  /**
   * Destination provides configuration necessary for syncing the HCP Vault
   * Application secrets to Kubernetes.
   *
   * @schema HcpVaultSecretsAppSpec#destination
   */
  readonly destination: HcpVaultSecretsAppSpecDestination;

  /**
   * HCPAuthRef to the HCPAuth resource, can be prefixed with a namespace, eg:
   * `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default
   * to the namespace of the HCPAuth CR. If no value is specified for HCPAuthRef the
   * Operator will default to the `default` HCPAuth, configured in the operator's
   * namespace.
   *
   * @schema HcpVaultSecretsAppSpec#hcpAuthRef
   */
  readonly hcpAuthRef?: string;

  /**
   * RefreshAfter a period of time, in duration notation e.g. 30s, 1m, 24h
   *
   * @schema HcpVaultSecretsAppSpec#refreshAfter
   */
  readonly refreshAfter?: string;

  /**
   * RolloutRestartTargets should be configured whenever the application(s)
   * consuming the HCP Vault Secrets App does not support dynamically reloading a
   * rotated secret. In that case one, or more RolloutRestartTarget(s) can be
   * configured here. The Operator will trigger a "rollout-restart" for each target
   * whenever the Vault secret changes between reconciliation events. See
   * RolloutRestartTarget for more details.
   *
   * @schema HcpVaultSecretsAppSpec#rolloutRestartTargets
   */
  readonly rolloutRestartTargets?: HcpVaultSecretsAppSpecRolloutRestartTargets[];

  /**
   * SyncConfig configures sync behavior from HVS to VSO
   *
   * @schema HcpVaultSecretsAppSpec#syncConfig
   */
  readonly syncConfig?: HcpVaultSecretsAppSpecSyncConfig;
}

/**
 * Converts an object of type 'HcpVaultSecretsAppSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HcpVaultSecretsAppSpec(obj: HcpVaultSecretsAppSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appName': obj.appName,
    'destination': toJson_HcpVaultSecretsAppSpecDestination(obj.destination),
    'hcpAuthRef': obj.hcpAuthRef,
    'refreshAfter': obj.refreshAfter,
    'rolloutRestartTargets': obj.rolloutRestartTargets?.map(y => toJson_HcpVaultSecretsAppSpecRolloutRestartTargets(y)),
    'syncConfig': toJson_HcpVaultSecretsAppSpecSyncConfig(obj.syncConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Destination provides configuration necessary for syncing the HCP Vault
 * Application secrets to Kubernetes.
 *
 * @schema HcpVaultSecretsAppSpecDestination
 */
export interface HcpVaultSecretsAppSpecDestination {
  /**
   * Annotations to apply to the Secret. Requires Create to be set to true.
   *
   * @schema HcpVaultSecretsAppSpecDestination#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Create the destination Secret.
   * If the Secret already exists this should be set to false.
   *
   * @schema HcpVaultSecretsAppSpecDestination#create
   */
  readonly create?: boolean;

  /**
   * Labels to apply to the Secret. Requires Create to be set to true.
   *
   * @schema HcpVaultSecretsAppSpecDestination#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name of the Secret
   *
   * @schema HcpVaultSecretsAppSpecDestination#name
   */
  readonly name: string;

  /**
   * Overwrite the destination Secret if it exists and Create is true. This is
   * useful when migrating to VSO from a previous secret deployment strategy.
   *
   * @schema HcpVaultSecretsAppSpecDestination#overwrite
   */
  readonly overwrite?: boolean;

  /**
   * Transformation provides configuration for transforming the secret data before
   * it is stored in the Destination.
   *
   * @schema HcpVaultSecretsAppSpecDestination#transformation
   */
  readonly transformation?: HcpVaultSecretsAppSpecDestinationTransformation;

  /**
   * Type of Kubernetes Secret. Requires Create to be set to true.
   * Defaults to Opaque.
   *
   * @default Opaque.
   * @schema HcpVaultSecretsAppSpecDestination#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'HcpVaultSecretsAppSpecDestination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HcpVaultSecretsAppSpecDestination(obj: HcpVaultSecretsAppSpecDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'create': obj.create,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'overwrite': obj.overwrite,
    'transformation': toJson_HcpVaultSecretsAppSpecDestinationTransformation(obj.transformation),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RolloutRestartTarget provides the configuration required to perform a
 * rollout-restart of the supported resources upon Vault Secret rotation.
 * The rollout-restart is triggered by patching the target resource's
 * 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt'
 * with a timestamp value of when the trigger was executed.
 * E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z"
 *
 * Supported resources: Deployment, DaemonSet, StatefulSet, argo.Rollout
 *
 * @schema HcpVaultSecretsAppSpecRolloutRestartTargets
 */
export interface HcpVaultSecretsAppSpecRolloutRestartTargets {
  /**
   * Kind of the resource
   *
   * @schema HcpVaultSecretsAppSpecRolloutRestartTargets#kind
   */
  readonly kind: HcpVaultSecretsAppSpecRolloutRestartTargetsKind;

  /**
   * Name of the resource
   *
   * @schema HcpVaultSecretsAppSpecRolloutRestartTargets#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'HcpVaultSecretsAppSpecRolloutRestartTargets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HcpVaultSecretsAppSpecRolloutRestartTargets(obj: HcpVaultSecretsAppSpecRolloutRestartTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SyncConfig configures sync behavior from HVS to VSO
 *
 * @schema HcpVaultSecretsAppSpecSyncConfig
 */
export interface HcpVaultSecretsAppSpecSyncConfig {
  /**
   * Dynamic configures sync behavior for dynamic secrets.
   *
   * @schema HcpVaultSecretsAppSpecSyncConfig#dynamic
   */
  readonly dynamic?: HcpVaultSecretsAppSpecSyncConfigDynamic;
}

/**
 * Converts an object of type 'HcpVaultSecretsAppSpecSyncConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HcpVaultSecretsAppSpecSyncConfig(obj: HcpVaultSecretsAppSpecSyncConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dynamic': toJson_HcpVaultSecretsAppSpecSyncConfigDynamic(obj.dynamic),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Transformation provides configuration for transforming the secret data before
 * it is stored in the Destination.
 *
 * @schema HcpVaultSecretsAppSpecDestinationTransformation
 */
export interface HcpVaultSecretsAppSpecDestinationTransformation {
  /**
   * ExcludeRaw data from the destination Secret. Exclusion policy can be set
   * globally by including 'exclude-raw` in the '--global-transformation-options'
   * command line flag. If set, the command line flag always takes precedence over
   * this configuration.
   *
   * @schema HcpVaultSecretsAppSpecDestinationTransformation#excludeRaw
   */
  readonly excludeRaw?: boolean;

  /**
   * Excludes contains regex patterns used to filter top-level source secret data
   * fields for exclusion from the final K8s Secret data. These pattern filters are
   * never applied to templated fields as defined in Templates. They are always
   * applied before any inclusion patterns. To exclude all source secret data
   * fields, you can configure the single pattern ".*".
   *
   * @schema HcpVaultSecretsAppSpecDestinationTransformation#excludes
   */
  readonly excludes?: string[];

  /**
   * Includes contains regex patterns used to filter top-level source secret data
   * fields for inclusion in the final K8s Secret data. These pattern filters are
   * never applied to templated fields as defined in Templates. They are always
   * applied last.
   *
   * @schema HcpVaultSecretsAppSpecDestinationTransformation#includes
   */
  readonly includes?: string[];

  /**
   * Templates maps a template name to its Template. Templates are always included
   * in the rendered K8s Secret, and take precedence over templates defined in a
   * SecretTransformation.
   *
   * @schema HcpVaultSecretsAppSpecDestinationTransformation#templates
   */
  readonly templates?: { [key: string]: HcpVaultSecretsAppSpecDestinationTransformationTemplates };

  /**
   * TransformationRefs contain references to template configuration from
   * SecretTransformation.
   *
   * @schema HcpVaultSecretsAppSpecDestinationTransformation#transformationRefs
   */
  readonly transformationRefs?: HcpVaultSecretsAppSpecDestinationTransformationTransformationRefs[];
}

/**
 * Converts an object of type 'HcpVaultSecretsAppSpecDestinationTransformation' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HcpVaultSecretsAppSpecDestinationTransformation(obj: HcpVaultSecretsAppSpecDestinationTransformation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'excludeRaw': obj.excludeRaw,
    'excludes': obj.excludes?.map(y => y),
    'includes': obj.includes?.map(y => y),
    'templates': ((obj.templates) === undefined) ? undefined : (Object.entries(obj.templates).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_HcpVaultSecretsAppSpecDestinationTransformationTemplates(i[1]) }), {})),
    'transformationRefs': obj.transformationRefs?.map(y => toJson_HcpVaultSecretsAppSpecDestinationTransformationTransformationRefs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind of the resource
 *
 * @schema HcpVaultSecretsAppSpecRolloutRestartTargetsKind
 */
export enum HcpVaultSecretsAppSpecRolloutRestartTargetsKind {
  /** Deployment */
  DEPLOYMENT = "Deployment",
  /** DaemonSet */
  DAEMON_SET = "DaemonSet",
  /** StatefulSet */
  STATEFUL_SET = "StatefulSet",
  /** argo.Rollout */
  ARGO_PERIOD_ROLLOUT = "argo.Rollout",
}

/**
 * Dynamic configures sync behavior for dynamic secrets.
 *
 * @schema HcpVaultSecretsAppSpecSyncConfigDynamic
 */
export interface HcpVaultSecretsAppSpecSyncConfigDynamic {
  /**
   * RenewalPercent is the percent out of 100 of a dynamic secret's TTL when
   * new secrets are generated. Defaults to 67 percent plus up to 10% jitter.
   *
   * @default 67 percent plus up to 10% jitter.
   * @schema HcpVaultSecretsAppSpecSyncConfigDynamic#renewalPercent
   */
  readonly renewalPercent?: number;
}

/**
 * Converts an object of type 'HcpVaultSecretsAppSpecSyncConfigDynamic' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HcpVaultSecretsAppSpecSyncConfigDynamic(obj: HcpVaultSecretsAppSpecSyncConfigDynamic | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'renewalPercent': obj.renewalPercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Template provides templating configuration.
 *
 * @schema HcpVaultSecretsAppSpecDestinationTransformationTemplates
 */
export interface HcpVaultSecretsAppSpecDestinationTransformationTemplates {
  /**
   * Name of the Template
   *
   * @schema HcpVaultSecretsAppSpecDestinationTransformationTemplates#name
   */
  readonly name?: string;

  /**
   * Text contains the Go text template format. The template
   * references attributes from the data structure of the source secret.
   * Refer to https://pkg.go.dev/text/template for more information.
   *
   * @schema HcpVaultSecretsAppSpecDestinationTransformationTemplates#text
   */
  readonly text: string;
}

/**
 * Converts an object of type 'HcpVaultSecretsAppSpecDestinationTransformationTemplates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HcpVaultSecretsAppSpecDestinationTransformationTemplates(obj: HcpVaultSecretsAppSpecDestinationTransformationTemplates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'text': obj.text,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TransformationRef contains the configuration for accessing templates from an
 * SecretTransformation resource. TransformationRefs can be shared across all
 * syncable secret custom resources.
 *
 * @schema HcpVaultSecretsAppSpecDestinationTransformationTransformationRefs
 */
export interface HcpVaultSecretsAppSpecDestinationTransformationTransformationRefs {
  /**
   * IgnoreExcludes controls whether to use the SecretTransformation's Excludes
   * data key filters.
   *
   * @schema HcpVaultSecretsAppSpecDestinationTransformationTransformationRefs#ignoreExcludes
   */
  readonly ignoreExcludes?: boolean;

  /**
   * IgnoreIncludes controls whether to use the SecretTransformation's Includes
   * data key filters.
   *
   * @schema HcpVaultSecretsAppSpecDestinationTransformationTransformationRefs#ignoreIncludes
   */
  readonly ignoreIncludes?: boolean;

  /**
   * Name of the SecretTransformation resource.
   *
   * @schema HcpVaultSecretsAppSpecDestinationTransformationTransformationRefs#name
   */
  readonly name: string;

  /**
   * Namespace of the SecretTransformation resource.
   *
   * @schema HcpVaultSecretsAppSpecDestinationTransformationTransformationRefs#namespace
   */
  readonly namespace?: string;

  /**
   * TemplateRefs map to a Template found in this TransformationRef. If empty, then
   * all templates from the SecretTransformation will be rendered to the K8s Secret.
   *
   * @schema HcpVaultSecretsAppSpecDestinationTransformationTransformationRefs#templateRefs
   */
  readonly templateRefs?: HcpVaultSecretsAppSpecDestinationTransformationTransformationRefsTemplateRefs[];
}

/**
 * Converts an object of type 'HcpVaultSecretsAppSpecDestinationTransformationTransformationRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HcpVaultSecretsAppSpecDestinationTransformationTransformationRefs(obj: HcpVaultSecretsAppSpecDestinationTransformationTransformationRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreExcludes': obj.ignoreExcludes,
    'ignoreIncludes': obj.ignoreIncludes,
    'name': obj.name,
    'namespace': obj.namespace,
    'templateRefs': obj.templateRefs?.map(y => toJson_HcpVaultSecretsAppSpecDestinationTransformationTransformationRefsTemplateRefs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TemplateRef points to templating text that is stored in a
 * SecretTransformation custom resource.
 *
 * @schema HcpVaultSecretsAppSpecDestinationTransformationTransformationRefsTemplateRefs
 */
export interface HcpVaultSecretsAppSpecDestinationTransformationTransformationRefsTemplateRefs {
  /**
   * KeyOverride to the rendered template in the Destination secret. If Key is
   * empty, then the Key from reference spec will be used. Set this to override the
   * Key set from the reference spec.
   *
   * @schema HcpVaultSecretsAppSpecDestinationTransformationTransformationRefsTemplateRefs#keyOverride
   */
  readonly keyOverride?: string;

  /**
   * Name of the Template in SecretTransformationSpec.Templates.
   * the rendered secret data.
   *
   * @schema HcpVaultSecretsAppSpecDestinationTransformationTransformationRefsTemplateRefs#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'HcpVaultSecretsAppSpecDestinationTransformationTransformationRefsTemplateRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HcpVaultSecretsAppSpecDestinationTransformationTransformationRefsTemplateRefs(obj: HcpVaultSecretsAppSpecDestinationTransformationTransformationRefsTemplateRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyOverride': obj.keyOverride,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * SecretTransformation is the Schema for the secrettransformations API
 *
 * @schema SecretTransformation
 */
export class SecretTransformation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SecretTransformation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secrets.hashicorp.com/v1beta1',
    kind: 'SecretTransformation',
  }

  /**
   * Renders a Kubernetes manifest for "SecretTransformation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecretTransformationProps = {}): any {
    return {
      ...SecretTransformation.GVK,
      ...toJson_SecretTransformationProps(props),
    };
  }

  /**
   * Defines a "SecretTransformation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SecretTransformationProps = {}) {
    super(scope, id, {
      ...SecretTransformation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...SecretTransformation.GVK,
      ...toJson_SecretTransformationProps(resolved),
    };
  }
}

/**
 * SecretTransformation is the Schema for the secrettransformations API
 *
 * @schema SecretTransformation
 */
export interface SecretTransformationProps {
  /**
   * @schema SecretTransformation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecretTransformationSpec defines the desired state of SecretTransformation
   *
   * @schema SecretTransformation#spec
   */
  readonly spec?: SecretTransformationSpec;
}

/**
 * Converts an object of type 'SecretTransformationProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretTransformationProps(obj: SecretTransformationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SecretTransformationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretTransformationSpec defines the desired state of SecretTransformation
 *
 * @schema SecretTransformationSpec
 */
export interface SecretTransformationSpec {
  /**
   * Excludes contains regex patterns used to filter top-level source secret data
   * fields for exclusion from the final secret data. These pattern filters are
   * never applied to templated fields as defined in Templates. They are always
   * applied before any inclusion patterns. To exclude all source secret data
   * fields, you can configure the single pattern ".*".
   *
   * @schema SecretTransformationSpec#excludes
   */
  readonly excludes?: string[];

  /**
   * Includes contains regex patterns used to filter top-level source secret data
   * fields for inclusion in the final secret data. These pattern filters are
   * never applied to templated fields as defined in Templates. They are always
   * applied last.
   *
   * @schema SecretTransformationSpec#includes
   */
  readonly includes?: string[];

  /**
   * SourceTemplates are never included in the rendered secret, they can be
   * used to provide common template definitions, etc.
   *
   * @schema SecretTransformationSpec#sourceTemplates
   */
  readonly sourceTemplates?: SecretTransformationSpecSourceTemplates[];

  /**
   * Templates maps a template name to its Template. Templates are always included
   * in the rendered secret with the specified key.
   *
   * @schema SecretTransformationSpec#templates
   */
  readonly templates?: { [key: string]: SecretTransformationSpecTemplates };
}

/**
 * Converts an object of type 'SecretTransformationSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretTransformationSpec(obj: SecretTransformationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'excludes': obj.excludes?.map(y => y),
    'includes': obj.includes?.map(y => y),
    'sourceTemplates': obj.sourceTemplates?.map(y => toJson_SecretTransformationSpecSourceTemplates(y)),
    'templates': ((obj.templates) === undefined) ? undefined : (Object.entries(obj.templates).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_SecretTransformationSpecTemplates(i[1]) }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SourceTemplate provides source templating configuration.
 *
 * @schema SecretTransformationSpecSourceTemplates
 */
export interface SecretTransformationSpecSourceTemplates {
  /**
   * @schema SecretTransformationSpecSourceTemplates#name
   */
  readonly name?: string;

  /**
   * Text contains the Go text template format. The template
   * references attributes from the data structure of the source secret.
   * Refer to https://pkg.go.dev/text/template for more information.
   *
   * @schema SecretTransformationSpecSourceTemplates#text
   */
  readonly text: string;
}

/**
 * Converts an object of type 'SecretTransformationSpecSourceTemplates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretTransformationSpecSourceTemplates(obj: SecretTransformationSpecSourceTemplates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'text': obj.text,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Template provides templating configuration.
 *
 * @schema SecretTransformationSpecTemplates
 */
export interface SecretTransformationSpecTemplates {
  /**
   * Name of the Template
   *
   * @schema SecretTransformationSpecTemplates#name
   */
  readonly name?: string;

  /**
   * Text contains the Go text template format. The template
   * references attributes from the data structure of the source secret.
   * Refer to https://pkg.go.dev/text/template for more information.
   *
   * @schema SecretTransformationSpecTemplates#text
   */
  readonly text: string;
}

/**
 * Converts an object of type 'SecretTransformationSpecTemplates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SecretTransformationSpecTemplates(obj: SecretTransformationSpecTemplates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'text': obj.text,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * VaultAuth is the Schema for the vaultauths API
 *
 * @schema VaultAuth
 */
export class VaultAuth extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VaultAuth"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secrets.hashicorp.com/v1beta1',
    kind: 'VaultAuth',
  }

  /**
   * Renders a Kubernetes manifest for "VaultAuth".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VaultAuthProps = {}): any {
    return {
      ...VaultAuth.GVK,
      ...toJson_VaultAuthProps(props),
    };
  }

  /**
   * Defines a "VaultAuth" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VaultAuthProps = {}) {
    super(scope, id, {
      ...VaultAuth.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VaultAuth.GVK,
      ...toJson_VaultAuthProps(resolved),
    };
  }
}

/**
 * VaultAuth is the Schema for the vaultauths API
 *
 * @schema VaultAuth
 */
export interface VaultAuthProps {
  /**
   * @schema VaultAuth#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VaultAuthSpec defines the desired state of VaultAuth
   *
   * @schema VaultAuth#spec
   */
  readonly spec?: VaultAuthSpec;
}

/**
 * Converts an object of type 'VaultAuthProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultAuthProps(obj: VaultAuthProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VaultAuthSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VaultAuthSpec defines the desired state of VaultAuth
 *
 * @schema VaultAuthSpec
 */
export interface VaultAuthSpec {
  /**
   * AllowedNamespaces Kubernetes Namespaces which are allow-listed for use with this AuthMethod.
   * This field allows administrators to customize which Kubernetes namespaces are authorized to
   * use with this AuthMethod. While Vault will still enforce its own rules, this has the added
   * configurability of restricting which VaultAuthMethods can be used by which namespaces.
   * You only need to set allowedNamespaces when you want to control access from a resource in
   * a different namespace than the VaultAuth it references. Secret resources in
   * the same namespace as the VaultAuth bypass this check.
   * Accepted values:
   * []{"*"} - wildcard, all namespaces.
   * []{"a", "b"} - list of namespaces.
   * unset - disallow all namespaces except the Operator's the VaultAuthMethod's namespace, this
   * is the default behavior.
   *
   * @schema VaultAuthSpec#allowedNamespaces
   */
  readonly allowedNamespaces?: string[];

  /**
   * AppRole specific auth configuration, requires that the Method be set to `appRole`.
   *
   * @schema VaultAuthSpec#appRole
   */
  readonly appRole?: VaultAuthSpecAppRole;

  /**
   * AWS specific auth configuration, requires that Method be set to `aws`.
   *
   * @schema VaultAuthSpec#aws
   */
  readonly aws?: VaultAuthSpecAws;

  /**
   * GCP specific auth configuration, requires that Method be set to `gcp`.
   *
   * @schema VaultAuthSpec#gcp
   */
  readonly gcp?: VaultAuthSpecGcp;

  /**
   * Headers to be included in all Vault requests.
   *
   * @schema VaultAuthSpec#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * JWT specific auth configuration, requires that the Method be set to `jwt`.
   *
   * @schema VaultAuthSpec#jwt
   */
  readonly jwt?: VaultAuthSpecJwt;

  /**
   * Kubernetes specific auth configuration, requires that the Method be set to `kubernetes`.
   *
   * @schema VaultAuthSpec#kubernetes
   */
  readonly kubernetes?: VaultAuthSpecKubernetes;

  /**
   * Method to use when authenticating to Vault.
   *
   * @schema VaultAuthSpec#method
   */
  readonly method?: VaultAuthSpecMethod;

  /**
   * Mount to use when authenticating to auth method.
   *
   * @schema VaultAuthSpec#mount
   */
  readonly mount?: string;

  /**
   * Namespace to auth to in Vault
   *
   * @schema VaultAuthSpec#namespace
   */
  readonly namespace?: string;

  /**
   * Params to use when authenticating to Vault
   *
   * @schema VaultAuthSpec#params
   */
  readonly params?: { [key: string]: string };

  /**
   * StorageEncryption provides the necessary configuration to encrypt the client storage cache.
   * This should only be configured when client cache persistence with encryption is enabled.
   * This is done by passing setting the manager's commandline argument
   * --client-cache-persistence-model=direct-encrypted. Typically, there should only ever
   * be one VaultAuth configured with StorageEncryption in the Cluster, and it should have
   * the label: cacheStorageEncryption=true
   *
   * @schema VaultAuthSpec#storageEncryption
   */
  readonly storageEncryption?: VaultAuthSpecStorageEncryption;

  /**
   * VaultAuthGlobalRef.
   *
   * @schema VaultAuthSpec#vaultAuthGlobalRef
   */
  readonly vaultAuthGlobalRef?: VaultAuthSpecVaultAuthGlobalRef;

  /**
   * VaultConnectionRef to the VaultConnection resource, can be prefixed with a namespace,
   * eg: `namespaceA/vaultConnectionRefB`. If no namespace prefix is provided it will default to
   * the namespace of the VaultConnection CR. If no value is specified for VaultConnectionRef the
   * Operator will default to the `default` VaultConnection, configured in the operator's namespace.
   *
   * @schema VaultAuthSpec#vaultConnectionRef
   */
  readonly vaultConnectionRef?: string;
}

/**
 * Converts an object of type 'VaultAuthSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultAuthSpec(obj: VaultAuthSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedNamespaces': obj.allowedNamespaces?.map(y => y),
    'appRole': toJson_VaultAuthSpecAppRole(obj.appRole),
    'aws': toJson_VaultAuthSpecAws(obj.aws),
    'gcp': toJson_VaultAuthSpecGcp(obj.gcp),
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'jwt': toJson_VaultAuthSpecJwt(obj.jwt),
    'kubernetes': toJson_VaultAuthSpecKubernetes(obj.kubernetes),
    'method': obj.method,
    'mount': obj.mount,
    'namespace': obj.namespace,
    'params': ((obj.params) === undefined) ? undefined : (Object.entries(obj.params).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'storageEncryption': toJson_VaultAuthSpecStorageEncryption(obj.storageEncryption),
    'vaultAuthGlobalRef': toJson_VaultAuthSpecVaultAuthGlobalRef(obj.vaultAuthGlobalRef),
    'vaultConnectionRef': obj.vaultConnectionRef,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AppRole specific auth configuration, requires that the Method be set to `appRole`.
 *
 * @schema VaultAuthSpecAppRole
 */
export interface VaultAuthSpecAppRole {
  /**
   * RoleID of the AppRole Role to use for authenticating to Vault.
   *
   * @schema VaultAuthSpecAppRole#roleId
   */
  readonly roleId?: string;

  /**
   * SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which
   * provides the AppRole Role's SecretID. The secret must have a key named `id` which holds the
   * AppRole Role's secretID.
   *
   * @schema VaultAuthSpecAppRole#secretRef
   */
  readonly secretRef?: string;
}

/**
 * Converts an object of type 'VaultAuthSpecAppRole' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultAuthSpecAppRole(obj: VaultAuthSpecAppRole | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'roleId': obj.roleId,
    'secretRef': obj.secretRef,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AWS specific auth configuration, requires that Method be set to `aws`.
 *
 * @schema VaultAuthSpecAws
 */
export interface VaultAuthSpecAws {
  /**
   * The Vault header value to include in the STS signing request
   *
   * @schema VaultAuthSpecAws#headerValue
   */
  readonly headerValue?: string;

  /**
   * The IAM endpoint to use; if not set will use the default
   *
   * @schema VaultAuthSpecAws#iamEndpoint
   */
  readonly iamEndpoint?: string;

  /**
   * IRSAServiceAccount name to use with IAM Roles for Service Accounts
   * (IRSA), and should be annotated with "eks.amazonaws.com/role-arn". This
   * ServiceAccount will be checked for other EKS annotations:
   * eks.amazonaws.com/audience and eks.amazonaws.com/token-expiration
   *
   * @schema VaultAuthSpecAws#irsaServiceAccount
   */
  readonly irsaServiceAccount?: string;

  /**
   * AWS Region to use for signing the authentication request
   *
   * @schema VaultAuthSpecAws#region
   */
  readonly region?: string;

  /**
   * Vault role to use for authenticating
   *
   * @schema VaultAuthSpecAws#role
   */
  readonly role?: string;

  /**
   * SecretRef is the name of a Kubernetes Secret in the consumer's (VDS/VSS/PKI) namespace
   * which holds credentials for AWS. Expected keys include `access_key_id`, `secret_access_key`,
   * `session_token`
   *
   * @schema VaultAuthSpecAws#secretRef
   */
  readonly secretRef?: string;

  /**
   * The role session name to use when creating a webidentity provider
   *
   * @schema VaultAuthSpecAws#sessionName
   */
  readonly sessionName?: string;

  /**
   * The STS endpoint to use; if not set will use the default
   *
   * @schema VaultAuthSpecAws#stsEndpoint
   */
  readonly stsEndpoint?: string;
}

/**
 * Converts an object of type 'VaultAuthSpecAws' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultAuthSpecAws(obj: VaultAuthSpecAws | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerValue': obj.headerValue,
    'iamEndpoint': obj.iamEndpoint,
    'irsaServiceAccount': obj.irsaServiceAccount,
    'region': obj.region,
    'role': obj.role,
    'secretRef': obj.secretRef,
    'sessionName': obj.sessionName,
    'stsEndpoint': obj.stsEndpoint,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GCP specific auth configuration, requires that Method be set to `gcp`.
 *
 * @schema VaultAuthSpecGcp
 */
export interface VaultAuthSpecGcp {
  /**
   * GKE cluster name. Defaults to the cluster-name returned from the operator
   * pod's local metadata server.
   *
   * @default the cluster-name returned from the operator
   * @schema VaultAuthSpecGcp#clusterName
   */
  readonly clusterName?: string;

  /**
   * GCP project ID. Defaults to the project-id returned from the operator
   * pod's local metadata server.
   *
   * @default the project-id returned from the operator
   * @schema VaultAuthSpecGcp#projectID
   */
  readonly projectId?: string;

  /**
   * GCP Region of the GKE cluster's identity provider. Defaults to the region
   * returned from the operator pod's local metadata server.
   *
   * @default the region
   * @schema VaultAuthSpecGcp#region
   */
  readonly region?: string;

  /**
   * Vault role to use for authenticating
   *
   * @schema VaultAuthSpecGcp#role
   */
  readonly role?: string;

  /**
   * WorkloadIdentityServiceAccount is the name of a Kubernetes service
   * account (in the same Kubernetes namespace as the Vault*Secret referencing
   * this resource) which has been configured for workload identity in GKE.
   * Should be annotated with "iam.gke.io/gcp-service-account".
   *
   * @schema VaultAuthSpecGcp#workloadIdentityServiceAccount
   */
  readonly workloadIdentityServiceAccount?: string;
}

/**
 * Converts an object of type 'VaultAuthSpecGcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultAuthSpecGcp(obj: VaultAuthSpecGcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterName': obj.clusterName,
    'projectID': obj.projectId,
    'region': obj.region,
    'role': obj.role,
    'workloadIdentityServiceAccount': obj.workloadIdentityServiceAccount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * JWT specific auth configuration, requires that the Method be set to `jwt`.
 *
 * @schema VaultAuthSpecJwt
 */
export interface VaultAuthSpecJwt {
  /**
   * TokenAudiences to include in the ServiceAccount token.
   *
   * @schema VaultAuthSpecJwt#audiences
   */
  readonly audiences?: string[];

  /**
   * Role to use for authenticating to Vault.
   *
   * @schema VaultAuthSpecJwt#role
   */
  readonly role?: string;

  /**
   * SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which
   * provides the JWT token to authenticate to Vault's JWT authentication backend. The secret must
   * have a key named `jwt` which holds the JWT token.
   *
   * @schema VaultAuthSpecJwt#secretRef
   */
  readonly secretRef?: string;

  /**
   * ServiceAccount to use when creating a ServiceAccount token to authenticate to Vault's
   * JWT authentication backend.
   *
   * @schema VaultAuthSpecJwt#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * TokenExpirationSeconds to set the ServiceAccount token.
   *
   * @schema VaultAuthSpecJwt#tokenExpirationSeconds
   */
  readonly tokenExpirationSeconds?: number;
}

/**
 * Converts an object of type 'VaultAuthSpecJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultAuthSpecJwt(obj: VaultAuthSpecJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'role': obj.role,
    'secretRef': obj.secretRef,
    'serviceAccount': obj.serviceAccount,
    'tokenExpirationSeconds': obj.tokenExpirationSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubernetes specific auth configuration, requires that the Method be set to `kubernetes`.
 *
 * @schema VaultAuthSpecKubernetes
 */
export interface VaultAuthSpecKubernetes {
  /**
   * TokenAudiences to include in the ServiceAccount token.
   *
   * @schema VaultAuthSpecKubernetes#audiences
   */
  readonly audiences?: string[];

  /**
   * Role to use for authenticating to Vault.
   *
   * @schema VaultAuthSpecKubernetes#role
   */
  readonly role?: string;

  /**
   * ServiceAccount to use when authenticating to Vault's
   * authentication backend. This must reside in the consuming secret's (VDS/VSS/PKI) namespace.
   *
   * @schema VaultAuthSpecKubernetes#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * TokenExpirationSeconds to set the ServiceAccount token.
   *
   * @schema VaultAuthSpecKubernetes#tokenExpirationSeconds
   */
  readonly tokenExpirationSeconds?: number;
}

/**
 * Converts an object of type 'VaultAuthSpecKubernetes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultAuthSpecKubernetes(obj: VaultAuthSpecKubernetes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'role': obj.role,
    'serviceAccount': obj.serviceAccount,
    'tokenExpirationSeconds': obj.tokenExpirationSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Method to use when authenticating to Vault.
 *
 * @schema VaultAuthSpecMethod
 */
export enum VaultAuthSpecMethod {
  /** kubernetes */
  KUBERNETES = "kubernetes",
  /** jwt */
  JWT = "jwt",
  /** appRole */
  APP_ROLE = "appRole",
  /** aws */
  AWS = "aws",
  /** gcp */
  GCP = "gcp",
}

/**
 * StorageEncryption provides the necessary configuration to encrypt the client storage cache.
 * This should only be configured when client cache persistence with encryption is enabled.
 * This is done by passing setting the manager's commandline argument
 * --client-cache-persistence-model=direct-encrypted. Typically, there should only ever
 * be one VaultAuth configured with StorageEncryption in the Cluster, and it should have
 * the label: cacheStorageEncryption=true
 *
 * @schema VaultAuthSpecStorageEncryption
 */
export interface VaultAuthSpecStorageEncryption {
  /**
   * KeyName to use for encrypt/decrypt operations via Vault Transit.
   *
   * @schema VaultAuthSpecStorageEncryption#keyName
   */
  readonly keyName: string;

  /**
   * Mount path of the Transit engine in Vault.
   *
   * @schema VaultAuthSpecStorageEncryption#mount
   */
  readonly mount: string;
}

/**
 * Converts an object of type 'VaultAuthSpecStorageEncryption' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultAuthSpecStorageEncryption(obj: VaultAuthSpecStorageEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyName': obj.keyName,
    'mount': obj.mount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VaultAuthGlobalRef.
 *
 * @schema VaultAuthSpecVaultAuthGlobalRef
 */
export interface VaultAuthSpecVaultAuthGlobalRef {
  /**
   * AllowDefault when set to true will use the default VaultAuthGlobal resource
   * as the default if Name is not set. The 'allow-default-globals' option must be
   * set on the operator's '-global-vault-auth-options' flag
   *
   * The default VaultAuthGlobal search is conditional.
   * When a ref Namespace is set, the search for the default
   * VaultAuthGlobal resource is constrained to that namespace.
   * Otherwise, the search order is:
   * 1. The default VaultAuthGlobal resource in the referring VaultAuth resource's
   * namespace.
   * 2. The default VaultAuthGlobal resource in the Operator's namespace.
   *
   * @schema VaultAuthSpecVaultAuthGlobalRef#allowDefault
   */
  readonly allowDefault?: boolean;

  /**
   * MergeStrategy configures the merge strategy for HTTP headers and parameters
   * that are included in all Vault authentication requests.
   *
   * @schema VaultAuthSpecVaultAuthGlobalRef#mergeStrategy
   */
  readonly mergeStrategy?: VaultAuthSpecVaultAuthGlobalRefMergeStrategy;

  /**
   * Name of the VaultAuthGlobal resource.
   *
   * @schema VaultAuthSpecVaultAuthGlobalRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the VaultAuthGlobal resource. If not provided, the namespace of
   * the referring VaultAuth resource is used.
   *
   * @schema VaultAuthSpecVaultAuthGlobalRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'VaultAuthSpecVaultAuthGlobalRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultAuthSpecVaultAuthGlobalRef(obj: VaultAuthSpecVaultAuthGlobalRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowDefault': obj.allowDefault,
    'mergeStrategy': toJson_VaultAuthSpecVaultAuthGlobalRefMergeStrategy(obj.mergeStrategy),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MergeStrategy configures the merge strategy for HTTP headers and parameters
 * that are included in all Vault authentication requests.
 *
 * @schema VaultAuthSpecVaultAuthGlobalRefMergeStrategy
 */
export interface VaultAuthSpecVaultAuthGlobalRefMergeStrategy {
  /**
   * Headers configures the merge strategy for HTTP headers that are included in
   * all Vault requests. Choices are `union`, `replace`, or `none`.
   *
   * If `union` is set, the headers from the VaultAuthGlobal and VaultAuth
   * resources are merged. The headers from the VaultAuth always take precedence.
   *
   * If `replace` is set, the first set of non-empty headers taken in order from:
   * VaultAuth, VaultAuthGlobal auth method, VaultGlobal default headers.
   *
   * If `none` is set, the headers from the
   * VaultAuthGlobal resource are ignored and only the headers from the VaultAuth
   * resource are used. The default is `none`.
   *
   * @schema VaultAuthSpecVaultAuthGlobalRefMergeStrategy#headers
   */
  readonly headers?: VaultAuthSpecVaultAuthGlobalRefMergeStrategyHeaders;

  /**
   * Params configures the merge strategy for HTTP parameters that are included in
   * all Vault requests. Choices are `union`, `replace`, or `none`.
   *
   * If `union` is set, the parameters from the VaultAuthGlobal and VaultAuth
   * resources are merged. The parameters from the VaultAuth always take
   * precedence.
   *
   * If `replace` is set, the first set of non-empty parameters taken in order from:
   * VaultAuth, VaultAuthGlobal auth method, VaultGlobal default parameters.
   *
   * If `none` is set, the parameters from the VaultAuthGlobal resource are ignored
   * and only the parameters from the VaultAuth resource are used. The default is
   * `none`.
   *
   * @schema VaultAuthSpecVaultAuthGlobalRefMergeStrategy#params
   */
  readonly params?: VaultAuthSpecVaultAuthGlobalRefMergeStrategyParams;
}

/**
 * Converts an object of type 'VaultAuthSpecVaultAuthGlobalRefMergeStrategy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultAuthSpecVaultAuthGlobalRefMergeStrategy(obj: VaultAuthSpecVaultAuthGlobalRefMergeStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headers': obj.headers,
    'params': obj.params,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Headers configures the merge strategy for HTTP headers that are included in
 * all Vault requests. Choices are `union`, `replace`, or `none`.
 *
 * If `union` is set, the headers from the VaultAuthGlobal and VaultAuth
 * resources are merged. The headers from the VaultAuth always take precedence.
 *
 * If `replace` is set, the first set of non-empty headers taken in order from:
 * VaultAuth, VaultAuthGlobal auth method, VaultGlobal default headers.
 *
 * If `none` is set, the headers from the
 * VaultAuthGlobal resource are ignored and only the headers from the VaultAuth
 * resource are used. The default is `none`.
 *
 * @schema VaultAuthSpecVaultAuthGlobalRefMergeStrategyHeaders
 */
export enum VaultAuthSpecVaultAuthGlobalRefMergeStrategyHeaders {
  /** union */
  UNION = "union",
  /** replace */
  REPLACE = "replace",
  /** none */
  NONE = "none",
}

/**
 * Params configures the merge strategy for HTTP parameters that are included in
 * all Vault requests. Choices are `union`, `replace`, or `none`.
 *
 * If `union` is set, the parameters from the VaultAuthGlobal and VaultAuth
 * resources are merged. The parameters from the VaultAuth always take
 * precedence.
 *
 * If `replace` is set, the first set of non-empty parameters taken in order from:
 * VaultAuth, VaultAuthGlobal auth method, VaultGlobal default parameters.
 *
 * If `none` is set, the parameters from the VaultAuthGlobal resource are ignored
 * and only the parameters from the VaultAuth resource are used. The default is
 * `none`.
 *
 * @schema VaultAuthSpecVaultAuthGlobalRefMergeStrategyParams
 */
export enum VaultAuthSpecVaultAuthGlobalRefMergeStrategyParams {
  /** union */
  UNION = "union",
  /** replace */
  REPLACE = "replace",
  /** none */
  NONE = "none",
}


/**
 * VaultAuthGlobal is the Schema for the vaultauthglobals API
 *
 * @schema VaultAuthGlobal
 */
export class VaultAuthGlobal extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VaultAuthGlobal"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secrets.hashicorp.com/v1beta1',
    kind: 'VaultAuthGlobal',
  }

  /**
   * Renders a Kubernetes manifest for "VaultAuthGlobal".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VaultAuthGlobalProps = {}): any {
    return {
      ...VaultAuthGlobal.GVK,
      ...toJson_VaultAuthGlobalProps(props),
    };
  }

  /**
   * Defines a "VaultAuthGlobal" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VaultAuthGlobalProps = {}) {
    super(scope, id, {
      ...VaultAuthGlobal.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VaultAuthGlobal.GVK,
      ...toJson_VaultAuthGlobalProps(resolved),
    };
  }
}

/**
 * VaultAuthGlobal is the Schema for the vaultauthglobals API
 *
 * @schema VaultAuthGlobal
 */
export interface VaultAuthGlobalProps {
  /**
   * @schema VaultAuthGlobal#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VaultAuthGlobalSpec defines the desired state of VaultAuthGlobal
   *
   * @schema VaultAuthGlobal#spec
   */
  readonly spec?: VaultAuthGlobalSpec;
}

/**
 * Converts an object of type 'VaultAuthGlobalProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultAuthGlobalProps(obj: VaultAuthGlobalProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VaultAuthGlobalSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VaultAuthGlobalSpec defines the desired state of VaultAuthGlobal
 *
 * @schema VaultAuthGlobalSpec
 */
export interface VaultAuthGlobalSpec {
  /**
   * AllowedNamespaces Kubernetes Namespaces which are allow-listed for use with
   * this VaultAuthGlobal. This field allows administrators to customize which
   * Kubernetes namespaces are authorized to reference this resource. While Vault
   * will still enforce its own rules, this has the added configurability of
   * restricting which VaultAuthMethods can be used by which namespaces. Accepted
   * values: []{"*"} - wildcard, all namespaces. []{"a", "b"} - list of namespaces.
   * unset - disallow all namespaces except the Operator's and the referring
   * VaultAuthMethod's namespace, this is the default behavior.
   *
   * @schema VaultAuthGlobalSpec#allowedNamespaces
   */
  readonly allowedNamespaces?: string[];

  /**
   * AppRole specific auth configuration, requires that the Method be set to `appRole`.
   *
   * @schema VaultAuthGlobalSpec#appRole
   */
  readonly appRole?: VaultAuthGlobalSpecAppRole;

  /**
   * AWS specific auth configuration, requires that Method be set to `aws`.
   *
   * @schema VaultAuthGlobalSpec#aws
   */
  readonly aws?: VaultAuthGlobalSpecAws;

  /**
   * DefaultAuthMethod to use when authenticating to Vault.
   *
   * @schema VaultAuthGlobalSpec#defaultAuthMethod
   */
  readonly defaultAuthMethod?: VaultAuthGlobalSpecDefaultAuthMethod;

  /**
   * DefaultMount to use when authenticating to auth method. If not specified the mount of
   * the auth method configured in Vault will be used.
   *
   * @schema VaultAuthGlobalSpec#defaultMount
   */
  readonly defaultMount?: string;

  /**
   * DefaultVaultNamespace to auth to in Vault, if not specified the namespace of the auth
   * method will be used. This can be used as a default Vault namespace for all
   * auth methods.
   *
   * @schema VaultAuthGlobalSpec#defaultVaultNamespace
   */
  readonly defaultVaultNamespace?: string;

  /**
   * GCP specific auth configuration, requires that Method be set to `gcp`.
   *
   * @schema VaultAuthGlobalSpec#gcp
   */
  readonly gcp?: VaultAuthGlobalSpecGcp;

  /**
   * DefaultHeaders to be included in all Vault requests.
   *
   * @schema VaultAuthGlobalSpec#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * JWT specific auth configuration, requires that the Method be set to `jwt`.
   *
   * @schema VaultAuthGlobalSpec#jwt
   */
  readonly jwt?: VaultAuthGlobalSpecJwt;

  /**
   * Kubernetes specific auth configuration, requires that the Method be set to `kubernetes`.
   *
   * @schema VaultAuthGlobalSpec#kubernetes
   */
  readonly kubernetes?: VaultAuthGlobalSpecKubernetes;

  /**
   * DefaultParams to use when authenticating to Vault
   *
   * @schema VaultAuthGlobalSpec#params
   */
  readonly params?: { [key: string]: string };

  /**
   * VaultConnectionRef to the VaultConnection resource, can be prefixed with a namespace,
   * eg: `namespaceA/vaultConnectionRefB`. If no namespace prefix is provided it will default to
   * the namespace of the VaultConnection CR. If no value is specified for VaultConnectionRef the
   * Operator will default to the `default` VaultConnection, configured in the operator's namespace.
   *
   * @schema VaultAuthGlobalSpec#vaultConnectionRef
   */
  readonly vaultConnectionRef?: string;
}

/**
 * Converts an object of type 'VaultAuthGlobalSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultAuthGlobalSpec(obj: VaultAuthGlobalSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedNamespaces': obj.allowedNamespaces?.map(y => y),
    'appRole': toJson_VaultAuthGlobalSpecAppRole(obj.appRole),
    'aws': toJson_VaultAuthGlobalSpecAws(obj.aws),
    'defaultAuthMethod': obj.defaultAuthMethod,
    'defaultMount': obj.defaultMount,
    'defaultVaultNamespace': obj.defaultVaultNamespace,
    'gcp': toJson_VaultAuthGlobalSpecGcp(obj.gcp),
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'jwt': toJson_VaultAuthGlobalSpecJwt(obj.jwt),
    'kubernetes': toJson_VaultAuthGlobalSpecKubernetes(obj.kubernetes),
    'params': ((obj.params) === undefined) ? undefined : (Object.entries(obj.params).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vaultConnectionRef': obj.vaultConnectionRef,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AppRole specific auth configuration, requires that the Method be set to `appRole`.
 *
 * @schema VaultAuthGlobalSpecAppRole
 */
export interface VaultAuthGlobalSpecAppRole {
  /**
   * Headers to be included in all Vault requests.
   *
   * @schema VaultAuthGlobalSpecAppRole#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * Mount to use when authenticating to auth method.
   *
   * @schema VaultAuthGlobalSpecAppRole#mount
   */
  readonly mount?: string;

  /**
   * Namespace to auth to in Vault
   *
   * @schema VaultAuthGlobalSpecAppRole#namespace
   */
  readonly namespace?: string;

  /**
   * Params to use when authenticating to Vault
   *
   * @schema VaultAuthGlobalSpecAppRole#params
   */
  readonly params?: { [key: string]: string };

  /**
   * RoleID of the AppRole Role to use for authenticating to Vault.
   *
   * @schema VaultAuthGlobalSpecAppRole#roleId
   */
  readonly roleId?: string;

  /**
   * SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which
   * provides the AppRole Role's SecretID. The secret must have a key named `id` which holds the
   * AppRole Role's secretID.
   *
   * @schema VaultAuthGlobalSpecAppRole#secretRef
   */
  readonly secretRef?: string;
}

/**
 * Converts an object of type 'VaultAuthGlobalSpecAppRole' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultAuthGlobalSpecAppRole(obj: VaultAuthGlobalSpecAppRole | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'mount': obj.mount,
    'namespace': obj.namespace,
    'params': ((obj.params) === undefined) ? undefined : (Object.entries(obj.params).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'roleId': obj.roleId,
    'secretRef': obj.secretRef,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AWS specific auth configuration, requires that Method be set to `aws`.
 *
 * @schema VaultAuthGlobalSpecAws
 */
export interface VaultAuthGlobalSpecAws {
  /**
   * The Vault header value to include in the STS signing request
   *
   * @schema VaultAuthGlobalSpecAws#headerValue
   */
  readonly headerValue?: string;

  /**
   * Headers to be included in all Vault requests.
   *
   * @schema VaultAuthGlobalSpecAws#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * The IAM endpoint to use; if not set will use the default
   *
   * @schema VaultAuthGlobalSpecAws#iamEndpoint
   */
  readonly iamEndpoint?: string;

  /**
   * IRSAServiceAccount name to use with IAM Roles for Service Accounts
   * (IRSA), and should be annotated with "eks.amazonaws.com/role-arn". This
   * ServiceAccount will be checked for other EKS annotations:
   * eks.amazonaws.com/audience and eks.amazonaws.com/token-expiration
   *
   * @schema VaultAuthGlobalSpecAws#irsaServiceAccount
   */
  readonly irsaServiceAccount?: string;

  /**
   * Mount to use when authenticating to auth method.
   *
   * @schema VaultAuthGlobalSpecAws#mount
   */
  readonly mount?: string;

  /**
   * Namespace to auth to in Vault
   *
   * @schema VaultAuthGlobalSpecAws#namespace
   */
  readonly namespace?: string;

  /**
   * Params to use when authenticating to Vault
   *
   * @schema VaultAuthGlobalSpecAws#params
   */
  readonly params?: { [key: string]: string };

  /**
   * AWS Region to use for signing the authentication request
   *
   * @schema VaultAuthGlobalSpecAws#region
   */
  readonly region?: string;

  /**
   * Vault role to use for authenticating
   *
   * @schema VaultAuthGlobalSpecAws#role
   */
  readonly role?: string;

  /**
   * SecretRef is the name of a Kubernetes Secret in the consumer's (VDS/VSS/PKI) namespace
   * which holds credentials for AWS. Expected keys include `access_key_id`, `secret_access_key`,
   * `session_token`
   *
   * @schema VaultAuthGlobalSpecAws#secretRef
   */
  readonly secretRef?: string;

  /**
   * The role session name to use when creating a webidentity provider
   *
   * @schema VaultAuthGlobalSpecAws#sessionName
   */
  readonly sessionName?: string;

  /**
   * The STS endpoint to use; if not set will use the default
   *
   * @schema VaultAuthGlobalSpecAws#stsEndpoint
   */
  readonly stsEndpoint?: string;
}

/**
 * Converts an object of type 'VaultAuthGlobalSpecAws' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultAuthGlobalSpecAws(obj: VaultAuthGlobalSpecAws | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerValue': obj.headerValue,
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'iamEndpoint': obj.iamEndpoint,
    'irsaServiceAccount': obj.irsaServiceAccount,
    'mount': obj.mount,
    'namespace': obj.namespace,
    'params': ((obj.params) === undefined) ? undefined : (Object.entries(obj.params).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'region': obj.region,
    'role': obj.role,
    'secretRef': obj.secretRef,
    'sessionName': obj.sessionName,
    'stsEndpoint': obj.stsEndpoint,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DefaultAuthMethod to use when authenticating to Vault.
 *
 * @schema VaultAuthGlobalSpecDefaultAuthMethod
 */
export enum VaultAuthGlobalSpecDefaultAuthMethod {
  /** kubernetes */
  KUBERNETES = "kubernetes",
  /** jwt */
  JWT = "jwt",
  /** appRole */
  APP_ROLE = "appRole",
  /** aws */
  AWS = "aws",
  /** gcp */
  GCP = "gcp",
}

/**
 * GCP specific auth configuration, requires that Method be set to `gcp`.
 *
 * @schema VaultAuthGlobalSpecGcp
 */
export interface VaultAuthGlobalSpecGcp {
  /**
   * GKE cluster name. Defaults to the cluster-name returned from the operator
   * pod's local metadata server.
   *
   * @default the cluster-name returned from the operator
   * @schema VaultAuthGlobalSpecGcp#clusterName
   */
  readonly clusterName?: string;

  /**
   * Headers to be included in all Vault requests.
   *
   * @schema VaultAuthGlobalSpecGcp#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * Mount to use when authenticating to auth method.
   *
   * @schema VaultAuthGlobalSpecGcp#mount
   */
  readonly mount?: string;

  /**
   * Namespace to auth to in Vault
   *
   * @schema VaultAuthGlobalSpecGcp#namespace
   */
  readonly namespace?: string;

  /**
   * Params to use when authenticating to Vault
   *
   * @schema VaultAuthGlobalSpecGcp#params
   */
  readonly params?: { [key: string]: string };

  /**
   * GCP project ID. Defaults to the project-id returned from the operator
   * pod's local metadata server.
   *
   * @default the project-id returned from the operator
   * @schema VaultAuthGlobalSpecGcp#projectID
   */
  readonly projectId?: string;

  /**
   * GCP Region of the GKE cluster's identity provider. Defaults to the region
   * returned from the operator pod's local metadata server.
   *
   * @default the region
   * @schema VaultAuthGlobalSpecGcp#region
   */
  readonly region?: string;

  /**
   * Vault role to use for authenticating
   *
   * @schema VaultAuthGlobalSpecGcp#role
   */
  readonly role?: string;

  /**
   * WorkloadIdentityServiceAccount is the name of a Kubernetes service
   * account (in the same Kubernetes namespace as the Vault*Secret referencing
   * this resource) which has been configured for workload identity in GKE.
   * Should be annotated with "iam.gke.io/gcp-service-account".
   *
   * @schema VaultAuthGlobalSpecGcp#workloadIdentityServiceAccount
   */
  readonly workloadIdentityServiceAccount?: string;
}

/**
 * Converts an object of type 'VaultAuthGlobalSpecGcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultAuthGlobalSpecGcp(obj: VaultAuthGlobalSpecGcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterName': obj.clusterName,
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'mount': obj.mount,
    'namespace': obj.namespace,
    'params': ((obj.params) === undefined) ? undefined : (Object.entries(obj.params).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'projectID': obj.projectId,
    'region': obj.region,
    'role': obj.role,
    'workloadIdentityServiceAccount': obj.workloadIdentityServiceAccount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * JWT specific auth configuration, requires that the Method be set to `jwt`.
 *
 * @schema VaultAuthGlobalSpecJwt
 */
export interface VaultAuthGlobalSpecJwt {
  /**
   * TokenAudiences to include in the ServiceAccount token.
   *
   * @schema VaultAuthGlobalSpecJwt#audiences
   */
  readonly audiences?: string[];

  /**
   * Headers to be included in all Vault requests.
   *
   * @schema VaultAuthGlobalSpecJwt#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * Mount to use when authenticating to auth method.
   *
   * @schema VaultAuthGlobalSpecJwt#mount
   */
  readonly mount?: string;

  /**
   * Namespace to auth to in Vault
   *
   * @schema VaultAuthGlobalSpecJwt#namespace
   */
  readonly namespace?: string;

  /**
   * Params to use when authenticating to Vault
   *
   * @schema VaultAuthGlobalSpecJwt#params
   */
  readonly params?: { [key: string]: string };

  /**
   * Role to use for authenticating to Vault.
   *
   * @schema VaultAuthGlobalSpecJwt#role
   */
  readonly role?: string;

  /**
   * SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which
   * provides the JWT token to authenticate to Vault's JWT authentication backend. The secret must
   * have a key named `jwt` which holds the JWT token.
   *
   * @schema VaultAuthGlobalSpecJwt#secretRef
   */
  readonly secretRef?: string;

  /**
   * ServiceAccount to use when creating a ServiceAccount token to authenticate to Vault's
   * JWT authentication backend.
   *
   * @schema VaultAuthGlobalSpecJwt#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * TokenExpirationSeconds to set the ServiceAccount token.
   *
   * @schema VaultAuthGlobalSpecJwt#tokenExpirationSeconds
   */
  readonly tokenExpirationSeconds?: number;
}

/**
 * Converts an object of type 'VaultAuthGlobalSpecJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultAuthGlobalSpecJwt(obj: VaultAuthGlobalSpecJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'mount': obj.mount,
    'namespace': obj.namespace,
    'params': ((obj.params) === undefined) ? undefined : (Object.entries(obj.params).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'role': obj.role,
    'secretRef': obj.secretRef,
    'serviceAccount': obj.serviceAccount,
    'tokenExpirationSeconds': obj.tokenExpirationSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubernetes specific auth configuration, requires that the Method be set to `kubernetes`.
 *
 * @schema VaultAuthGlobalSpecKubernetes
 */
export interface VaultAuthGlobalSpecKubernetes {
  /**
   * TokenAudiences to include in the ServiceAccount token.
   *
   * @schema VaultAuthGlobalSpecKubernetes#audiences
   */
  readonly audiences?: string[];

  /**
   * Headers to be included in all Vault requests.
   *
   * @schema VaultAuthGlobalSpecKubernetes#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * Mount to use when authenticating to auth method.
   *
   * @schema VaultAuthGlobalSpecKubernetes#mount
   */
  readonly mount?: string;

  /**
   * Namespace to auth to in Vault
   *
   * @schema VaultAuthGlobalSpecKubernetes#namespace
   */
  readonly namespace?: string;

  /**
   * Params to use when authenticating to Vault
   *
   * @schema VaultAuthGlobalSpecKubernetes#params
   */
  readonly params?: { [key: string]: string };

  /**
   * Role to use for authenticating to Vault.
   *
   * @schema VaultAuthGlobalSpecKubernetes#role
   */
  readonly role?: string;

  /**
   * ServiceAccount to use when authenticating to Vault's
   * authentication backend. This must reside in the consuming secret's (VDS/VSS/PKI) namespace.
   *
   * @schema VaultAuthGlobalSpecKubernetes#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * TokenExpirationSeconds to set the ServiceAccount token.
   *
   * @schema VaultAuthGlobalSpecKubernetes#tokenExpirationSeconds
   */
  readonly tokenExpirationSeconds?: number;
}

/**
 * Converts an object of type 'VaultAuthGlobalSpecKubernetes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultAuthGlobalSpecKubernetes(obj: VaultAuthGlobalSpecKubernetes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'mount': obj.mount,
    'namespace': obj.namespace,
    'params': ((obj.params) === undefined) ? undefined : (Object.entries(obj.params).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'role': obj.role,
    'serviceAccount': obj.serviceAccount,
    'tokenExpirationSeconds': obj.tokenExpirationSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * VaultConnection is the Schema for the vaultconnections API
 *
 * @schema VaultConnection
 */
export class VaultConnection extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VaultConnection"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secrets.hashicorp.com/v1beta1',
    kind: 'VaultConnection',
  }

  /**
   * Renders a Kubernetes manifest for "VaultConnection".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VaultConnectionProps = {}): any {
    return {
      ...VaultConnection.GVK,
      ...toJson_VaultConnectionProps(props),
    };
  }

  /**
   * Defines a "VaultConnection" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VaultConnectionProps = {}) {
    super(scope, id, {
      ...VaultConnection.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VaultConnection.GVK,
      ...toJson_VaultConnectionProps(resolved),
    };
  }
}

/**
 * VaultConnection is the Schema for the vaultconnections API
 *
 * @schema VaultConnection
 */
export interface VaultConnectionProps {
  /**
   * @schema VaultConnection#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VaultConnectionSpec defines the desired state of VaultConnection
   *
   * @schema VaultConnection#spec
   */
  readonly spec?: VaultConnectionSpec;
}

/**
 * Converts an object of type 'VaultConnectionProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultConnectionProps(obj: VaultConnectionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VaultConnectionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VaultConnectionSpec defines the desired state of VaultConnection
 *
 * @schema VaultConnectionSpec
 */
export interface VaultConnectionSpec {
  /**
   * Address of the Vault server
   *
   * @schema VaultConnectionSpec#address
   */
  readonly address: string;

  /**
   * CACertSecretRef is the name of a Kubernetes secret containing the trusted PEM encoded CA certificate chain as `ca.crt`.
   *
   * @schema VaultConnectionSpec#caCertSecretRef
   */
  readonly caCertSecretRef?: string;

  /**
   * Headers to be included in all Vault requests.
   *
   * @schema VaultConnectionSpec#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * SkipTLSVerify for TLS connections.
   *
   * @schema VaultConnectionSpec#skipTLSVerify
   */
  readonly skipTlsVerify: boolean;

  /**
   * Timeout applied to all Vault requests for this connection. If not set, the
   * default timeout from the Vault API client config is used.
   *
   * @schema VaultConnectionSpec#timeout
   */
  readonly timeout?: string;

  /**
   * TLSServerName to use as the SNI host for TLS connections.
   *
   * @schema VaultConnectionSpec#tlsServerName
   */
  readonly tlsServerName?: string;
}

/**
 * Converts an object of type 'VaultConnectionSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultConnectionSpec(obj: VaultConnectionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'caCertSecretRef': obj.caCertSecretRef,
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'skipTLSVerify': obj.skipTlsVerify,
    'timeout': obj.timeout,
    'tlsServerName': obj.tlsServerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * VaultDynamicSecret is the Schema for the vaultdynamicsecrets API
 *
 * @schema VaultDynamicSecret
 */
export class VaultDynamicSecret extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VaultDynamicSecret"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secrets.hashicorp.com/v1beta1',
    kind: 'VaultDynamicSecret',
  }

  /**
   * Renders a Kubernetes manifest for "VaultDynamicSecret".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VaultDynamicSecretProps = {}): any {
    return {
      ...VaultDynamicSecret.GVK,
      ...toJson_VaultDynamicSecretProps(props),
    };
  }

  /**
   * Defines a "VaultDynamicSecret" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VaultDynamicSecretProps = {}) {
    super(scope, id, {
      ...VaultDynamicSecret.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VaultDynamicSecret.GVK,
      ...toJson_VaultDynamicSecretProps(resolved),
    };
  }
}

/**
 * VaultDynamicSecret is the Schema for the vaultdynamicsecrets API
 *
 * @schema VaultDynamicSecret
 */
export interface VaultDynamicSecretProps {
  /**
   * @schema VaultDynamicSecret#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VaultDynamicSecretSpec defines the desired state of VaultDynamicSecret
   *
   * @schema VaultDynamicSecret#spec
   */
  readonly spec?: VaultDynamicSecretSpec;
}

/**
 * Converts an object of type 'VaultDynamicSecretProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultDynamicSecretProps(obj: VaultDynamicSecretProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VaultDynamicSecretSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VaultDynamicSecretSpec defines the desired state of VaultDynamicSecret
 *
 * @schema VaultDynamicSecretSpec
 */
export interface VaultDynamicSecretSpec {
  /**
   * AllowStaticCreds should be set when syncing credentials that are periodically
   * rotated by the Vault server, rather than created upon request. These secrets
   * are sometimes referred to as "static roles", or "static credentials", with a
   * request path that contains "static-creds".
   *
   * @schema VaultDynamicSecretSpec#allowStaticCreds
   */
  readonly allowStaticCreds?: boolean;

  /**
   * Destination provides configuration necessary for syncing the Vault secret to Kubernetes.
   *
   * @schema VaultDynamicSecretSpec#destination
   */
  readonly destination: VaultDynamicSecretSpecDestination;

  /**
   * Mount path of the secret's engine in Vault.
   *
   * @schema VaultDynamicSecretSpec#mount
   */
  readonly mount: string;

  /**
   * Namespace of the secrets engine mount in Vault. If not set, the namespace that's
   * part of VaultAuth resource will be inferred.
   *
   * @schema VaultDynamicSecretSpec#namespace
   */
  readonly namespace?: string;

  /**
   * Params that can be passed when requesting credentials/secrets.
   * When Params is set the configured RequestHTTPMethod will be
   * ignored. See RequestHTTPMethod for more details.
   * Please consult https://developer.hashicorp.com/vault/docs/secrets if you are
   * uncertain about what 'params' should/can be set to.
   *
   * @schema VaultDynamicSecretSpec#params
   */
  readonly params?: { [key: string]: string };

  /**
   * Path in Vault to get the credentials for, and is relative to Mount.
   * Please consult https://developer.hashicorp.com/vault/docs/secrets if you are
   * uncertain about what 'path' should be set to.
   *
   * @schema VaultDynamicSecretSpec#path
   */
  readonly path: string;

  /**
   * RefreshAfter a period of time for VSO to sync the source secret data, in
   * duration notation e.g. 30s, 1m, 24h. This value only needs to be set when
   * syncing from a secret's engine that does not provide a lease TTL in its
   * response. The value should be within the secret engine's configured ttl or
   * max_ttl. The source secret's lease duration takes precedence over this
   * configuration when it is greater than 0.
   *
   * @schema VaultDynamicSecretSpec#refreshAfter
   */
  readonly refreshAfter?: string;

  /**
   * RenewalPercent is the percent out of 100 of the lease duration when the
   * lease is renewed. Defaults to 67 percent plus jitter.
   *
   * @default 67 percent plus jitter.
   * @schema VaultDynamicSecretSpec#renewalPercent
   */
  readonly renewalPercent?: number;

  /**
   * RequestHTTPMethod to use when syncing Secrets from Vault.
   * Setting a value here is not typically required.
   * If left unset the Operator will make requests using the GET method.
   * In the case where Params are specified the Operator will use the PUT method.
   * Please consult https://developer.hashicorp.com/vault/docs/secrets if you are
   * uncertain about what method to use.
   * Of note, the Vault client treats PUT and POST as being equivalent.
   * The underlying Vault client implementation will always use the PUT method.
   *
   * @schema VaultDynamicSecretSpec#requestHTTPMethod
   */
  readonly requestHttpMethod?: VaultDynamicSecretSpecRequestHttpMethod;

  /**
   * Revoke the existing lease on VDS resource deletion.
   *
   * @schema VaultDynamicSecretSpec#revoke
   */
  readonly revoke?: boolean;

  /**
   * RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does
   * not support dynamically reloading a rotated secret.
   * In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will
   * trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events.
   * See RolloutRestartTarget for more details.
   *
   * @schema VaultDynamicSecretSpec#rolloutRestartTargets
   */
  readonly rolloutRestartTargets?: VaultDynamicSecretSpecRolloutRestartTargets[];

  /**
   * VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace,
   * eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to
   * the namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator
   * will default to the `default` VaultAuth, configured in the operator's namespace.
   *
   * @schema VaultDynamicSecretSpec#vaultAuthRef
   */
  readonly vaultAuthRef?: string;
}

/**
 * Converts an object of type 'VaultDynamicSecretSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultDynamicSecretSpec(obj: VaultDynamicSecretSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowStaticCreds': obj.allowStaticCreds,
    'destination': toJson_VaultDynamicSecretSpecDestination(obj.destination),
    'mount': obj.mount,
    'namespace': obj.namespace,
    'params': ((obj.params) === undefined) ? undefined : (Object.entries(obj.params).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'path': obj.path,
    'refreshAfter': obj.refreshAfter,
    'renewalPercent': obj.renewalPercent,
    'requestHTTPMethod': obj.requestHttpMethod,
    'revoke': obj.revoke,
    'rolloutRestartTargets': obj.rolloutRestartTargets?.map(y => toJson_VaultDynamicSecretSpecRolloutRestartTargets(y)),
    'vaultAuthRef': obj.vaultAuthRef,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Destination provides configuration necessary for syncing the Vault secret to Kubernetes.
 *
 * @schema VaultDynamicSecretSpecDestination
 */
export interface VaultDynamicSecretSpecDestination {
  /**
   * Annotations to apply to the Secret. Requires Create to be set to true.
   *
   * @schema VaultDynamicSecretSpecDestination#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Create the destination Secret.
   * If the Secret already exists this should be set to false.
   *
   * @schema VaultDynamicSecretSpecDestination#create
   */
  readonly create?: boolean;

  /**
   * Labels to apply to the Secret. Requires Create to be set to true.
   *
   * @schema VaultDynamicSecretSpecDestination#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name of the Secret
   *
   * @schema VaultDynamicSecretSpecDestination#name
   */
  readonly name: string;

  /**
   * Overwrite the destination Secret if it exists and Create is true. This is
   * useful when migrating to VSO from a previous secret deployment strategy.
   *
   * @schema VaultDynamicSecretSpecDestination#overwrite
   */
  readonly overwrite?: boolean;

  /**
   * Transformation provides configuration for transforming the secret data before
   * it is stored in the Destination.
   *
   * @schema VaultDynamicSecretSpecDestination#transformation
   */
  readonly transformation?: VaultDynamicSecretSpecDestinationTransformation;

  /**
   * Type of Kubernetes Secret. Requires Create to be set to true.
   * Defaults to Opaque.
   *
   * @default Opaque.
   * @schema VaultDynamicSecretSpecDestination#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'VaultDynamicSecretSpecDestination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultDynamicSecretSpecDestination(obj: VaultDynamicSecretSpecDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'create': obj.create,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'overwrite': obj.overwrite,
    'transformation': toJson_VaultDynamicSecretSpecDestinationTransformation(obj.transformation),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RequestHTTPMethod to use when syncing Secrets from Vault.
 * Setting a value here is not typically required.
 * If left unset the Operator will make requests using the GET method.
 * In the case where Params are specified the Operator will use the PUT method.
 * Please consult https://developer.hashicorp.com/vault/docs/secrets if you are
 * uncertain about what method to use.
 * Of note, the Vault client treats PUT and POST as being equivalent.
 * The underlying Vault client implementation will always use the PUT method.
 *
 * @schema VaultDynamicSecretSpecRequestHttpMethod
 */
export enum VaultDynamicSecretSpecRequestHttpMethod {
  /** GET */
  GET = "GET",
  /** POST */
  POST = "POST",
  /** PUT */
  PUT = "PUT",
}

/**
 * RolloutRestartTarget provides the configuration required to perform a
 * rollout-restart of the supported resources upon Vault Secret rotation.
 * The rollout-restart is triggered by patching the target resource's
 * 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt'
 * with a timestamp value of when the trigger was executed.
 * E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z"
 *
 * Supported resources: Deployment, DaemonSet, StatefulSet, argo.Rollout
 *
 * @schema VaultDynamicSecretSpecRolloutRestartTargets
 */
export interface VaultDynamicSecretSpecRolloutRestartTargets {
  /**
   * Kind of the resource
   *
   * @schema VaultDynamicSecretSpecRolloutRestartTargets#kind
   */
  readonly kind: VaultDynamicSecretSpecRolloutRestartTargetsKind;

  /**
   * Name of the resource
   *
   * @schema VaultDynamicSecretSpecRolloutRestartTargets#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'VaultDynamicSecretSpecRolloutRestartTargets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultDynamicSecretSpecRolloutRestartTargets(obj: VaultDynamicSecretSpecRolloutRestartTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Transformation provides configuration for transforming the secret data before
 * it is stored in the Destination.
 *
 * @schema VaultDynamicSecretSpecDestinationTransformation
 */
export interface VaultDynamicSecretSpecDestinationTransformation {
  /**
   * ExcludeRaw data from the destination Secret. Exclusion policy can be set
   * globally by including 'exclude-raw` in the '--global-transformation-options'
   * command line flag. If set, the command line flag always takes precedence over
   * this configuration.
   *
   * @schema VaultDynamicSecretSpecDestinationTransformation#excludeRaw
   */
  readonly excludeRaw?: boolean;

  /**
   * Excludes contains regex patterns used to filter top-level source secret data
   * fields for exclusion from the final K8s Secret data. These pattern filters are
   * never applied to templated fields as defined in Templates. They are always
   * applied before any inclusion patterns. To exclude all source secret data
   * fields, you can configure the single pattern ".*".
   *
   * @schema VaultDynamicSecretSpecDestinationTransformation#excludes
   */
  readonly excludes?: string[];

  /**
   * Includes contains regex patterns used to filter top-level source secret data
   * fields for inclusion in the final K8s Secret data. These pattern filters are
   * never applied to templated fields as defined in Templates. They are always
   * applied last.
   *
   * @schema VaultDynamicSecretSpecDestinationTransformation#includes
   */
  readonly includes?: string[];

  /**
   * Templates maps a template name to its Template. Templates are always included
   * in the rendered K8s Secret, and take precedence over templates defined in a
   * SecretTransformation.
   *
   * @schema VaultDynamicSecretSpecDestinationTransformation#templates
   */
  readonly templates?: { [key: string]: VaultDynamicSecretSpecDestinationTransformationTemplates };

  /**
   * TransformationRefs contain references to template configuration from
   * SecretTransformation.
   *
   * @schema VaultDynamicSecretSpecDestinationTransformation#transformationRefs
   */
  readonly transformationRefs?: VaultDynamicSecretSpecDestinationTransformationTransformationRefs[];
}

/**
 * Converts an object of type 'VaultDynamicSecretSpecDestinationTransformation' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultDynamicSecretSpecDestinationTransformation(obj: VaultDynamicSecretSpecDestinationTransformation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'excludeRaw': obj.excludeRaw,
    'excludes': obj.excludes?.map(y => y),
    'includes': obj.includes?.map(y => y),
    'templates': ((obj.templates) === undefined) ? undefined : (Object.entries(obj.templates).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_VaultDynamicSecretSpecDestinationTransformationTemplates(i[1]) }), {})),
    'transformationRefs': obj.transformationRefs?.map(y => toJson_VaultDynamicSecretSpecDestinationTransformationTransformationRefs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind of the resource
 *
 * @schema VaultDynamicSecretSpecRolloutRestartTargetsKind
 */
export enum VaultDynamicSecretSpecRolloutRestartTargetsKind {
  /** Deployment */
  DEPLOYMENT = "Deployment",
  /** DaemonSet */
  DAEMON_SET = "DaemonSet",
  /** StatefulSet */
  STATEFUL_SET = "StatefulSet",
  /** argo.Rollout */
  ARGO_PERIOD_ROLLOUT = "argo.Rollout",
}

/**
 * Template provides templating configuration.
 *
 * @schema VaultDynamicSecretSpecDestinationTransformationTemplates
 */
export interface VaultDynamicSecretSpecDestinationTransformationTemplates {
  /**
   * Name of the Template
   *
   * @schema VaultDynamicSecretSpecDestinationTransformationTemplates#name
   */
  readonly name?: string;

  /**
   * Text contains the Go text template format. The template
   * references attributes from the data structure of the source secret.
   * Refer to https://pkg.go.dev/text/template for more information.
   *
   * @schema VaultDynamicSecretSpecDestinationTransformationTemplates#text
   */
  readonly text: string;
}

/**
 * Converts an object of type 'VaultDynamicSecretSpecDestinationTransformationTemplates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultDynamicSecretSpecDestinationTransformationTemplates(obj: VaultDynamicSecretSpecDestinationTransformationTemplates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'text': obj.text,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TransformationRef contains the configuration for accessing templates from an
 * SecretTransformation resource. TransformationRefs can be shared across all
 * syncable secret custom resources.
 *
 * @schema VaultDynamicSecretSpecDestinationTransformationTransformationRefs
 */
export interface VaultDynamicSecretSpecDestinationTransformationTransformationRefs {
  /**
   * IgnoreExcludes controls whether to use the SecretTransformation's Excludes
   * data key filters.
   *
   * @schema VaultDynamicSecretSpecDestinationTransformationTransformationRefs#ignoreExcludes
   */
  readonly ignoreExcludes?: boolean;

  /**
   * IgnoreIncludes controls whether to use the SecretTransformation's Includes
   * data key filters.
   *
   * @schema VaultDynamicSecretSpecDestinationTransformationTransformationRefs#ignoreIncludes
   */
  readonly ignoreIncludes?: boolean;

  /**
   * Name of the SecretTransformation resource.
   *
   * @schema VaultDynamicSecretSpecDestinationTransformationTransformationRefs#name
   */
  readonly name: string;

  /**
   * Namespace of the SecretTransformation resource.
   *
   * @schema VaultDynamicSecretSpecDestinationTransformationTransformationRefs#namespace
   */
  readonly namespace?: string;

  /**
   * TemplateRefs map to a Template found in this TransformationRef. If empty, then
   * all templates from the SecretTransformation will be rendered to the K8s Secret.
   *
   * @schema VaultDynamicSecretSpecDestinationTransformationTransformationRefs#templateRefs
   */
  readonly templateRefs?: VaultDynamicSecretSpecDestinationTransformationTransformationRefsTemplateRefs[];
}

/**
 * Converts an object of type 'VaultDynamicSecretSpecDestinationTransformationTransformationRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultDynamicSecretSpecDestinationTransformationTransformationRefs(obj: VaultDynamicSecretSpecDestinationTransformationTransformationRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreExcludes': obj.ignoreExcludes,
    'ignoreIncludes': obj.ignoreIncludes,
    'name': obj.name,
    'namespace': obj.namespace,
    'templateRefs': obj.templateRefs?.map(y => toJson_VaultDynamicSecretSpecDestinationTransformationTransformationRefsTemplateRefs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TemplateRef points to templating text that is stored in a
 * SecretTransformation custom resource.
 *
 * @schema VaultDynamicSecretSpecDestinationTransformationTransformationRefsTemplateRefs
 */
export interface VaultDynamicSecretSpecDestinationTransformationTransformationRefsTemplateRefs {
  /**
   * KeyOverride to the rendered template in the Destination secret. If Key is
   * empty, then the Key from reference spec will be used. Set this to override the
   * Key set from the reference spec.
   *
   * @schema VaultDynamicSecretSpecDestinationTransformationTransformationRefsTemplateRefs#keyOverride
   */
  readonly keyOverride?: string;

  /**
   * Name of the Template in SecretTransformationSpec.Templates.
   * the rendered secret data.
   *
   * @schema VaultDynamicSecretSpecDestinationTransformationTransformationRefsTemplateRefs#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'VaultDynamicSecretSpecDestinationTransformationTransformationRefsTemplateRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultDynamicSecretSpecDestinationTransformationTransformationRefsTemplateRefs(obj: VaultDynamicSecretSpecDestinationTransformationTransformationRefsTemplateRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyOverride': obj.keyOverride,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * VaultPKISecret is the Schema for the vaultpkisecrets API
 *
 * @schema VaultPKISecret
 */
export class VaultPkiSecret extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VaultPKISecret"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secrets.hashicorp.com/v1beta1',
    kind: 'VaultPKISecret',
  }

  /**
   * Renders a Kubernetes manifest for "VaultPKISecret".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VaultPkiSecretProps = {}): any {
    return {
      ...VaultPkiSecret.GVK,
      ...toJson_VaultPkiSecretProps(props),
    };
  }

  /**
   * Defines a "VaultPKISecret" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VaultPkiSecretProps = {}) {
    super(scope, id, {
      ...VaultPkiSecret.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VaultPkiSecret.GVK,
      ...toJson_VaultPkiSecretProps(resolved),
    };
  }
}

/**
 * VaultPKISecret is the Schema for the vaultpkisecrets API
 *
 * @schema VaultPKISecret
 */
export interface VaultPkiSecretProps {
  /**
   * @schema VaultPKISecret#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VaultPKISecretSpec defines the desired state of VaultPKISecret
   *
   * @schema VaultPKISecret#spec
   */
  readonly spec?: VaultPkiSecretSpec;
}

/**
 * Converts an object of type 'VaultPkiSecretProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultPkiSecretProps(obj: VaultPkiSecretProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VaultPkiSecretSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VaultPKISecretSpec defines the desired state of VaultPKISecret
 *
 * @schema VaultPkiSecretSpec
 */
export interface VaultPkiSecretSpec {
  /**
   * AltNames to include in the request
   * May contain both DNS names and email addresses.
   *
   * @schema VaultPkiSecretSpec#altNames
   */
  readonly altNames?: string[];

  /**
   * Clear the Kubernetes secret when the resource is deleted.
   *
   * @schema VaultPkiSecretSpec#clear
   */
  readonly clear?: boolean;

  /**
   * CommonName to include in the request.
   *
   * @schema VaultPkiSecretSpec#commonName
   */
  readonly commonName?: string;

  /**
   * Destination provides configuration necessary for syncing the Vault secret
   * to Kubernetes. If the type is set to "kubernetes.io/tls", "tls.key" will
   * be set to the "private_key" response from Vault, and "tls.crt" will be
   * set to "certificate" + "ca_chain" from the Vault response ("issuing_ca"
   * is used when "ca_chain" is empty). The "remove_roots_from_chain=true"
   * option is used with Vault to exclude the root CA from the Vault response.
   *
   * @schema VaultPkiSecretSpec#destination
   */
  readonly destination: VaultPkiSecretSpecDestination;

  /**
   * ExcludeCNFromSans from DNS or Email Subject Alternate Names.
   * Default: false
   *
   * @schema VaultPkiSecretSpec#excludeCNFromSans
   */
  readonly excludeCnFromSans?: boolean;

  /**
   * ExpiryOffset to use for computing when the certificate should be renewed.
   * The rotation time will be difference between the expiration and the offset.
   * Should be in duration notation e.g. 30s, 120s, etc.
   *
   * @schema VaultPkiSecretSpec#expiryOffset
   */
  readonly expiryOffset?: string;

  /**
   * Format for the certificate. Choices: "pem", "der", "pem_bundle".
   * If "pem_bundle",
   * any private key and issuing cert will be appended to the certificate pem.
   * If "der", the value will be base64 encoded.
   * Default: pem
   *
   * @schema VaultPkiSecretSpec#format
   */
  readonly format?: string;

  /**
   * IPSans to include in the request.
   *
   * @schema VaultPkiSecretSpec#ipSans
   */
  readonly ipSans?: string[];

  /**
   * IssuerRef reference to an existing PKI issuer, either by Vault-generated
   * identifier, the literal string default to refer to the currently
   * configured default issuer, or the name assigned to an issuer.
   * This parameter is part of the request URL.
   *
   * @schema VaultPkiSecretSpec#issuerRef
   */
  readonly issuerRef?: string;

  /**
   * Mount for the secret in Vault
   *
   * @schema VaultPkiSecretSpec#mount
   */
  readonly mount: string;

  /**
   * Namespace of the secrets engine mount in Vault. If not set, the namespace that's
   * part of VaultAuth resource will be inferred.
   *
   * @schema VaultPkiSecretSpec#namespace
   */
  readonly namespace?: string;

  /**
   * NotAfter field of the certificate with specified date value.
   * The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ
   *
   * @schema VaultPkiSecretSpec#notAfter
   */
  readonly notAfter?: string;

  /**
   * Requested other SANs, in an array with the format
   * oid;type:value for each entry.
   *
   * @schema VaultPkiSecretSpec#otherSans
   */
  readonly otherSans?: string[];

  /**
   * PrivateKeyFormat, generally the default will be controlled by the Format
   * parameter as either base64-encoded DER or PEM-encoded DER.
   * However, this can be set to "pkcs8" to have the returned
   * private key contain base64-encoded pkcs8 or PEM-encoded
   * pkcs8 instead.
   * Default: der
   *
   * @schema VaultPkiSecretSpec#privateKeyFormat
   */
  readonly privateKeyFormat?: string;

  /**
   * Revoke the certificate when the resource is deleted.
   *
   * @schema VaultPkiSecretSpec#revoke
   */
  readonly revoke?: boolean;

  /**
   * Role in Vault to use when issuing TLS certificates.
   *
   * @schema VaultPkiSecretSpec#role
   */
  readonly role: string;

  /**
   * RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does
   * not support dynamically reloading a rotated secret.
   * In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will
   * trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events.
   * See RolloutRestartTarget for more details.
   *
   * @schema VaultPkiSecretSpec#rolloutRestartTargets
   */
  readonly rolloutRestartTargets?: VaultPkiSecretSpecRolloutRestartTargets[];

  /**
   * TTL for the certificate; sets the expiration date.
   * If not specified the Vault role's default,
   * backend default, or system default TTL is used, in that order.
   * Cannot be larger than the mount's max TTL.
   * Note: this only has an effect when generating a CA cert or signing a CA cert,
   * not when generating a CSR for an intermediate CA.
   * Should be in duration notation e.g. 120s, 2h, etc.
   *
   * @schema VaultPkiSecretSpec#ttl
   */
  readonly ttl?: string;

  /**
   * The requested URI SANs.
   *
   * @schema VaultPkiSecretSpec#uriSans
   */
  readonly uriSans?: string[];

  /**
   * User ID (OID 0.9.2342.19200300.100.1.1) Subject values to be placed on the
   * signed certificate.
   *
   * @schema VaultPkiSecretSpec#userIDs
   */
  readonly userIDs?: string[];

  /**
   * VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace,
   * eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to
   * the namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator
   * will default to the `default` VaultAuth, configured in the operator's namespace.
   *
   * @schema VaultPkiSecretSpec#vaultAuthRef
   */
  readonly vaultAuthRef?: string;
}

/**
 * Converts an object of type 'VaultPkiSecretSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultPkiSecretSpec(obj: VaultPkiSecretSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'altNames': obj.altNames?.map(y => y),
    'clear': obj.clear,
    'commonName': obj.commonName,
    'destination': toJson_VaultPkiSecretSpecDestination(obj.destination),
    'excludeCNFromSans': obj.excludeCnFromSans,
    'expiryOffset': obj.expiryOffset,
    'format': obj.format,
    'ipSans': obj.ipSans?.map(y => y),
    'issuerRef': obj.issuerRef,
    'mount': obj.mount,
    'namespace': obj.namespace,
    'notAfter': obj.notAfter,
    'otherSans': obj.otherSans?.map(y => y),
    'privateKeyFormat': obj.privateKeyFormat,
    'revoke': obj.revoke,
    'role': obj.role,
    'rolloutRestartTargets': obj.rolloutRestartTargets?.map(y => toJson_VaultPkiSecretSpecRolloutRestartTargets(y)),
    'ttl': obj.ttl,
    'uriSans': obj.uriSans?.map(y => y),
    'userIDs': obj.userIDs?.map(y => y),
    'vaultAuthRef': obj.vaultAuthRef,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Destination provides configuration necessary for syncing the Vault secret
 * to Kubernetes. If the type is set to "kubernetes.io/tls", "tls.key" will
 * be set to the "private_key" response from Vault, and "tls.crt" will be
 * set to "certificate" + "ca_chain" from the Vault response ("issuing_ca"
 * is used when "ca_chain" is empty). The "remove_roots_from_chain=true"
 * option is used with Vault to exclude the root CA from the Vault response.
 *
 * @schema VaultPkiSecretSpecDestination
 */
export interface VaultPkiSecretSpecDestination {
  /**
   * Annotations to apply to the Secret. Requires Create to be set to true.
   *
   * @schema VaultPkiSecretSpecDestination#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Create the destination Secret.
   * If the Secret already exists this should be set to false.
   *
   * @schema VaultPkiSecretSpecDestination#create
   */
  readonly create?: boolean;

  /**
   * Labels to apply to the Secret. Requires Create to be set to true.
   *
   * @schema VaultPkiSecretSpecDestination#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name of the Secret
   *
   * @schema VaultPkiSecretSpecDestination#name
   */
  readonly name: string;

  /**
   * Overwrite the destination Secret if it exists and Create is true. This is
   * useful when migrating to VSO from a previous secret deployment strategy.
   *
   * @schema VaultPkiSecretSpecDestination#overwrite
   */
  readonly overwrite?: boolean;

  /**
   * Transformation provides configuration for transforming the secret data before
   * it is stored in the Destination.
   *
   * @schema VaultPkiSecretSpecDestination#transformation
   */
  readonly transformation?: VaultPkiSecretSpecDestinationTransformation;

  /**
   * Type of Kubernetes Secret. Requires Create to be set to true.
   * Defaults to Opaque.
   *
   * @default Opaque.
   * @schema VaultPkiSecretSpecDestination#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'VaultPkiSecretSpecDestination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultPkiSecretSpecDestination(obj: VaultPkiSecretSpecDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'create': obj.create,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'overwrite': obj.overwrite,
    'transformation': toJson_VaultPkiSecretSpecDestinationTransformation(obj.transformation),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RolloutRestartTarget provides the configuration required to perform a
 * rollout-restart of the supported resources upon Vault Secret rotation.
 * The rollout-restart is triggered by patching the target resource's
 * 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt'
 * with a timestamp value of when the trigger was executed.
 * E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z"
 *
 * Supported resources: Deployment, DaemonSet, StatefulSet, argo.Rollout
 *
 * @schema VaultPkiSecretSpecRolloutRestartTargets
 */
export interface VaultPkiSecretSpecRolloutRestartTargets {
  /**
   * Kind of the resource
   *
   * @schema VaultPkiSecretSpecRolloutRestartTargets#kind
   */
  readonly kind: VaultPkiSecretSpecRolloutRestartTargetsKind;

  /**
   * Name of the resource
   *
   * @schema VaultPkiSecretSpecRolloutRestartTargets#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'VaultPkiSecretSpecRolloutRestartTargets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultPkiSecretSpecRolloutRestartTargets(obj: VaultPkiSecretSpecRolloutRestartTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Transformation provides configuration for transforming the secret data before
 * it is stored in the Destination.
 *
 * @schema VaultPkiSecretSpecDestinationTransformation
 */
export interface VaultPkiSecretSpecDestinationTransformation {
  /**
   * ExcludeRaw data from the destination Secret. Exclusion policy can be set
   * globally by including 'exclude-raw` in the '--global-transformation-options'
   * command line flag. If set, the command line flag always takes precedence over
   * this configuration.
   *
   * @schema VaultPkiSecretSpecDestinationTransformation#excludeRaw
   */
  readonly excludeRaw?: boolean;

  /**
   * Excludes contains regex patterns used to filter top-level source secret data
   * fields for exclusion from the final K8s Secret data. These pattern filters are
   * never applied to templated fields as defined in Templates. They are always
   * applied before any inclusion patterns. To exclude all source secret data
   * fields, you can configure the single pattern ".*".
   *
   * @schema VaultPkiSecretSpecDestinationTransformation#excludes
   */
  readonly excludes?: string[];

  /**
   * Includes contains regex patterns used to filter top-level source secret data
   * fields for inclusion in the final K8s Secret data. These pattern filters are
   * never applied to templated fields as defined in Templates. They are always
   * applied last.
   *
   * @schema VaultPkiSecretSpecDestinationTransformation#includes
   */
  readonly includes?: string[];

  /**
   * Templates maps a template name to its Template. Templates are always included
   * in the rendered K8s Secret, and take precedence over templates defined in a
   * SecretTransformation.
   *
   * @schema VaultPkiSecretSpecDestinationTransformation#templates
   */
  readonly templates?: { [key: string]: VaultPkiSecretSpecDestinationTransformationTemplates };

  /**
   * TransformationRefs contain references to template configuration from
   * SecretTransformation.
   *
   * @schema VaultPkiSecretSpecDestinationTransformation#transformationRefs
   */
  readonly transformationRefs?: VaultPkiSecretSpecDestinationTransformationTransformationRefs[];
}

/**
 * Converts an object of type 'VaultPkiSecretSpecDestinationTransformation' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultPkiSecretSpecDestinationTransformation(obj: VaultPkiSecretSpecDestinationTransformation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'excludeRaw': obj.excludeRaw,
    'excludes': obj.excludes?.map(y => y),
    'includes': obj.includes?.map(y => y),
    'templates': ((obj.templates) === undefined) ? undefined : (Object.entries(obj.templates).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_VaultPkiSecretSpecDestinationTransformationTemplates(i[1]) }), {})),
    'transformationRefs': obj.transformationRefs?.map(y => toJson_VaultPkiSecretSpecDestinationTransformationTransformationRefs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind of the resource
 *
 * @schema VaultPkiSecretSpecRolloutRestartTargetsKind
 */
export enum VaultPkiSecretSpecRolloutRestartTargetsKind {
  /** Deployment */
  DEPLOYMENT = "Deployment",
  /** DaemonSet */
  DAEMON_SET = "DaemonSet",
  /** StatefulSet */
  STATEFUL_SET = "StatefulSet",
  /** argo.Rollout */
  ARGO_PERIOD_ROLLOUT = "argo.Rollout",
}

/**
 * Template provides templating configuration.
 *
 * @schema VaultPkiSecretSpecDestinationTransformationTemplates
 */
export interface VaultPkiSecretSpecDestinationTransformationTemplates {
  /**
   * Name of the Template
   *
   * @schema VaultPkiSecretSpecDestinationTransformationTemplates#name
   */
  readonly name?: string;

  /**
   * Text contains the Go text template format. The template
   * references attributes from the data structure of the source secret.
   * Refer to https://pkg.go.dev/text/template for more information.
   *
   * @schema VaultPkiSecretSpecDestinationTransformationTemplates#text
   */
  readonly text: string;
}

/**
 * Converts an object of type 'VaultPkiSecretSpecDestinationTransformationTemplates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultPkiSecretSpecDestinationTransformationTemplates(obj: VaultPkiSecretSpecDestinationTransformationTemplates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'text': obj.text,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TransformationRef contains the configuration for accessing templates from an
 * SecretTransformation resource. TransformationRefs can be shared across all
 * syncable secret custom resources.
 *
 * @schema VaultPkiSecretSpecDestinationTransformationTransformationRefs
 */
export interface VaultPkiSecretSpecDestinationTransformationTransformationRefs {
  /**
   * IgnoreExcludes controls whether to use the SecretTransformation's Excludes
   * data key filters.
   *
   * @schema VaultPkiSecretSpecDestinationTransformationTransformationRefs#ignoreExcludes
   */
  readonly ignoreExcludes?: boolean;

  /**
   * IgnoreIncludes controls whether to use the SecretTransformation's Includes
   * data key filters.
   *
   * @schema VaultPkiSecretSpecDestinationTransformationTransformationRefs#ignoreIncludes
   */
  readonly ignoreIncludes?: boolean;

  /**
   * Name of the SecretTransformation resource.
   *
   * @schema VaultPkiSecretSpecDestinationTransformationTransformationRefs#name
   */
  readonly name: string;

  /**
   * Namespace of the SecretTransformation resource.
   *
   * @schema VaultPkiSecretSpecDestinationTransformationTransformationRefs#namespace
   */
  readonly namespace?: string;

  /**
   * TemplateRefs map to a Template found in this TransformationRef. If empty, then
   * all templates from the SecretTransformation will be rendered to the K8s Secret.
   *
   * @schema VaultPkiSecretSpecDestinationTransformationTransformationRefs#templateRefs
   */
  readonly templateRefs?: VaultPkiSecretSpecDestinationTransformationTransformationRefsTemplateRefs[];
}

/**
 * Converts an object of type 'VaultPkiSecretSpecDestinationTransformationTransformationRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultPkiSecretSpecDestinationTransformationTransformationRefs(obj: VaultPkiSecretSpecDestinationTransformationTransformationRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreExcludes': obj.ignoreExcludes,
    'ignoreIncludes': obj.ignoreIncludes,
    'name': obj.name,
    'namespace': obj.namespace,
    'templateRefs': obj.templateRefs?.map(y => toJson_VaultPkiSecretSpecDestinationTransformationTransformationRefsTemplateRefs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TemplateRef points to templating text that is stored in a
 * SecretTransformation custom resource.
 *
 * @schema VaultPkiSecretSpecDestinationTransformationTransformationRefsTemplateRefs
 */
export interface VaultPkiSecretSpecDestinationTransformationTransformationRefsTemplateRefs {
  /**
   * KeyOverride to the rendered template in the Destination secret. If Key is
   * empty, then the Key from reference spec will be used. Set this to override the
   * Key set from the reference spec.
   *
   * @schema VaultPkiSecretSpecDestinationTransformationTransformationRefsTemplateRefs#keyOverride
   */
  readonly keyOverride?: string;

  /**
   * Name of the Template in SecretTransformationSpec.Templates.
   * the rendered secret data.
   *
   * @schema VaultPkiSecretSpecDestinationTransformationTransformationRefsTemplateRefs#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'VaultPkiSecretSpecDestinationTransformationTransformationRefsTemplateRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultPkiSecretSpecDestinationTransformationTransformationRefsTemplateRefs(obj: VaultPkiSecretSpecDestinationTransformationTransformationRefsTemplateRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyOverride': obj.keyOverride,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * VaultStaticSecret is the Schema for the vaultstaticsecrets API
 *
 * @schema VaultStaticSecret
 */
export class VaultStaticSecret extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VaultStaticSecret"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secrets.hashicorp.com/v1beta1',
    kind: 'VaultStaticSecret',
  }

  /**
   * Renders a Kubernetes manifest for "VaultStaticSecret".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VaultStaticSecretProps = {}): any {
    return {
      ...VaultStaticSecret.GVK,
      ...toJson_VaultStaticSecretProps(props),
    };
  }

  /**
   * Defines a "VaultStaticSecret" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VaultStaticSecretProps = {}) {
    super(scope, id, {
      ...VaultStaticSecret.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VaultStaticSecret.GVK,
      ...toJson_VaultStaticSecretProps(resolved),
    };
  }
}

/**
 * VaultStaticSecret is the Schema for the vaultstaticsecrets API
 *
 * @schema VaultStaticSecret
 */
export interface VaultStaticSecretProps {
  /**
   * @schema VaultStaticSecret#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VaultStaticSecretSpec defines the desired state of VaultStaticSecret
   *
   * @schema VaultStaticSecret#spec
   */
  readonly spec?: VaultStaticSecretSpec;
}

/**
 * Converts an object of type 'VaultStaticSecretProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultStaticSecretProps(obj: VaultStaticSecretProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VaultStaticSecretSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VaultStaticSecretSpec defines the desired state of VaultStaticSecret
 *
 * @schema VaultStaticSecretSpec
 */
export interface VaultStaticSecretSpec {
  /**
   * Destination provides configuration necessary for syncing the Vault secret to Kubernetes.
   *
   * @schema VaultStaticSecretSpec#destination
   */
  readonly destination: VaultStaticSecretSpecDestination;

  /**
   * HMACSecretData determines whether the Operator computes the
   * HMAC of the Secret's data. The MAC value will be stored in
   * the resource's Status.SecretMac field, and will be used for drift detection
   * and during incoming Vault secret comparison.
   * Enabling this feature is recommended to ensure that Secret's data stays consistent with Vault.
   *
   * @schema VaultStaticSecretSpec#hmacSecretData
   */
  readonly hmacSecretData?: boolean;

  /**
   * Mount for the secret in Vault
   *
   * @schema VaultStaticSecretSpec#mount
   */
  readonly mount: string;

  /**
   * Namespace of the secrets engine mount in Vault. If not set, the namespace that's
   * part of VaultAuth resource will be inferred.
   *
   * @schema VaultStaticSecretSpec#namespace
   */
  readonly namespace?: string;

  /**
   * Path of the secret in Vault, corresponds to the `path` parameter for:
   * kv-v1: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v1#read-secret
   * kv-v2: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2#read-secret-version
   *
   * @schema VaultStaticSecretSpec#path
   */
  readonly path: string;

  /**
   * RefreshAfter a period of time, in duration notation e.g. 30s, 1m, 24h
   *
   * @schema VaultStaticSecretSpec#refreshAfter
   */
  readonly refreshAfter?: string;

  /**
   * RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does
   * not support dynamically reloading a rotated secret.
   * In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will
   * trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events.
   * All configured targets will be ignored if HMACSecretData is set to false.
   * See RolloutRestartTarget for more details.
   *
   * @schema VaultStaticSecretSpec#rolloutRestartTargets
   */
  readonly rolloutRestartTargets?: VaultStaticSecretSpecRolloutRestartTargets[];

  /**
   * SyncConfig configures sync behavior from Vault to VSO
   *
   * @schema VaultStaticSecretSpec#syncConfig
   */
  readonly syncConfig?: VaultStaticSecretSpecSyncConfig;

  /**
   * Type of the Vault static secret
   *
   * @schema VaultStaticSecretSpec#type
   */
  readonly type: VaultStaticSecretSpecType;

  /**
   * VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace,
   * eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to the
   * namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will
   * default to the `default` VaultAuth, configured in the operator's namespace.
   *
   * @schema VaultStaticSecretSpec#vaultAuthRef
   */
  readonly vaultAuthRef?: string;

  /**
   * Version of the secret to fetch. Only valid for type kv-v2. Corresponds to version query parameter:
   * https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2#version
   *
   * @schema VaultStaticSecretSpec#version
   */
  readonly version?: number;
}

/**
 * Converts an object of type 'VaultStaticSecretSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultStaticSecretSpec(obj: VaultStaticSecretSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_VaultStaticSecretSpecDestination(obj.destination),
    'hmacSecretData': obj.hmacSecretData,
    'mount': obj.mount,
    'namespace': obj.namespace,
    'path': obj.path,
    'refreshAfter': obj.refreshAfter,
    'rolloutRestartTargets': obj.rolloutRestartTargets?.map(y => toJson_VaultStaticSecretSpecRolloutRestartTargets(y)),
    'syncConfig': toJson_VaultStaticSecretSpecSyncConfig(obj.syncConfig),
    'type': obj.type,
    'vaultAuthRef': obj.vaultAuthRef,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Destination provides configuration necessary for syncing the Vault secret to Kubernetes.
 *
 * @schema VaultStaticSecretSpecDestination
 */
export interface VaultStaticSecretSpecDestination {
  /**
   * Annotations to apply to the Secret. Requires Create to be set to true.
   *
   * @schema VaultStaticSecretSpecDestination#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Create the destination Secret.
   * If the Secret already exists this should be set to false.
   *
   * @schema VaultStaticSecretSpecDestination#create
   */
  readonly create?: boolean;

  /**
   * Labels to apply to the Secret. Requires Create to be set to true.
   *
   * @schema VaultStaticSecretSpecDestination#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name of the Secret
   *
   * @schema VaultStaticSecretSpecDestination#name
   */
  readonly name: string;

  /**
   * Overwrite the destination Secret if it exists and Create is true. This is
   * useful when migrating to VSO from a previous secret deployment strategy.
   *
   * @schema VaultStaticSecretSpecDestination#overwrite
   */
  readonly overwrite?: boolean;

  /**
   * Transformation provides configuration for transforming the secret data before
   * it is stored in the Destination.
   *
   * @schema VaultStaticSecretSpecDestination#transformation
   */
  readonly transformation?: VaultStaticSecretSpecDestinationTransformation;

  /**
   * Type of Kubernetes Secret. Requires Create to be set to true.
   * Defaults to Opaque.
   *
   * @default Opaque.
   * @schema VaultStaticSecretSpecDestination#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'VaultStaticSecretSpecDestination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultStaticSecretSpecDestination(obj: VaultStaticSecretSpecDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'create': obj.create,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'overwrite': obj.overwrite,
    'transformation': toJson_VaultStaticSecretSpecDestinationTransformation(obj.transformation),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RolloutRestartTarget provides the configuration required to perform a
 * rollout-restart of the supported resources upon Vault Secret rotation.
 * The rollout-restart is triggered by patching the target resource's
 * 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt'
 * with a timestamp value of when the trigger was executed.
 * E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z"
 *
 * Supported resources: Deployment, DaemonSet, StatefulSet, argo.Rollout
 *
 * @schema VaultStaticSecretSpecRolloutRestartTargets
 */
export interface VaultStaticSecretSpecRolloutRestartTargets {
  /**
   * Kind of the resource
   *
   * @schema VaultStaticSecretSpecRolloutRestartTargets#kind
   */
  readonly kind: VaultStaticSecretSpecRolloutRestartTargetsKind;

  /**
   * Name of the resource
   *
   * @schema VaultStaticSecretSpecRolloutRestartTargets#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'VaultStaticSecretSpecRolloutRestartTargets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultStaticSecretSpecRolloutRestartTargets(obj: VaultStaticSecretSpecRolloutRestartTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SyncConfig configures sync behavior from Vault to VSO
 *
 * @schema VaultStaticSecretSpecSyncConfig
 */
export interface VaultStaticSecretSpecSyncConfig {
  /**
   * InstantUpdates is a flag to indicate that event-driven updates are
   * enabled for this VaultStaticSecret
   *
   * @schema VaultStaticSecretSpecSyncConfig#instantUpdates
   */
  readonly instantUpdates?: boolean;
}

/**
 * Converts an object of type 'VaultStaticSecretSpecSyncConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultStaticSecretSpecSyncConfig(obj: VaultStaticSecretSpecSyncConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instantUpdates': obj.instantUpdates,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type of the Vault static secret
 *
 * @schema VaultStaticSecretSpecType
 */
export enum VaultStaticSecretSpecType {
  /** kv-v1 */
  KV_HYPHEN_V1 = "kv-v1",
  /** kv-v2 */
  KV_HYPHEN_V2 = "kv-v2",
}

/**
 * Transformation provides configuration for transforming the secret data before
 * it is stored in the Destination.
 *
 * @schema VaultStaticSecretSpecDestinationTransformation
 */
export interface VaultStaticSecretSpecDestinationTransformation {
  /**
   * ExcludeRaw data from the destination Secret. Exclusion policy can be set
   * globally by including 'exclude-raw` in the '--global-transformation-options'
   * command line flag. If set, the command line flag always takes precedence over
   * this configuration.
   *
   * @schema VaultStaticSecretSpecDestinationTransformation#excludeRaw
   */
  readonly excludeRaw?: boolean;

  /**
   * Excludes contains regex patterns used to filter top-level source secret data
   * fields for exclusion from the final K8s Secret data. These pattern filters are
   * never applied to templated fields as defined in Templates. They are always
   * applied before any inclusion patterns. To exclude all source secret data
   * fields, you can configure the single pattern ".*".
   *
   * @schema VaultStaticSecretSpecDestinationTransformation#excludes
   */
  readonly excludes?: string[];

  /**
   * Includes contains regex patterns used to filter top-level source secret data
   * fields for inclusion in the final K8s Secret data. These pattern filters are
   * never applied to templated fields as defined in Templates. They are always
   * applied last.
   *
   * @schema VaultStaticSecretSpecDestinationTransformation#includes
   */
  readonly includes?: string[];

  /**
   * Templates maps a template name to its Template. Templates are always included
   * in the rendered K8s Secret, and take precedence over templates defined in a
   * SecretTransformation.
   *
   * @schema VaultStaticSecretSpecDestinationTransformation#templates
   */
  readonly templates?: { [key: string]: VaultStaticSecretSpecDestinationTransformationTemplates };

  /**
   * TransformationRefs contain references to template configuration from
   * SecretTransformation.
   *
   * @schema VaultStaticSecretSpecDestinationTransformation#transformationRefs
   */
  readonly transformationRefs?: VaultStaticSecretSpecDestinationTransformationTransformationRefs[];
}

/**
 * Converts an object of type 'VaultStaticSecretSpecDestinationTransformation' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultStaticSecretSpecDestinationTransformation(obj: VaultStaticSecretSpecDestinationTransformation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'excludeRaw': obj.excludeRaw,
    'excludes': obj.excludes?.map(y => y),
    'includes': obj.includes?.map(y => y),
    'templates': ((obj.templates) === undefined) ? undefined : (Object.entries(obj.templates).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_VaultStaticSecretSpecDestinationTransformationTemplates(i[1]) }), {})),
    'transformationRefs': obj.transformationRefs?.map(y => toJson_VaultStaticSecretSpecDestinationTransformationTransformationRefs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind of the resource
 *
 * @schema VaultStaticSecretSpecRolloutRestartTargetsKind
 */
export enum VaultStaticSecretSpecRolloutRestartTargetsKind {
  /** Deployment */
  DEPLOYMENT = "Deployment",
  /** DaemonSet */
  DAEMON_SET = "DaemonSet",
  /** StatefulSet */
  STATEFUL_SET = "StatefulSet",
  /** argo.Rollout */
  ARGO_PERIOD_ROLLOUT = "argo.Rollout",
}

/**
 * Template provides templating configuration.
 *
 * @schema VaultStaticSecretSpecDestinationTransformationTemplates
 */
export interface VaultStaticSecretSpecDestinationTransformationTemplates {
  /**
   * Name of the Template
   *
   * @schema VaultStaticSecretSpecDestinationTransformationTemplates#name
   */
  readonly name?: string;

  /**
   * Text contains the Go text template format. The template
   * references attributes from the data structure of the source secret.
   * Refer to https://pkg.go.dev/text/template for more information.
   *
   * @schema VaultStaticSecretSpecDestinationTransformationTemplates#text
   */
  readonly text: string;
}

/**
 * Converts an object of type 'VaultStaticSecretSpecDestinationTransformationTemplates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultStaticSecretSpecDestinationTransformationTemplates(obj: VaultStaticSecretSpecDestinationTransformationTemplates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'text': obj.text,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TransformationRef contains the configuration for accessing templates from an
 * SecretTransformation resource. TransformationRefs can be shared across all
 * syncable secret custom resources.
 *
 * @schema VaultStaticSecretSpecDestinationTransformationTransformationRefs
 */
export interface VaultStaticSecretSpecDestinationTransformationTransformationRefs {
  /**
   * IgnoreExcludes controls whether to use the SecretTransformation's Excludes
   * data key filters.
   *
   * @schema VaultStaticSecretSpecDestinationTransformationTransformationRefs#ignoreExcludes
   */
  readonly ignoreExcludes?: boolean;

  /**
   * IgnoreIncludes controls whether to use the SecretTransformation's Includes
   * data key filters.
   *
   * @schema VaultStaticSecretSpecDestinationTransformationTransformationRefs#ignoreIncludes
   */
  readonly ignoreIncludes?: boolean;

  /**
   * Name of the SecretTransformation resource.
   *
   * @schema VaultStaticSecretSpecDestinationTransformationTransformationRefs#name
   */
  readonly name: string;

  /**
   * Namespace of the SecretTransformation resource.
   *
   * @schema VaultStaticSecretSpecDestinationTransformationTransformationRefs#namespace
   */
  readonly namespace?: string;

  /**
   * TemplateRefs map to a Template found in this TransformationRef. If empty, then
   * all templates from the SecretTransformation will be rendered to the K8s Secret.
   *
   * @schema VaultStaticSecretSpecDestinationTransformationTransformationRefs#templateRefs
   */
  readonly templateRefs?: VaultStaticSecretSpecDestinationTransformationTransformationRefsTemplateRefs[];
}

/**
 * Converts an object of type 'VaultStaticSecretSpecDestinationTransformationTransformationRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultStaticSecretSpecDestinationTransformationTransformationRefs(obj: VaultStaticSecretSpecDestinationTransformationTransformationRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreExcludes': obj.ignoreExcludes,
    'ignoreIncludes': obj.ignoreIncludes,
    'name': obj.name,
    'namespace': obj.namespace,
    'templateRefs': obj.templateRefs?.map(y => toJson_VaultStaticSecretSpecDestinationTransformationTransformationRefsTemplateRefs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TemplateRef points to templating text that is stored in a
 * SecretTransformation custom resource.
 *
 * @schema VaultStaticSecretSpecDestinationTransformationTransformationRefsTemplateRefs
 */
export interface VaultStaticSecretSpecDestinationTransformationTransformationRefsTemplateRefs {
  /**
   * KeyOverride to the rendered template in the Destination secret. If Key is
   * empty, then the Key from reference spec will be used. Set this to override the
   * Key set from the reference spec.
   *
   * @schema VaultStaticSecretSpecDestinationTransformationTransformationRefsTemplateRefs#keyOverride
   */
  readonly keyOverride?: string;

  /**
   * Name of the Template in SecretTransformationSpec.Templates.
   * the rendered secret data.
   *
   * @schema VaultStaticSecretSpecDestinationTransformationTransformationRefsTemplateRefs#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'VaultStaticSecretSpecDestinationTransformationTransformationRefsTemplateRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VaultStaticSecretSpecDestinationTransformationTransformationRefsTemplateRefs(obj: VaultStaticSecretSpecDestinationTransformationTransformationRefsTemplateRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyOverride': obj.keyOverride,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

