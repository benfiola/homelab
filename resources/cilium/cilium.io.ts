// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * CiliumBGPAdvertisement is the Schema for the ciliumbgpadvertisements API
 *
 * @schema CiliumBGPAdvertisement
 */
export class CiliumBgpAdvertisement extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CiliumBGPAdvertisement"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cilium.io/v2alpha1',
    kind: 'CiliumBGPAdvertisement',
  }

  /**
   * Renders a Kubernetes manifest for "CiliumBGPAdvertisement".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CiliumBgpAdvertisementProps): any {
    return {
      ...CiliumBgpAdvertisement.GVK,
      ...toJson_CiliumBgpAdvertisementProps(props),
    };
  }

  /**
   * Defines a "CiliumBGPAdvertisement" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CiliumBgpAdvertisementProps) {
    super(scope, id, {
      ...CiliumBgpAdvertisement.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CiliumBgpAdvertisement.GVK,
      ...toJson_CiliumBgpAdvertisementProps(resolved),
    };
  }
}

/**
 * CiliumBGPAdvertisement is the Schema for the ciliumbgpadvertisements API
 *
 * @schema CiliumBGPAdvertisement
 */
export interface CiliumBgpAdvertisementProps {
  /**
   * @schema CiliumBGPAdvertisement#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * @schema CiliumBGPAdvertisement#spec
   */
  readonly spec: CiliumBgpAdvertisementSpec;

}

/**
 * Converts an object of type 'CiliumBgpAdvertisementProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpAdvertisementProps(obj: CiliumBgpAdvertisementProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CiliumBgpAdvertisementSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CiliumBgpAdvertisementSpec
 */
export interface CiliumBgpAdvertisementSpec {
  /**
   * Advertisements is a list of BGP advertisements.
   *
   * @schema CiliumBgpAdvertisementSpec#advertisements
   */
  readonly advertisements: CiliumBgpAdvertisementSpecAdvertisements[];

}

/**
 * Converts an object of type 'CiliumBgpAdvertisementSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpAdvertisementSpec(obj: CiliumBgpAdvertisementSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advertisements': obj.advertisements?.map(y => toJson_CiliumBgpAdvertisementSpecAdvertisements(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Advertisement defines which routes Cilium should advertise to BGP peers. Optionally, additional attributes can be set to the advertised routes.
 *
 * @schema CiliumBgpAdvertisementSpecAdvertisements
 */
export interface CiliumBgpAdvertisementSpecAdvertisements {
  /**
   * AdvertisementType defines type of advertisement which has to be advertised.
   *
   * @schema CiliumBgpAdvertisementSpecAdvertisements#advertisementType
   */
  readonly advertisementType: CiliumBgpAdvertisementSpecAdvertisementsAdvertisementType;

  /**
   * Attributes defines additional attributes to set to the advertised routes. If not specified, no additional attributes are set.
   *
   * @schema CiliumBgpAdvertisementSpecAdvertisements#attributes
   */
  readonly attributes?: CiliumBgpAdvertisementSpecAdvertisementsAttributes;

  /**
   * Selector is a label selector to select objects of the type specified by AdvertisementType. If not specified, all objects of the type specified by AdvertisementType are selected for advertisement.
   *
   * @schema CiliumBgpAdvertisementSpecAdvertisements#selector
   */
  readonly selector?: CiliumBgpAdvertisementSpecAdvertisementsSelector;

}

/**
 * Converts an object of type 'CiliumBgpAdvertisementSpecAdvertisements' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpAdvertisementSpecAdvertisements(obj: CiliumBgpAdvertisementSpecAdvertisements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advertisementType': obj.advertisementType,
    'attributes': toJson_CiliumBgpAdvertisementSpecAdvertisementsAttributes(obj.attributes),
    'selector': toJson_CiliumBgpAdvertisementSpecAdvertisementsSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AdvertisementType defines type of advertisement which has to be advertised.
 *
 * @schema CiliumBgpAdvertisementSpecAdvertisementsAdvertisementType
 */
export enum CiliumBgpAdvertisementSpecAdvertisementsAdvertisementType {
  /** PodCIDR */
  POD_CIDR = "PodCIDR",
  /** CiliumPodIPPool */
  CILIUM_POD_IP_POOL = "CiliumPodIPPool",
  /** CiliumLoadBalancerIP */
  CILIUM_LOAD_BALANCER_IP = "CiliumLoadBalancerIP",
}

/**
 * Attributes defines additional attributes to set to the advertised routes. If not specified, no additional attributes are set.
 *
 * @schema CiliumBgpAdvertisementSpecAdvertisementsAttributes
 */
export interface CiliumBgpAdvertisementSpecAdvertisementsAttributes {
  /**
   * Community sets the community attribute in the route. If not specified, no community attribute is set.
   *
   * @schema CiliumBgpAdvertisementSpecAdvertisementsAttributes#community
   */
  readonly community?: CiliumBgpAdvertisementSpecAdvertisementsAttributesCommunity;

  /**
   * LocalPreference sets the local preference attribute in the route. If not specified, no local preference attribute is set.
   *
   * @schema CiliumBgpAdvertisementSpecAdvertisementsAttributes#localPreference
   */
  readonly localPreference?: number;

}

/**
 * Converts an object of type 'CiliumBgpAdvertisementSpecAdvertisementsAttributes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpAdvertisementSpecAdvertisementsAttributes(obj: CiliumBgpAdvertisementSpecAdvertisementsAttributes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'community': toJson_CiliumBgpAdvertisementSpecAdvertisementsAttributesCommunity(obj.community),
    'localPreference': obj.localPreference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector is a label selector to select objects of the type specified by AdvertisementType. If not specified, all objects of the type specified by AdvertisementType are selected for advertisement.
 *
 * @schema CiliumBgpAdvertisementSpecAdvertisementsSelector
 */
export interface CiliumBgpAdvertisementSpecAdvertisementsSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumBgpAdvertisementSpecAdvertisementsSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumBgpAdvertisementSpecAdvertisementsSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumBgpAdvertisementSpecAdvertisementsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumBgpAdvertisementSpecAdvertisementsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpAdvertisementSpecAdvertisementsSelector(obj: CiliumBgpAdvertisementSpecAdvertisementsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumBgpAdvertisementSpecAdvertisementsSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Community sets the community attribute in the route. If not specified, no community attribute is set.
 *
 * @schema CiliumBgpAdvertisementSpecAdvertisementsAttributesCommunity
 */
export interface CiliumBgpAdvertisementSpecAdvertisementsAttributesCommunity {
  /**
   * Large holds a list of the BGP Large Communities Attribute (RFC 8092) values.
   *
   * @schema CiliumBgpAdvertisementSpecAdvertisementsAttributesCommunity#large
   */
  readonly large?: string[];

  /**
   * Standard holds a list of "standard" 32-bit BGP Communities Attribute (RFC 1997) values.
   *
   * @schema CiliumBgpAdvertisementSpecAdvertisementsAttributesCommunity#standard
   */
  readonly standard?: string[];

}

/**
 * Converts an object of type 'CiliumBgpAdvertisementSpecAdvertisementsAttributesCommunity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpAdvertisementSpecAdvertisementsAttributesCommunity(obj: CiliumBgpAdvertisementSpecAdvertisementsAttributesCommunity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'large': obj.large?.map(y => y),
    'standard': obj.standard?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumBgpAdvertisementSpecAdvertisementsSelectorMatchExpressions
 */
export interface CiliumBgpAdvertisementSpecAdvertisementsSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumBgpAdvertisementSpecAdvertisementsSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumBgpAdvertisementSpecAdvertisementsSelectorMatchExpressions#operator
   */
  readonly operator: CiliumBgpAdvertisementSpecAdvertisementsSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumBgpAdvertisementSpecAdvertisementsSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumBgpAdvertisementSpecAdvertisementsSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpAdvertisementSpecAdvertisementsSelectorMatchExpressions(obj: CiliumBgpAdvertisementSpecAdvertisementsSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumBgpAdvertisementSpecAdvertisementsSelectorMatchExpressionsOperator
 */
export enum CiliumBgpAdvertisementSpecAdvertisementsSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}


/**
 * CiliumBGPClusterConfig is the Schema for the CiliumBGPClusterConfig API
 *
 * @schema CiliumBGPClusterConfig
 */
export class CiliumBgpClusterConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CiliumBGPClusterConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cilium.io/v2alpha1',
    kind: 'CiliumBGPClusterConfig',
  }

  /**
   * Renders a Kubernetes manifest for "CiliumBGPClusterConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CiliumBgpClusterConfigProps): any {
    return {
      ...CiliumBgpClusterConfig.GVK,
      ...toJson_CiliumBgpClusterConfigProps(props),
    };
  }

  /**
   * Defines a "CiliumBGPClusterConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CiliumBgpClusterConfigProps) {
    super(scope, id, {
      ...CiliumBgpClusterConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CiliumBgpClusterConfig.GVK,
      ...toJson_CiliumBgpClusterConfigProps(resolved),
    };
  }
}

/**
 * CiliumBGPClusterConfig is the Schema for the CiliumBGPClusterConfig API
 *
 * @schema CiliumBGPClusterConfig
 */
export interface CiliumBgpClusterConfigProps {
  /**
   * @schema CiliumBGPClusterConfig#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * Spec defines the desired cluster configuration of the BGP control plane.
   *
   * @schema CiliumBGPClusterConfig#spec
   */
  readonly spec: CiliumBgpClusterConfigSpec;

}

/**
 * Converts an object of type 'CiliumBgpClusterConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpClusterConfigProps(obj: CiliumBgpClusterConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CiliumBgpClusterConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Spec defines the desired cluster configuration of the BGP control plane.
 *
 * @schema CiliumBgpClusterConfigSpec
 */
export interface CiliumBgpClusterConfigSpec {
  /**
   * A list of CiliumBGPInstance(s) which instructs the BGP control plane how to instantiate virtual BGP routers.
   *
   * @schema CiliumBgpClusterConfigSpec#bgpInstances
   */
  readonly bgpInstances: CiliumBgpClusterConfigSpecBgpInstances[];

  /**
   * NodeSelector selects a group of nodes where this BGP Cluster config applies. If empty / nil this config applies to all nodes.
   *
   * @schema CiliumBgpClusterConfigSpec#nodeSelector
   */
  readonly nodeSelector?: CiliumBgpClusterConfigSpecNodeSelector;

}

/**
 * Converts an object of type 'CiliumBgpClusterConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpClusterConfigSpec(obj: CiliumBgpClusterConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bgpInstances': obj.bgpInstances?.map(y => toJson_CiliumBgpClusterConfigSpecBgpInstances(y)),
    'nodeSelector': toJson_CiliumBgpClusterConfigSpecNodeSelector(obj.nodeSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CiliumBgpClusterConfigSpecBgpInstances
 */
export interface CiliumBgpClusterConfigSpecBgpInstances {
  /**
   * LocalASN is the ASN of this BGP instance. Supports extended 32bit ASNs.
   *
   * @schema CiliumBgpClusterConfigSpecBgpInstances#localASN
   */
  readonly localAsn?: number;

  /**
   * Name is the name of the BGP instance. It is a unique identifier for the BGP instance within the cluster configuration.
   *
   * @schema CiliumBgpClusterConfigSpecBgpInstances#name
   */
  readonly name: string;

  /**
   * Peers is a list of neighboring BGP peers for this virtual router
   *
   * @schema CiliumBgpClusterConfigSpecBgpInstances#peers
   */
  readonly peers?: CiliumBgpClusterConfigSpecBgpInstancesPeers[];

}

/**
 * Converts an object of type 'CiliumBgpClusterConfigSpecBgpInstances' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpClusterConfigSpecBgpInstances(obj: CiliumBgpClusterConfigSpecBgpInstances | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localASN': obj.localAsn,
    'name': obj.name,
    'peers': obj.peers?.map(y => toJson_CiliumBgpClusterConfigSpecBgpInstancesPeers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodeSelector selects a group of nodes where this BGP Cluster config applies. If empty / nil this config applies to all nodes.
 *
 * @schema CiliumBgpClusterConfigSpecNodeSelector
 */
export interface CiliumBgpClusterConfigSpecNodeSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumBgpClusterConfigSpecNodeSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumBgpClusterConfigSpecNodeSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumBgpClusterConfigSpecNodeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumBgpClusterConfigSpecNodeSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpClusterConfigSpecNodeSelector(obj: CiliumBgpClusterConfigSpecNodeSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumBgpClusterConfigSpecNodeSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CiliumBgpClusterConfigSpecBgpInstancesPeers
 */
export interface CiliumBgpClusterConfigSpecBgpInstancesPeers {
  /**
   * Name is the name of the BGP peer. It is a unique identifier for the peer within the BGP instance.
   *
   * @schema CiliumBgpClusterConfigSpecBgpInstancesPeers#name
   */
  readonly name: string;

  /**
   * PeerASN is the ASN of the peer BGP router. Supports extended 32bit ASNs.
   *
   * @schema CiliumBgpClusterConfigSpecBgpInstancesPeers#peerASN
   */
  readonly peerAsn?: number;

  /**
   * PeerAddress is the IP address of the neighbor. Supports IPv4 and IPv6 addresses.
   *
   * @schema CiliumBgpClusterConfigSpecBgpInstancesPeers#peerAddress
   */
  readonly peerAddress?: string;

  /**
   * PeerConfigRef is a reference to a peer configuration resource. If not specified, the default BGP configuration is used for this peer.
   *
   * @schema CiliumBgpClusterConfigSpecBgpInstancesPeers#peerConfigRef
   */
  readonly peerConfigRef?: CiliumBgpClusterConfigSpecBgpInstancesPeersPeerConfigRef;

}

/**
 * Converts an object of type 'CiliumBgpClusterConfigSpecBgpInstancesPeers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpClusterConfigSpecBgpInstancesPeers(obj: CiliumBgpClusterConfigSpecBgpInstancesPeers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'peerASN': obj.peerAsn,
    'peerAddress': obj.peerAddress,
    'peerConfigRef': toJson_CiliumBgpClusterConfigSpecBgpInstancesPeersPeerConfigRef(obj.peerConfigRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumBgpClusterConfigSpecNodeSelectorMatchExpressions
 */
export interface CiliumBgpClusterConfigSpecNodeSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumBgpClusterConfigSpecNodeSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumBgpClusterConfigSpecNodeSelectorMatchExpressions#operator
   */
  readonly operator: CiliumBgpClusterConfigSpecNodeSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumBgpClusterConfigSpecNodeSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumBgpClusterConfigSpecNodeSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpClusterConfigSpecNodeSelectorMatchExpressions(obj: CiliumBgpClusterConfigSpecNodeSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PeerConfigRef is a reference to a peer configuration resource. If not specified, the default BGP configuration is used for this peer.
 *
 * @schema CiliumBgpClusterConfigSpecBgpInstancesPeersPeerConfigRef
 */
export interface CiliumBgpClusterConfigSpecBgpInstancesPeersPeerConfigRef {
  /**
   * Group is the group of the peer config resource. If not specified, the default of "cilium.io" is used.
   *
   * @schema CiliumBgpClusterConfigSpecBgpInstancesPeersPeerConfigRef#group
   */
  readonly group?: string;

  /**
   * Kind is the kind of the peer config resource. If not specified, the default of "CiliumBGPPeerConfig" is used.
   *
   * @schema CiliumBgpClusterConfigSpecBgpInstancesPeersPeerConfigRef#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the peer config resource. Name refers to the name of a Kubernetes object (typically a CiliumBGPPeerConfig).
   *
   * @schema CiliumBgpClusterConfigSpecBgpInstancesPeersPeerConfigRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CiliumBgpClusterConfigSpecBgpInstancesPeersPeerConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpClusterConfigSpecBgpInstancesPeersPeerConfigRef(obj: CiliumBgpClusterConfigSpecBgpInstancesPeersPeerConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumBgpClusterConfigSpecNodeSelectorMatchExpressionsOperator
 */
export enum CiliumBgpClusterConfigSpecNodeSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}


/**
 * CiliumBGPNodeConfig is node local configuration for BGP agent. Name of the object should be node name. This resource will be created by Cilium operator and is read-only for the users.
 *
 * @schema CiliumBGPNodeConfig
 */
export class CiliumBgpNodeConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CiliumBGPNodeConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cilium.io/v2alpha1',
    kind: 'CiliumBGPNodeConfig',
  }

  /**
   * Renders a Kubernetes manifest for "CiliumBGPNodeConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CiliumBgpNodeConfigProps): any {
    return {
      ...CiliumBgpNodeConfig.GVK,
      ...toJson_CiliumBgpNodeConfigProps(props),
    };
  }

  /**
   * Defines a "CiliumBGPNodeConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CiliumBgpNodeConfigProps) {
    super(scope, id, {
      ...CiliumBgpNodeConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CiliumBgpNodeConfig.GVK,
      ...toJson_CiliumBgpNodeConfigProps(resolved),
    };
  }
}

/**
 * CiliumBGPNodeConfig is node local configuration for BGP agent. Name of the object should be node name. This resource will be created by Cilium operator and is read-only for the users.
 *
 * @schema CiliumBGPNodeConfig
 */
export interface CiliumBgpNodeConfigProps {
  /**
   * @schema CiliumBGPNodeConfig#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * Spec is the specification of the desired behavior of the CiliumBGPNodeConfig.
   *
   * @schema CiliumBGPNodeConfig#spec
   */
  readonly spec: CiliumBgpNodeConfigSpec;

}

/**
 * Converts an object of type 'CiliumBgpNodeConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpNodeConfigProps(obj: CiliumBgpNodeConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CiliumBgpNodeConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Spec is the specification of the desired behavior of the CiliumBGPNodeConfig.
 *
 * @schema CiliumBgpNodeConfigSpec
 */
export interface CiliumBgpNodeConfigSpec {
  /**
   * BGPInstances is a list of BGP router instances on the node.
   *
   * @schema CiliumBgpNodeConfigSpec#bgpInstances
   */
  readonly bgpInstances: CiliumBgpNodeConfigSpecBgpInstances[];

}

/**
 * Converts an object of type 'CiliumBgpNodeConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpNodeConfigSpec(obj: CiliumBgpNodeConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bgpInstances': obj.bgpInstances?.map(y => toJson_CiliumBgpNodeConfigSpecBgpInstances(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CiliumBGPNodeInstance is a single BGP router instance configuration on the node.
 *
 * @schema CiliumBgpNodeConfigSpecBgpInstances
 */
export interface CiliumBgpNodeConfigSpecBgpInstances {
  /**
   * LocalASN is the ASN of this virtual router. Supports extended 32bit ASNs.
   *
   * @schema CiliumBgpNodeConfigSpecBgpInstances#localASN
   */
  readonly localAsn?: number;

  /**
   * LocalPort is the port on which the BGP daemon listens for incoming connections.
   * If not specified, BGP instance will not listen for incoming connections.
   *
   * @schema CiliumBgpNodeConfigSpecBgpInstances#localPort
   */
  readonly localPort?: number;

  /**
   * Name is the name of the BGP instance. This name is used to identify the BGP instance on the node.
   *
   * @schema CiliumBgpNodeConfigSpecBgpInstances#name
   */
  readonly name: string;

  /**
   * Peers is a list of neighboring BGP peers for this virtual router
   *
   * @schema CiliumBgpNodeConfigSpecBgpInstances#peers
   */
  readonly peers?: CiliumBgpNodeConfigSpecBgpInstancesPeers[];

  /**
   * RouterID is the BGP router ID of this virtual router. This configuration is derived from CiliumBGPNodeConfigOverride resource.
   * If not specified, the router ID will be derived from the node local address.
   *
   * @schema CiliumBgpNodeConfigSpecBgpInstances#routerID
   */
  readonly routerId?: string;

}

/**
 * Converts an object of type 'CiliumBgpNodeConfigSpecBgpInstances' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpNodeConfigSpecBgpInstances(obj: CiliumBgpNodeConfigSpecBgpInstances | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localASN': obj.localAsn,
    'localPort': obj.localPort,
    'name': obj.name,
    'peers': obj.peers?.map(y => toJson_CiliumBgpNodeConfigSpecBgpInstancesPeers(y)),
    'routerID': obj.routerId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CiliumBgpNodeConfigSpecBgpInstancesPeers
 */
export interface CiliumBgpNodeConfigSpecBgpInstancesPeers {
  /**
   * LocalAddress is the IP address of the local interface to use for the peering session. This configuration is derived from CiliumBGPNodeConfigOverride resource. If not specified, the local address will be used for setting up peering.
   *
   * @schema CiliumBgpNodeConfigSpecBgpInstancesPeers#localAddress
   */
  readonly localAddress?: string;

  /**
   * Name is the name of the BGP peer. This name is used to identify the BGP peer for the BGP instance.
   *
   * @schema CiliumBgpNodeConfigSpecBgpInstancesPeers#name
   */
  readonly name: string;

  /**
   * PeerASN is the ASN of the peer BGP router. Supports extended 32bit ASNs
   *
   * @schema CiliumBgpNodeConfigSpecBgpInstancesPeers#peerASN
   */
  readonly peerAsn?: number;

  /**
   * PeerAddress is the IP address of the neighbor. Supports IPv4 and IPv6 addresses.
   *
   * @schema CiliumBgpNodeConfigSpecBgpInstancesPeers#peerAddress
   */
  readonly peerAddress?: string;

  /**
   * PeerConfigRef is a reference to a peer configuration resource. If not specified, the default BGP configuration is used for this peer.
   *
   * @schema CiliumBgpNodeConfigSpecBgpInstancesPeers#peerConfigRef
   */
  readonly peerConfigRef?: CiliumBgpNodeConfigSpecBgpInstancesPeersPeerConfigRef;

}

/**
 * Converts an object of type 'CiliumBgpNodeConfigSpecBgpInstancesPeers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpNodeConfigSpecBgpInstancesPeers(obj: CiliumBgpNodeConfigSpecBgpInstancesPeers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localAddress': obj.localAddress,
    'name': obj.name,
    'peerASN': obj.peerAsn,
    'peerAddress': obj.peerAddress,
    'peerConfigRef': toJson_CiliumBgpNodeConfigSpecBgpInstancesPeersPeerConfigRef(obj.peerConfigRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PeerConfigRef is a reference to a peer configuration resource. If not specified, the default BGP configuration is used for this peer.
 *
 * @schema CiliumBgpNodeConfigSpecBgpInstancesPeersPeerConfigRef
 */
export interface CiliumBgpNodeConfigSpecBgpInstancesPeersPeerConfigRef {
  /**
   * Group is the group of the peer config resource. If not specified, the default of "cilium.io" is used.
   *
   * @schema CiliumBgpNodeConfigSpecBgpInstancesPeersPeerConfigRef#group
   */
  readonly group?: string;

  /**
   * Kind is the kind of the peer config resource. If not specified, the default of "CiliumBGPPeerConfig" is used.
   *
   * @schema CiliumBgpNodeConfigSpecBgpInstancesPeersPeerConfigRef#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the peer config resource. Name refers to the name of a Kubernetes object (typically a CiliumBGPPeerConfig).
   *
   * @schema CiliumBgpNodeConfigSpecBgpInstancesPeersPeerConfigRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CiliumBgpNodeConfigSpecBgpInstancesPeersPeerConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpNodeConfigSpecBgpInstancesPeersPeerConfigRef(obj: CiliumBgpNodeConfigSpecBgpInstancesPeersPeerConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * CiliumBGPNodeConfigOverride is used to overrides some of the BGP configurations which are node local. Users can user this resource to override auto-generated BGP settings for the node.
 *
 * @schema CiliumBGPNodeConfigOverride
 */
export class CiliumBgpNodeConfigOverride extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CiliumBGPNodeConfigOverride"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cilium.io/v2alpha1',
    kind: 'CiliumBGPNodeConfigOverride',
  }

  /**
   * Renders a Kubernetes manifest for "CiliumBGPNodeConfigOverride".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CiliumBgpNodeConfigOverrideProps): any {
    return {
      ...CiliumBgpNodeConfigOverride.GVK,
      ...toJson_CiliumBgpNodeConfigOverrideProps(props),
    };
  }

  /**
   * Defines a "CiliumBGPNodeConfigOverride" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CiliumBgpNodeConfigOverrideProps) {
    super(scope, id, {
      ...CiliumBgpNodeConfigOverride.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CiliumBgpNodeConfigOverride.GVK,
      ...toJson_CiliumBgpNodeConfigOverrideProps(resolved),
    };
  }
}

/**
 * CiliumBGPNodeConfigOverride is used to overrides some of the BGP configurations which are node local. Users can user this resource to override auto-generated BGP settings for the node.
 *
 * @schema CiliumBGPNodeConfigOverride
 */
export interface CiliumBgpNodeConfigOverrideProps {
  /**
   * @schema CiliumBGPNodeConfigOverride#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * Spec is the specification of the desired behavior of the CiliumBGPNodeConfigOverride.
   *
   * @schema CiliumBGPNodeConfigOverride#spec
   */
  readonly spec: CiliumBgpNodeConfigOverrideSpec;

}

/**
 * Converts an object of type 'CiliumBgpNodeConfigOverrideProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpNodeConfigOverrideProps(obj: CiliumBgpNodeConfigOverrideProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CiliumBgpNodeConfigOverrideSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Spec is the specification of the desired behavior of the CiliumBGPNodeConfigOverride.
 *
 * @schema CiliumBgpNodeConfigOverrideSpec
 */
export interface CiliumBgpNodeConfigOverrideSpec {
  /**
   * BGPInstances is a list of BGP instances to override.
   *
   * @schema CiliumBgpNodeConfigOverrideSpec#bgpInstances
   */
  readonly bgpInstances: CiliumBgpNodeConfigOverrideSpecBgpInstances[];

  /**
   * NodeRef is the name of the node for which the BGP configuration is overridden.
   *
   * @schema CiliumBgpNodeConfigOverrideSpec#nodeRef
   */
  readonly nodeRef: string;

}

/**
 * Converts an object of type 'CiliumBgpNodeConfigOverrideSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpNodeConfigOverrideSpec(obj: CiliumBgpNodeConfigOverrideSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bgpInstances': obj.bgpInstances?.map(y => toJson_CiliumBgpNodeConfigOverrideSpecBgpInstances(y)),
    'nodeRef': obj.nodeRef,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CiliumBGPNodeConfigInstanceOverride defines configuration options which can be overridden for a specific BGP instance.
 *
 * @schema CiliumBgpNodeConfigOverrideSpecBgpInstances
 */
export interface CiliumBgpNodeConfigOverrideSpecBgpInstances {
  /**
   * LocalPort is port to use for this BGP instance.
   *
   * @schema CiliumBgpNodeConfigOverrideSpecBgpInstances#localPort
   */
  readonly localPort?: number;

  /**
   * Name is the name of the BGP instance for which the configuration is overridden.
   *
   * @schema CiliumBgpNodeConfigOverrideSpecBgpInstances#name
   */
  readonly name: string;

  /**
   * Peers is a list of peer configurations to override.
   *
   * @schema CiliumBgpNodeConfigOverrideSpecBgpInstances#peers
   */
  readonly peers?: CiliumBgpNodeConfigOverrideSpecBgpInstancesPeers[];

  /**
   * RouterID is BGP router id to use for this instance. It must be unique across all BGP instances.
   *
   * @schema CiliumBgpNodeConfigOverrideSpecBgpInstances#routerID
   */
  readonly routerId?: string;

}

/**
 * Converts an object of type 'CiliumBgpNodeConfigOverrideSpecBgpInstances' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpNodeConfigOverrideSpecBgpInstances(obj: CiliumBgpNodeConfigOverrideSpecBgpInstances | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localPort': obj.localPort,
    'name': obj.name,
    'peers': obj.peers?.map(y => toJson_CiliumBgpNodeConfigOverrideSpecBgpInstancesPeers(y)),
    'routerID': obj.routerId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CiliumBGPNodeConfigPeerOverride defines configuration options which can be overridden for a specific peer.
 *
 * @schema CiliumBgpNodeConfigOverrideSpecBgpInstancesPeers
 */
export interface CiliumBgpNodeConfigOverrideSpecBgpInstancesPeers {
  /**
   * LocalAddress is the IP address to use for connecting to this peer.
   *
   * @schema CiliumBgpNodeConfigOverrideSpecBgpInstancesPeers#localAddress
   */
  readonly localAddress?: string;

  /**
   * LocalPort is source port to use for connecting to this peer.
   *
   * @schema CiliumBgpNodeConfigOverrideSpecBgpInstancesPeers#localPort
   */
  readonly localPort?: number;

  /**
   * Name is the name of the peer for which the configuration is overridden.
   *
   * @schema CiliumBgpNodeConfigOverrideSpecBgpInstancesPeers#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CiliumBgpNodeConfigOverrideSpecBgpInstancesPeers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpNodeConfigOverrideSpecBgpInstancesPeers(obj: CiliumBgpNodeConfigOverrideSpecBgpInstancesPeers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localAddress': obj.localAddress,
    'localPort': obj.localPort,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema CiliumBGPPeerConfig
 */
export class CiliumBgpPeerConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CiliumBGPPeerConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cilium.io/v2alpha1',
    kind: 'CiliumBGPPeerConfig',
  }

  /**
   * Renders a Kubernetes manifest for "CiliumBGPPeerConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CiliumBgpPeerConfigProps): any {
    return {
      ...CiliumBgpPeerConfig.GVK,
      ...toJson_CiliumBgpPeerConfigProps(props),
    };
  }

  /**
   * Defines a "CiliumBGPPeerConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CiliumBgpPeerConfigProps) {
    super(scope, id, {
      ...CiliumBgpPeerConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CiliumBgpPeerConfig.GVK,
      ...toJson_CiliumBgpPeerConfigProps(resolved),
    };
  }
}

/**
 * @schema CiliumBGPPeerConfig
 */
export interface CiliumBgpPeerConfigProps {
  /**
   * @schema CiliumBGPPeerConfig#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * Spec is the specification of the desired behavior of the CiliumBGPPeerConfig.
   *
   * @schema CiliumBGPPeerConfig#spec
   */
  readonly spec: CiliumBgpPeerConfigSpec;

}

/**
 * Converts an object of type 'CiliumBgpPeerConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpPeerConfigProps(obj: CiliumBgpPeerConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CiliumBgpPeerConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Spec is the specification of the desired behavior of the CiliumBGPPeerConfig.
 *
 * @schema CiliumBgpPeerConfigSpec
 */
export interface CiliumBgpPeerConfigSpec {
  /**
   * AuthSecretRef is the name of the secret to use to fetch a TCP authentication password for this peer.
   * If not specified, no authentication is used.
   *
   * @schema CiliumBgpPeerConfigSpec#authSecretRef
   */
  readonly authSecretRef?: string;

  /**
   * EBGPMultihopTTL controls the multi-hop feature for eBGP peers. Its value defines the Time To Live (TTL) value used in BGP packets sent to the peer.
   * If not specified, EBGP multihop is disabled. This field is ignored for iBGP neighbors.
   *
   * @schema CiliumBgpPeerConfigSpec#ebgpMultihop
   */
  readonly ebgpMultihop?: number;

  /**
   * Families, if provided, defines a set of AFI/SAFIs the speaker will negotiate with it's peer.
   * If not specified, the default families of IPv6/unicast and IPv4/unicast will be created.
   *
   * @schema CiliumBgpPeerConfigSpec#families
   */
  readonly families?: CiliumBgpPeerConfigSpecFamilies[];

  /**
   * GracefulRestart defines graceful restart parameters which are negotiated with this peer.
   * If not specified, the graceful restart capability is disabled.
   *
   * @schema CiliumBgpPeerConfigSpec#gracefulRestart
   */
  readonly gracefulRestart?: CiliumBgpPeerConfigSpecGracefulRestart;

  /**
   * Timers defines the BGP timers for the peer.
   * If not specified, the default timers are used.
   *
   * @schema CiliumBgpPeerConfigSpec#timers
   */
  readonly timers?: CiliumBgpPeerConfigSpecTimers;

  /**
   * Transport defines the BGP transport parameters for the peer.
   * If not specified, the default transport parameters are used.
   *
   * @schema CiliumBgpPeerConfigSpec#transport
   */
  readonly transport?: CiliumBgpPeerConfigSpecTransport;

}

/**
 * Converts an object of type 'CiliumBgpPeerConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpPeerConfigSpec(obj: CiliumBgpPeerConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authSecretRef': obj.authSecretRef,
    'ebgpMultihop': obj.ebgpMultihop,
    'families': obj.families?.map(y => toJson_CiliumBgpPeerConfigSpecFamilies(y)),
    'gracefulRestart': toJson_CiliumBgpPeerConfigSpecGracefulRestart(obj.gracefulRestart),
    'timers': toJson_CiliumBgpPeerConfigSpecTimers(obj.timers),
    'transport': toJson_CiliumBgpPeerConfigSpecTransport(obj.transport),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CiliumBGPFamilyWithAdverts represents a AFI/SAFI address family pair along with reference to BGP Advertisements.
 *
 * @schema CiliumBgpPeerConfigSpecFamilies
 */
export interface CiliumBgpPeerConfigSpecFamilies {
  /**
   * Advertisements selects group of BGP Advertisement(s) to advertise for this family.
   * If not specified, no advertisements are sent for this family.
   * This field is ignored in CiliumBGPNeighbor which is used in CiliumBGPPeeringPolicy. Use CiliumBGPPeeringPolicy advertisement options instead.
   *
   * @schema CiliumBgpPeerConfigSpecFamilies#advertisements
   */
  readonly advertisements?: CiliumBgpPeerConfigSpecFamiliesAdvertisements;

  /**
   * Afi is the Address Family Identifier (AFI) of the family.
   *
   * @schema CiliumBgpPeerConfigSpecFamilies#afi
   */
  readonly afi: CiliumBgpPeerConfigSpecFamiliesAfi;

  /**
   * Safi is the Subsequent Address Family Identifier (SAFI) of the family.
   *
   * @schema CiliumBgpPeerConfigSpecFamilies#safi
   */
  readonly safi: CiliumBgpPeerConfigSpecFamiliesSafi;

}

/**
 * Converts an object of type 'CiliumBgpPeerConfigSpecFamilies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpPeerConfigSpecFamilies(obj: CiliumBgpPeerConfigSpecFamilies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advertisements': toJson_CiliumBgpPeerConfigSpecFamiliesAdvertisements(obj.advertisements),
    'afi': obj.afi,
    'safi': obj.safi,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GracefulRestart defines graceful restart parameters which are negotiated with this peer.
 * If not specified, the graceful restart capability is disabled.
 *
 * @schema CiliumBgpPeerConfigSpecGracefulRestart
 */
export interface CiliumBgpPeerConfigSpecGracefulRestart {
  /**
   * Enabled flag, when set enables graceful restart capability.
   *
   * @schema CiliumBgpPeerConfigSpecGracefulRestart#enabled
   */
  readonly enabled: boolean;

  /**
   * RestartTimeSeconds is the estimated time it will take for the BGP session to be re-established with peer after a restart. After this period, peer will remove stale routes. This is described RFC 4724 section 4.2.
   *
   * @schema CiliumBgpPeerConfigSpecGracefulRestart#restartTimeSeconds
   */
  readonly restartTimeSeconds?: number;

}

/**
 * Converts an object of type 'CiliumBgpPeerConfigSpecGracefulRestart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpPeerConfigSpecGracefulRestart(obj: CiliumBgpPeerConfigSpecGracefulRestart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'restartTimeSeconds': obj.restartTimeSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Timers defines the BGP timers for the peer.
 * If not specified, the default timers are used.
 *
 * @schema CiliumBgpPeerConfigSpecTimers
 */
export interface CiliumBgpPeerConfigSpecTimers {
  /**
   * ConnectRetryTimeSeconds defines the initial value for the BGP ConnectRetryTimer (RFC 4271, Section 8).
   * If not specified, defaults to 120 seconds.
   *
   * @schema CiliumBgpPeerConfigSpecTimers#connectRetryTimeSeconds
   */
  readonly connectRetryTimeSeconds?: number;

  /**
   * HoldTimeSeconds defines the initial value for the BGP HoldTimer (RFC 4271, Section 4.2). Updating this value will cause a session reset.
   * If not specified, defaults to 90 seconds.
   *
   * @schema CiliumBgpPeerConfigSpecTimers#holdTimeSeconds
   */
  readonly holdTimeSeconds?: number;

  /**
   * KeepaliveTimeSeconds defines the initial value for the BGP KeepaliveTimer (RFC 4271, Section 8). It can not be larger than HoldTimeSeconds. Updating this value will cause a session reset.
   * If not specified, defaults to 30 seconds.
   *
   * @schema CiliumBgpPeerConfigSpecTimers#keepAliveTimeSeconds
   */
  readonly keepAliveTimeSeconds?: number;

}

/**
 * Converts an object of type 'CiliumBgpPeerConfigSpecTimers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpPeerConfigSpecTimers(obj: CiliumBgpPeerConfigSpecTimers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectRetryTimeSeconds': obj.connectRetryTimeSeconds,
    'holdTimeSeconds': obj.holdTimeSeconds,
    'keepAliveTimeSeconds': obj.keepAliveTimeSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Transport defines the BGP transport parameters for the peer.
 * If not specified, the default transport parameters are used.
 *
 * @schema CiliumBgpPeerConfigSpecTransport
 */
export interface CiliumBgpPeerConfigSpecTransport {
  /**
   * LocalPort is the local port to be used for the BGP session.
   * If not specified, defaults to TCP port 179.
   *
   * @schema CiliumBgpPeerConfigSpecTransport#localPort
   */
  readonly localPort?: number;

  /**
   * PeerPort is the peer port to be used for the BGP session.
   * If not specified, defaults to TCP port 179.
   *
   * @schema CiliumBgpPeerConfigSpecTransport#peerPort
   */
  readonly peerPort?: number;

}

/**
 * Converts an object of type 'CiliumBgpPeerConfigSpecTransport' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpPeerConfigSpecTransport(obj: CiliumBgpPeerConfigSpecTransport | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localPort': obj.localPort,
    'peerPort': obj.peerPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Advertisements selects group of BGP Advertisement(s) to advertise for this family.
 * If not specified, no advertisements are sent for this family.
 * This field is ignored in CiliumBGPNeighbor which is used in CiliumBGPPeeringPolicy. Use CiliumBGPPeeringPolicy advertisement options instead.
 *
 * @schema CiliumBgpPeerConfigSpecFamiliesAdvertisements
 */
export interface CiliumBgpPeerConfigSpecFamiliesAdvertisements {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumBgpPeerConfigSpecFamiliesAdvertisements#matchExpressions
   */
  readonly matchExpressions?: CiliumBgpPeerConfigSpecFamiliesAdvertisementsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumBgpPeerConfigSpecFamiliesAdvertisements#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumBgpPeerConfigSpecFamiliesAdvertisements' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpPeerConfigSpecFamiliesAdvertisements(obj: CiliumBgpPeerConfigSpecFamiliesAdvertisements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumBgpPeerConfigSpecFamiliesAdvertisementsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Afi is the Address Family Identifier (AFI) of the family.
 *
 * @schema CiliumBgpPeerConfigSpecFamiliesAfi
 */
export enum CiliumBgpPeerConfigSpecFamiliesAfi {
  /** ipv4 */
  IPV4 = "ipv4",
  /** ipv6 */
  IPV6 = "ipv6",
  /** l2vpn */
  L2VPN = "l2vpn",
  /** ls */
  LS = "ls",
  /** opaque */
  OPAQUE = "opaque",
}

/**
 * Safi is the Subsequent Address Family Identifier (SAFI) of the family.
 *
 * @schema CiliumBgpPeerConfigSpecFamiliesSafi
 */
export enum CiliumBgpPeerConfigSpecFamiliesSafi {
  /** unicast */
  UNICAST = "unicast",
  /** multicast */
  MULTICAST = "multicast",
  /** mpls_label */
  MPLS_UNDERSCORE_LABEL = "mpls_label",
  /** encapsulation */
  ENCAPSULATION = "encapsulation",
  /** vpls */
  VPLS = "vpls",
  /** evpn */
  EVPN = "evpn",
  /** ls */
  LS = "ls",
  /** sr_policy */
  SR_UNDERSCORE_POLICY = "sr_policy",
  /** mup */
  MUP = "mup",
  /** mpls_vpn */
  MPLS_UNDERSCORE_VPN = "mpls_vpn",
  /** mpls_vpn_multicast */
  MPLS_UNDERSCORE_VPN_UNDERSCORE_MULTICAST = "mpls_vpn_multicast",
  /** route_target_constraints */
  ROUTE_UNDERSCORE_TARGET_UNDERSCORE_CONSTRAINTS = "route_target_constraints",
  /** flowspec_unicast */
  FLOWSPEC_UNDERSCORE_UNICAST = "flowspec_unicast",
  /** flowspec_vpn */
  FLOWSPEC_UNDERSCORE_VPN = "flowspec_vpn",
  /** key_value */
  KEY_UNDERSCORE_VALUE = "key_value",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumBgpPeerConfigSpecFamiliesAdvertisementsMatchExpressions
 */
export interface CiliumBgpPeerConfigSpecFamiliesAdvertisementsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumBgpPeerConfigSpecFamiliesAdvertisementsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumBgpPeerConfigSpecFamiliesAdvertisementsMatchExpressions#operator
   */
  readonly operator: CiliumBgpPeerConfigSpecFamiliesAdvertisementsMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumBgpPeerConfigSpecFamiliesAdvertisementsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumBgpPeerConfigSpecFamiliesAdvertisementsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpPeerConfigSpecFamiliesAdvertisementsMatchExpressions(obj: CiliumBgpPeerConfigSpecFamiliesAdvertisementsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumBgpPeerConfigSpecFamiliesAdvertisementsMatchExpressionsOperator
 */
export enum CiliumBgpPeerConfigSpecFamiliesAdvertisementsMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}


/**
 * CiliumBGPPeeringPolicy is a Kubernetes third-party resource for instructing Cilium's BGP control plane to create virtual BGP routers.
 *
 * @schema CiliumBGPPeeringPolicy
 */
export class CiliumBgpPeeringPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CiliumBGPPeeringPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cilium.io/v2alpha1',
    kind: 'CiliumBGPPeeringPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "CiliumBGPPeeringPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CiliumBgpPeeringPolicyProps): any {
    return {
      ...CiliumBgpPeeringPolicy.GVK,
      ...toJson_CiliumBgpPeeringPolicyProps(props),
    };
  }

  /**
   * Defines a "CiliumBGPPeeringPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CiliumBgpPeeringPolicyProps) {
    super(scope, id, {
      ...CiliumBgpPeeringPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CiliumBgpPeeringPolicy.GVK,
      ...toJson_CiliumBgpPeeringPolicyProps(resolved),
    };
  }
}

/**
 * CiliumBGPPeeringPolicy is a Kubernetes third-party resource for instructing Cilium's BGP control plane to create virtual BGP routers.
 *
 * @schema CiliumBGPPeeringPolicy
 */
export interface CiliumBgpPeeringPolicyProps {
  /**
   * @schema CiliumBGPPeeringPolicy#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * Spec is a human readable description of a BGP peering policy
   *
   * @schema CiliumBGPPeeringPolicy#spec
   */
  readonly spec?: CiliumBgpPeeringPolicySpec;

}

/**
 * Converts an object of type 'CiliumBgpPeeringPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpPeeringPolicyProps(obj: CiliumBgpPeeringPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CiliumBgpPeeringPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Spec is a human readable description of a BGP peering policy
 *
 * @schema CiliumBgpPeeringPolicySpec
 */
export interface CiliumBgpPeeringPolicySpec {
  /**
   * NodeSelector selects a group of nodes where this BGP Peering Policy applies.
   * If empty / nil this policy applies to all nodes.
   *
   * @schema CiliumBgpPeeringPolicySpec#nodeSelector
   */
  readonly nodeSelector?: CiliumBgpPeeringPolicySpecNodeSelector;

  /**
   * A list of CiliumBGPVirtualRouter(s) which instructs the BGP control plane how to instantiate virtual BGP routers.
   *
   * @schema CiliumBgpPeeringPolicySpec#virtualRouters
   */
  readonly virtualRouters: CiliumBgpPeeringPolicySpecVirtualRouters[];

}

/**
 * Converts an object of type 'CiliumBgpPeeringPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpPeeringPolicySpec(obj: CiliumBgpPeeringPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelector': toJson_CiliumBgpPeeringPolicySpecNodeSelector(obj.nodeSelector),
    'virtualRouters': obj.virtualRouters?.map(y => toJson_CiliumBgpPeeringPolicySpecVirtualRouters(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodeSelector selects a group of nodes where this BGP Peering Policy applies.
 * If empty / nil this policy applies to all nodes.
 *
 * @schema CiliumBgpPeeringPolicySpecNodeSelector
 */
export interface CiliumBgpPeeringPolicySpecNodeSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumBgpPeeringPolicySpecNodeSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumBgpPeeringPolicySpecNodeSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumBgpPeeringPolicySpecNodeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumBgpPeeringPolicySpecNodeSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpPeeringPolicySpecNodeSelector(obj: CiliumBgpPeeringPolicySpecNodeSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumBgpPeeringPolicySpecNodeSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CiliumBGPVirtualRouter defines a discrete BGP virtual router configuration.
 *
 * @schema CiliumBgpPeeringPolicySpecVirtualRouters
 */
export interface CiliumBgpPeeringPolicySpecVirtualRouters {
  /**
   * ExportPodCIDR determines whether to export the Node's private CIDR block to the configured neighbors.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRouters#exportPodCIDR
   */
  readonly exportPodCidr?: boolean;

  /**
   * LocalASN is the ASN of this virtual router. Supports extended 32bit ASNs
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRouters#localASN
   */
  readonly localAsn: number;

  /**
   * Neighbors is a list of neighboring BGP peers for this virtual router
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRouters#neighbors
   */
  readonly neighbors: CiliumBgpPeeringPolicySpecVirtualRoutersNeighbors[];

  /**
   * PodIPPoolSelector selects CiliumPodIPPools based on labels. The virtual router will announce allocated CIDRs of matching CiliumPodIPPools.
   * If empty / nil no CiliumPodIPPools will be announced.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRouters#podIPPoolSelector
   */
  readonly podIpPoolSelector?: CiliumBgpPeeringPolicySpecVirtualRoutersPodIpPoolSelector;

  /**
   * ServiceSelector selects a group of load balancer services which this virtual router will announce. The loadBalancerClass for a service must be nil or specify a class supported by Cilium, e.g. "io.cilium/bgp-control-plane". Refer to the following document for additional details regarding load balancer classes:
   * https://kubernetes.io/docs/concepts/services-networking/service/#load-balancer-class
   * If empty / nil no services will be announced.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRouters#serviceSelector
   */
  readonly serviceSelector?: CiliumBgpPeeringPolicySpecVirtualRoutersServiceSelector;

}

/**
 * Converts an object of type 'CiliumBgpPeeringPolicySpecVirtualRouters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpPeeringPolicySpecVirtualRouters(obj: CiliumBgpPeeringPolicySpecVirtualRouters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exportPodCIDR': obj.exportPodCidr,
    'localASN': obj.localAsn,
    'neighbors': obj.neighbors?.map(y => toJson_CiliumBgpPeeringPolicySpecVirtualRoutersNeighbors(y)),
    'podIPPoolSelector': toJson_CiliumBgpPeeringPolicySpecVirtualRoutersPodIpPoolSelector(obj.podIpPoolSelector),
    'serviceSelector': toJson_CiliumBgpPeeringPolicySpecVirtualRoutersServiceSelector(obj.serviceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumBgpPeeringPolicySpecNodeSelectorMatchExpressions
 */
export interface CiliumBgpPeeringPolicySpecNodeSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumBgpPeeringPolicySpecNodeSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumBgpPeeringPolicySpecNodeSelectorMatchExpressions#operator
   */
  readonly operator: CiliumBgpPeeringPolicySpecNodeSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumBgpPeeringPolicySpecNodeSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumBgpPeeringPolicySpecNodeSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpPeeringPolicySpecNodeSelectorMatchExpressions(obj: CiliumBgpPeeringPolicySpecNodeSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CiliumBGPNeighbor is a neighboring peer for use in a CiliumBGPVirtualRouter configuration.
 *
 * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighbors
 */
export interface CiliumBgpPeeringPolicySpecVirtualRoutersNeighbors {
  /**
   * AdvertisedPathAttributes can be used to apply additional path attributes to selected routes when advertising them to the peer. If empty / nil, no additional path attributes are advertised.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighbors#advertisedPathAttributes
   */
  readonly advertisedPathAttributes?: CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributes[];

  /**
   * AuthSecretRef is the name of the secret to use to fetch a TCP authentication password for this peer.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighbors#authSecretRef
   */
  readonly authSecretRef?: string;

  /**
   * ConnectRetryTimeSeconds defines the initial value for the BGP ConnectRetryTimer (RFC 4271, Section 8).
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighbors#connectRetryTimeSeconds
   */
  readonly connectRetryTimeSeconds?: number;

  /**
   * EBGPMultihopTTL controls the multi-hop feature for eBGP peers. Its value defines the Time To Live (TTL) value used in BGP packets sent to the neighbor. The value 1 implies that eBGP multi-hop feature is disabled (only a single hop is allowed). This field is ignored for iBGP peers.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighbors#eBGPMultihopTTL
   */
  readonly eBgpMultihopTtl?: number;

  /**
   * Families, if provided, defines a set of AFI/SAFIs the speaker will negotiate with it's peer.
   * If this slice is not provided the default families of IPv6 and IPv4 will be provided.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighbors#families
   */
  readonly families?: CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsFamilies[];

  /**
   * GracefulRestart defines graceful restart parameters which are negotiated with this neighbor. If empty / nil, the graceful restart capability is disabled.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighbors#gracefulRestart
   */
  readonly gracefulRestart?: CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsGracefulRestart;

  /**
   * HoldTimeSeconds defines the initial value for the BGP HoldTimer (RFC 4271, Section 4.2). Updating this value will cause a session reset.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighbors#holdTimeSeconds
   */
  readonly holdTimeSeconds?: number;

  /**
   * KeepaliveTimeSeconds defines the initial value for the BGP KeepaliveTimer (RFC 4271, Section 8). It can not be larger than HoldTimeSeconds. Updating this value will cause a session reset.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighbors#keepAliveTimeSeconds
   */
  readonly keepAliveTimeSeconds?: number;

  /**
   * PeerASN is the ASN of the peer BGP router. Supports extended 32bit ASNs
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighbors#peerASN
   */
  readonly peerAsn: number;

  /**
   * PeerAddress is the IP address of the peer. This must be in CIDR notation and use a /32 to express a single host.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighbors#peerAddress
   */
  readonly peerAddress: string;

  /**
   * PeerPort is the TCP port of the peer. 1-65535 is the range of valid port numbers that can be specified. If unset, defaults to 179.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighbors#peerPort
   */
  readonly peerPort?: number;

}

/**
 * Converts an object of type 'CiliumBgpPeeringPolicySpecVirtualRoutersNeighbors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpPeeringPolicySpecVirtualRoutersNeighbors(obj: CiliumBgpPeeringPolicySpecVirtualRoutersNeighbors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advertisedPathAttributes': obj.advertisedPathAttributes?.map(y => toJson_CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributes(y)),
    'authSecretRef': obj.authSecretRef,
    'connectRetryTimeSeconds': obj.connectRetryTimeSeconds,
    'eBGPMultihopTTL': obj.eBgpMultihopTtl,
    'families': obj.families?.map(y => toJson_CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsFamilies(y)),
    'gracefulRestart': toJson_CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsGracefulRestart(obj.gracefulRestart),
    'holdTimeSeconds': obj.holdTimeSeconds,
    'keepAliveTimeSeconds': obj.keepAliveTimeSeconds,
    'peerASN': obj.peerAsn,
    'peerAddress': obj.peerAddress,
    'peerPort': obj.peerPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodIPPoolSelector selects CiliumPodIPPools based on labels. The virtual router will announce allocated CIDRs of matching CiliumPodIPPools.
 * If empty / nil no CiliumPodIPPools will be announced.
 *
 * @schema CiliumBgpPeeringPolicySpecVirtualRoutersPodIpPoolSelector
 */
export interface CiliumBgpPeeringPolicySpecVirtualRoutersPodIpPoolSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersPodIpPoolSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumBgpPeeringPolicySpecVirtualRoutersPodIpPoolSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersPodIpPoolSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumBgpPeeringPolicySpecVirtualRoutersPodIpPoolSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpPeeringPolicySpecVirtualRoutersPodIpPoolSelector(obj: CiliumBgpPeeringPolicySpecVirtualRoutersPodIpPoolSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumBgpPeeringPolicySpecVirtualRoutersPodIpPoolSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceSelector selects a group of load balancer services which this virtual router will announce. The loadBalancerClass for a service must be nil or specify a class supported by Cilium, e.g. "io.cilium/bgp-control-plane". Refer to the following document for additional details regarding load balancer classes:
 * https://kubernetes.io/docs/concepts/services-networking/service/#load-balancer-class
 * If empty / nil no services will be announced.
 *
 * @schema CiliumBgpPeeringPolicySpecVirtualRoutersServiceSelector
 */
export interface CiliumBgpPeeringPolicySpecVirtualRoutersServiceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersServiceSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumBgpPeeringPolicySpecVirtualRoutersServiceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersServiceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumBgpPeeringPolicySpecVirtualRoutersServiceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpPeeringPolicySpecVirtualRoutersServiceSelector(obj: CiliumBgpPeeringPolicySpecVirtualRoutersServiceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumBgpPeeringPolicySpecVirtualRoutersServiceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumBgpPeeringPolicySpecNodeSelectorMatchExpressionsOperator
 */
export enum CiliumBgpPeeringPolicySpecNodeSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * CiliumBGPPathAttributes can be used to apply additional path attributes to matched routes when advertising them to a BGP peer.
 *
 * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributes
 */
export interface CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributes {
  /**
   * Communities defines a set of community values advertised in the supported BGP Communities path attributes. If nil / not set, no BGP Communities path attribute will be advertised.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributes#communities
   */
  readonly communities?: CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesCommunities;

  /**
   * LocalPreference defines the preference value advertised in the BGP Local Preference path attribute. As Local Preference is only valid for iBGP peers, this value will be ignored for eBGP peers (no Local Preference path attribute will be advertised). If nil / not set, the default Local Preference of 100 will be advertised in the Local Preference path attribute for iBGP peers.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributes#localPreference
   */
  readonly localPreference?: number;

  /**
   * Selector selects a group of objects of the SelectorType resulting into routes that will be announced with the configured Attributes. If nil / not set, all objects of the SelectorType are selected.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributes#selector
   */
  readonly selector?: CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelector;

  /**
   * SelectorType defines the object type on which the Selector applies: - For "PodCIDR" the Selector matches k8s CiliumNode resources (path attributes apply to routes announced for PodCIDRs of selected CiliumNodes. Only affects routes of cluster scope / Kubernetes IPAM CIDRs, not Multi-Pool IPAM CIDRs. - For "CiliumLoadBalancerIPPool" the Selector matches CiliumLoadBalancerIPPool custom resources (path attributes apply to routes announced for selected CiliumLoadBalancerIPPools). - For "CiliumPodIPPool" the Selector matches CiliumPodIPPool custom resources (path attributes apply to routes announced for allocated CIDRs of selected CiliumPodIPPools).
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributes#selectorType
   */
  readonly selectorType: CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelectorType;

}

/**
 * Converts an object of type 'CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributes(obj: CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'communities': toJson_CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesCommunities(obj.communities),
    'localPreference': obj.localPreference,
    'selector': toJson_CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelector(obj.selector),
    'selectorType': obj.selectorType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CiliumBGPFamily represents a AFI/SAFI address family pair.
 *
 * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsFamilies
 */
export interface CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsFamilies {
  /**
   * Afi is the Address Family Identifier (AFI) of the family.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsFamilies#afi
   */
  readonly afi: CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsFamiliesAfi;

  /**
   * Safi is the Subsequent Address Family Identifier (SAFI) of the family.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsFamilies#safi
   */
  readonly safi: CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsFamiliesSafi;

}

/**
 * Converts an object of type 'CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsFamilies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsFamilies(obj: CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsFamilies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'afi': obj.afi,
    'safi': obj.safi,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GracefulRestart defines graceful restart parameters which are negotiated with this neighbor. If empty / nil, the graceful restart capability is disabled.
 *
 * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsGracefulRestart
 */
export interface CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsGracefulRestart {
  /**
   * Enabled flag, when set enables graceful restart capability.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsGracefulRestart#enabled
   */
  readonly enabled: boolean;

  /**
   * RestartTimeSeconds is the estimated time it will take for the BGP session to be re-established with peer after a restart. After this period, peer will remove stale routes. This is described RFC 4724 section 4.2.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsGracefulRestart#restartTimeSeconds
   */
  readonly restartTimeSeconds?: number;

}

/**
 * Converts an object of type 'CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsGracefulRestart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsGracefulRestart(obj: CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsGracefulRestart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'restartTimeSeconds': obj.restartTimeSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumBgpPeeringPolicySpecVirtualRoutersPodIpPoolSelectorMatchExpressions
 */
export interface CiliumBgpPeeringPolicySpecVirtualRoutersPodIpPoolSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersPodIpPoolSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersPodIpPoolSelectorMatchExpressions#operator
   */
  readonly operator: CiliumBgpPeeringPolicySpecVirtualRoutersPodIpPoolSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersPodIpPoolSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumBgpPeeringPolicySpecVirtualRoutersPodIpPoolSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpPeeringPolicySpecVirtualRoutersPodIpPoolSelectorMatchExpressions(obj: CiliumBgpPeeringPolicySpecVirtualRoutersPodIpPoolSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumBgpPeeringPolicySpecVirtualRoutersServiceSelectorMatchExpressions
 */
export interface CiliumBgpPeeringPolicySpecVirtualRoutersServiceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersServiceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersServiceSelectorMatchExpressions#operator
   */
  readonly operator: CiliumBgpPeeringPolicySpecVirtualRoutersServiceSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersServiceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumBgpPeeringPolicySpecVirtualRoutersServiceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpPeeringPolicySpecVirtualRoutersServiceSelectorMatchExpressions(obj: CiliumBgpPeeringPolicySpecVirtualRoutersServiceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Communities defines a set of community values advertised in the supported BGP Communities path attributes. If nil / not set, no BGP Communities path attribute will be advertised.
 *
 * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesCommunities
 */
export interface CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesCommunities {
  /**
   * Large holds a list of the BGP Large Communities Attribute (RFC 8092) values.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesCommunities#large
   */
  readonly large?: string[];

  /**
   * Standard holds a list of "standard" 32-bit BGP Communities Attribute (RFC 1997) values.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesCommunities#standard
   */
  readonly standard?: string[];

}

/**
 * Converts an object of type 'CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesCommunities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesCommunities(obj: CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesCommunities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'large': obj.large?.map(y => y),
    'standard': obj.standard?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector selects a group of objects of the SelectorType resulting into routes that will be announced with the configured Attributes. If nil / not set, all objects of the SelectorType are selected.
 *
 * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelector
 */
export interface CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelector(obj: CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SelectorType defines the object type on which the Selector applies: - For "PodCIDR" the Selector matches k8s CiliumNode resources (path attributes apply to routes announced for PodCIDRs of selected CiliumNodes. Only affects routes of cluster scope / Kubernetes IPAM CIDRs, not Multi-Pool IPAM CIDRs. - For "CiliumLoadBalancerIPPool" the Selector matches CiliumLoadBalancerIPPool custom resources (path attributes apply to routes announced for selected CiliumLoadBalancerIPPools). - For "CiliumPodIPPool" the Selector matches CiliumPodIPPool custom resources (path attributes apply to routes announced for allocated CIDRs of selected CiliumPodIPPools).
 *
 * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelectorType
 */
export enum CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelectorType {
  /** PodCIDR */
  POD_CIDR = "PodCIDR",
  /** CiliumLoadBalancerIPPool */
  CILIUM_LOAD_BALANCER_IP_POOL = "CiliumLoadBalancerIPPool",
  /** CiliumPodIPPool */
  CILIUM_POD_IP_POOL = "CiliumPodIPPool",
}

/**
 * Afi is the Address Family Identifier (AFI) of the family.
 *
 * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsFamiliesAfi
 */
export enum CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsFamiliesAfi {
  /** ipv4 */
  IPV4 = "ipv4",
  /** ipv6 */
  IPV6 = "ipv6",
  /** l2vpn */
  L2VPN = "l2vpn",
  /** ls */
  LS = "ls",
  /** opaque */
  OPAQUE = "opaque",
}

/**
 * Safi is the Subsequent Address Family Identifier (SAFI) of the family.
 *
 * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsFamiliesSafi
 */
export enum CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsFamiliesSafi {
  /** unicast */
  UNICAST = "unicast",
  /** multicast */
  MULTICAST = "multicast",
  /** mpls_label */
  MPLS_UNDERSCORE_LABEL = "mpls_label",
  /** encapsulation */
  ENCAPSULATION = "encapsulation",
  /** vpls */
  VPLS = "vpls",
  /** evpn */
  EVPN = "evpn",
  /** ls */
  LS = "ls",
  /** sr_policy */
  SR_UNDERSCORE_POLICY = "sr_policy",
  /** mup */
  MUP = "mup",
  /** mpls_vpn */
  MPLS_UNDERSCORE_VPN = "mpls_vpn",
  /** mpls_vpn_multicast */
  MPLS_UNDERSCORE_VPN_UNDERSCORE_MULTICAST = "mpls_vpn_multicast",
  /** route_target_constraints */
  ROUTE_UNDERSCORE_TARGET_UNDERSCORE_CONSTRAINTS = "route_target_constraints",
  /** flowspec_unicast */
  FLOWSPEC_UNDERSCORE_UNICAST = "flowspec_unicast",
  /** flowspec_vpn */
  FLOWSPEC_UNDERSCORE_VPN = "flowspec_vpn",
  /** key_value */
  KEY_UNDERSCORE_VALUE = "key_value",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumBgpPeeringPolicySpecVirtualRoutersPodIpPoolSelectorMatchExpressionsOperator
 */
export enum CiliumBgpPeeringPolicySpecVirtualRoutersPodIpPoolSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumBgpPeeringPolicySpecVirtualRoutersServiceSelectorMatchExpressionsOperator
 */
export enum CiliumBgpPeeringPolicySpecVirtualRoutersServiceSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelectorMatchExpressions
 */
export interface CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelectorMatchExpressions#operator
   */
  readonly operator: CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelectorMatchExpressions(obj: CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelectorMatchExpressionsOperator
 */
export enum CiliumBgpPeeringPolicySpecVirtualRoutersNeighborsAdvertisedPathAttributesSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}


/**
 * CiliumCIDRGroup is a list of external CIDRs (i.e: CIDRs selecting peers outside the clusters) that can be referenced as a single entity from CiliumNetworkPolicies.
 *
 * @schema CiliumCIDRGroup
 */
export class CiliumCidrGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CiliumCIDRGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cilium.io/v2alpha1',
    kind: 'CiliumCIDRGroup',
  }

  /**
   * Renders a Kubernetes manifest for "CiliumCIDRGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CiliumCidrGroupProps): any {
    return {
      ...CiliumCidrGroup.GVK,
      ...toJson_CiliumCidrGroupProps(props),
    };
  }

  /**
   * Defines a "CiliumCIDRGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CiliumCidrGroupProps) {
    super(scope, id, {
      ...CiliumCidrGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CiliumCidrGroup.GVK,
      ...toJson_CiliumCidrGroupProps(resolved),
    };
  }
}

/**
 * CiliumCIDRGroup is a list of external CIDRs (i.e: CIDRs selecting peers outside the clusters) that can be referenced as a single entity from CiliumNetworkPolicies.
 *
 * @schema CiliumCIDRGroup
 */
export interface CiliumCidrGroupProps {
  /**
   * @schema CiliumCIDRGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema CiliumCIDRGroup#spec
   */
  readonly spec: CiliumCidrGroupSpec;

}

/**
 * Converts an object of type 'CiliumCidrGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumCidrGroupProps(obj: CiliumCidrGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CiliumCidrGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CiliumCidrGroupSpec
 */
export interface CiliumCidrGroupSpec {
  /**
   * ExternalCIDRs is a list of CIDRs selecting peers outside the clusters.
   *
   * @schema CiliumCidrGroupSpec#externalCIDRs
   */
  readonly externalCidRs: string[];

}

/**
 * Converts an object of type 'CiliumCidrGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumCidrGroupSpec(obj: CiliumCidrGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalCIDRs': obj.externalCidRs?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema CiliumClusterwideEnvoyConfig
 */
export class CiliumClusterwideEnvoyConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CiliumClusterwideEnvoyConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cilium.io/v2',
    kind: 'CiliumClusterwideEnvoyConfig',
  }

  /**
   * Renders a Kubernetes manifest for "CiliumClusterwideEnvoyConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CiliumClusterwideEnvoyConfigProps): any {
    return {
      ...CiliumClusterwideEnvoyConfig.GVK,
      ...toJson_CiliumClusterwideEnvoyConfigProps(props),
    };
  }

  /**
   * Defines a "CiliumClusterwideEnvoyConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CiliumClusterwideEnvoyConfigProps) {
    super(scope, id, {
      ...CiliumClusterwideEnvoyConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CiliumClusterwideEnvoyConfig.GVK,
      ...toJson_CiliumClusterwideEnvoyConfigProps(resolved),
    };
  }
}

/**
 * @schema CiliumClusterwideEnvoyConfig
 */
export interface CiliumClusterwideEnvoyConfigProps {
  /**
   * @schema CiliumClusterwideEnvoyConfig#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * @schema CiliumClusterwideEnvoyConfig#spec
   */
  readonly spec?: CiliumClusterwideEnvoyConfigSpec;

}

/**
 * Converts an object of type 'CiliumClusterwideEnvoyConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideEnvoyConfigProps(obj: CiliumClusterwideEnvoyConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CiliumClusterwideEnvoyConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CiliumClusterwideEnvoyConfigSpec
 */
export interface CiliumClusterwideEnvoyConfigSpec {
  /**
   * BackendServices specifies Kubernetes services whose backends are automatically synced to Envoy using EDS.  Traffic for these services is not forwarded to an Envoy listener. This allows an Envoy listener load balance traffic to these backends while normal Cilium service load balancing takes care of balancing traffic for these services at the same time.
   *
   * @schema CiliumClusterwideEnvoyConfigSpec#backendServices
   */
  readonly backendServices?: CiliumClusterwideEnvoyConfigSpecBackendServices[];

  /**
   * Envoy xDS resources, a list of the following Envoy resource types: type.googleapis.com/envoy.config.listener.v3.Listener, type.googleapis.com/envoy.config.route.v3.RouteConfiguration, type.googleapis.com/envoy.config.cluster.v3.Cluster, type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment, and type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.Secret.
   *
   * @schema CiliumClusterwideEnvoyConfigSpec#resources
   */
  readonly resources?: any[];

  /**
   * Services specifies Kubernetes services for which traffic is forwarded to an Envoy listener for L7 load balancing. Backends of these services are automatically synced to Envoy usign EDS.
   *
   * @schema CiliumClusterwideEnvoyConfigSpec#services
   */
  readonly services?: CiliumClusterwideEnvoyConfigSpecServices[];

}

/**
 * Converts an object of type 'CiliumClusterwideEnvoyConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideEnvoyConfigSpec(obj: CiliumClusterwideEnvoyConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendServices': obj.backendServices?.map(y => toJson_CiliumClusterwideEnvoyConfigSpecBackendServices(y)),
    'resources': obj.resources?.map(y => y),
    'services': obj.services?.map(y => toJson_CiliumClusterwideEnvoyConfigSpecServices(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CiliumClusterwideEnvoyConfigSpecBackendServices
 */
export interface CiliumClusterwideEnvoyConfigSpecBackendServices {
  /**
   * Name is the name of a destination Kubernetes service that identifies traffic to be redirected.
   *
   * @schema CiliumClusterwideEnvoyConfigSpecBackendServices#name
   */
  readonly name: string;

  /**
   * Namespace is the Kubernetes service namespace. In CiliumEnvoyConfig namespace defaults to the namespace of the CEC, In CiliumClusterwideEnvoyConfig namespace defaults to "default".
   *
   * @schema CiliumClusterwideEnvoyConfigSpecBackendServices#namespace
   */
  readonly namespace?: string;

  /**
   * Port is the port number, which can be used for filtering in case of underlying is exposing multiple port numbers.
   *
   * @schema CiliumClusterwideEnvoyConfigSpecBackendServices#number
   */
  readonly number?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideEnvoyConfigSpecBackendServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideEnvoyConfigSpecBackendServices(obj: CiliumClusterwideEnvoyConfigSpecBackendServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
    'number': obj.number?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CiliumClusterwideEnvoyConfigSpecServices
 */
export interface CiliumClusterwideEnvoyConfigSpecServices {
  /**
   * Listener specifies the name of the Envoy listener the service traffic is redirected to. The listener must be specified in the Envoy 'resources' of the same CiliumEnvoyConfig.
   * If omitted, the first listener specified in 'resources' is used.
   *
   * @schema CiliumClusterwideEnvoyConfigSpecServices#listener
   */
  readonly listener?: string;

  /**
   * Name is the name of a destination Kubernetes service that identifies traffic to be redirected.
   *
   * @schema CiliumClusterwideEnvoyConfigSpecServices#name
   */
  readonly name: string;

  /**
   * Namespace is the Kubernetes service namespace. In CiliumEnvoyConfig namespace this is overridden to the namespace of the CEC, In CiliumClusterwideEnvoyConfig namespace defaults to "default".
   *
   * @schema CiliumClusterwideEnvoyConfigSpecServices#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideEnvoyConfigSpecServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideEnvoyConfigSpecServices(obj: CiliumClusterwideEnvoyConfigSpecServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'listener': obj.listener,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * CiliumClusterwideNetworkPolicy is a Kubernetes third-party resource with an modified version of CiliumNetworkPolicy which is cluster scoped rather than namespace scoped.
 *
 * @schema CiliumClusterwideNetworkPolicy
 */
export class CiliumClusterwideNetworkPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CiliumClusterwideNetworkPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cilium.io/v2',
    kind: 'CiliumClusterwideNetworkPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "CiliumClusterwideNetworkPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CiliumClusterwideNetworkPolicyProps): any {
    return {
      ...CiliumClusterwideNetworkPolicy.GVK,
      ...toJson_CiliumClusterwideNetworkPolicyProps(props),
    };
  }

  /**
   * Defines a "CiliumClusterwideNetworkPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CiliumClusterwideNetworkPolicyProps) {
    super(scope, id, {
      ...CiliumClusterwideNetworkPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CiliumClusterwideNetworkPolicy.GVK,
      ...toJson_CiliumClusterwideNetworkPolicyProps(resolved),
    };
  }
}

/**
 * CiliumClusterwideNetworkPolicy is a Kubernetes third-party resource with an modified version of CiliumNetworkPolicy which is cluster scoped rather than namespace scoped.
 *
 * @schema CiliumClusterwideNetworkPolicy
 */
export interface CiliumClusterwideNetworkPolicyProps {
  /**
   * @schema CiliumClusterwideNetworkPolicy#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * Spec is the desired Cilium specific rule specification.
   *
   * @schema CiliumClusterwideNetworkPolicy#spec
   */
  readonly spec?: CiliumClusterwideNetworkPolicySpec;

  /**
   * Specs is a list of desired Cilium specific rule specification.
   *
   * @schema CiliumClusterwideNetworkPolicy#specs
   */
  readonly specs?: CiliumClusterwideNetworkPolicySpecs[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicyProps(obj: CiliumClusterwideNetworkPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CiliumClusterwideNetworkPolicySpec(obj.spec),
    'specs': obj.specs?.map(y => toJson_CiliumClusterwideNetworkPolicySpecs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Spec is the desired Cilium specific rule specification.
 *
 * @schema CiliumClusterwideNetworkPolicySpec
 */
export interface CiliumClusterwideNetworkPolicySpec {
  /**
   * Description is a free form string, it can be used by the creator of the rule to store human readable explanation of the purpose of this rule. Rules cannot be identified by comment.
   *
   * @schema CiliumClusterwideNetworkPolicySpec#description
   */
  readonly description?: string;

  /**
   * Egress is a list of EgressRule which are enforced at egress. If omitted or empty, this rule does not apply at egress.
   *
   * @schema CiliumClusterwideNetworkPolicySpec#egress
   */
  readonly egress?: CiliumClusterwideNetworkPolicySpecEgress[];

  /**
   * EgressDeny is a list of EgressDenyRule which are enforced at egress. Any rule inserted here will be denied regardless of the allowed egress rules in the 'egress' field. If omitted or empty, this rule does not apply at egress.
   *
   * @schema CiliumClusterwideNetworkPolicySpec#egressDeny
   */
  readonly egressDeny?: CiliumClusterwideNetworkPolicySpecEgressDeny[];

  /**
   * EndpointSelector selects all endpoints which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive.
   *
   * @schema CiliumClusterwideNetworkPolicySpec#endpointSelector
   */
  readonly endpointSelector?: CiliumClusterwideNetworkPolicySpecEndpointSelector;

  /**
   * Ingress is a list of IngressRule which are enforced at ingress. If omitted or empty, this rule does not apply at ingress.
   *
   * @schema CiliumClusterwideNetworkPolicySpec#ingress
   */
  readonly ingress?: CiliumClusterwideNetworkPolicySpecIngress[];

  /**
   * IngressDeny is a list of IngressDenyRule which are enforced at ingress. Any rule inserted here will be denied regardless of the allowed ingress rules in the 'ingress' field. If omitted or empty, this rule does not apply at ingress.
   *
   * @schema CiliumClusterwideNetworkPolicySpec#ingressDeny
   */
  readonly ingressDeny?: CiliumClusterwideNetworkPolicySpecIngressDeny[];

  /**
   * Labels is a list of optional strings which can be used to re-identify the rule or to store metadata. It is possible to lookup or delete strings based on labels. Labels are not required to be unique, multiple rules can have overlapping or identical labels.
   *
   * @schema CiliumClusterwideNetworkPolicySpec#labels
   */
  readonly labels?: CiliumClusterwideNetworkPolicySpecLabels[];

  /**
   * NodeSelector selects all nodes which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive. Can only be used in CiliumClusterwideNetworkPolicies.
   *
   * @schema CiliumClusterwideNetworkPolicySpec#nodeSelector
   */
  readonly nodeSelector?: CiliumClusterwideNetworkPolicySpecNodeSelector;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpec(obj: CiliumClusterwideNetworkPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'egress': obj.egress?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgress(y)),
    'egressDeny': obj.egressDeny?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressDeny(y)),
    'endpointSelector': toJson_CiliumClusterwideNetworkPolicySpecEndpointSelector(obj.endpointSelector),
    'ingress': obj.ingress?.map(y => toJson_CiliumClusterwideNetworkPolicySpecIngress(y)),
    'ingressDeny': obj.ingressDeny?.map(y => toJson_CiliumClusterwideNetworkPolicySpecIngressDeny(y)),
    'labels': obj.labels?.map(y => toJson_CiliumClusterwideNetworkPolicySpecLabels(y)),
    'nodeSelector': toJson_CiliumClusterwideNetworkPolicySpecNodeSelector(obj.nodeSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rule is a policy rule which must be applied to all endpoints which match the labels contained in the endpointSelector
 * Each rule is split into an ingress section which contains all rules applicable at ingress, and an egress section applicable at egress. For rule types such as `L4Rule` and `CIDR` which can be applied at both ingress and egress, both ingress and egress side have to either specifically allow the connection or one side has to be omitted.
 * Either ingress, egress, or both can be provided. If both ingress and egress are omitted, the rule has no effect.
 *
 * @schema CiliumClusterwideNetworkPolicySpecs
 */
export interface CiliumClusterwideNetworkPolicySpecs {
  /**
   * Description is a free form string, it can be used by the creator of the rule to store human readable explanation of the purpose of this rule. Rules cannot be identified by comment.
   *
   * @schema CiliumClusterwideNetworkPolicySpecs#description
   */
  readonly description?: string;

  /**
   * Egress is a list of EgressRule which are enforced at egress. If omitted or empty, this rule does not apply at egress.
   *
   * @schema CiliumClusterwideNetworkPolicySpecs#egress
   */
  readonly egress?: CiliumClusterwideNetworkPolicySpecsEgress[];

  /**
   * EgressDeny is a list of EgressDenyRule which are enforced at egress. Any rule inserted here will be denied regardless of the allowed egress rules in the 'egress' field. If omitted or empty, this rule does not apply at egress.
   *
   * @schema CiliumClusterwideNetworkPolicySpecs#egressDeny
   */
  readonly egressDeny?: CiliumClusterwideNetworkPolicySpecsEgressDeny[];

  /**
   * EndpointSelector selects all endpoints which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive.
   *
   * @schema CiliumClusterwideNetworkPolicySpecs#endpointSelector
   */
  readonly endpointSelector?: CiliumClusterwideNetworkPolicySpecsEndpointSelector;

  /**
   * Ingress is a list of IngressRule which are enforced at ingress. If omitted or empty, this rule does not apply at ingress.
   *
   * @schema CiliumClusterwideNetworkPolicySpecs#ingress
   */
  readonly ingress?: CiliumClusterwideNetworkPolicySpecsIngress[];

  /**
   * IngressDeny is a list of IngressDenyRule which are enforced at ingress. Any rule inserted here will be denied regardless of the allowed ingress rules in the 'ingress' field. If omitted or empty, this rule does not apply at ingress.
   *
   * @schema CiliumClusterwideNetworkPolicySpecs#ingressDeny
   */
  readonly ingressDeny?: CiliumClusterwideNetworkPolicySpecsIngressDeny[];

  /**
   * Labels is a list of optional strings which can be used to re-identify the rule or to store metadata. It is possible to lookup or delete strings based on labels. Labels are not required to be unique, multiple rules can have overlapping or identical labels.
   *
   * @schema CiliumClusterwideNetworkPolicySpecs#labels
   */
  readonly labels?: CiliumClusterwideNetworkPolicySpecsLabels[];

  /**
   * NodeSelector selects all nodes which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive. Can only be used in CiliumClusterwideNetworkPolicies.
   *
   * @schema CiliumClusterwideNetworkPolicySpecs#nodeSelector
   */
  readonly nodeSelector?: CiliumClusterwideNetworkPolicySpecsNodeSelector;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecs(obj: CiliumClusterwideNetworkPolicySpecs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'egress': obj.egress?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgress(y)),
    'egressDeny': obj.egressDeny?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressDeny(y)),
    'endpointSelector': toJson_CiliumClusterwideNetworkPolicySpecsEndpointSelector(obj.endpointSelector),
    'ingress': obj.ingress?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsIngress(y)),
    'ingressDeny': obj.ingressDeny?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsIngressDeny(y)),
    'labels': obj.labels?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsLabels(y)),
    'nodeSelector': toJson_CiliumClusterwideNetworkPolicySpecsNodeSelector(obj.nodeSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EgressRule contains all rule types which can be applied at egress, i.e. network traffic that originates inside the endpoint and exits the endpoint selected by the endpointSelector.
 * - All members of this structure are optional. If omitted or empty, the member will have no effect on the rule.
 * - If multiple members of the structure are specified, then all members must match in order for the rule to take effect. The exception to this rule is the ToRequires member; the effects of any Requires field in any rule will apply to all other rules as well.
 * - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are mutually exclusive. Only one of these members may be present within an individual rule.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgress
 */
export interface CiliumClusterwideNetworkPolicySpecEgress {
  /**
   * Authentication is the required authentication type for the allowed traffic, if any.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgress#authentication
   */
  readonly authentication?: CiliumClusterwideNetworkPolicySpecEgressAuthentication;

  /**
   * ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to connect to.
   * Example: Any endpoint with the label "app=httpd" is allowed to initiate type 8 ICMP connections.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgress#icmps
   */
  readonly icmps?: CiliumClusterwideNetworkPolicySpecEgressIcmps[];

  /**
   * ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules.  This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet.
   * Example: Any endpoint with the label "app=database-proxy" is allowed to initiate connections to 10.2.3.0/24
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgress#toCIDR
   */
  readonly toCidr?: string[];

  /**
   * ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet.
   * Example: Any endpoint with the label "app=database-proxy" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgress#toCIDRSet
   */
  readonly toCidrSet?: CiliumClusterwideNetworkPolicySpecEgressToCidrSet[];

  /**
   * ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate.
   * Example: Any endpoint with the label "role=frontend" can communicate with any endpoint carrying the label "role=backend".
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgress#toEndpoints
   */
  readonly toEndpoints?: CiliumClusterwideNetworkPolicySpecEgressToEndpoints[];

  /**
   * ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`, `health`,`unmanaged` and `all`.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgress#toEntities
   */
  readonly toEntities?: CiliumClusterwideNetworkPolicySpecEgressToEntities[];

  /**
   * ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result from DNS resolution of `ToFQDN.MatchName`s are added to the same EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and L7 rules within this EgressRule will also apply to these IPs. The DNS -> IP mapping is re-resolved periodically from within the cilium-agent, and the IPs in the DNS response are effected in the policy for selected pods as-is (i.e. the list of IPs is not modified in any way). Note: An explicit rule to allow for DNS traffic is needed for the pods, as ToFQDN counts as an egress rule and will enforce egress policy when PolicyEnforcment=default. Note: If the resolved IPs are IPs within the kubernetes cluster, the ToFQDN rule will not apply to that IP. Note: ToFQDN cannot occur in the same policy as other To* rules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgress#toFQDNs
   */
  readonly toFqdNs?: CiliumClusterwideNetworkPolicySpecEgressToFqdNs[];

  /**
   * ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives:
   * Example: toGroups: - aws: securityGroupsIds: - 'sg-XXXXXXXXXXXXX'
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgress#toGroups
   */
  readonly toGroups?: CiliumClusterwideNetworkPolicySpecEgressToGroups[];

  /**
   * ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to connect to.
   * Example: Any endpoint with the label "role=frontend" is allowed to initiate connections to destination port 8080/tcp
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgress#toPorts
   */
  readonly toPorts?: CiliumClusterwideNetworkPolicySpecEgressToPorts[];

  /**
   * ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints.
   * Example: Any Endpoint with the label "team=A" requires any endpoint to which it communicates to also carry the label "team=A".
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgress#toRequires
   */
  readonly toRequires?: CiliumClusterwideNetworkPolicySpecEgressToRequires[];

  /**
   * ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors.
   * Example: Any endpoint with the label "app=backend-app" is allowed to initiate connections to all cidrs backing the "external-service" service
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgress#toServices
   */
  readonly toServices?: CiliumClusterwideNetworkPolicySpecEgressToServices[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgress(obj: CiliumClusterwideNetworkPolicySpecEgress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authentication': toJson_CiliumClusterwideNetworkPolicySpecEgressAuthentication(obj.authentication),
    'icmps': obj.icmps?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressIcmps(y)),
    'toCIDR': obj.toCidr?.map(y => y),
    'toCIDRSet': obj.toCidrSet?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressToCidrSet(y)),
    'toEndpoints': obj.toEndpoints?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressToEndpoints(y)),
    'toEntities': obj.toEntities?.map(y => y),
    'toFQDNs': obj.toFqdNs?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressToFqdNs(y)),
    'toGroups': obj.toGroups?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressToGroups(y)),
    'toPorts': obj.toPorts?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressToPorts(y)),
    'toRequires': obj.toRequires?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressToRequires(y)),
    'toServices': obj.toServices?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressToServices(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EgressDenyRule contains all rule types which can be applied at egress, i.e. network traffic that originates inside the endpoint and exits the endpoint selected by the endpointSelector.
 * - All members of this structure are optional. If omitted or empty, the member will have no effect on the rule.
 * - If multiple members of the structure are specified, then all members must match in order for the rule to take effect. The exception to this rule is the ToRequires member; the effects of any Requires field in any rule will apply to all other rules as well.
 * - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are mutually exclusive. Only one of these members may be present within an individual rule.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressDeny
 */
export interface CiliumClusterwideNetworkPolicySpecEgressDeny {
  /**
   * ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to connect to.
   * Example: Any endpoint with the label "app=httpd" is not allowed to initiate type 8 ICMP connections.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDeny#icmps
   */
  readonly icmps?: CiliumClusterwideNetworkPolicySpecEgressDenyIcmps[];

  /**
   * ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules.  This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet.
   * Example: Any endpoint with the label "app=database-proxy" is allowed to initiate connections to 10.2.3.0/24
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDeny#toCIDR
   */
  readonly toCidr?: string[];

  /**
   * ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet.
   * Example: Any endpoint with the label "app=database-proxy" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDeny#toCIDRSet
   */
  readonly toCidrSet?: CiliumClusterwideNetworkPolicySpecEgressDenyToCidrSet[];

  /**
   * ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate.
   * Example: Any endpoint with the label "role=frontend" can communicate with any endpoint carrying the label "role=backend".
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDeny#toEndpoints
   */
  readonly toEndpoints?: CiliumClusterwideNetworkPolicySpecEgressDenyToEndpoints[];

  /**
   * ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`, `health`,`unmanaged` and `all`.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDeny#toEntities
   */
  readonly toEntities?: CiliumClusterwideNetworkPolicySpecEgressDenyToEntities[];

  /**
   * ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives:
   * Example: toGroups: - aws: securityGroupsIds: - 'sg-XXXXXXXXXXXXX'
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDeny#toGroups
   */
  readonly toGroups?: CiliumClusterwideNetworkPolicySpecEgressDenyToGroups[];

  /**
   * ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to connect to.
   * Example: Any endpoint with the label "role=frontend" is not allowed to initiate connections to destination port 8080/tcp
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDeny#toPorts
   */
  readonly toPorts?: CiliumClusterwideNetworkPolicySpecEgressDenyToPorts[];

  /**
   * ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints.
   * Example: Any Endpoint with the label "team=A" requires any endpoint to which it communicates to also carry the label "team=A".
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDeny#toRequires
   */
  readonly toRequires?: CiliumClusterwideNetworkPolicySpecEgressDenyToRequires[];

  /**
   * ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors.
   * Example: Any endpoint with the label "app=backend-app" is allowed to initiate connections to all cidrs backing the "external-service" service
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDeny#toServices
   */
  readonly toServices?: CiliumClusterwideNetworkPolicySpecEgressDenyToServices[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressDeny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressDeny(obj: CiliumClusterwideNetworkPolicySpecEgressDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'icmps': obj.icmps?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressDenyIcmps(y)),
    'toCIDR': obj.toCidr?.map(y => y),
    'toCIDRSet': obj.toCidrSet?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToCidrSet(y)),
    'toEndpoints': obj.toEndpoints?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToEndpoints(y)),
    'toEntities': obj.toEntities?.map(y => y),
    'toGroups': obj.toGroups?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToGroups(y)),
    'toPorts': obj.toPorts?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToPorts(y)),
    'toRequires': obj.toRequires?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToRequires(y)),
    'toServices': obj.toServices?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToServices(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector selects all endpoints which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEndpointSelector
 */
export interface CiliumClusterwideNetworkPolicySpecEndpointSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEndpointSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumClusterwideNetworkPolicySpecEndpointSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEndpointSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEndpointSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEndpointSelector(obj: CiliumClusterwideNetworkPolicySpecEndpointSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEndpointSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IngressRule contains all rule types which can be applied at ingress, i.e. network traffic that originates outside of the endpoint and is entering the endpoint selected by the endpointSelector.
 * - All members of this structure are optional. If omitted or empty, the member will have no effect on the rule.
 * - If multiple members are set, all of them need to match in order for the rule to take effect. The exception to this rule is FromRequires field; the effects of any Requires field in any rule will apply to all other rules as well.
 * - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually exclusive. Only one of these members may be present within an individual rule.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngress
 */
export interface CiliumClusterwideNetworkPolicySpecIngress {
  /**
   * Authentication is the required authentication type for the allowed traffic, if any.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngress#authentication
   */
  readonly authentication?: CiliumClusterwideNetworkPolicySpecIngressAuthentication;

  /**
   * FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do *not* originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field.  This will match on the source IP address of incoming connections. Adding  a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are allowed between FromCIDR and FromCIDRSet.
   * Example: Any endpoint with the label "app=my-legacy-pet" is allowed to receive connections from 10.3.9.1
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngress#fromCIDR
   */
  readonly fromCidr?: string[];

  /**
   * FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
   * Example: Any endpoint with the label "app=my-legacy-pet" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngress#fromCIDRSet
   */
  readonly fromCidrSet?: CiliumClusterwideNetworkPolicySpecIngressFromCidrSet[];

  /**
   * FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule.
   * Example: Any endpoint with the label "role=backend" can be consumed by any endpoint carrying the label "role=frontend".
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngress#fromEndpoints
   */
  readonly fromEndpoints?: CiliumClusterwideNetworkPolicySpecIngressFromEndpoints[];

  /**
   * FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are `world`, `cluster` and `host`
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngress#fromEntities
   */
  readonly fromEntities?: CiliumClusterwideNetworkPolicySpecIngressFromEntities[];

  /**
   * FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints.
   * Example: Any Endpoint with the label "team=A" requires consuming endpoint to also carry the label "team=A".
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngress#fromRequires
   */
  readonly fromRequires?: CiliumClusterwideNetworkPolicySpecIngressFromRequires[];

  /**
   * ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to receive connections on.
   * Example: Any endpoint with the label "app=httpd" can only accept incoming type 8 ICMP connections.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngress#icmps
   */
  readonly icmps?: CiliumClusterwideNetworkPolicySpecIngressIcmps[];

  /**
   * ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to receive connections on.
   * Example: Any endpoint with the label "app=httpd" can only accept incoming connections on port 80/tcp.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngress#toPorts
   */
  readonly toPorts?: CiliumClusterwideNetworkPolicySpecIngressToPorts[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngress(obj: CiliumClusterwideNetworkPolicySpecIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authentication': toJson_CiliumClusterwideNetworkPolicySpecIngressAuthentication(obj.authentication),
    'fromCIDR': obj.fromCidr?.map(y => y),
    'fromCIDRSet': obj.fromCidrSet?.map(y => toJson_CiliumClusterwideNetworkPolicySpecIngressFromCidrSet(y)),
    'fromEndpoints': obj.fromEndpoints?.map(y => toJson_CiliumClusterwideNetworkPolicySpecIngressFromEndpoints(y)),
    'fromEntities': obj.fromEntities?.map(y => y),
    'fromRequires': obj.fromRequires?.map(y => toJson_CiliumClusterwideNetworkPolicySpecIngressFromRequires(y)),
    'icmps': obj.icmps?.map(y => toJson_CiliumClusterwideNetworkPolicySpecIngressIcmps(y)),
    'toPorts': obj.toPorts?.map(y => toJson_CiliumClusterwideNetworkPolicySpecIngressToPorts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IngressDenyRule contains all rule types which can be applied at ingress, i.e. network traffic that originates outside of the endpoint and is entering the endpoint selected by the endpointSelector.
 * - All members of this structure are optional. If omitted or empty, the member will have no effect on the rule.
 * - If multiple members are set, all of them need to match in order for the rule to take effect. The exception to this rule is FromRequires field; the effects of any Requires field in any rule will apply to all other rules as well.
 * - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually exclusive. Only one of these members may be present within an individual rule.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressDeny
 */
export interface CiliumClusterwideNetworkPolicySpecIngressDeny {
  /**
   * FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do *not* originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field.  This will match on the source IP address of incoming connections. Adding  a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are allowed between FromCIDR and FromCIDRSet.
   * Example: Any endpoint with the label "app=my-legacy-pet" is allowed to receive connections from 10.3.9.1
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDeny#fromCIDR
   */
  readonly fromCidr?: string[];

  /**
   * FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
   * Example: Any endpoint with the label "app=my-legacy-pet" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDeny#fromCIDRSet
   */
  readonly fromCidrSet?: CiliumClusterwideNetworkPolicySpecIngressDenyFromCidrSet[];

  /**
   * FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule.
   * Example: Any endpoint with the label "role=backend" can be consumed by any endpoint carrying the label "role=frontend".
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDeny#fromEndpoints
   */
  readonly fromEndpoints?: CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpoints[];

  /**
   * FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are `world`, `cluster` and `host`
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDeny#fromEntities
   */
  readonly fromEntities?: CiliumClusterwideNetworkPolicySpecIngressDenyFromEntities[];

  /**
   * FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints.
   * Example: Any Endpoint with the label "team=A" requires consuming endpoint to also carry the label "team=A".
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDeny#fromRequires
   */
  readonly fromRequires?: CiliumClusterwideNetworkPolicySpecIngressDenyFromRequires[];

  /**
   * ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to receive connections on.
   * Example: Any endpoint with the label "app=httpd" can not accept incoming type 8 ICMP connections.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDeny#icmps
   */
  readonly icmps?: CiliumClusterwideNetworkPolicySpecIngressDenyIcmps[];

  /**
   * ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to receive connections on.
   * Example: Any endpoint with the label "app=httpd" can not accept incoming connections on port 80/tcp.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDeny#toPorts
   */
  readonly toPorts?: CiliumClusterwideNetworkPolicySpecIngressDenyToPorts[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressDeny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressDeny(obj: CiliumClusterwideNetworkPolicySpecIngressDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromCIDR': obj.fromCidr?.map(y => y),
    'fromCIDRSet': obj.fromCidrSet?.map(y => toJson_CiliumClusterwideNetworkPolicySpecIngressDenyFromCidrSet(y)),
    'fromEndpoints': obj.fromEndpoints?.map(y => toJson_CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpoints(y)),
    'fromEntities': obj.fromEntities?.map(y => y),
    'fromRequires': obj.fromRequires?.map(y => toJson_CiliumClusterwideNetworkPolicySpecIngressDenyFromRequires(y)),
    'icmps': obj.icmps?.map(y => toJson_CiliumClusterwideNetworkPolicySpecIngressDenyIcmps(y)),
    'toPorts': obj.toPorts?.map(y => toJson_CiliumClusterwideNetworkPolicySpecIngressDenyToPorts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Label is the Cilium's representation of a container label.
 *
 * @schema CiliumClusterwideNetworkPolicySpecLabels
 */
export interface CiliumClusterwideNetworkPolicySpecLabels {
  /**
   * @schema CiliumClusterwideNetworkPolicySpecLabels#key
   */
  readonly key: string;

  /**
   * Source can be one of the above values (e.g.: LabelSourceContainer).
   *
   * @schema CiliumClusterwideNetworkPolicySpecLabels#source
   */
  readonly source?: string;

  /**
   * @schema CiliumClusterwideNetworkPolicySpecLabels#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecLabels(obj: CiliumClusterwideNetworkPolicySpecLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'source': obj.source,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodeSelector selects all nodes which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive. Can only be used in CiliumClusterwideNetworkPolicies.
 *
 * @schema CiliumClusterwideNetworkPolicySpecNodeSelector
 */
export interface CiliumClusterwideNetworkPolicySpecNodeSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecNodeSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumClusterwideNetworkPolicySpecNodeSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecNodeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecNodeSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecNodeSelector(obj: CiliumClusterwideNetworkPolicySpecNodeSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumClusterwideNetworkPolicySpecNodeSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EgressRule contains all rule types which can be applied at egress, i.e. network traffic that originates inside the endpoint and exits the endpoint selected by the endpointSelector.
 * - All members of this structure are optional. If omitted or empty, the member will have no effect on the rule.
 * - If multiple members of the structure are specified, then all members must match in order for the rule to take effect. The exception to this rule is the ToRequires member; the effects of any Requires field in any rule will apply to all other rules as well.
 * - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are mutually exclusive. Only one of these members may be present within an individual rule.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgress
 */
export interface CiliumClusterwideNetworkPolicySpecsEgress {
  /**
   * Authentication is the required authentication type for the allowed traffic, if any.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgress#authentication
   */
  readonly authentication?: CiliumClusterwideNetworkPolicySpecsEgressAuthentication;

  /**
   * ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to connect to.
   * Example: Any endpoint with the label "app=httpd" is allowed to initiate type 8 ICMP connections.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgress#icmps
   */
  readonly icmps?: CiliumClusterwideNetworkPolicySpecsEgressIcmps[];

  /**
   * ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules.  This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet.
   * Example: Any endpoint with the label "app=database-proxy" is allowed to initiate connections to 10.2.3.0/24
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgress#toCIDR
   */
  readonly toCidr?: string[];

  /**
   * ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet.
   * Example: Any endpoint with the label "app=database-proxy" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgress#toCIDRSet
   */
  readonly toCidrSet?: CiliumClusterwideNetworkPolicySpecsEgressToCidrSet[];

  /**
   * ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate.
   * Example: Any endpoint with the label "role=frontend" can communicate with any endpoint carrying the label "role=backend".
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgress#toEndpoints
   */
  readonly toEndpoints?: CiliumClusterwideNetworkPolicySpecsEgressToEndpoints[];

  /**
   * ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`, `health`,`unmanaged` and `all`.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgress#toEntities
   */
  readonly toEntities?: CiliumClusterwideNetworkPolicySpecsEgressToEntities[];

  /**
   * ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result from DNS resolution of `ToFQDN.MatchName`s are added to the same EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and L7 rules within this EgressRule will also apply to these IPs. The DNS -> IP mapping is re-resolved periodically from within the cilium-agent, and the IPs in the DNS response are effected in the policy for selected pods as-is (i.e. the list of IPs is not modified in any way). Note: An explicit rule to allow for DNS traffic is needed for the pods, as ToFQDN counts as an egress rule and will enforce egress policy when PolicyEnforcment=default. Note: If the resolved IPs are IPs within the kubernetes cluster, the ToFQDN rule will not apply to that IP. Note: ToFQDN cannot occur in the same policy as other To* rules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgress#toFQDNs
   */
  readonly toFqdNs?: CiliumClusterwideNetworkPolicySpecsEgressToFqdNs[];

  /**
   * ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives:
   * Example: toGroups: - aws: securityGroupsIds: - 'sg-XXXXXXXXXXXXX'
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgress#toGroups
   */
  readonly toGroups?: CiliumClusterwideNetworkPolicySpecsEgressToGroups[];

  /**
   * ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to connect to.
   * Example: Any endpoint with the label "role=frontend" is allowed to initiate connections to destination port 8080/tcp
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgress#toPorts
   */
  readonly toPorts?: CiliumClusterwideNetworkPolicySpecsEgressToPorts[];

  /**
   * ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints.
   * Example: Any Endpoint with the label "team=A" requires any endpoint to which it communicates to also carry the label "team=A".
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgress#toRequires
   */
  readonly toRequires?: CiliumClusterwideNetworkPolicySpecsEgressToRequires[];

  /**
   * ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors.
   * Example: Any endpoint with the label "app=backend-app" is allowed to initiate connections to all cidrs backing the "external-service" service
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgress#toServices
   */
  readonly toServices?: CiliumClusterwideNetworkPolicySpecsEgressToServices[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgress(obj: CiliumClusterwideNetworkPolicySpecsEgress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authentication': toJson_CiliumClusterwideNetworkPolicySpecsEgressAuthentication(obj.authentication),
    'icmps': obj.icmps?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressIcmps(y)),
    'toCIDR': obj.toCidr?.map(y => y),
    'toCIDRSet': obj.toCidrSet?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressToCidrSet(y)),
    'toEndpoints': obj.toEndpoints?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressToEndpoints(y)),
    'toEntities': obj.toEntities?.map(y => y),
    'toFQDNs': obj.toFqdNs?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressToFqdNs(y)),
    'toGroups': obj.toGroups?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressToGroups(y)),
    'toPorts': obj.toPorts?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressToPorts(y)),
    'toRequires': obj.toRequires?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressToRequires(y)),
    'toServices': obj.toServices?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressToServices(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EgressDenyRule contains all rule types which can be applied at egress, i.e. network traffic that originates inside the endpoint and exits the endpoint selected by the endpointSelector.
 * - All members of this structure are optional. If omitted or empty, the member will have no effect on the rule.
 * - If multiple members of the structure are specified, then all members must match in order for the rule to take effect. The exception to this rule is the ToRequires member; the effects of any Requires field in any rule will apply to all other rules as well.
 * - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are mutually exclusive. Only one of these members may be present within an individual rule.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressDeny
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressDeny {
  /**
   * ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to connect to.
   * Example: Any endpoint with the label "app=httpd" is not allowed to initiate type 8 ICMP connections.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDeny#icmps
   */
  readonly icmps?: CiliumClusterwideNetworkPolicySpecsEgressDenyIcmps[];

  /**
   * ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules.  This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet.
   * Example: Any endpoint with the label "app=database-proxy" is allowed to initiate connections to 10.2.3.0/24
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDeny#toCIDR
   */
  readonly toCidr?: string[];

  /**
   * ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet.
   * Example: Any endpoint with the label "app=database-proxy" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDeny#toCIDRSet
   */
  readonly toCidrSet?: CiliumClusterwideNetworkPolicySpecsEgressDenyToCidrSet[];

  /**
   * ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate.
   * Example: Any endpoint with the label "role=frontend" can communicate with any endpoint carrying the label "role=backend".
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDeny#toEndpoints
   */
  readonly toEndpoints?: CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpoints[];

  /**
   * ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`, `health`,`unmanaged` and `all`.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDeny#toEntities
   */
  readonly toEntities?: CiliumClusterwideNetworkPolicySpecsEgressDenyToEntities[];

  /**
   * ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives:
   * Example: toGroups: - aws: securityGroupsIds: - 'sg-XXXXXXXXXXXXX'
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDeny#toGroups
   */
  readonly toGroups?: CiliumClusterwideNetworkPolicySpecsEgressDenyToGroups[];

  /**
   * ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to connect to.
   * Example: Any endpoint with the label "role=frontend" is not allowed to initiate connections to destination port 8080/tcp
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDeny#toPorts
   */
  readonly toPorts?: CiliumClusterwideNetworkPolicySpecsEgressDenyToPorts[];

  /**
   * ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints.
   * Example: Any Endpoint with the label "team=A" requires any endpoint to which it communicates to also carry the label "team=A".
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDeny#toRequires
   */
  readonly toRequires?: CiliumClusterwideNetworkPolicySpecsEgressDenyToRequires[];

  /**
   * ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors.
   * Example: Any endpoint with the label "app=backend-app" is allowed to initiate connections to all cidrs backing the "external-service" service
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDeny#toServices
   */
  readonly toServices?: CiliumClusterwideNetworkPolicySpecsEgressDenyToServices[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressDeny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressDeny(obj: CiliumClusterwideNetworkPolicySpecsEgressDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'icmps': obj.icmps?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyIcmps(y)),
    'toCIDR': obj.toCidr?.map(y => y),
    'toCIDRSet': obj.toCidrSet?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToCidrSet(y)),
    'toEndpoints': obj.toEndpoints?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpoints(y)),
    'toEntities': obj.toEntities?.map(y => y),
    'toGroups': obj.toGroups?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToGroups(y)),
    'toPorts': obj.toPorts?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToPorts(y)),
    'toRequires': obj.toRequires?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToRequires(y)),
    'toServices': obj.toServices?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToServices(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector selects all endpoints which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEndpointSelector
 */
export interface CiliumClusterwideNetworkPolicySpecsEndpointSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEndpointSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumClusterwideNetworkPolicySpecsEndpointSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEndpointSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEndpointSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEndpointSelector(obj: CiliumClusterwideNetworkPolicySpecsEndpointSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEndpointSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IngressRule contains all rule types which can be applied at ingress, i.e. network traffic that originates outside of the endpoint and is entering the endpoint selected by the endpointSelector.
 * - All members of this structure are optional. If omitted or empty, the member will have no effect on the rule.
 * - If multiple members are set, all of them need to match in order for the rule to take effect. The exception to this rule is FromRequires field; the effects of any Requires field in any rule will apply to all other rules as well.
 * - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually exclusive. Only one of these members may be present within an individual rule.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngress
 */
export interface CiliumClusterwideNetworkPolicySpecsIngress {
  /**
   * Authentication is the required authentication type for the allowed traffic, if any.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngress#authentication
   */
  readonly authentication?: CiliumClusterwideNetworkPolicySpecsIngressAuthentication;

  /**
   * FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do *not* originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field.  This will match on the source IP address of incoming connections. Adding  a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are allowed between FromCIDR and FromCIDRSet.
   * Example: Any endpoint with the label "app=my-legacy-pet" is allowed to receive connections from 10.3.9.1
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngress#fromCIDR
   */
  readonly fromCidr?: string[];

  /**
   * FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
   * Example: Any endpoint with the label "app=my-legacy-pet" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngress#fromCIDRSet
   */
  readonly fromCidrSet?: CiliumClusterwideNetworkPolicySpecsIngressFromCidrSet[];

  /**
   * FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule.
   * Example: Any endpoint with the label "role=backend" can be consumed by any endpoint carrying the label "role=frontend".
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngress#fromEndpoints
   */
  readonly fromEndpoints?: CiliumClusterwideNetworkPolicySpecsIngressFromEndpoints[];

  /**
   * FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are `world`, `cluster` and `host`
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngress#fromEntities
   */
  readonly fromEntities?: CiliumClusterwideNetworkPolicySpecsIngressFromEntities[];

  /**
   * FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints.
   * Example: Any Endpoint with the label "team=A" requires consuming endpoint to also carry the label "team=A".
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngress#fromRequires
   */
  readonly fromRequires?: CiliumClusterwideNetworkPolicySpecsIngressFromRequires[];

  /**
   * ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to receive connections on.
   * Example: Any endpoint with the label "app=httpd" can only accept incoming type 8 ICMP connections.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngress#icmps
   */
  readonly icmps?: CiliumClusterwideNetworkPolicySpecsIngressIcmps[];

  /**
   * ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to receive connections on.
   * Example: Any endpoint with the label "app=httpd" can only accept incoming connections on port 80/tcp.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngress#toPorts
   */
  readonly toPorts?: CiliumClusterwideNetworkPolicySpecsIngressToPorts[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngress(obj: CiliumClusterwideNetworkPolicySpecsIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authentication': toJson_CiliumClusterwideNetworkPolicySpecsIngressAuthentication(obj.authentication),
    'fromCIDR': obj.fromCidr?.map(y => y),
    'fromCIDRSet': obj.fromCidrSet?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsIngressFromCidrSet(y)),
    'fromEndpoints': obj.fromEndpoints?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsIngressFromEndpoints(y)),
    'fromEntities': obj.fromEntities?.map(y => y),
    'fromRequires': obj.fromRequires?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsIngressFromRequires(y)),
    'icmps': obj.icmps?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsIngressIcmps(y)),
    'toPorts': obj.toPorts?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsIngressToPorts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IngressDenyRule contains all rule types which can be applied at ingress, i.e. network traffic that originates outside of the endpoint and is entering the endpoint selected by the endpointSelector.
 * - All members of this structure are optional. If omitted or empty, the member will have no effect on the rule.
 * - If multiple members are set, all of them need to match in order for the rule to take effect. The exception to this rule is FromRequires field; the effects of any Requires field in any rule will apply to all other rules as well.
 * - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually exclusive. Only one of these members may be present within an individual rule.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressDeny
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressDeny {
  /**
   * FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do *not* originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field.  This will match on the source IP address of incoming connections. Adding  a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are allowed between FromCIDR and FromCIDRSet.
   * Example: Any endpoint with the label "app=my-legacy-pet" is allowed to receive connections from 10.3.9.1
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDeny#fromCIDR
   */
  readonly fromCidr?: string[];

  /**
   * FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
   * Example: Any endpoint with the label "app=my-legacy-pet" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDeny#fromCIDRSet
   */
  readonly fromCidrSet?: CiliumClusterwideNetworkPolicySpecsIngressDenyFromCidrSet[];

  /**
   * FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule.
   * Example: Any endpoint with the label "role=backend" can be consumed by any endpoint carrying the label "role=frontend".
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDeny#fromEndpoints
   */
  readonly fromEndpoints?: CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpoints[];

  /**
   * FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are `world`, `cluster` and `host`
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDeny#fromEntities
   */
  readonly fromEntities?: CiliumClusterwideNetworkPolicySpecsIngressDenyFromEntities[];

  /**
   * FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints.
   * Example: Any Endpoint with the label "team=A" requires consuming endpoint to also carry the label "team=A".
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDeny#fromRequires
   */
  readonly fromRequires?: CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequires[];

  /**
   * ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to receive connections on.
   * Example: Any endpoint with the label "app=httpd" can not accept incoming type 8 ICMP connections.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDeny#icmps
   */
  readonly icmps?: CiliumClusterwideNetworkPolicySpecsIngressDenyIcmps[];

  /**
   * ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to receive connections on.
   * Example: Any endpoint with the label "app=httpd" can not accept incoming connections on port 80/tcp.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDeny#toPorts
   */
  readonly toPorts?: CiliumClusterwideNetworkPolicySpecsIngressDenyToPorts[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressDeny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressDeny(obj: CiliumClusterwideNetworkPolicySpecsIngressDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromCIDR': obj.fromCidr?.map(y => y),
    'fromCIDRSet': obj.fromCidrSet?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsIngressDenyFromCidrSet(y)),
    'fromEndpoints': obj.fromEndpoints?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpoints(y)),
    'fromEntities': obj.fromEntities?.map(y => y),
    'fromRequires': obj.fromRequires?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequires(y)),
    'icmps': obj.icmps?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsIngressDenyIcmps(y)),
    'toPorts': obj.toPorts?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsIngressDenyToPorts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Label is the Cilium's representation of a container label.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsLabels
 */
export interface CiliumClusterwideNetworkPolicySpecsLabels {
  /**
   * @schema CiliumClusterwideNetworkPolicySpecsLabels#key
   */
  readonly key: string;

  /**
   * Source can be one of the above values (e.g.: LabelSourceContainer).
   *
   * @schema CiliumClusterwideNetworkPolicySpecsLabels#source
   */
  readonly source?: string;

  /**
   * @schema CiliumClusterwideNetworkPolicySpecsLabels#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsLabels(obj: CiliumClusterwideNetworkPolicySpecsLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'source': obj.source,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodeSelector selects all nodes which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive. Can only be used in CiliumClusterwideNetworkPolicies.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsNodeSelector
 */
export interface CiliumClusterwideNetworkPolicySpecsNodeSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsNodeSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumClusterwideNetworkPolicySpecsNodeSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsNodeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsNodeSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsNodeSelector(obj: CiliumClusterwideNetworkPolicySpecsNodeSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsNodeSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication is the required authentication type for the allowed traffic, if any.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressAuthentication
 */
export interface CiliumClusterwideNetworkPolicySpecEgressAuthentication {
  /**
   * Mode is the required authentication mode for the allowed traffic, if any.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressAuthentication#mode
   */
  readonly mode: CiliumClusterwideNetworkPolicySpecEgressAuthenticationMode;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressAuthentication(obj: CiliumClusterwideNetworkPolicySpecEgressAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPRule is a list of ICMP fields.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressIcmps
 */
export interface CiliumClusterwideNetworkPolicySpecEgressIcmps {
  /**
   * Fields is a list of ICMP fields.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressIcmps#fields
   */
  readonly fields?: CiliumClusterwideNetworkPolicySpecEgressIcmpsFields[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressIcmps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressIcmps(obj: CiliumClusterwideNetworkPolicySpecEgressIcmps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fields': obj.fields?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressIcmpsFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToCidrSet
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToCidrSet {
  /**
   * CIDR is a CIDR prefix / IP Block.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToCidrSet#cidr
   */
  readonly cidr?: string;

  /**
   * CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToCidrSet#cidrGroupRef
   */
  readonly cidrGroupRef?: string;

  /**
   * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToCidrSet#except
   */
  readonly except?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToCidrSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToCidrSet(obj: CiliumClusterwideNetworkPolicySpecEgressToCidrSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'cidrGroupRef': obj.cidrGroupRef,
    'except': obj.except?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToEndpoints
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToEndpoints {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToEndpoints#matchExpressions
   */
  readonly matchExpressions?: CiliumClusterwideNetworkPolicySpecEgressToEndpointsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToEndpoints#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToEndpoints(obj: CiliumClusterwideNetworkPolicySpecEgressToEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressToEndpointsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe "outside of cluster", "host", etc.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToEntities
 */
export enum CiliumClusterwideNetworkPolicySpecEgressToEntities {
  /** all */
  ALL = "all",
  /** world */
  WORLD = "world",
  /** cluster */
  CLUSTER = "cluster",
  /** host */
  HOST = "host",
  /** init */
  INIT = "init",
  /** ingress */
  INGRESS = "ingress",
  /** unmanaged */
  UNMANAGED = "unmanaged",
  /** remote-node */
  REMOTE_HYPHEN_NODE = "remote-node",
  /** health */
  HEALTH = "health",
  /** none */
  NONE = "none",
  /** kube-apiserver */
  KUBE_HYPHEN_APISERVER = "kube-apiserver",
}

/**
 * @schema CiliumClusterwideNetworkPolicySpecEgressToFqdNs
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToFqdNs {
  /**
   * MatchName matches literal DNS names. A trailing "." is automatically added when missing.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToFqdNs#matchName
   */
  readonly matchName?: string;

  /**
   * MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - "*" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a "*" as the leftmost character, without a following "." matches all subdomains as well as the name to the right. A trailing "." is automatically added when missing.
   * Examples: `*.cilium.io` matches subomains of cilium at that level www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io" except those containing "." separator, subcilium.io and sub-cilium.io match, www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with "sub" sub.cilium.io and subdomain.cilium.io match, www.cilium.io, blog.cilium.io, cilium.io and google.com do not
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToFqdNs#matchPattern
   */
  readonly matchPattern?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToFqdNs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToFqdNs(obj: CiliumClusterwideNetworkPolicySpecEgressToFqdNs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchName': obj.matchName,
    'matchPattern': obj.matchPattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ToGroups structure to store all kinds of new integrations that needs a new derivative policy.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToGroups
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToGroups {
  /**
   * AWSGroup is an structure that can be used to whitelisting information from AWS integration
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToGroups#aws
   */
  readonly aws?: CiliumClusterwideNetworkPolicySpecEgressToGroupsAws;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToGroups' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToGroups(obj: CiliumClusterwideNetworkPolicySpecEgressToGroups | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aws': toJson_CiliumClusterwideNetworkPolicySpecEgressToGroupsAws(obj.aws),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortRule is a list of ports/protocol combinations with optional Layer 7 rules which must be met.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToPorts
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToPorts {
  /**
   * listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPorts#listener
   */
  readonly listener?: CiliumClusterwideNetworkPolicySpecEgressToPortsListener;

  /**
   * OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPorts#originatingTLS
   */
  readonly originatingTls?: CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTls;

  /**
   * Ports is a list of L4 port/protocol
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPorts#ports
   */
  readonly ports?: CiliumClusterwideNetworkPolicySpecEgressToPortsPorts[];

  /**
   * Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPorts#rules
   */
  readonly rules?: CiliumClusterwideNetworkPolicySpecEgressToPortsRules;

  /**
   * ServerNames is a list of allowed TLS SNI values. If not empty, then TLS must be present and one of the provided SNIs must be indicated in the TLS handshake.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPorts#serverNames
   */
  readonly serverNames?: string[];

  /**
   * TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPorts#terminatingTLS
   */
  readonly terminatingTls?: CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTls;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToPorts(obj: CiliumClusterwideNetworkPolicySpecEgressToPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'listener': toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsListener(obj.listener),
    'originatingTLS': toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTls(obj.originatingTls),
    'ports': obj.ports?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsPorts(y)),
    'rules': toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsRules(obj.rules),
    'serverNames': obj.serverNames?.map(y => y),
    'terminatingTLS': toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTls(obj.terminatingTls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToRequires
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToRequires {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToRequires#matchExpressions
   */
  readonly matchExpressions?: CiliumClusterwideNetworkPolicySpecEgressToRequiresMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToRequires#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToRequires' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToRequires(obj: CiliumClusterwideNetworkPolicySpecEgressToRequires | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressToRequiresMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Service wraps around selectors for services
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToServices
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToServices {
  /**
   * K8sService selects service by name and namespace pair
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToServices#k8sService
   */
  readonly k8SService?: CiliumClusterwideNetworkPolicySpecEgressToServicesK8SService;

  /**
   * K8sServiceSelector selects services by k8s labels and namespace
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToServices#k8sServiceSelector
   */
  readonly k8SServiceSelector?: CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelector;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToServices(obj: CiliumClusterwideNetworkPolicySpecEgressToServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'k8sService': toJson_CiliumClusterwideNetworkPolicySpecEgressToServicesK8SService(obj.k8SService),
    'k8sServiceSelector': toJson_CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelector(obj.k8SServiceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPRule is a list of ICMP fields.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressDenyIcmps
 */
export interface CiliumClusterwideNetworkPolicySpecEgressDenyIcmps {
  /**
   * Fields is a list of ICMP fields.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyIcmps#fields
   */
  readonly fields?: CiliumClusterwideNetworkPolicySpecEgressDenyIcmpsFields[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressDenyIcmps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressDenyIcmps(obj: CiliumClusterwideNetworkPolicySpecEgressDenyIcmps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fields': obj.fields?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressDenyIcmpsFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToCidrSet
 */
export interface CiliumClusterwideNetworkPolicySpecEgressDenyToCidrSet {
  /**
   * CIDR is a CIDR prefix / IP Block.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToCidrSet#cidr
   */
  readonly cidr?: string;

  /**
   * CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToCidrSet#cidrGroupRef
   */
  readonly cidrGroupRef?: string;

  /**
   * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToCidrSet#except
   */
  readonly except?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressDenyToCidrSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToCidrSet(obj: CiliumClusterwideNetworkPolicySpecEgressDenyToCidrSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'cidrGroupRef': obj.cidrGroupRef,
    'except': obj.except?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToEndpoints
 */
export interface CiliumClusterwideNetworkPolicySpecEgressDenyToEndpoints {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToEndpoints#matchExpressions
   */
  readonly matchExpressions?: CiliumClusterwideNetworkPolicySpecEgressDenyToEndpointsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToEndpoints#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressDenyToEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToEndpoints(obj: CiliumClusterwideNetworkPolicySpecEgressDenyToEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToEndpointsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe "outside of cluster", "host", etc.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToEntities
 */
export enum CiliumClusterwideNetworkPolicySpecEgressDenyToEntities {
  /** all */
  ALL = "all",
  /** world */
  WORLD = "world",
  /** cluster */
  CLUSTER = "cluster",
  /** host */
  HOST = "host",
  /** init */
  INIT = "init",
  /** ingress */
  INGRESS = "ingress",
  /** unmanaged */
  UNMANAGED = "unmanaged",
  /** remote-node */
  REMOTE_HYPHEN_NODE = "remote-node",
  /** health */
  HEALTH = "health",
  /** none */
  NONE = "none",
  /** kube-apiserver */
  KUBE_HYPHEN_APISERVER = "kube-apiserver",
}

/**
 * ToGroups structure to store all kinds of new integrations that needs a new derivative policy.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToGroups
 */
export interface CiliumClusterwideNetworkPolicySpecEgressDenyToGroups {
  /**
   * AWSGroup is an structure that can be used to whitelisting information from AWS integration
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToGroups#aws
   */
  readonly aws?: CiliumClusterwideNetworkPolicySpecEgressDenyToGroupsAws;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressDenyToGroups' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToGroups(obj: CiliumClusterwideNetworkPolicySpecEgressDenyToGroups | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aws': toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToGroupsAws(obj.aws),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortDenyRule is a list of ports/protocol that should be used for deny policies. This structure lacks the L7Rules since it's not supported in deny policies.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToPorts
 */
export interface CiliumClusterwideNetworkPolicySpecEgressDenyToPorts {
  /**
   * Ports is a list of L4 port/protocol
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToPorts#ports
   */
  readonly ports?: CiliumClusterwideNetworkPolicySpecEgressDenyToPortsPorts[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressDenyToPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToPorts(obj: CiliumClusterwideNetworkPolicySpecEgressDenyToPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToPortsPorts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToRequires
 */
export interface CiliumClusterwideNetworkPolicySpecEgressDenyToRequires {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToRequires#matchExpressions
   */
  readonly matchExpressions?: CiliumClusterwideNetworkPolicySpecEgressDenyToRequiresMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToRequires#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressDenyToRequires' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToRequires(obj: CiliumClusterwideNetworkPolicySpecEgressDenyToRequires | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToRequiresMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Service wraps around selectors for services
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToServices
 */
export interface CiliumClusterwideNetworkPolicySpecEgressDenyToServices {
  /**
   * K8sService selects service by name and namespace pair
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToServices#k8sService
   */
  readonly k8SService?: CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SService;

  /**
   * K8sServiceSelector selects services by k8s labels and namespace
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToServices#k8sServiceSelector
   */
  readonly k8SServiceSelector?: CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelector;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressDenyToServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToServices(obj: CiliumClusterwideNetworkPolicySpecEgressDenyToServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'k8sService': toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SService(obj.k8SService),
    'k8sServiceSelector': toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelector(obj.k8SServiceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEndpointSelectorMatchExpressions
 */
export interface CiliumClusterwideNetworkPolicySpecEndpointSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEndpointSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEndpointSelectorMatchExpressions#operator
   */
  readonly operator: CiliumClusterwideNetworkPolicySpecEndpointSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEndpointSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEndpointSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEndpointSelectorMatchExpressions(obj: CiliumClusterwideNetworkPolicySpecEndpointSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication is the required authentication type for the allowed traffic, if any.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressAuthentication
 */
export interface CiliumClusterwideNetworkPolicySpecIngressAuthentication {
  /**
   * Mode is the required authentication mode for the allowed traffic, if any.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressAuthentication#mode
   */
  readonly mode: CiliumClusterwideNetworkPolicySpecIngressAuthenticationMode;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressAuthentication(obj: CiliumClusterwideNetworkPolicySpecIngressAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressFromCidrSet
 */
export interface CiliumClusterwideNetworkPolicySpecIngressFromCidrSet {
  /**
   * CIDR is a CIDR prefix / IP Block.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressFromCidrSet#cidr
   */
  readonly cidr?: string;

  /**
   * CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressFromCidrSet#cidrGroupRef
   */
  readonly cidrGroupRef?: string;

  /**
   * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressFromCidrSet#except
   */
  readonly except?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressFromCidrSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressFromCidrSet(obj: CiliumClusterwideNetworkPolicySpecIngressFromCidrSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'cidrGroupRef': obj.cidrGroupRef,
    'except': obj.except?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressFromEndpoints
 */
export interface CiliumClusterwideNetworkPolicySpecIngressFromEndpoints {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressFromEndpoints#matchExpressions
   */
  readonly matchExpressions?: CiliumClusterwideNetworkPolicySpecIngressFromEndpointsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressFromEndpoints#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressFromEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressFromEndpoints(obj: CiliumClusterwideNetworkPolicySpecIngressFromEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumClusterwideNetworkPolicySpecIngressFromEndpointsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe "outside of cluster", "host", etc.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressFromEntities
 */
export enum CiliumClusterwideNetworkPolicySpecIngressFromEntities {
  /** all */
  ALL = "all",
  /** world */
  WORLD = "world",
  /** cluster */
  CLUSTER = "cluster",
  /** host */
  HOST = "host",
  /** init */
  INIT = "init",
  /** ingress */
  INGRESS = "ingress",
  /** unmanaged */
  UNMANAGED = "unmanaged",
  /** remote-node */
  REMOTE_HYPHEN_NODE = "remote-node",
  /** health */
  HEALTH = "health",
  /** none */
  NONE = "none",
  /** kube-apiserver */
  KUBE_HYPHEN_APISERVER = "kube-apiserver",
}

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressFromRequires
 */
export interface CiliumClusterwideNetworkPolicySpecIngressFromRequires {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressFromRequires#matchExpressions
   */
  readonly matchExpressions?: CiliumClusterwideNetworkPolicySpecIngressFromRequiresMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressFromRequires#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressFromRequires' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressFromRequires(obj: CiliumClusterwideNetworkPolicySpecIngressFromRequires | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumClusterwideNetworkPolicySpecIngressFromRequiresMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPRule is a list of ICMP fields.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressIcmps
 */
export interface CiliumClusterwideNetworkPolicySpecIngressIcmps {
  /**
   * Fields is a list of ICMP fields.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressIcmps#fields
   */
  readonly fields?: CiliumClusterwideNetworkPolicySpecIngressIcmpsFields[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressIcmps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressIcmps(obj: CiliumClusterwideNetworkPolicySpecIngressIcmps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fields': obj.fields?.map(y => toJson_CiliumClusterwideNetworkPolicySpecIngressIcmpsFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortRule is a list of ports/protocol combinations with optional Layer 7 rules which must be met.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressToPorts
 */
export interface CiliumClusterwideNetworkPolicySpecIngressToPorts {
  /**
   * listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPorts#listener
   */
  readonly listener?: CiliumClusterwideNetworkPolicySpecIngressToPortsListener;

  /**
   * OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPorts#originatingTLS
   */
  readonly originatingTls?: CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTls;

  /**
   * Ports is a list of L4 port/protocol
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPorts#ports
   */
  readonly ports?: CiliumClusterwideNetworkPolicySpecIngressToPortsPorts[];

  /**
   * Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPorts#rules
   */
  readonly rules?: CiliumClusterwideNetworkPolicySpecIngressToPortsRules;

  /**
   * ServerNames is a list of allowed TLS SNI values. If not empty, then TLS must be present and one of the provided SNIs must be indicated in the TLS handshake.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPorts#serverNames
   */
  readonly serverNames?: string[];

  /**
   * TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPorts#terminatingTLS
   */
  readonly terminatingTls?: CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTls;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressToPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressToPorts(obj: CiliumClusterwideNetworkPolicySpecIngressToPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'listener': toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsListener(obj.listener),
    'originatingTLS': toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTls(obj.originatingTls),
    'ports': obj.ports?.map(y => toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsPorts(y)),
    'rules': toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsRules(obj.rules),
    'serverNames': obj.serverNames?.map(y => y),
    'terminatingTLS': toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTls(obj.terminatingTls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressDenyFromCidrSet
 */
export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromCidrSet {
  /**
   * CIDR is a CIDR prefix / IP Block.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDenyFromCidrSet#cidr
   */
  readonly cidr?: string;

  /**
   * CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDenyFromCidrSet#cidrGroupRef
   */
  readonly cidrGroupRef?: string;

  /**
   * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDenyFromCidrSet#except
   */
  readonly except?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressDenyFromCidrSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressDenyFromCidrSet(obj: CiliumClusterwideNetworkPolicySpecIngressDenyFromCidrSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'cidrGroupRef': obj.cidrGroupRef,
    'except': obj.except?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpoints
 */
export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpoints {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpoints#matchExpressions
   */
  readonly matchExpressions?: CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpointsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpoints#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpoints(obj: CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpointsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe "outside of cluster", "host", etc.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressDenyFromEntities
 */
export enum CiliumClusterwideNetworkPolicySpecIngressDenyFromEntities {
  /** all */
  ALL = "all",
  /** world */
  WORLD = "world",
  /** cluster */
  CLUSTER = "cluster",
  /** host */
  HOST = "host",
  /** init */
  INIT = "init",
  /** ingress */
  INGRESS = "ingress",
  /** unmanaged */
  UNMANAGED = "unmanaged",
  /** remote-node */
  REMOTE_HYPHEN_NODE = "remote-node",
  /** health */
  HEALTH = "health",
  /** none */
  NONE = "none",
  /** kube-apiserver */
  KUBE_HYPHEN_APISERVER = "kube-apiserver",
}

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressDenyFromRequires
 */
export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromRequires {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDenyFromRequires#matchExpressions
   */
  readonly matchExpressions?: CiliumClusterwideNetworkPolicySpecIngressDenyFromRequiresMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDenyFromRequires#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressDenyFromRequires' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressDenyFromRequires(obj: CiliumClusterwideNetworkPolicySpecIngressDenyFromRequires | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumClusterwideNetworkPolicySpecIngressDenyFromRequiresMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPRule is a list of ICMP fields.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressDenyIcmps
 */
export interface CiliumClusterwideNetworkPolicySpecIngressDenyIcmps {
  /**
   * Fields is a list of ICMP fields.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDenyIcmps#fields
   */
  readonly fields?: CiliumClusterwideNetworkPolicySpecIngressDenyIcmpsFields[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressDenyIcmps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressDenyIcmps(obj: CiliumClusterwideNetworkPolicySpecIngressDenyIcmps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fields': obj.fields?.map(y => toJson_CiliumClusterwideNetworkPolicySpecIngressDenyIcmpsFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortDenyRule is a list of ports/protocol that should be used for deny policies. This structure lacks the L7Rules since it's not supported in deny policies.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressDenyToPorts
 */
export interface CiliumClusterwideNetworkPolicySpecIngressDenyToPorts {
  /**
   * Ports is a list of L4 port/protocol
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDenyToPorts#ports
   */
  readonly ports?: CiliumClusterwideNetworkPolicySpecIngressDenyToPortsPorts[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressDenyToPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressDenyToPorts(obj: CiliumClusterwideNetworkPolicySpecIngressDenyToPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => toJson_CiliumClusterwideNetworkPolicySpecIngressDenyToPortsPorts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumClusterwideNetworkPolicySpecNodeSelectorMatchExpressions
 */
export interface CiliumClusterwideNetworkPolicySpecNodeSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecNodeSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecNodeSelectorMatchExpressions#operator
   */
  readonly operator: CiliumClusterwideNetworkPolicySpecNodeSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumClusterwideNetworkPolicySpecNodeSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecNodeSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecNodeSelectorMatchExpressions(obj: CiliumClusterwideNetworkPolicySpecNodeSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication is the required authentication type for the allowed traffic, if any.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressAuthentication
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressAuthentication {
  /**
   * Mode is the required authentication mode for the allowed traffic, if any.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressAuthentication#mode
   */
  readonly mode: CiliumClusterwideNetworkPolicySpecsEgressAuthenticationMode;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressAuthentication(obj: CiliumClusterwideNetworkPolicySpecsEgressAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPRule is a list of ICMP fields.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressIcmps
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressIcmps {
  /**
   * Fields is a list of ICMP fields.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressIcmps#fields
   */
  readonly fields?: CiliumClusterwideNetworkPolicySpecsEgressIcmpsFields[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressIcmps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressIcmps(obj: CiliumClusterwideNetworkPolicySpecsEgressIcmps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fields': obj.fields?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressIcmpsFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToCidrSet
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToCidrSet {
  /**
   * CIDR is a CIDR prefix / IP Block.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToCidrSet#cidr
   */
  readonly cidr?: string;

  /**
   * CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToCidrSet#cidrGroupRef
   */
  readonly cidrGroupRef?: string;

  /**
   * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToCidrSet#except
   */
  readonly except?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToCidrSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToCidrSet(obj: CiliumClusterwideNetworkPolicySpecsEgressToCidrSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'cidrGroupRef': obj.cidrGroupRef,
    'except': obj.except?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToEndpoints
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToEndpoints {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToEndpoints#matchExpressions
   */
  readonly matchExpressions?: CiliumClusterwideNetworkPolicySpecsEgressToEndpointsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToEndpoints#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToEndpoints(obj: CiliumClusterwideNetworkPolicySpecsEgressToEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressToEndpointsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe "outside of cluster", "host", etc.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToEntities
 */
export enum CiliumClusterwideNetworkPolicySpecsEgressToEntities {
  /** all */
  ALL = "all",
  /** world */
  WORLD = "world",
  /** cluster */
  CLUSTER = "cluster",
  /** host */
  HOST = "host",
  /** init */
  INIT = "init",
  /** ingress */
  INGRESS = "ingress",
  /** unmanaged */
  UNMANAGED = "unmanaged",
  /** remote-node */
  REMOTE_HYPHEN_NODE = "remote-node",
  /** health */
  HEALTH = "health",
  /** none */
  NONE = "none",
  /** kube-apiserver */
  KUBE_HYPHEN_APISERVER = "kube-apiserver",
}

/**
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToFqdNs
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToFqdNs {
  /**
   * MatchName matches literal DNS names. A trailing "." is automatically added when missing.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToFqdNs#matchName
   */
  readonly matchName?: string;

  /**
   * MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - "*" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a "*" as the leftmost character, without a following "." matches all subdomains as well as the name to the right. A trailing "." is automatically added when missing.
   * Examples: `*.cilium.io` matches subomains of cilium at that level www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io" except those containing "." separator, subcilium.io and sub-cilium.io match, www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with "sub" sub.cilium.io and subdomain.cilium.io match, www.cilium.io, blog.cilium.io, cilium.io and google.com do not
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToFqdNs#matchPattern
   */
  readonly matchPattern?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToFqdNs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToFqdNs(obj: CiliumClusterwideNetworkPolicySpecsEgressToFqdNs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchName': obj.matchName,
    'matchPattern': obj.matchPattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ToGroups structure to store all kinds of new integrations that needs a new derivative policy.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToGroups
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToGroups {
  /**
   * AWSGroup is an structure that can be used to whitelisting information from AWS integration
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToGroups#aws
   */
  readonly aws?: CiliumClusterwideNetworkPolicySpecsEgressToGroupsAws;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToGroups' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToGroups(obj: CiliumClusterwideNetworkPolicySpecsEgressToGroups | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aws': toJson_CiliumClusterwideNetworkPolicySpecsEgressToGroupsAws(obj.aws),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortRule is a list of ports/protocol combinations with optional Layer 7 rules which must be met.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToPorts
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToPorts {
  /**
   * listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPorts#listener
   */
  readonly listener?: CiliumClusterwideNetworkPolicySpecsEgressToPortsListener;

  /**
   * OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPorts#originatingTLS
   */
  readonly originatingTls?: CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTls;

  /**
   * Ports is a list of L4 port/protocol
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPorts#ports
   */
  readonly ports?: CiliumClusterwideNetworkPolicySpecsEgressToPortsPorts[];

  /**
   * Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPorts#rules
   */
  readonly rules?: CiliumClusterwideNetworkPolicySpecsEgressToPortsRules;

  /**
   * ServerNames is a list of allowed TLS SNI values. If not empty, then TLS must be present and one of the provided SNIs must be indicated in the TLS handshake.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPorts#serverNames
   */
  readonly serverNames?: string[];

  /**
   * TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPorts#terminatingTLS
   */
  readonly terminatingTls?: CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTls;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToPorts(obj: CiliumClusterwideNetworkPolicySpecsEgressToPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'listener': toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsListener(obj.listener),
    'originatingTLS': toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTls(obj.originatingTls),
    'ports': obj.ports?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsPorts(y)),
    'rules': toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsRules(obj.rules),
    'serverNames': obj.serverNames?.map(y => y),
    'terminatingTLS': toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTls(obj.terminatingTls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToRequires
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToRequires {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToRequires#matchExpressions
   */
  readonly matchExpressions?: CiliumClusterwideNetworkPolicySpecsEgressToRequiresMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToRequires#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToRequires' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToRequires(obj: CiliumClusterwideNetworkPolicySpecsEgressToRequires | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressToRequiresMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Service wraps around selectors for services
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToServices
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToServices {
  /**
   * K8sService selects service by name and namespace pair
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToServices#k8sService
   */
  readonly k8SService?: CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SService;

  /**
   * K8sServiceSelector selects services by k8s labels and namespace
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToServices#k8sServiceSelector
   */
  readonly k8SServiceSelector?: CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelector;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToServices(obj: CiliumClusterwideNetworkPolicySpecsEgressToServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'k8sService': toJson_CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SService(obj.k8SService),
    'k8sServiceSelector': toJson_CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelector(obj.k8SServiceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPRule is a list of ICMP fields.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyIcmps
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressDenyIcmps {
  /**
   * Fields is a list of ICMP fields.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyIcmps#fields
   */
  readonly fields?: CiliumClusterwideNetworkPolicySpecsEgressDenyIcmpsFields[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressDenyIcmps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyIcmps(obj: CiliumClusterwideNetworkPolicySpecsEgressDenyIcmps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fields': obj.fields?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyIcmpsFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToCidrSet
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToCidrSet {
  /**
   * CIDR is a CIDR prefix / IP Block.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToCidrSet#cidr
   */
  readonly cidr?: string;

  /**
   * CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToCidrSet#cidrGroupRef
   */
  readonly cidrGroupRef?: string;

  /**
   * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToCidrSet#except
   */
  readonly except?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressDenyToCidrSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToCidrSet(obj: CiliumClusterwideNetworkPolicySpecsEgressDenyToCidrSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'cidrGroupRef': obj.cidrGroupRef,
    'except': obj.except?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpoints
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpoints {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpoints#matchExpressions
   */
  readonly matchExpressions?: CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpointsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpoints#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpoints(obj: CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpointsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe "outside of cluster", "host", etc.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToEntities
 */
export enum CiliumClusterwideNetworkPolicySpecsEgressDenyToEntities {
  /** all */
  ALL = "all",
  /** world */
  WORLD = "world",
  /** cluster */
  CLUSTER = "cluster",
  /** host */
  HOST = "host",
  /** init */
  INIT = "init",
  /** ingress */
  INGRESS = "ingress",
  /** unmanaged */
  UNMANAGED = "unmanaged",
  /** remote-node */
  REMOTE_HYPHEN_NODE = "remote-node",
  /** health */
  HEALTH = "health",
  /** none */
  NONE = "none",
  /** kube-apiserver */
  KUBE_HYPHEN_APISERVER = "kube-apiserver",
}

/**
 * ToGroups structure to store all kinds of new integrations that needs a new derivative policy.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToGroups
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToGroups {
  /**
   * AWSGroup is an structure that can be used to whitelisting information from AWS integration
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToGroups#aws
   */
  readonly aws?: CiliumClusterwideNetworkPolicySpecsEgressDenyToGroupsAws;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressDenyToGroups' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToGroups(obj: CiliumClusterwideNetworkPolicySpecsEgressDenyToGroups | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aws': toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToGroupsAws(obj.aws),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortDenyRule is a list of ports/protocol that should be used for deny policies. This structure lacks the L7Rules since it's not supported in deny policies.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToPorts
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToPorts {
  /**
   * Ports is a list of L4 port/protocol
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToPorts#ports
   */
  readonly ports?: CiliumClusterwideNetworkPolicySpecsEgressDenyToPortsPorts[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressDenyToPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToPorts(obj: CiliumClusterwideNetworkPolicySpecsEgressDenyToPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToPortsPorts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToRequires
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToRequires {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToRequires#matchExpressions
   */
  readonly matchExpressions?: CiliumClusterwideNetworkPolicySpecsEgressDenyToRequiresMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToRequires#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressDenyToRequires' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToRequires(obj: CiliumClusterwideNetworkPolicySpecsEgressDenyToRequires | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToRequiresMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Service wraps around selectors for services
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToServices
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToServices {
  /**
   * K8sService selects service by name and namespace pair
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToServices#k8sService
   */
  readonly k8SService?: CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SService;

  /**
   * K8sServiceSelector selects services by k8s labels and namespace
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToServices#k8sServiceSelector
   */
  readonly k8SServiceSelector?: CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelector;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressDenyToServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToServices(obj: CiliumClusterwideNetworkPolicySpecsEgressDenyToServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'k8sService': toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SService(obj.k8SService),
    'k8sServiceSelector': toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelector(obj.k8SServiceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEndpointSelectorMatchExpressions
 */
export interface CiliumClusterwideNetworkPolicySpecsEndpointSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEndpointSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEndpointSelectorMatchExpressions#operator
   */
  readonly operator: CiliumClusterwideNetworkPolicySpecsEndpointSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEndpointSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEndpointSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEndpointSelectorMatchExpressions(obj: CiliumClusterwideNetworkPolicySpecsEndpointSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication is the required authentication type for the allowed traffic, if any.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressAuthentication
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressAuthentication {
  /**
   * Mode is the required authentication mode for the allowed traffic, if any.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressAuthentication#mode
   */
  readonly mode: CiliumClusterwideNetworkPolicySpecsIngressAuthenticationMode;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressAuthentication(obj: CiliumClusterwideNetworkPolicySpecsIngressAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressFromCidrSet
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressFromCidrSet {
  /**
   * CIDR is a CIDR prefix / IP Block.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressFromCidrSet#cidr
   */
  readonly cidr?: string;

  /**
   * CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressFromCidrSet#cidrGroupRef
   */
  readonly cidrGroupRef?: string;

  /**
   * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressFromCidrSet#except
   */
  readonly except?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressFromCidrSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressFromCidrSet(obj: CiliumClusterwideNetworkPolicySpecsIngressFromCidrSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'cidrGroupRef': obj.cidrGroupRef,
    'except': obj.except?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressFromEndpoints
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressFromEndpoints {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressFromEndpoints#matchExpressions
   */
  readonly matchExpressions?: CiliumClusterwideNetworkPolicySpecsIngressFromEndpointsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressFromEndpoints#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressFromEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressFromEndpoints(obj: CiliumClusterwideNetworkPolicySpecsIngressFromEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsIngressFromEndpointsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe "outside of cluster", "host", etc.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressFromEntities
 */
export enum CiliumClusterwideNetworkPolicySpecsIngressFromEntities {
  /** all */
  ALL = "all",
  /** world */
  WORLD = "world",
  /** cluster */
  CLUSTER = "cluster",
  /** host */
  HOST = "host",
  /** init */
  INIT = "init",
  /** ingress */
  INGRESS = "ingress",
  /** unmanaged */
  UNMANAGED = "unmanaged",
  /** remote-node */
  REMOTE_HYPHEN_NODE = "remote-node",
  /** health */
  HEALTH = "health",
  /** none */
  NONE = "none",
  /** kube-apiserver */
  KUBE_HYPHEN_APISERVER = "kube-apiserver",
}

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressFromRequires
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressFromRequires {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressFromRequires#matchExpressions
   */
  readonly matchExpressions?: CiliumClusterwideNetworkPolicySpecsIngressFromRequiresMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressFromRequires#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressFromRequires' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressFromRequires(obj: CiliumClusterwideNetworkPolicySpecsIngressFromRequires | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsIngressFromRequiresMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPRule is a list of ICMP fields.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressIcmps
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressIcmps {
  /**
   * Fields is a list of ICMP fields.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressIcmps#fields
   */
  readonly fields?: CiliumClusterwideNetworkPolicySpecsIngressIcmpsFields[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressIcmps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressIcmps(obj: CiliumClusterwideNetworkPolicySpecsIngressIcmps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fields': obj.fields?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsIngressIcmpsFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortRule is a list of ports/protocol combinations with optional Layer 7 rules which must be met.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressToPorts
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressToPorts {
  /**
   * listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPorts#listener
   */
  readonly listener?: CiliumClusterwideNetworkPolicySpecsIngressToPortsListener;

  /**
   * OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPorts#originatingTLS
   */
  readonly originatingTls?: CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTls;

  /**
   * Ports is a list of L4 port/protocol
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPorts#ports
   */
  readonly ports?: CiliumClusterwideNetworkPolicySpecsIngressToPortsPorts[];

  /**
   * Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPorts#rules
   */
  readonly rules?: CiliumClusterwideNetworkPolicySpecsIngressToPortsRules;

  /**
   * ServerNames is a list of allowed TLS SNI values. If not empty, then TLS must be present and one of the provided SNIs must be indicated in the TLS handshake.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPorts#serverNames
   */
  readonly serverNames?: string[];

  /**
   * TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPorts#terminatingTLS
   */
  readonly terminatingTls?: CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTls;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressToPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressToPorts(obj: CiliumClusterwideNetworkPolicySpecsIngressToPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'listener': toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsListener(obj.listener),
    'originatingTLS': toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTls(obj.originatingTls),
    'ports': obj.ports?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsPorts(y)),
    'rules': toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsRules(obj.rules),
    'serverNames': obj.serverNames?.map(y => y),
    'terminatingTLS': toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTls(obj.terminatingTls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyFromCidrSet
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromCidrSet {
  /**
   * CIDR is a CIDR prefix / IP Block.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyFromCidrSet#cidr
   */
  readonly cidr?: string;

  /**
   * CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyFromCidrSet#cidrGroupRef
   */
  readonly cidrGroupRef?: string;

  /**
   * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyFromCidrSet#except
   */
  readonly except?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressDenyFromCidrSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressDenyFromCidrSet(obj: CiliumClusterwideNetworkPolicySpecsIngressDenyFromCidrSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'cidrGroupRef': obj.cidrGroupRef,
    'except': obj.except?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpoints
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpoints {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpoints#matchExpressions
   */
  readonly matchExpressions?: CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpoints#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpoints(obj: CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe "outside of cluster", "host", etc.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyFromEntities
 */
export enum CiliumClusterwideNetworkPolicySpecsIngressDenyFromEntities {
  /** all */
  ALL = "all",
  /** world */
  WORLD = "world",
  /** cluster */
  CLUSTER = "cluster",
  /** host */
  HOST = "host",
  /** init */
  INIT = "init",
  /** ingress */
  INGRESS = "ingress",
  /** unmanaged */
  UNMANAGED = "unmanaged",
  /** remote-node */
  REMOTE_HYPHEN_NODE = "remote-node",
  /** health */
  HEALTH = "health",
  /** none */
  NONE = "none",
  /** kube-apiserver */
  KUBE_HYPHEN_APISERVER = "kube-apiserver",
}

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequires
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequires {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequires#matchExpressions
   */
  readonly matchExpressions?: CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequiresMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequires#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequires' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequires(obj: CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequires | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequiresMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPRule is a list of ICMP fields.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyIcmps
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressDenyIcmps {
  /**
   * Fields is a list of ICMP fields.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyIcmps#fields
   */
  readonly fields?: CiliumClusterwideNetworkPolicySpecsIngressDenyIcmpsFields[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressDenyIcmps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressDenyIcmps(obj: CiliumClusterwideNetworkPolicySpecsIngressDenyIcmps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fields': obj.fields?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsIngressDenyIcmpsFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortDenyRule is a list of ports/protocol that should be used for deny policies. This structure lacks the L7Rules since it's not supported in deny policies.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyToPorts
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressDenyToPorts {
  /**
   * Ports is a list of L4 port/protocol
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyToPorts#ports
   */
  readonly ports?: CiliumClusterwideNetworkPolicySpecsIngressDenyToPortsPorts[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressDenyToPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressDenyToPorts(obj: CiliumClusterwideNetworkPolicySpecsIngressDenyToPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsIngressDenyToPortsPorts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsNodeSelectorMatchExpressions
 */
export interface CiliumClusterwideNetworkPolicySpecsNodeSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsNodeSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsNodeSelectorMatchExpressions#operator
   */
  readonly operator: CiliumClusterwideNetworkPolicySpecsNodeSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsNodeSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsNodeSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsNodeSelectorMatchExpressions(obj: CiliumClusterwideNetworkPolicySpecsNodeSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mode is the required authentication mode for the allowed traffic, if any.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressAuthenticationMode
 */
export enum CiliumClusterwideNetworkPolicySpecEgressAuthenticationMode {
  /** disabled */
  DISABLED = "disabled",
  /** required */
  REQUIRED = "required",
  /** test-always-fail */
  TEST_HYPHEN_ALWAYS_HYPHEN_FAIL = "test-always-fail",
}

/**
 * ICMPField is a ICMP field.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressIcmpsFields
 */
export interface CiliumClusterwideNetworkPolicySpecEgressIcmpsFields {
  /**
   * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressIcmpsFields#family
   */
  readonly family?: CiliumClusterwideNetworkPolicySpecEgressIcmpsFieldsFamily;

  /**
   * Type is a ICMP-type. It should be 0-255 (8bit).
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressIcmpsFields#type
   */
  readonly type: number;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressIcmpsFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressIcmpsFields(obj: CiliumClusterwideNetworkPolicySpecEgressIcmpsFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'family': obj.family,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToEndpointsMatchExpressions
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToEndpointsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToEndpointsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToEndpointsMatchExpressions#operator
   */
  readonly operator: CiliumClusterwideNetworkPolicySpecEgressToEndpointsMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToEndpointsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToEndpointsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToEndpointsMatchExpressions(obj: CiliumClusterwideNetworkPolicySpecEgressToEndpointsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSGroup is an structure that can be used to whitelisting information from AWS integration
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToGroupsAws
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToGroupsAws {
  /**
   * @schema CiliumClusterwideNetworkPolicySpecEgressToGroupsAws#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema CiliumClusterwideNetworkPolicySpecEgressToGroupsAws#region
   */
  readonly region?: string;

  /**
   * @schema CiliumClusterwideNetworkPolicySpecEgressToGroupsAws#securityGroupsIds
   */
  readonly securityGroupsIds?: string[];

  /**
   * @schema CiliumClusterwideNetworkPolicySpecEgressToGroupsAws#securityGroupsNames
   */
  readonly securityGroupsNames?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToGroupsAws' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToGroupsAws(obj: CiliumClusterwideNetworkPolicySpecEgressToGroupsAws | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'region': obj.region,
    'securityGroupsIds': obj.securityGroupsIds?.map(y => y),
    'securityGroupsNames': obj.securityGroupsNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsListener
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToPortsListener {
  /**
   * EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsListener#envoyConfig
   */
  readonly envoyConfig: CiliumClusterwideNetworkPolicySpecEgressToPortsListenerEnvoyConfig;

  /**
   * Name is the name of the listener.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsListener#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToPortsListener' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsListener(obj: CiliumClusterwideNetworkPolicySpecEgressToPortsListener | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'envoyConfig': toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsListenerEnvoyConfig(obj.envoyConfig),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTls
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTls {
  /**
   * Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTls#certificate
   */
  readonly certificate?: string;

  /**
   * PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTls#secret
   */
  readonly secret: CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTlsSecret;

  /**
   * TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTls#trustedCA
   */
  readonly trustedCa?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTls(obj: CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'privateKey': obj.privateKey,
    'secret': toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTlsSecret(obj.secret),
    'trustedCA': obj.trustedCa,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortProtocol specifies an L4 port with an optional transport protocol
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsPorts
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToPortsPorts {
  /**
   * Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form "1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsPorts#port
   */
  readonly port: string;

  /**
   * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
   * Matching on ICMP is not supported.
   * Named port specified for a container may narrow this down, but may not contradict this.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsPorts#protocol
   */
  readonly protocol?: CiliumClusterwideNetworkPolicySpecEgressToPortsPortsProtocol;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToPortsPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsPorts(obj: CiliumClusterwideNetworkPolicySpecEgressToPortsPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRules
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToPortsRules {
  /**
   * DNS-specific rules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRules#dns
   */
  readonly dns?: CiliumClusterwideNetworkPolicySpecEgressToPortsRulesDns[];

  /**
   * HTTP specific rules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRules#http
   */
  readonly http?: CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttp[];

  /**
   * Kafka-specific rules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRules#kafka
   */
  readonly kafka?: CiliumClusterwideNetworkPolicySpecEgressToPortsRulesKafka[];

  /**
   * Key-value pair rules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRules#l7
   */
  readonly l7?: { [key: string]: string }[];

  /**
   * Name of the L7 protocol for which the Key-value pair rules apply.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRules#l7proto
   */
  readonly l7Proto?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToPortsRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsRules(obj: CiliumClusterwideNetworkPolicySpecEgressToPortsRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dns': obj.dns?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsRulesDns(y)),
    'http': obj.http?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttp(y)),
    'kafka': obj.kafka?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsRulesKafka(y)),
    'l7': obj.l7?.map(y => ((y) === undefined) ? undefined : (Object.entries(y).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {}))),
    'l7proto': obj.l7Proto,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTls
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTls {
  /**
   * Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTls#certificate
   */
  readonly certificate?: string;

  /**
   * PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTls#secret
   */
  readonly secret: CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTlsSecret;

  /**
   * TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTls#trustedCA
   */
  readonly trustedCa?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTls(obj: CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'privateKey': obj.privateKey,
    'secret': toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTlsSecret(obj.secret),
    'trustedCA': obj.trustedCa,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToRequiresMatchExpressions
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToRequiresMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToRequiresMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToRequiresMatchExpressions#operator
   */
  readonly operator: CiliumClusterwideNetworkPolicySpecEgressToRequiresMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToRequiresMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToRequiresMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToRequiresMatchExpressions(obj: CiliumClusterwideNetworkPolicySpecEgressToRequiresMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * K8sService selects service by name and namespace pair
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToServicesK8SService
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToServicesK8SService {
  /**
   * @schema CiliumClusterwideNetworkPolicySpecEgressToServicesK8SService#namespace
   */
  readonly namespace?: string;

  /**
   * @schema CiliumClusterwideNetworkPolicySpecEgressToServicesK8SService#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToServicesK8SService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToServicesK8SService(obj: CiliumClusterwideNetworkPolicySpecEgressToServicesK8SService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespace': obj.namespace,
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * K8sServiceSelector selects services by k8s labels and namespace
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelector
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelector {
  /**
   * @schema CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelector#namespace
   */
  readonly namespace?: string;

  /**
   * ServiceSelector is a label selector for k8s services
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelector#selector
   */
  readonly selector: CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelectorSelector;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelector(obj: CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespace': obj.namespace,
    'selector': toJson_CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelectorSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPField is a ICMP field.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressDenyIcmpsFields
 */
export interface CiliumClusterwideNetworkPolicySpecEgressDenyIcmpsFields {
  /**
   * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyIcmpsFields#family
   */
  readonly family?: CiliumClusterwideNetworkPolicySpecEgressDenyIcmpsFieldsFamily;

  /**
   * Type is a ICMP-type. It should be 0-255 (8bit).
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyIcmpsFields#type
   */
  readonly type: number;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressDenyIcmpsFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressDenyIcmpsFields(obj: CiliumClusterwideNetworkPolicySpecEgressDenyIcmpsFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'family': obj.family,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToEndpointsMatchExpressions
 */
export interface CiliumClusterwideNetworkPolicySpecEgressDenyToEndpointsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToEndpointsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToEndpointsMatchExpressions#operator
   */
  readonly operator: CiliumClusterwideNetworkPolicySpecEgressDenyToEndpointsMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToEndpointsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressDenyToEndpointsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToEndpointsMatchExpressions(obj: CiliumClusterwideNetworkPolicySpecEgressDenyToEndpointsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSGroup is an structure that can be used to whitelisting information from AWS integration
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToGroupsAws
 */
export interface CiliumClusterwideNetworkPolicySpecEgressDenyToGroupsAws {
  /**
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToGroupsAws#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToGroupsAws#region
   */
  readonly region?: string;

  /**
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToGroupsAws#securityGroupsIds
   */
  readonly securityGroupsIds?: string[];

  /**
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToGroupsAws#securityGroupsNames
   */
  readonly securityGroupsNames?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressDenyToGroupsAws' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToGroupsAws(obj: CiliumClusterwideNetworkPolicySpecEgressDenyToGroupsAws | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'region': obj.region,
    'securityGroupsIds': obj.securityGroupsIds?.map(y => y),
    'securityGroupsNames': obj.securityGroupsNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortProtocol specifies an L4 port with an optional transport protocol
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToPortsPorts
 */
export interface CiliumClusterwideNetworkPolicySpecEgressDenyToPortsPorts {
  /**
   * Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form "1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToPortsPorts#port
   */
  readonly port: string;

  /**
   * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
   * Matching on ICMP is not supported.
   * Named port specified for a container may narrow this down, but may not contradict this.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToPortsPorts#protocol
   */
  readonly protocol?: CiliumClusterwideNetworkPolicySpecEgressDenyToPortsPortsProtocol;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressDenyToPortsPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToPortsPorts(obj: CiliumClusterwideNetworkPolicySpecEgressDenyToPortsPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToRequiresMatchExpressions
 */
export interface CiliumClusterwideNetworkPolicySpecEgressDenyToRequiresMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToRequiresMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToRequiresMatchExpressions#operator
   */
  readonly operator: CiliumClusterwideNetworkPolicySpecEgressDenyToRequiresMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToRequiresMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressDenyToRequiresMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToRequiresMatchExpressions(obj: CiliumClusterwideNetworkPolicySpecEgressDenyToRequiresMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * K8sService selects service by name and namespace pair
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SService
 */
export interface CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SService {
  /**
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SService#namespace
   */
  readonly namespace?: string;

  /**
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SService#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SService(obj: CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespace': obj.namespace,
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * K8sServiceSelector selects services by k8s labels and namespace
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelector
 */
export interface CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelector {
  /**
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelector#namespace
   */
  readonly namespace?: string;

  /**
   * ServiceSelector is a label selector for k8s services
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelector#selector
   */
  readonly selector: CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelector;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelector(obj: CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespace': obj.namespace,
    'selector': toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEndpointSelectorMatchExpressionsOperator
 */
export enum CiliumClusterwideNetworkPolicySpecEndpointSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * Mode is the required authentication mode for the allowed traffic, if any.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressAuthenticationMode
 */
export enum CiliumClusterwideNetworkPolicySpecIngressAuthenticationMode {
  /** disabled */
  DISABLED = "disabled",
  /** required */
  REQUIRED = "required",
  /** test-always-fail */
  TEST_HYPHEN_ALWAYS_HYPHEN_FAIL = "test-always-fail",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressFromEndpointsMatchExpressions
 */
export interface CiliumClusterwideNetworkPolicySpecIngressFromEndpointsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressFromEndpointsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressFromEndpointsMatchExpressions#operator
   */
  readonly operator: CiliumClusterwideNetworkPolicySpecIngressFromEndpointsMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressFromEndpointsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressFromEndpointsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressFromEndpointsMatchExpressions(obj: CiliumClusterwideNetworkPolicySpecIngressFromEndpointsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressFromRequiresMatchExpressions
 */
export interface CiliumClusterwideNetworkPolicySpecIngressFromRequiresMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressFromRequiresMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressFromRequiresMatchExpressions#operator
   */
  readonly operator: CiliumClusterwideNetworkPolicySpecIngressFromRequiresMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressFromRequiresMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressFromRequiresMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressFromRequiresMatchExpressions(obj: CiliumClusterwideNetworkPolicySpecIngressFromRequiresMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPField is a ICMP field.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressIcmpsFields
 */
export interface CiliumClusterwideNetworkPolicySpecIngressIcmpsFields {
  /**
   * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressIcmpsFields#family
   */
  readonly family?: CiliumClusterwideNetworkPolicySpecIngressIcmpsFieldsFamily;

  /**
   * Type is a ICMP-type. It should be 0-255 (8bit).
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressIcmpsFields#type
   */
  readonly type: number;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressIcmpsFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressIcmpsFields(obj: CiliumClusterwideNetworkPolicySpecIngressIcmpsFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'family': obj.family,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsListener
 */
export interface CiliumClusterwideNetworkPolicySpecIngressToPortsListener {
  /**
   * EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsListener#envoyConfig
   */
  readonly envoyConfig: CiliumClusterwideNetworkPolicySpecIngressToPortsListenerEnvoyConfig;

  /**
   * Name is the name of the listener.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsListener#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressToPortsListener' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsListener(obj: CiliumClusterwideNetworkPolicySpecIngressToPortsListener | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'envoyConfig': toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsListenerEnvoyConfig(obj.envoyConfig),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTls
 */
export interface CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTls {
  /**
   * Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTls#certificate
   */
  readonly certificate?: string;

  /**
   * PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTls#secret
   */
  readonly secret: CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTlsSecret;

  /**
   * TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTls#trustedCA
   */
  readonly trustedCa?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTls(obj: CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'privateKey': obj.privateKey,
    'secret': toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTlsSecret(obj.secret),
    'trustedCA': obj.trustedCa,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortProtocol specifies an L4 port with an optional transport protocol
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsPorts
 */
export interface CiliumClusterwideNetworkPolicySpecIngressToPortsPorts {
  /**
   * Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form "1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsPorts#port
   */
  readonly port: string;

  /**
   * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
   * Matching on ICMP is not supported.
   * Named port specified for a container may narrow this down, but may not contradict this.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsPorts#protocol
   */
  readonly protocol?: CiliumClusterwideNetworkPolicySpecIngressToPortsPortsProtocol;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressToPortsPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsPorts(obj: CiliumClusterwideNetworkPolicySpecIngressToPortsPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRules
 */
export interface CiliumClusterwideNetworkPolicySpecIngressToPortsRules {
  /**
   * DNS-specific rules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRules#dns
   */
  readonly dns?: CiliumClusterwideNetworkPolicySpecIngressToPortsRulesDns[];

  /**
   * HTTP specific rules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRules#http
   */
  readonly http?: CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttp[];

  /**
   * Kafka-specific rules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRules#kafka
   */
  readonly kafka?: CiliumClusterwideNetworkPolicySpecIngressToPortsRulesKafka[];

  /**
   * Key-value pair rules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRules#l7
   */
  readonly l7?: { [key: string]: string }[];

  /**
   * Name of the L7 protocol for which the Key-value pair rules apply.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRules#l7proto
   */
  readonly l7Proto?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressToPortsRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsRules(obj: CiliumClusterwideNetworkPolicySpecIngressToPortsRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dns': obj.dns?.map(y => toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsRulesDns(y)),
    'http': obj.http?.map(y => toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttp(y)),
    'kafka': obj.kafka?.map(y => toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsRulesKafka(y)),
    'l7': obj.l7?.map(y => ((y) === undefined) ? undefined : (Object.entries(y).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {}))),
    'l7proto': obj.l7Proto,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTls
 */
export interface CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTls {
  /**
   * Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTls#certificate
   */
  readonly certificate?: string;

  /**
   * PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTls#secret
   */
  readonly secret: CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTlsSecret;

  /**
   * TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTls#trustedCA
   */
  readonly trustedCa?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTls(obj: CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'privateKey': obj.privateKey,
    'secret': toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTlsSecret(obj.secret),
    'trustedCA': obj.trustedCa,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpointsMatchExpressions
 */
export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpointsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpointsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpointsMatchExpressions#operator
   */
  readonly operator: CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpointsMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpointsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpointsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpointsMatchExpressions(obj: CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpointsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressDenyFromRequiresMatchExpressions
 */
export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromRequiresMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDenyFromRequiresMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDenyFromRequiresMatchExpressions#operator
   */
  readonly operator: CiliumClusterwideNetworkPolicySpecIngressDenyFromRequiresMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDenyFromRequiresMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressDenyFromRequiresMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressDenyFromRequiresMatchExpressions(obj: CiliumClusterwideNetworkPolicySpecIngressDenyFromRequiresMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPField is a ICMP field.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressDenyIcmpsFields
 */
export interface CiliumClusterwideNetworkPolicySpecIngressDenyIcmpsFields {
  /**
   * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDenyIcmpsFields#family
   */
  readonly family?: CiliumClusterwideNetworkPolicySpecIngressDenyIcmpsFieldsFamily;

  /**
   * Type is a ICMP-type. It should be 0-255 (8bit).
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDenyIcmpsFields#type
   */
  readonly type: number;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressDenyIcmpsFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressDenyIcmpsFields(obj: CiliumClusterwideNetworkPolicySpecIngressDenyIcmpsFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'family': obj.family,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortProtocol specifies an L4 port with an optional transport protocol
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressDenyToPortsPorts
 */
export interface CiliumClusterwideNetworkPolicySpecIngressDenyToPortsPorts {
  /**
   * Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form "1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDenyToPortsPorts#port
   */
  readonly port: string;

  /**
   * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
   * Matching on ICMP is not supported.
   * Named port specified for a container may narrow this down, but may not contradict this.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressDenyToPortsPorts#protocol
   */
  readonly protocol?: CiliumClusterwideNetworkPolicySpecIngressDenyToPortsPortsProtocol;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressDenyToPortsPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressDenyToPortsPorts(obj: CiliumClusterwideNetworkPolicySpecIngressDenyToPortsPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumClusterwideNetworkPolicySpecNodeSelectorMatchExpressionsOperator
 */
export enum CiliumClusterwideNetworkPolicySpecNodeSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * Mode is the required authentication mode for the allowed traffic, if any.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressAuthenticationMode
 */
export enum CiliumClusterwideNetworkPolicySpecsEgressAuthenticationMode {
  /** disabled */
  DISABLED = "disabled",
  /** required */
  REQUIRED = "required",
  /** test-always-fail */
  TEST_HYPHEN_ALWAYS_HYPHEN_FAIL = "test-always-fail",
}

/**
 * ICMPField is a ICMP field.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressIcmpsFields
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressIcmpsFields {
  /**
   * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressIcmpsFields#family
   */
  readonly family?: CiliumClusterwideNetworkPolicySpecsEgressIcmpsFieldsFamily;

  /**
   * Type is a ICMP-type. It should be 0-255 (8bit).
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressIcmpsFields#type
   */
  readonly type: number;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressIcmpsFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressIcmpsFields(obj: CiliumClusterwideNetworkPolicySpecsEgressIcmpsFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'family': obj.family,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToEndpointsMatchExpressions
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToEndpointsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToEndpointsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToEndpointsMatchExpressions#operator
   */
  readonly operator: CiliumClusterwideNetworkPolicySpecsEgressToEndpointsMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToEndpointsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToEndpointsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToEndpointsMatchExpressions(obj: CiliumClusterwideNetworkPolicySpecsEgressToEndpointsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSGroup is an structure that can be used to whitelisting information from AWS integration
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToGroupsAws
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToGroupsAws {
  /**
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToGroupsAws#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToGroupsAws#region
   */
  readonly region?: string;

  /**
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToGroupsAws#securityGroupsIds
   */
  readonly securityGroupsIds?: string[];

  /**
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToGroupsAws#securityGroupsNames
   */
  readonly securityGroupsNames?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToGroupsAws' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToGroupsAws(obj: CiliumClusterwideNetworkPolicySpecsEgressToGroupsAws | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'region': obj.region,
    'securityGroupsIds': obj.securityGroupsIds?.map(y => y),
    'securityGroupsNames': obj.securityGroupsNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsListener
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsListener {
  /**
   * EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsListener#envoyConfig
   */
  readonly envoyConfig: CiliumClusterwideNetworkPolicySpecsEgressToPortsListenerEnvoyConfig;

  /**
   * Name is the name of the listener.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsListener#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToPortsListener' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsListener(obj: CiliumClusterwideNetworkPolicySpecsEgressToPortsListener | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'envoyConfig': toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsListenerEnvoyConfig(obj.envoyConfig),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTls
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTls {
  /**
   * Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTls#certificate
   */
  readonly certificate?: string;

  /**
   * PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTls#secret
   */
  readonly secret: CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTlsSecret;

  /**
   * TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTls#trustedCA
   */
  readonly trustedCa?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTls(obj: CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'privateKey': obj.privateKey,
    'secret': toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTlsSecret(obj.secret),
    'trustedCA': obj.trustedCa,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortProtocol specifies an L4 port with an optional transport protocol
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsPorts
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsPorts {
  /**
   * Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form "1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsPorts#port
   */
  readonly port: string;

  /**
   * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
   * Matching on ICMP is not supported.
   * Named port specified for a container may narrow this down, but may not contradict this.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsPorts#protocol
   */
  readonly protocol?: CiliumClusterwideNetworkPolicySpecsEgressToPortsPortsProtocol;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToPortsPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsPorts(obj: CiliumClusterwideNetworkPolicySpecsEgressToPortsPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRules
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsRules {
  /**
   * DNS-specific rules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRules#dns
   */
  readonly dns?: CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesDns[];

  /**
   * HTTP specific rules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRules#http
   */
  readonly http?: CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttp[];

  /**
   * Kafka-specific rules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRules#kafka
   */
  readonly kafka?: CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesKafka[];

  /**
   * Key-value pair rules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRules#l7
   */
  readonly l7?: { [key: string]: string }[];

  /**
   * Name of the L7 protocol for which the Key-value pair rules apply.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRules#l7proto
   */
  readonly l7Proto?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToPortsRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsRules(obj: CiliumClusterwideNetworkPolicySpecsEgressToPortsRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dns': obj.dns?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesDns(y)),
    'http': obj.http?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttp(y)),
    'kafka': obj.kafka?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesKafka(y)),
    'l7': obj.l7?.map(y => ((y) === undefined) ? undefined : (Object.entries(y).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {}))),
    'l7proto': obj.l7Proto,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTls
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTls {
  /**
   * Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTls#certificate
   */
  readonly certificate?: string;

  /**
   * PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTls#secret
   */
  readonly secret: CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTlsSecret;

  /**
   * TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTls#trustedCA
   */
  readonly trustedCa?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTls(obj: CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'privateKey': obj.privateKey,
    'secret': toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTlsSecret(obj.secret),
    'trustedCA': obj.trustedCa,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToRequiresMatchExpressions
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToRequiresMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToRequiresMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToRequiresMatchExpressions#operator
   */
  readonly operator: CiliumClusterwideNetworkPolicySpecsEgressToRequiresMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToRequiresMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToRequiresMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToRequiresMatchExpressions(obj: CiliumClusterwideNetworkPolicySpecsEgressToRequiresMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * K8sService selects service by name and namespace pair
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SService
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SService {
  /**
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SService#namespace
   */
  readonly namespace?: string;

  /**
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SService#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SService(obj: CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespace': obj.namespace,
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * K8sServiceSelector selects services by k8s labels and namespace
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelector
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelector {
  /**
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelector#namespace
   */
  readonly namespace?: string;

  /**
   * ServiceSelector is a label selector for k8s services
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelector#selector
   */
  readonly selector: CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelector;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelector(obj: CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespace': obj.namespace,
    'selector': toJson_CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPField is a ICMP field.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyIcmpsFields
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressDenyIcmpsFields {
  /**
   * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyIcmpsFields#family
   */
  readonly family?: CiliumClusterwideNetworkPolicySpecsEgressDenyIcmpsFieldsFamily;

  /**
   * Type is a ICMP-type. It should be 0-255 (8bit).
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyIcmpsFields#type
   */
  readonly type: number;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressDenyIcmpsFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyIcmpsFields(obj: CiliumClusterwideNetworkPolicySpecsEgressDenyIcmpsFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'family': obj.family,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpointsMatchExpressions
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpointsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpointsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpointsMatchExpressions#operator
   */
  readonly operator: CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpointsMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpointsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpointsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpointsMatchExpressions(obj: CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpointsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSGroup is an structure that can be used to whitelisting information from AWS integration
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToGroupsAws
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToGroupsAws {
  /**
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToGroupsAws#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToGroupsAws#region
   */
  readonly region?: string;

  /**
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToGroupsAws#securityGroupsIds
   */
  readonly securityGroupsIds?: string[];

  /**
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToGroupsAws#securityGroupsNames
   */
  readonly securityGroupsNames?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressDenyToGroupsAws' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToGroupsAws(obj: CiliumClusterwideNetworkPolicySpecsEgressDenyToGroupsAws | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'region': obj.region,
    'securityGroupsIds': obj.securityGroupsIds?.map(y => y),
    'securityGroupsNames': obj.securityGroupsNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortProtocol specifies an L4 port with an optional transport protocol
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToPortsPorts
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToPortsPorts {
  /**
   * Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form "1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToPortsPorts#port
   */
  readonly port: string;

  /**
   * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
   * Matching on ICMP is not supported.
   * Named port specified for a container may narrow this down, but may not contradict this.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToPortsPorts#protocol
   */
  readonly protocol?: CiliumClusterwideNetworkPolicySpecsEgressDenyToPortsPortsProtocol;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressDenyToPortsPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToPortsPorts(obj: CiliumClusterwideNetworkPolicySpecsEgressDenyToPortsPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToRequiresMatchExpressions
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToRequiresMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToRequiresMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToRequiresMatchExpressions#operator
   */
  readonly operator: CiliumClusterwideNetworkPolicySpecsEgressDenyToRequiresMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToRequiresMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressDenyToRequiresMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToRequiresMatchExpressions(obj: CiliumClusterwideNetworkPolicySpecsEgressDenyToRequiresMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * K8sService selects service by name and namespace pair
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SService
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SService {
  /**
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SService#namespace
   */
  readonly namespace?: string;

  /**
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SService#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SService(obj: CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespace': obj.namespace,
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * K8sServiceSelector selects services by k8s labels and namespace
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelector
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelector {
  /**
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelector#namespace
   */
  readonly namespace?: string;

  /**
   * ServiceSelector is a label selector for k8s services
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelector#selector
   */
  readonly selector: CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelector;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelector(obj: CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespace': obj.namespace,
    'selector': toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEndpointSelectorMatchExpressionsOperator
 */
export enum CiliumClusterwideNetworkPolicySpecsEndpointSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * Mode is the required authentication mode for the allowed traffic, if any.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressAuthenticationMode
 */
export enum CiliumClusterwideNetworkPolicySpecsIngressAuthenticationMode {
  /** disabled */
  DISABLED = "disabled",
  /** required */
  REQUIRED = "required",
  /** test-always-fail */
  TEST_HYPHEN_ALWAYS_HYPHEN_FAIL = "test-always-fail",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressFromEndpointsMatchExpressions
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressFromEndpointsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressFromEndpointsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressFromEndpointsMatchExpressions#operator
   */
  readonly operator: CiliumClusterwideNetworkPolicySpecsIngressFromEndpointsMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressFromEndpointsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressFromEndpointsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressFromEndpointsMatchExpressions(obj: CiliumClusterwideNetworkPolicySpecsIngressFromEndpointsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressFromRequiresMatchExpressions
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressFromRequiresMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressFromRequiresMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressFromRequiresMatchExpressions#operator
   */
  readonly operator: CiliumClusterwideNetworkPolicySpecsIngressFromRequiresMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressFromRequiresMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressFromRequiresMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressFromRequiresMatchExpressions(obj: CiliumClusterwideNetworkPolicySpecsIngressFromRequiresMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPField is a ICMP field.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressIcmpsFields
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressIcmpsFields {
  /**
   * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressIcmpsFields#family
   */
  readonly family?: CiliumClusterwideNetworkPolicySpecsIngressIcmpsFieldsFamily;

  /**
   * Type is a ICMP-type. It should be 0-255 (8bit).
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressIcmpsFields#type
   */
  readonly type: number;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressIcmpsFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressIcmpsFields(obj: CiliumClusterwideNetworkPolicySpecsIngressIcmpsFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'family': obj.family,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsListener
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsListener {
  /**
   * EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsListener#envoyConfig
   */
  readonly envoyConfig: CiliumClusterwideNetworkPolicySpecsIngressToPortsListenerEnvoyConfig;

  /**
   * Name is the name of the listener.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsListener#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressToPortsListener' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsListener(obj: CiliumClusterwideNetworkPolicySpecsIngressToPortsListener | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'envoyConfig': toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsListenerEnvoyConfig(obj.envoyConfig),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTls
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTls {
  /**
   * Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTls#certificate
   */
  readonly certificate?: string;

  /**
   * PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTls#secret
   */
  readonly secret: CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTlsSecret;

  /**
   * TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTls#trustedCA
   */
  readonly trustedCa?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTls(obj: CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'privateKey': obj.privateKey,
    'secret': toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTlsSecret(obj.secret),
    'trustedCA': obj.trustedCa,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortProtocol specifies an L4 port with an optional transport protocol
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsPorts
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsPorts {
  /**
   * Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form "1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsPorts#port
   */
  readonly port: string;

  /**
   * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
   * Matching on ICMP is not supported.
   * Named port specified for a container may narrow this down, but may not contradict this.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsPorts#protocol
   */
  readonly protocol?: CiliumClusterwideNetworkPolicySpecsIngressToPortsPortsProtocol;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressToPortsPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsPorts(obj: CiliumClusterwideNetworkPolicySpecsIngressToPortsPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRules
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsRules {
  /**
   * DNS-specific rules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRules#dns
   */
  readonly dns?: CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesDns[];

  /**
   * HTTP specific rules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRules#http
   */
  readonly http?: CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttp[];

  /**
   * Kafka-specific rules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRules#kafka
   */
  readonly kafka?: CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesKafka[];

  /**
   * Key-value pair rules.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRules#l7
   */
  readonly l7?: { [key: string]: string }[];

  /**
   * Name of the L7 protocol for which the Key-value pair rules apply.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRules#l7proto
   */
  readonly l7Proto?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressToPortsRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsRules(obj: CiliumClusterwideNetworkPolicySpecsIngressToPortsRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dns': obj.dns?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesDns(y)),
    'http': obj.http?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttp(y)),
    'kafka': obj.kafka?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesKafka(y)),
    'l7': obj.l7?.map(y => ((y) === undefined) ? undefined : (Object.entries(y).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {}))),
    'l7proto': obj.l7Proto,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTls
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTls {
  /**
   * Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTls#certificate
   */
  readonly certificate?: string;

  /**
   * PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTls#secret
   */
  readonly secret: CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTlsSecret;

  /**
   * TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTls#trustedCA
   */
  readonly trustedCa?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTls(obj: CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'privateKey': obj.privateKey,
    'secret': toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTlsSecret(obj.secret),
    'trustedCA': obj.trustedCa,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressions
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressions#operator
   */
  readonly operator: CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressions(obj: CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequiresMatchExpressions
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequiresMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequiresMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequiresMatchExpressions#operator
   */
  readonly operator: CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequiresMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequiresMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequiresMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequiresMatchExpressions(obj: CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequiresMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPField is a ICMP field.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyIcmpsFields
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressDenyIcmpsFields {
  /**
   * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyIcmpsFields#family
   */
  readonly family?: CiliumClusterwideNetworkPolicySpecsIngressDenyIcmpsFieldsFamily;

  /**
   * Type is a ICMP-type. It should be 0-255 (8bit).
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyIcmpsFields#type
   */
  readonly type: number;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressDenyIcmpsFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressDenyIcmpsFields(obj: CiliumClusterwideNetworkPolicySpecsIngressDenyIcmpsFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'family': obj.family,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortProtocol specifies an L4 port with an optional transport protocol
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyToPortsPorts
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressDenyToPortsPorts {
  /**
   * Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form "1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyToPortsPorts#port
   */
  readonly port: string;

  /**
   * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
   * Matching on ICMP is not supported.
   * Named port specified for a container may narrow this down, but may not contradict this.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyToPortsPorts#protocol
   */
  readonly protocol?: CiliumClusterwideNetworkPolicySpecsIngressDenyToPortsPortsProtocol;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressDenyToPortsPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressDenyToPortsPorts(obj: CiliumClusterwideNetworkPolicySpecsIngressDenyToPortsPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsNodeSelectorMatchExpressionsOperator
 */
export enum CiliumClusterwideNetworkPolicySpecsNodeSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressIcmpsFieldsFamily
 */
export enum CiliumClusterwideNetworkPolicySpecEgressIcmpsFieldsFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToEndpointsMatchExpressionsOperator
 */
export enum CiliumClusterwideNetworkPolicySpecEgressToEndpointsMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsListenerEnvoyConfig
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToPortsListenerEnvoyConfig {
  /**
   * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
   *
   * @default CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsListenerEnvoyConfig#kind
   */
  readonly kind?: CiliumClusterwideNetworkPolicySpecEgressToPortsListenerEnvoyConfigKind;

  /**
   * Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where the listener is defined in.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsListenerEnvoyConfig#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToPortsListenerEnvoyConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsListenerEnvoyConfig(obj: CiliumClusterwideNetworkPolicySpecEgressToPortsListenerEnvoyConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTlsSecret
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTlsSecret {
  /**
   * Name is the name of the secret.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTlsSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., "default").
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTlsSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTlsSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTlsSecret(obj: CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTlsSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
 * Matching on ICMP is not supported.
 * Named port specified for a container may narrow this down, but may not contradict this.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsPortsProtocol
 */
export enum CiliumClusterwideNetworkPolicySpecEgressToPortsPortsProtocol {
  /** TCP */
  TCP = "TCP",
  /** UDP */
  UDP = "UDP",
  /** SCTP */
  SCTP = "SCTP",
  /** ANY */
  ANY = "ANY",
}

/**
 * PortRuleDNS is a list of allowed DNS lookups.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesDns
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToPortsRulesDns {
  /**
   * MatchName matches literal DNS names. A trailing "." is automatically added when missing.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesDns#matchName
   */
  readonly matchName?: string;

  /**
   * MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - "*" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a "*" as the leftmost character, without a following "." matches all subdomains as well as the name to the right. A trailing "." is automatically added when missing.
   * Examples: `*.cilium.io` matches subomains of cilium at that level www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io" except those containing "." separator, subcilium.io and sub-cilium.io match, www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with "sub" sub.cilium.io and subdomain.cilium.io match, www.cilium.io, blog.cilium.io, cilium.io and google.com do not
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesDns#matchPattern
   */
  readonly matchPattern?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToPortsRulesDns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsRulesDns(obj: CiliumClusterwideNetworkPolicySpecEgressToPortsRulesDns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchName': obj.matchName,
    'matchPattern': obj.matchPattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortRuleHTTP is a list of HTTP protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect.
 * All fields of this type are extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional "path" part of a URL as defined by RFC 3986.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttp
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttp {
  /**
   * HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttp#headerMatches
   */
  readonly headerMatches?: CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches[];

  /**
   * Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttp#headers
   */
  readonly headers?: string[];

  /**
   * Host is an extended POSIX regex matched against the host header of a request, e.g. "foo.com"
   * If omitted or empty, the value of the host header is ignored.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttp#host
   */
  readonly host?: string;

  /**
   * Method is an extended POSIX regex matched against the method of a request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
   * If omitted or empty, all methods are allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttp#method
   */
  readonly method?: string;

  /**
   * Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional "path" part of a URL as defined by RFC 3986.
   * If omitted or empty, all paths are all allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttp#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttp(obj: CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerMatches': obj.headerMatches?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches(y)),
    'headers': obj.headers?.map(y => y),
    'host': obj.host,
    'method': obj.method,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortRule is a list of Kafka protocol constraints. All fields are optional, if all fields are empty or missing, the rule will match all Kafka messages.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesKafka
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToPortsRulesKafka {
  /**
   * APIKey is a case-insensitive string matched against the key of a request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys
   * If omitted or empty, and if Role is not specified, then all keys are allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesKafka#apiKey
   */
  readonly apiKey?: string;

  /**
   * APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer.
   * If omitted or empty, all versions are allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesKafka#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * ClientID is the client identifier as provided in the request.
   * From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client.
   * If omitted or empty, all client identifiers are allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesKafka#clientID
   */
  readonly clientId?: string;

  /**
   * Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as "produce" or "consume". A Role automatically expands into all APIKeys required to perform the specified higher-level operation.
   * The following values are supported: - "produce": Allow producing to the topics specified in the rule - "consume": Allow consuming from the topics specified in the rule
   * This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule.
   * If omitted or empty, and if APIKey is not specified, then all keys are allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesKafka#role
   */
  readonly role?: CiliumClusterwideNetworkPolicySpecEgressToPortsRulesKafkaRole;

  /**
   * Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected.
   * This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _.
   * Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255.
   * If omitted or empty, all topics are allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesKafka#topic
   */
  readonly topic?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToPortsRulesKafka' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsRulesKafka(obj: CiliumClusterwideNetworkPolicySpecEgressToPortsRulesKafka | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': obj.apiKey,
    'apiVersion': obj.apiVersion,
    'clientID': obj.clientId,
    'role': obj.role,
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTlsSecret
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTlsSecret {
  /**
   * Name is the name of the secret.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTlsSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., "default").
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTlsSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTlsSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTlsSecret(obj: CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTlsSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToRequiresMatchExpressionsOperator
 */
export enum CiliumClusterwideNetworkPolicySpecEgressToRequiresMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * ServiceSelector is a label selector for k8s services
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelectorSelector
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelectorSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelectorSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelectorSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelectorSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelectorSelector(obj: CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelectorSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressDenyIcmpsFieldsFamily
 */
export enum CiliumClusterwideNetworkPolicySpecEgressDenyIcmpsFieldsFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToEndpointsMatchExpressionsOperator
 */
export enum CiliumClusterwideNetworkPolicySpecEgressDenyToEndpointsMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
 * Matching on ICMP is not supported.
 * Named port specified for a container may narrow this down, but may not contradict this.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToPortsPortsProtocol
 */
export enum CiliumClusterwideNetworkPolicySpecEgressDenyToPortsPortsProtocol {
  /** TCP */
  TCP = "TCP",
  /** UDP */
  UDP = "UDP",
  /** SCTP */
  SCTP = "SCTP",
  /** ANY */
  ANY = "ANY",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToRequiresMatchExpressionsOperator
 */
export enum CiliumClusterwideNetworkPolicySpecEgressDenyToRequiresMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * ServiceSelector is a label selector for k8s services
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelector
 */
export interface CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelector(obj: CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressFromEndpointsMatchExpressionsOperator
 */
export enum CiliumClusterwideNetworkPolicySpecIngressFromEndpointsMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressFromRequiresMatchExpressionsOperator
 */
export enum CiliumClusterwideNetworkPolicySpecIngressFromRequiresMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressIcmpsFieldsFamily
 */
export enum CiliumClusterwideNetworkPolicySpecIngressIcmpsFieldsFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsListenerEnvoyConfig
 */
export interface CiliumClusterwideNetworkPolicySpecIngressToPortsListenerEnvoyConfig {
  /**
   * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
   *
   * @default CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsListenerEnvoyConfig#kind
   */
  readonly kind?: CiliumClusterwideNetworkPolicySpecIngressToPortsListenerEnvoyConfigKind;

  /**
   * Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where the listener is defined in.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsListenerEnvoyConfig#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressToPortsListenerEnvoyConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsListenerEnvoyConfig(obj: CiliumClusterwideNetworkPolicySpecIngressToPortsListenerEnvoyConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTlsSecret
 */
export interface CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTlsSecret {
  /**
   * Name is the name of the secret.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTlsSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., "default").
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTlsSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTlsSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTlsSecret(obj: CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTlsSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
 * Matching on ICMP is not supported.
 * Named port specified for a container may narrow this down, but may not contradict this.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsPortsProtocol
 */
export enum CiliumClusterwideNetworkPolicySpecIngressToPortsPortsProtocol {
  /** TCP */
  TCP = "TCP",
  /** UDP */
  UDP = "UDP",
  /** SCTP */
  SCTP = "SCTP",
  /** ANY */
  ANY = "ANY",
}

/**
 * PortRuleDNS is a list of allowed DNS lookups.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesDns
 */
export interface CiliumClusterwideNetworkPolicySpecIngressToPortsRulesDns {
  /**
   * MatchName matches literal DNS names. A trailing "." is automatically added when missing.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesDns#matchName
   */
  readonly matchName?: string;

  /**
   * MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - "*" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a "*" as the leftmost character, without a following "." matches all subdomains as well as the name to the right. A trailing "." is automatically added when missing.
   * Examples: `*.cilium.io` matches subomains of cilium at that level www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io" except those containing "." separator, subcilium.io and sub-cilium.io match, www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with "sub" sub.cilium.io and subdomain.cilium.io match, www.cilium.io, blog.cilium.io, cilium.io and google.com do not
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesDns#matchPattern
   */
  readonly matchPattern?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressToPortsRulesDns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsRulesDns(obj: CiliumClusterwideNetworkPolicySpecIngressToPortsRulesDns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchName': obj.matchName,
    'matchPattern': obj.matchPattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortRuleHTTP is a list of HTTP protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect.
 * All fields of this type are extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional "path" part of a URL as defined by RFC 3986.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttp
 */
export interface CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttp {
  /**
   * HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttp#headerMatches
   */
  readonly headerMatches?: CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches[];

  /**
   * Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttp#headers
   */
  readonly headers?: string[];

  /**
   * Host is an extended POSIX regex matched against the host header of a request, e.g. "foo.com"
   * If omitted or empty, the value of the host header is ignored.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttp#host
   */
  readonly host?: string;

  /**
   * Method is an extended POSIX regex matched against the method of a request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
   * If omitted or empty, all methods are allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttp#method
   */
  readonly method?: string;

  /**
   * Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional "path" part of a URL as defined by RFC 3986.
   * If omitted or empty, all paths are all allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttp#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttp(obj: CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerMatches': obj.headerMatches?.map(y => toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches(y)),
    'headers': obj.headers?.map(y => y),
    'host': obj.host,
    'method': obj.method,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortRule is a list of Kafka protocol constraints. All fields are optional, if all fields are empty or missing, the rule will match all Kafka messages.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesKafka
 */
export interface CiliumClusterwideNetworkPolicySpecIngressToPortsRulesKafka {
  /**
   * APIKey is a case-insensitive string matched against the key of a request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys
   * If omitted or empty, and if Role is not specified, then all keys are allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesKafka#apiKey
   */
  readonly apiKey?: string;

  /**
   * APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer.
   * If omitted or empty, all versions are allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesKafka#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * ClientID is the client identifier as provided in the request.
   * From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client.
   * If omitted or empty, all client identifiers are allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesKafka#clientID
   */
  readonly clientId?: string;

  /**
   * Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as "produce" or "consume". A Role automatically expands into all APIKeys required to perform the specified higher-level operation.
   * The following values are supported: - "produce": Allow producing to the topics specified in the rule - "consume": Allow consuming from the topics specified in the rule
   * This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule.
   * If omitted or empty, and if APIKey is not specified, then all keys are allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesKafka#role
   */
  readonly role?: CiliumClusterwideNetworkPolicySpecIngressToPortsRulesKafkaRole;

  /**
   * Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected.
   * This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _.
   * Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255.
   * If omitted or empty, all topics are allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesKafka#topic
   */
  readonly topic?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressToPortsRulesKafka' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsRulesKafka(obj: CiliumClusterwideNetworkPolicySpecIngressToPortsRulesKafka | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': obj.apiKey,
    'apiVersion': obj.apiVersion,
    'clientID': obj.clientId,
    'role': obj.role,
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTlsSecret
 */
export interface CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTlsSecret {
  /**
   * Name is the name of the secret.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTlsSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., "default").
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTlsSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTlsSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTlsSecret(obj: CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTlsSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpointsMatchExpressionsOperator
 */
export enum CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpointsMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressDenyFromRequiresMatchExpressionsOperator
 */
export enum CiliumClusterwideNetworkPolicySpecIngressDenyFromRequiresMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressDenyIcmpsFieldsFamily
 */
export enum CiliumClusterwideNetworkPolicySpecIngressDenyIcmpsFieldsFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
 * Matching on ICMP is not supported.
 * Named port specified for a container may narrow this down, but may not contradict this.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressDenyToPortsPortsProtocol
 */
export enum CiliumClusterwideNetworkPolicySpecIngressDenyToPortsPortsProtocol {
  /** TCP */
  TCP = "TCP",
  /** UDP */
  UDP = "UDP",
  /** SCTP */
  SCTP = "SCTP",
  /** ANY */
  ANY = "ANY",
}

/**
 * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressIcmpsFieldsFamily
 */
export enum CiliumClusterwideNetworkPolicySpecsEgressIcmpsFieldsFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToEndpointsMatchExpressionsOperator
 */
export enum CiliumClusterwideNetworkPolicySpecsEgressToEndpointsMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsListenerEnvoyConfig
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsListenerEnvoyConfig {
  /**
   * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
   *
   * @default CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsListenerEnvoyConfig#kind
   */
  readonly kind?: CiliumClusterwideNetworkPolicySpecsEgressToPortsListenerEnvoyConfigKind;

  /**
   * Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where the listener is defined in.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsListenerEnvoyConfig#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToPortsListenerEnvoyConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsListenerEnvoyConfig(obj: CiliumClusterwideNetworkPolicySpecsEgressToPortsListenerEnvoyConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTlsSecret
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTlsSecret {
  /**
   * Name is the name of the secret.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTlsSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., "default").
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTlsSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTlsSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTlsSecret(obj: CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTlsSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
 * Matching on ICMP is not supported.
 * Named port specified for a container may narrow this down, but may not contradict this.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsPortsProtocol
 */
export enum CiliumClusterwideNetworkPolicySpecsEgressToPortsPortsProtocol {
  /** TCP */
  TCP = "TCP",
  /** UDP */
  UDP = "UDP",
  /** SCTP */
  SCTP = "SCTP",
  /** ANY */
  ANY = "ANY",
}

/**
 * PortRuleDNS is a list of allowed DNS lookups.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesDns
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesDns {
  /**
   * MatchName matches literal DNS names. A trailing "." is automatically added when missing.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesDns#matchName
   */
  readonly matchName?: string;

  /**
   * MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - "*" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a "*" as the leftmost character, without a following "." matches all subdomains as well as the name to the right. A trailing "." is automatically added when missing.
   * Examples: `*.cilium.io` matches subomains of cilium at that level www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io" except those containing "." separator, subcilium.io and sub-cilium.io match, www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with "sub" sub.cilium.io and subdomain.cilium.io match, www.cilium.io, blog.cilium.io, cilium.io and google.com do not
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesDns#matchPattern
   */
  readonly matchPattern?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesDns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesDns(obj: CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesDns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchName': obj.matchName,
    'matchPattern': obj.matchPattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortRuleHTTP is a list of HTTP protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect.
 * All fields of this type are extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional "path" part of a URL as defined by RFC 3986.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttp
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttp {
  /**
   * HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttp#headerMatches
   */
  readonly headerMatches?: CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches[];

  /**
   * Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttp#headers
   */
  readonly headers?: string[];

  /**
   * Host is an extended POSIX regex matched against the host header of a request, e.g. "foo.com"
   * If omitted or empty, the value of the host header is ignored.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttp#host
   */
  readonly host?: string;

  /**
   * Method is an extended POSIX regex matched against the method of a request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
   * If omitted or empty, all methods are allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttp#method
   */
  readonly method?: string;

  /**
   * Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional "path" part of a URL as defined by RFC 3986.
   * If omitted or empty, all paths are all allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttp#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttp(obj: CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerMatches': obj.headerMatches?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches(y)),
    'headers': obj.headers?.map(y => y),
    'host': obj.host,
    'method': obj.method,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortRule is a list of Kafka protocol constraints. All fields are optional, if all fields are empty or missing, the rule will match all Kafka messages.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesKafka
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesKafka {
  /**
   * APIKey is a case-insensitive string matched against the key of a request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys
   * If omitted or empty, and if Role is not specified, then all keys are allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesKafka#apiKey
   */
  readonly apiKey?: string;

  /**
   * APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer.
   * If omitted or empty, all versions are allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesKafka#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * ClientID is the client identifier as provided in the request.
   * From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client.
   * If omitted or empty, all client identifiers are allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesKafka#clientID
   */
  readonly clientId?: string;

  /**
   * Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as "produce" or "consume". A Role automatically expands into all APIKeys required to perform the specified higher-level operation.
   * The following values are supported: - "produce": Allow producing to the topics specified in the rule - "consume": Allow consuming from the topics specified in the rule
   * This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule.
   * If omitted or empty, and if APIKey is not specified, then all keys are allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesKafka#role
   */
  readonly role?: CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesKafkaRole;

  /**
   * Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected.
   * This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _.
   * Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255.
   * If omitted or empty, all topics are allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesKafka#topic
   */
  readonly topic?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesKafka' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesKafka(obj: CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesKafka | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': obj.apiKey,
    'apiVersion': obj.apiVersion,
    'clientID': obj.clientId,
    'role': obj.role,
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTlsSecret
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTlsSecret {
  /**
   * Name is the name of the secret.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTlsSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., "default").
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTlsSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTlsSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTlsSecret(obj: CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTlsSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToRequiresMatchExpressionsOperator
 */
export enum CiliumClusterwideNetworkPolicySpecsEgressToRequiresMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * ServiceSelector is a label selector for k8s services
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelector
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelector(obj: CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyIcmpsFieldsFamily
 */
export enum CiliumClusterwideNetworkPolicySpecsEgressDenyIcmpsFieldsFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpointsMatchExpressionsOperator
 */
export enum CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpointsMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
 * Matching on ICMP is not supported.
 * Named port specified for a container may narrow this down, but may not contradict this.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToPortsPortsProtocol
 */
export enum CiliumClusterwideNetworkPolicySpecsEgressDenyToPortsPortsProtocol {
  /** TCP */
  TCP = "TCP",
  /** UDP */
  UDP = "UDP",
  /** SCTP */
  SCTP = "SCTP",
  /** ANY */
  ANY = "ANY",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToRequiresMatchExpressionsOperator
 */
export enum CiliumClusterwideNetworkPolicySpecsEgressDenyToRequiresMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * ServiceSelector is a label selector for k8s services
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelector
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelector(obj: CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressFromEndpointsMatchExpressionsOperator
 */
export enum CiliumClusterwideNetworkPolicySpecsIngressFromEndpointsMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressFromRequiresMatchExpressionsOperator
 */
export enum CiliumClusterwideNetworkPolicySpecsIngressFromRequiresMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressIcmpsFieldsFamily
 */
export enum CiliumClusterwideNetworkPolicySpecsIngressIcmpsFieldsFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsListenerEnvoyConfig
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsListenerEnvoyConfig {
  /**
   * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
   *
   * @default CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsListenerEnvoyConfig#kind
   */
  readonly kind?: CiliumClusterwideNetworkPolicySpecsIngressToPortsListenerEnvoyConfigKind;

  /**
   * Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where the listener is defined in.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsListenerEnvoyConfig#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressToPortsListenerEnvoyConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsListenerEnvoyConfig(obj: CiliumClusterwideNetworkPolicySpecsIngressToPortsListenerEnvoyConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTlsSecret
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTlsSecret {
  /**
   * Name is the name of the secret.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTlsSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., "default").
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTlsSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTlsSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTlsSecret(obj: CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTlsSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
 * Matching on ICMP is not supported.
 * Named port specified for a container may narrow this down, but may not contradict this.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsPortsProtocol
 */
export enum CiliumClusterwideNetworkPolicySpecsIngressToPortsPortsProtocol {
  /** TCP */
  TCP = "TCP",
  /** UDP */
  UDP = "UDP",
  /** SCTP */
  SCTP = "SCTP",
  /** ANY */
  ANY = "ANY",
}

/**
 * PortRuleDNS is a list of allowed DNS lookups.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesDns
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesDns {
  /**
   * MatchName matches literal DNS names. A trailing "." is automatically added when missing.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesDns#matchName
   */
  readonly matchName?: string;

  /**
   * MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - "*" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a "*" as the leftmost character, without a following "." matches all subdomains as well as the name to the right. A trailing "." is automatically added when missing.
   * Examples: `*.cilium.io` matches subomains of cilium at that level www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io" except those containing "." separator, subcilium.io and sub-cilium.io match, www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with "sub" sub.cilium.io and subdomain.cilium.io match, www.cilium.io, blog.cilium.io, cilium.io and google.com do not
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesDns#matchPattern
   */
  readonly matchPattern?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesDns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesDns(obj: CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesDns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchName': obj.matchName,
    'matchPattern': obj.matchPattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortRuleHTTP is a list of HTTP protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect.
 * All fields of this type are extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional "path" part of a URL as defined by RFC 3986.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttp
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttp {
  /**
   * HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttp#headerMatches
   */
  readonly headerMatches?: CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches[];

  /**
   * Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttp#headers
   */
  readonly headers?: string[];

  /**
   * Host is an extended POSIX regex matched against the host header of a request, e.g. "foo.com"
   * If omitted or empty, the value of the host header is ignored.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttp#host
   */
  readonly host?: string;

  /**
   * Method is an extended POSIX regex matched against the method of a request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
   * If omitted or empty, all methods are allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttp#method
   */
  readonly method?: string;

  /**
   * Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional "path" part of a URL as defined by RFC 3986.
   * If omitted or empty, all paths are all allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttp#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttp(obj: CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerMatches': obj.headerMatches?.map(y => toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches(y)),
    'headers': obj.headers?.map(y => y),
    'host': obj.host,
    'method': obj.method,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortRule is a list of Kafka protocol constraints. All fields are optional, if all fields are empty or missing, the rule will match all Kafka messages.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesKafka
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesKafka {
  /**
   * APIKey is a case-insensitive string matched against the key of a request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys
   * If omitted or empty, and if Role is not specified, then all keys are allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesKafka#apiKey
   */
  readonly apiKey?: string;

  /**
   * APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer.
   * If omitted or empty, all versions are allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesKafka#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * ClientID is the client identifier as provided in the request.
   * From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client.
   * If omitted or empty, all client identifiers are allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesKafka#clientID
   */
  readonly clientId?: string;

  /**
   * Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as "produce" or "consume". A Role automatically expands into all APIKeys required to perform the specified higher-level operation.
   * The following values are supported: - "produce": Allow producing to the topics specified in the rule - "consume": Allow consuming from the topics specified in the rule
   * This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule.
   * If omitted or empty, and if APIKey is not specified, then all keys are allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesKafka#role
   */
  readonly role?: CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesKafkaRole;

  /**
   * Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected.
   * This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _.
   * Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255.
   * If omitted or empty, all topics are allowed.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesKafka#topic
   */
  readonly topic?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesKafka' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesKafka(obj: CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesKafka | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': obj.apiKey,
    'apiVersion': obj.apiVersion,
    'clientID': obj.clientId,
    'role': obj.role,
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTlsSecret
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTlsSecret {
  /**
   * Name is the name of the secret.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTlsSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., "default").
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTlsSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTlsSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTlsSecret(obj: CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTlsSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressionsOperator
 */
export enum CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequiresMatchExpressionsOperator
 */
export enum CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequiresMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyIcmpsFieldsFamily
 */
export enum CiliumClusterwideNetworkPolicySpecsIngressDenyIcmpsFieldsFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
 * Matching on ICMP is not supported.
 * Named port specified for a container may narrow this down, but may not contradict this.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressDenyToPortsPortsProtocol
 */
export enum CiliumClusterwideNetworkPolicySpecsIngressDenyToPortsPortsProtocol {
  /** TCP */
  TCP = "TCP",
  /** UDP */
  UDP = "UDP",
  /** SCTP */
  SCTP = "SCTP",
  /** ANY */
  ANY = "ANY",
}

/**
 * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
 *
 * @default CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
 * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsListenerEnvoyConfigKind
 */
export enum CiliumClusterwideNetworkPolicySpecEgressToPortsListenerEnvoyConfigKind {
  /** CiliumEnvoyConfig */
  CILIUM_ENVOY_CONFIG = "CiliumEnvoyConfig",
  /** CiliumClusterwideEnvoyConfig */
  CILIUM_CLUSTERWIDE_ENVOY_CONFIG = "CiliumClusterwideEnvoyConfig",
}

/**
 * HeaderMatch extends the HeaderValue for matching requirement of a named header field against an immediate string, a secret value, or a regex.  If none of the optional fields is present, then the header value is not matched, only presence of the header is enough.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches {
  /**
   * Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches#mismatch
   */
  readonly mismatch?: CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesMismatch;

  /**
   * Name identifies the header.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches#name
   */
  readonly name: string;

  /**
   * Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no "Value" specified, the match will fail.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches#secret
   */
  readonly secret?: CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecret;

  /**
   * Value matches the exact value of the header. Can be specified either alone or together with "Secret"; will be used as the header value if the secret can not be found in the latter case.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches(obj: CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mismatch': obj.mismatch,
    'name': obj.name,
    'secret': toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecret(obj.secret),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as "produce" or "consume". A Role automatically expands into all APIKeys required to perform the specified higher-level operation.
 * The following values are supported: - "produce": Allow producing to the topics specified in the rule - "consume": Allow consuming from the topics specified in the rule
 * This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule.
 * If omitted or empty, and if APIKey is not specified, then all keys are allowed.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesKafkaRole
 */
export enum CiliumClusterwideNetworkPolicySpecEgressToPortsRulesKafkaRole {
  /** produce */
  PRODUCE = "produce",
  /** consume */
  CONSUME = "consume",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressions
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressions#operator
   */
  readonly operator: CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressions(obj: CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions
 */
export interface CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions#operator
   */
  readonly operator: CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions(obj: CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
 *
 * @default CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
 * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsListenerEnvoyConfigKind
 */
export enum CiliumClusterwideNetworkPolicySpecIngressToPortsListenerEnvoyConfigKind {
  /** CiliumEnvoyConfig */
  CILIUM_ENVOY_CONFIG = "CiliumEnvoyConfig",
  /** CiliumClusterwideEnvoyConfig */
  CILIUM_CLUSTERWIDE_ENVOY_CONFIG = "CiliumClusterwideEnvoyConfig",
}

/**
 * HeaderMatch extends the HeaderValue for matching requirement of a named header field against an immediate string, a secret value, or a regex.  If none of the optional fields is present, then the header value is not matched, only presence of the header is enough.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches
 */
export interface CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches {
  /**
   * Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches#mismatch
   */
  readonly mismatch?: CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesMismatch;

  /**
   * Name identifies the header.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches#name
   */
  readonly name: string;

  /**
   * Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no "Value" specified, the match will fail.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches#secret
   */
  readonly secret?: CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecret;

  /**
   * Value matches the exact value of the header. Can be specified either alone or together with "Secret"; will be used as the header value if the secret can not be found in the latter case.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches(obj: CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mismatch': obj.mismatch,
    'name': obj.name,
    'secret': toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecret(obj.secret),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as "produce" or "consume". A Role automatically expands into all APIKeys required to perform the specified higher-level operation.
 * The following values are supported: - "produce": Allow producing to the topics specified in the rule - "consume": Allow consuming from the topics specified in the rule
 * This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule.
 * If omitted or empty, and if APIKey is not specified, then all keys are allowed.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesKafkaRole
 */
export enum CiliumClusterwideNetworkPolicySpecIngressToPortsRulesKafkaRole {
  /** produce */
  PRODUCE = "produce",
  /** consume */
  CONSUME = "consume",
}

/**
 * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
 *
 * @default CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsListenerEnvoyConfigKind
 */
export enum CiliumClusterwideNetworkPolicySpecsEgressToPortsListenerEnvoyConfigKind {
  /** CiliumEnvoyConfig */
  CILIUM_ENVOY_CONFIG = "CiliumEnvoyConfig",
  /** CiliumClusterwideEnvoyConfig */
  CILIUM_CLUSTERWIDE_ENVOY_CONFIG = "CiliumClusterwideEnvoyConfig",
}

/**
 * HeaderMatch extends the HeaderValue for matching requirement of a named header field against an immediate string, a secret value, or a regex.  If none of the optional fields is present, then the header value is not matched, only presence of the header is enough.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches {
  /**
   * Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches#mismatch
   */
  readonly mismatch?: CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesMismatch;

  /**
   * Name identifies the header.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches#name
   */
  readonly name: string;

  /**
   * Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no "Value" specified, the match will fail.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches#secret
   */
  readonly secret?: CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecret;

  /**
   * Value matches the exact value of the header. Can be specified either alone or together with "Secret"; will be used as the header value if the secret can not be found in the latter case.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches(obj: CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mismatch': obj.mismatch,
    'name': obj.name,
    'secret': toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecret(obj.secret),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as "produce" or "consume". A Role automatically expands into all APIKeys required to perform the specified higher-level operation.
 * The following values are supported: - "produce": Allow producing to the topics specified in the rule - "consume": Allow consuming from the topics specified in the rule
 * This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule.
 * If omitted or empty, and if APIKey is not specified, then all keys are allowed.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesKafkaRole
 */
export enum CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesKafkaRole {
  /** produce */
  PRODUCE = "produce",
  /** consume */
  CONSUME = "consume",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressions
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressions#operator
   */
  readonly operator: CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressions(obj: CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions#operator
   */
  readonly operator: CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions(obj: CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
 *
 * @default CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
 * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsListenerEnvoyConfigKind
 */
export enum CiliumClusterwideNetworkPolicySpecsIngressToPortsListenerEnvoyConfigKind {
  /** CiliumEnvoyConfig */
  CILIUM_ENVOY_CONFIG = "CiliumEnvoyConfig",
  /** CiliumClusterwideEnvoyConfig */
  CILIUM_CLUSTERWIDE_ENVOY_CONFIG = "CiliumClusterwideEnvoyConfig",
}

/**
 * HeaderMatch extends the HeaderValue for matching requirement of a named header field against an immediate string, a secret value, or a regex.  If none of the optional fields is present, then the header value is not matched, only presence of the header is enough.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches {
  /**
   * Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches#mismatch
   */
  readonly mismatch?: CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesMismatch;

  /**
   * Name identifies the header.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches#name
   */
  readonly name: string;

  /**
   * Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no "Value" specified, the match will fail.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches#secret
   */
  readonly secret?: CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecret;

  /**
   * Value matches the exact value of the header. Can be specified either alone or together with "Secret"; will be used as the header value if the secret can not be found in the latter case.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches(obj: CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mismatch': obj.mismatch,
    'name': obj.name,
    'secret': toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecret(obj.secret),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as "produce" or "consume". A Role automatically expands into all APIKeys required to perform the specified higher-level operation.
 * The following values are supported: - "produce": Allow producing to the topics specified in the rule - "consume": Allow consuming from the topics specified in the rule
 * This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule.
 * If omitted or empty, and if APIKey is not specified, then all keys are allowed.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesKafkaRole
 */
export enum CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesKafkaRole {
  /** produce */
  PRODUCE = "produce",
  /** consume */
  CONSUME = "consume",
}

/**
 * Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesMismatch
 */
export enum CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesMismatch {
  /** LOG */
  LOG = "LOG",
  /** ADD */
  ADD = "ADD",
  /** DELETE */
  DELETE = "DELETE",
  /** REPLACE */
  REPLACE = "REPLACE",
}

/**
 * Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no "Value" specified, the match will fail.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecret
 */
export interface CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecret {
  /**
   * Name is the name of the secret.
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., "default").
   *
   * @schema CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecret(obj: CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressionsOperator
 */
export enum CiliumClusterwideNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressionsOperator
 */
export enum CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesMismatch
 */
export enum CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesMismatch {
  /** LOG */
  LOG = "LOG",
  /** ADD */
  ADD = "ADD",
  /** DELETE */
  DELETE = "DELETE",
  /** REPLACE */
  REPLACE = "REPLACE",
}

/**
 * Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no "Value" specified, the match will fail.
 *
 * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecret
 */
export interface CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecret {
  /**
   * Name is the name of the secret.
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., "default").
   *
   * @schema CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecret(obj: CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesMismatch
 */
export enum CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesMismatch {
  /** LOG */
  LOG = "LOG",
  /** ADD */
  ADD = "ADD",
  /** DELETE */
  DELETE = "DELETE",
  /** REPLACE */
  REPLACE = "REPLACE",
}

/**
 * Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no "Value" specified, the match will fail.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecret
 */
export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecret {
  /**
   * Name is the name of the secret.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., "default").
   *
   * @schema CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecret(obj: CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressionsOperator
 */
export enum CiliumClusterwideNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressionsOperator
 */
export enum CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesMismatch
 */
export enum CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesMismatch {
  /** LOG */
  LOG = "LOG",
  /** ADD */
  ADD = "ADD",
  /** DELETE */
  DELETE = "DELETE",
  /** REPLACE */
  REPLACE = "REPLACE",
}

/**
 * Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no "Value" specified, the match will fail.
 *
 * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecret
 */
export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecret {
  /**
   * Name is the name of the secret.
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., "default").
   *
   * @schema CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecret(obj: CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * CiliumEndpoint is the status of a Cilium policy rule.
 *
 * @schema CiliumEndpoint
 */
export class CiliumEndpoint extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CiliumEndpoint"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cilium.io/v2',
    kind: 'CiliumEndpoint',
  }

  /**
   * Renders a Kubernetes manifest for "CiliumEndpoint".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CiliumEndpointProps): any {
    return {
      ...CiliumEndpoint.GVK,
      ...toJson_CiliumEndpointProps(props),
    };
  }

  /**
   * Defines a "CiliumEndpoint" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CiliumEndpointProps) {
    super(scope, id, {
      ...CiliumEndpoint.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CiliumEndpoint.GVK,
      ...toJson_CiliumEndpointProps(resolved),
    };
  }
}

/**
 * CiliumEndpoint is the status of a Cilium policy rule.
 *
 * @schema CiliumEndpoint
 */
export interface CiliumEndpointProps {
  /**
   * @schema CiliumEndpoint#metadata
   */
  readonly metadata: ApiObjectMetadata;

}

/**
 * Converts an object of type 'CiliumEndpointProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumEndpointProps(obj: CiliumEndpointProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema CiliumEnvoyConfig
 */
export class CiliumEnvoyConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CiliumEnvoyConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cilium.io/v2',
    kind: 'CiliumEnvoyConfig',
  }

  /**
   * Renders a Kubernetes manifest for "CiliumEnvoyConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CiliumEnvoyConfigProps): any {
    return {
      ...CiliumEnvoyConfig.GVK,
      ...toJson_CiliumEnvoyConfigProps(props),
    };
  }

  /**
   * Defines a "CiliumEnvoyConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CiliumEnvoyConfigProps) {
    super(scope, id, {
      ...CiliumEnvoyConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CiliumEnvoyConfig.GVK,
      ...toJson_CiliumEnvoyConfigProps(resolved),
    };
  }
}

/**
 * @schema CiliumEnvoyConfig
 */
export interface CiliumEnvoyConfigProps {
  /**
   * @schema CiliumEnvoyConfig#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * @schema CiliumEnvoyConfig#spec
   */
  readonly spec?: CiliumEnvoyConfigSpec;

}

/**
 * Converts an object of type 'CiliumEnvoyConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumEnvoyConfigProps(obj: CiliumEnvoyConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CiliumEnvoyConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CiliumEnvoyConfigSpec
 */
export interface CiliumEnvoyConfigSpec {
  /**
   * BackendServices specifies Kubernetes services whose backends are automatically synced to Envoy using EDS.  Traffic for these services is not forwarded to an Envoy listener. This allows an Envoy listener load balance traffic to these backends while normal Cilium service load balancing takes care of balancing traffic for these services at the same time.
   *
   * @schema CiliumEnvoyConfigSpec#backendServices
   */
  readonly backendServices?: CiliumEnvoyConfigSpecBackendServices[];

  /**
   * Envoy xDS resources, a list of the following Envoy resource types: type.googleapis.com/envoy.config.listener.v3.Listener, type.googleapis.com/envoy.config.route.v3.RouteConfiguration, type.googleapis.com/envoy.config.cluster.v3.Cluster, type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment, and type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.Secret.
   *
   * @schema CiliumEnvoyConfigSpec#resources
   */
  readonly resources?: any[];

  /**
   * Services specifies Kubernetes services for which traffic is forwarded to an Envoy listener for L7 load balancing. Backends of these services are automatically synced to Envoy usign EDS.
   *
   * @schema CiliumEnvoyConfigSpec#services
   */
  readonly services?: CiliumEnvoyConfigSpecServices[];

}

/**
 * Converts an object of type 'CiliumEnvoyConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumEnvoyConfigSpec(obj: CiliumEnvoyConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendServices': obj.backendServices?.map(y => toJson_CiliumEnvoyConfigSpecBackendServices(y)),
    'resources': obj.resources?.map(y => y),
    'services': obj.services?.map(y => toJson_CiliumEnvoyConfigSpecServices(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CiliumEnvoyConfigSpecBackendServices
 */
export interface CiliumEnvoyConfigSpecBackendServices {
  /**
   * Name is the name of a destination Kubernetes service that identifies traffic to be redirected.
   *
   * @schema CiliumEnvoyConfigSpecBackendServices#name
   */
  readonly name: string;

  /**
   * Namespace is the Kubernetes service namespace. In CiliumEnvoyConfig namespace defaults to the namespace of the CEC, In CiliumClusterwideEnvoyConfig namespace defaults to "default".
   *
   * @schema CiliumEnvoyConfigSpecBackendServices#namespace
   */
  readonly namespace?: string;

  /**
   * Port is the port number, which can be used for filtering in case of underlying is exposing multiple port numbers.
   *
   * @schema CiliumEnvoyConfigSpecBackendServices#number
   */
  readonly number?: string[];

}

/**
 * Converts an object of type 'CiliumEnvoyConfigSpecBackendServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumEnvoyConfigSpecBackendServices(obj: CiliumEnvoyConfigSpecBackendServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
    'number': obj.number?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CiliumEnvoyConfigSpecServices
 */
export interface CiliumEnvoyConfigSpecServices {
  /**
   * Listener specifies the name of the Envoy listener the service traffic is redirected to. The listener must be specified in the Envoy 'resources' of the same CiliumEnvoyConfig.
   * If omitted, the first listener specified in 'resources' is used.
   *
   * @schema CiliumEnvoyConfigSpecServices#listener
   */
  readonly listener?: string;

  /**
   * Name is the name of a destination Kubernetes service that identifies traffic to be redirected.
   *
   * @schema CiliumEnvoyConfigSpecServices#name
   */
  readonly name: string;

  /**
   * Namespace is the Kubernetes service namespace. In CiliumEnvoyConfig namespace this is overridden to the namespace of the CEC, In CiliumClusterwideEnvoyConfig namespace defaults to "default".
   *
   * @schema CiliumEnvoyConfigSpecServices#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumEnvoyConfigSpecServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumEnvoyConfigSpecServices(obj: CiliumEnvoyConfigSpecServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'listener': obj.listener,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * CiliumExternalWorkload is a Kubernetes Custom Resource that contains a specification for an external workload that can join the cluster.  The name of the CRD is the FQDN of the external workload, and it needs to match the name in the workload registration. The labels on the CRD object are the labels that will be used to allocate a Cilium Identity for the external workload. If 'io.kubernetes.pod.namespace' or 'io.kubernetes.pod.name' labels are not explicitly specified, they will be defaulted to 'default' and <workload name>, respectively. 'io.cilium.k8s.policy.cluster' will always be defined as the name of the current cluster, which defaults to "default".
 *
 * @schema CiliumExternalWorkload
 */
export class CiliumExternalWorkload extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CiliumExternalWorkload"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cilium.io/v2',
    kind: 'CiliumExternalWorkload',
  }

  /**
   * Renders a Kubernetes manifest for "CiliumExternalWorkload".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CiliumExternalWorkloadProps): any {
    return {
      ...CiliumExternalWorkload.GVK,
      ...toJson_CiliumExternalWorkloadProps(props),
    };
  }

  /**
   * Defines a "CiliumExternalWorkload" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CiliumExternalWorkloadProps) {
    super(scope, id, {
      ...CiliumExternalWorkload.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CiliumExternalWorkload.GVK,
      ...toJson_CiliumExternalWorkloadProps(resolved),
    };
  }
}

/**
 * CiliumExternalWorkload is a Kubernetes Custom Resource that contains a specification for an external workload that can join the cluster.  The name of the CRD is the FQDN of the external workload, and it needs to match the name in the workload registration. The labels on the CRD object are the labels that will be used to allocate a Cilium Identity for the external workload. If 'io.kubernetes.pod.namespace' or 'io.kubernetes.pod.name' labels are not explicitly specified, they will be defaulted to 'default' and <workload name>, respectively. 'io.cilium.k8s.policy.cluster' will always be defined as the name of the current cluster, which defaults to "default".
 *
 * @schema CiliumExternalWorkload
 */
export interface CiliumExternalWorkloadProps {
  /**
   * @schema CiliumExternalWorkload#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * Spec is the desired configuration of the external Cilium workload.
   *
   * @schema CiliumExternalWorkload#spec
   */
  readonly spec?: CiliumExternalWorkloadSpec;

}

/**
 * Converts an object of type 'CiliumExternalWorkloadProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumExternalWorkloadProps(obj: CiliumExternalWorkloadProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CiliumExternalWorkloadSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Spec is the desired configuration of the external Cilium workload.
 *
 * @schema CiliumExternalWorkloadSpec
 */
export interface CiliumExternalWorkloadSpec {
  /**
   * IPv4AllocCIDR is the range of IPv4 addresses in the CIDR format that the external workload can use to allocate IP addresses for the tunnel device and the health endpoint.
   *
   * @schema CiliumExternalWorkloadSpec#ipv4-alloc-cidr
   */
  readonly ipv4AllocCidr?: string;

  /**
   * IPv6AllocCIDR is the range of IPv6 addresses in the CIDR format that the external workload can use to allocate IP addresses for the tunnel device and the health endpoint.
   *
   * @schema CiliumExternalWorkloadSpec#ipv6-alloc-cidr
   */
  readonly ipv6AllocCidr?: string;

}

/**
 * Converts an object of type 'CiliumExternalWorkloadSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumExternalWorkloadSpec(obj: CiliumExternalWorkloadSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipv4-alloc-cidr': obj.ipv4AllocCidr,
    'ipv6-alloc-cidr': obj.ipv6AllocCidr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * CiliumIdentity is a CRD that represents an identity managed by Cilium. It is intended as a backing store for identity allocation, acting as the global coordination backend, and can be used in place of a KVStore (such as etcd). The name of the CRD is the numeric identity and the labels on the CRD object are the kubernetes sourced labels seen by cilium. This is currently the only label source possible when running under kubernetes. Non-kubernetes labels are filtered but all labels, from all sources, are places in the SecurityLabels field. These also include the source and are used to define the identity. The labels under metav1.ObjectMeta can be used when searching for CiliumIdentity instances that include particular labels. This can be done with invocations such as: 
 kubectl get ciliumid -l 'foo=bar'
 *
 * @schema CiliumIdentity
 */
export class CiliumIdentity extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CiliumIdentity"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cilium.io/v2',
    kind: 'CiliumIdentity',
  }

  /**
   * Renders a Kubernetes manifest for "CiliumIdentity".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CiliumIdentityProps): any {
    return {
      ...CiliumIdentity.GVK,
      ...toJson_CiliumIdentityProps(props),
    };
  }

  /**
   * Defines a "CiliumIdentity" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CiliumIdentityProps) {
    super(scope, id, {
      ...CiliumIdentity.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CiliumIdentity.GVK,
      ...toJson_CiliumIdentityProps(resolved),
    };
  }
}

/**
 * CiliumIdentity is a CRD that represents an identity managed by Cilium. It is intended as a backing store for identity allocation, acting as the global coordination backend, and can be used in place of a KVStore (such as etcd). The name of the CRD is the numeric identity and the labels on the CRD object are the kubernetes sourced labels seen by cilium. This is currently the only label source possible when running under kubernetes. Non-kubernetes labels are filtered but all labels, from all sources, are places in the SecurityLabels field. These also include the source and are used to define the identity. The labels under metav1.ObjectMeta can be used when searching for CiliumIdentity instances that include particular labels. This can be done with invocations such as:
 * kubectl get ciliumid -l 'foo=bar'
 *
 * @schema CiliumIdentity
 */
export interface CiliumIdentityProps {
  /**
   * @schema CiliumIdentity#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * SecurityLabels is the source-of-truth set of labels for this identity.
   *
   * @schema CiliumIdentity#security-labels
   */
  readonly securityLabels: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumIdentityProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumIdentityProps(obj: CiliumIdentityProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'security-labels': ((obj.securityLabels) === undefined) ? undefined : (Object.entries(obj.securityLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * CiliumL2AnnouncementPolicy is a Kubernetes third-party resource which is used to defined which nodes should announce what services on the L2 network.
 *
 * @schema CiliumL2AnnouncementPolicy
 */
export class CiliumL2AnnouncementPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CiliumL2AnnouncementPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cilium.io/v2alpha1',
    kind: 'CiliumL2AnnouncementPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "CiliumL2AnnouncementPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CiliumL2AnnouncementPolicyProps): any {
    return {
      ...CiliumL2AnnouncementPolicy.GVK,
      ...toJson_CiliumL2AnnouncementPolicyProps(props),
    };
  }

  /**
   * Defines a "CiliumL2AnnouncementPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CiliumL2AnnouncementPolicyProps) {
    super(scope, id, {
      ...CiliumL2AnnouncementPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CiliumL2AnnouncementPolicy.GVK,
      ...toJson_CiliumL2AnnouncementPolicyProps(resolved),
    };
  }
}

/**
 * CiliumL2AnnouncementPolicy is a Kubernetes third-party resource which is used to defined which nodes should announce what services on the L2 network.
 *
 * @schema CiliumL2AnnouncementPolicy
 */
export interface CiliumL2AnnouncementPolicyProps {
  /**
   * @schema CiliumL2AnnouncementPolicy#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * Spec is a human readable description of a L2 announcement policy
   *
   * @schema CiliumL2AnnouncementPolicy#spec
   */
  readonly spec?: CiliumL2AnnouncementPolicySpec;

}

/**
 * Converts an object of type 'CiliumL2AnnouncementPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumL2AnnouncementPolicyProps(obj: CiliumL2AnnouncementPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CiliumL2AnnouncementPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Spec is a human readable description of a L2 announcement policy
 *
 * @schema CiliumL2AnnouncementPolicySpec
 */
export interface CiliumL2AnnouncementPolicySpec {
  /**
   * If true, the external IPs of the services are announced
   *
   * @schema CiliumL2AnnouncementPolicySpec#externalIPs
   */
  readonly externalIPs?: boolean;

  /**
   * A list of regular expressions that express which network interface(s) should be used to announce the services over. If nil, all network interfaces are used.
   *
   * @schema CiliumL2AnnouncementPolicySpec#interfaces
   */
  readonly interfaces?: string[];

  /**
   * If true, the loadbalancer IPs of the services are announced
   * If nil this policy applies to all services.
   *
   * @schema CiliumL2AnnouncementPolicySpec#loadBalancerIPs
   */
  readonly loadBalancerIPs?: boolean;

  /**
   * NodeSelector selects a group of nodes which will announce the IPs for the services selected by the service selector.
   * If nil this policy applies to all nodes.
   *
   * @schema CiliumL2AnnouncementPolicySpec#nodeSelector
   */
  readonly nodeSelector?: CiliumL2AnnouncementPolicySpecNodeSelector;

  /**
   * ServiceSelector selects a set of services which will be announced over L2 networks. The loadBalancerClass for a service must be nil or specify a supported class, e.g. "io.cilium/l2-announcer". Refer to the following document for additional details regarding load balancer classes:
   * https://kubernetes.io/docs/concepts/services-networking/service/#load-balancer-class
   * If nil this policy applies to all services.
   *
   * @schema CiliumL2AnnouncementPolicySpec#serviceSelector
   */
  readonly serviceSelector?: CiliumL2AnnouncementPolicySpecServiceSelector;

}

/**
 * Converts an object of type 'CiliumL2AnnouncementPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumL2AnnouncementPolicySpec(obj: CiliumL2AnnouncementPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalIPs': obj.externalIPs,
    'interfaces': obj.interfaces?.map(y => y),
    'loadBalancerIPs': obj.loadBalancerIPs,
    'nodeSelector': toJson_CiliumL2AnnouncementPolicySpecNodeSelector(obj.nodeSelector),
    'serviceSelector': toJson_CiliumL2AnnouncementPolicySpecServiceSelector(obj.serviceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodeSelector selects a group of nodes which will announce the IPs for the services selected by the service selector.
 * If nil this policy applies to all nodes.
 *
 * @schema CiliumL2AnnouncementPolicySpecNodeSelector
 */
export interface CiliumL2AnnouncementPolicySpecNodeSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumL2AnnouncementPolicySpecNodeSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumL2AnnouncementPolicySpecNodeSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumL2AnnouncementPolicySpecNodeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumL2AnnouncementPolicySpecNodeSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumL2AnnouncementPolicySpecNodeSelector(obj: CiliumL2AnnouncementPolicySpecNodeSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumL2AnnouncementPolicySpecNodeSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceSelector selects a set of services which will be announced over L2 networks. The loadBalancerClass for a service must be nil or specify a supported class, e.g. "io.cilium/l2-announcer". Refer to the following document for additional details regarding load balancer classes:
 * https://kubernetes.io/docs/concepts/services-networking/service/#load-balancer-class
 * If nil this policy applies to all services.
 *
 * @schema CiliumL2AnnouncementPolicySpecServiceSelector
 */
export interface CiliumL2AnnouncementPolicySpecServiceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumL2AnnouncementPolicySpecServiceSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumL2AnnouncementPolicySpecServiceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumL2AnnouncementPolicySpecServiceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumL2AnnouncementPolicySpecServiceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumL2AnnouncementPolicySpecServiceSelector(obj: CiliumL2AnnouncementPolicySpecServiceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumL2AnnouncementPolicySpecServiceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumL2AnnouncementPolicySpecNodeSelectorMatchExpressions
 */
export interface CiliumL2AnnouncementPolicySpecNodeSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumL2AnnouncementPolicySpecNodeSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumL2AnnouncementPolicySpecNodeSelectorMatchExpressions#operator
   */
  readonly operator: CiliumL2AnnouncementPolicySpecNodeSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumL2AnnouncementPolicySpecNodeSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumL2AnnouncementPolicySpecNodeSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumL2AnnouncementPolicySpecNodeSelectorMatchExpressions(obj: CiliumL2AnnouncementPolicySpecNodeSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumL2AnnouncementPolicySpecServiceSelectorMatchExpressions
 */
export interface CiliumL2AnnouncementPolicySpecServiceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumL2AnnouncementPolicySpecServiceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumL2AnnouncementPolicySpecServiceSelectorMatchExpressions#operator
   */
  readonly operator: CiliumL2AnnouncementPolicySpecServiceSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumL2AnnouncementPolicySpecServiceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumL2AnnouncementPolicySpecServiceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumL2AnnouncementPolicySpecServiceSelectorMatchExpressions(obj: CiliumL2AnnouncementPolicySpecServiceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumL2AnnouncementPolicySpecNodeSelectorMatchExpressionsOperator
 */
export enum CiliumL2AnnouncementPolicySpecNodeSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumL2AnnouncementPolicySpecServiceSelectorMatchExpressionsOperator
 */
export enum CiliumL2AnnouncementPolicySpecServiceSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}


/**
 * CiliumLoadBalancerIPPool is a Kubernetes third-party resource which is used to defined pools of IPs which the operator can use to to allocate and advertise IPs for Services of type LoadBalancer.
 *
 * @schema CiliumLoadBalancerIPPool
 */
export class CiliumLoadBalancerIpPool extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CiliumLoadBalancerIPPool"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cilium.io/v2alpha1',
    kind: 'CiliumLoadBalancerIPPool',
  }

  /**
   * Renders a Kubernetes manifest for "CiliumLoadBalancerIPPool".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CiliumLoadBalancerIpPoolProps): any {
    return {
      ...CiliumLoadBalancerIpPool.GVK,
      ...toJson_CiliumLoadBalancerIpPoolProps(props),
    };
  }

  /**
   * Defines a "CiliumLoadBalancerIPPool" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CiliumLoadBalancerIpPoolProps) {
    super(scope, id, {
      ...CiliumLoadBalancerIpPool.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CiliumLoadBalancerIpPool.GVK,
      ...toJson_CiliumLoadBalancerIpPoolProps(resolved),
    };
  }
}

/**
 * CiliumLoadBalancerIPPool is a Kubernetes third-party resource which is used to defined pools of IPs which the operator can use to to allocate and advertise IPs for Services of type LoadBalancer.
 *
 * @schema CiliumLoadBalancerIPPool
 */
export interface CiliumLoadBalancerIpPoolProps {
  /**
   * @schema CiliumLoadBalancerIPPool#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * Spec is a human readable description for a BGP load balancer ip pool.
   *
   * @schema CiliumLoadBalancerIPPool#spec
   */
  readonly spec?: CiliumLoadBalancerIpPoolSpec;

}

/**
 * Converts an object of type 'CiliumLoadBalancerIpPoolProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumLoadBalancerIpPoolProps(obj: CiliumLoadBalancerIpPoolProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CiliumLoadBalancerIpPoolSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Spec is a human readable description for a BGP load balancer ip pool.
 *
 * @schema CiliumLoadBalancerIpPoolSpec
 */
export interface CiliumLoadBalancerIpPoolSpec {
  /**
   * AllowFirstLastIPs, if set to `yes` means that the first and last IPs of each CIDR will be allocatable. If `no` or undefined, these IPs will be reserved. This field is ignored for /{31,32} and /{127,128} CIDRs since reserving the first and last IPs would make the CIDRs unusable.
   *
   * @schema CiliumLoadBalancerIpPoolSpec#allowFirstLastIPs
   */
  readonly allowFirstLastIPs?: CiliumLoadBalancerIpPoolSpecAllowFirstLastIPs;

  /**
   * Blocks is a list of CIDRs comprising this IP Pool
   *
   * @schema CiliumLoadBalancerIpPoolSpec#blocks
   */
  readonly blocks?: CiliumLoadBalancerIpPoolSpecBlocks[];

  /**
   * Cidrs is a list of CIDRs comprising this IP Pool Deprecated: please use the `blocks` field instead. This field will be removed in a future release. https://github.com/cilium/cilium/issues/28590
   *
   * @schema CiliumLoadBalancerIpPoolSpec#cidrs
   */
  readonly cidrs?: CiliumLoadBalancerIpPoolSpecCidrs[];

  /**
   * Disabled, if set to true means that no new IPs will be allocated from this pool. Existing allocations will not be removed from services.
   *
   * @schema CiliumLoadBalancerIpPoolSpec#disabled
   */
  readonly disabled?: boolean;

  /**
   * ServiceSelector selects a set of services which are eligible to receive IPs from this
   *
   * @schema CiliumLoadBalancerIpPoolSpec#serviceSelector
   */
  readonly serviceSelector?: CiliumLoadBalancerIpPoolSpecServiceSelector;

}

/**
 * Converts an object of type 'CiliumLoadBalancerIpPoolSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumLoadBalancerIpPoolSpec(obj: CiliumLoadBalancerIpPoolSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowFirstLastIPs': obj.allowFirstLastIPs,
    'blocks': obj.blocks?.map(y => toJson_CiliumLoadBalancerIpPoolSpecBlocks(y)),
    'cidrs': obj.cidrs?.map(y => toJson_CiliumLoadBalancerIpPoolSpecCidrs(y)),
    'disabled': obj.disabled,
    'serviceSelector': toJson_CiliumLoadBalancerIpPoolSpecServiceSelector(obj.serviceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AllowFirstLastIPs, if set to `yes` means that the first and last IPs of each CIDR will be allocatable. If `no` or undefined, these IPs will be reserved. This field is ignored for /{31,32} and /{127,128} CIDRs since reserving the first and last IPs would make the CIDRs unusable.
 *
 * @schema CiliumLoadBalancerIpPoolSpecAllowFirstLastIPs
 */
export enum CiliumLoadBalancerIpPoolSpecAllowFirstLastIPs {
  /** Yes */
  YES = "Yes",
  /** No */
  NO = "No",
}

/**
 * CiliumLoadBalancerIPPoolIPBlock describes a single IP block.
 *
 * @schema CiliumLoadBalancerIpPoolSpecBlocks
 */
export interface CiliumLoadBalancerIpPoolSpecBlocks {
  /**
   * @schema CiliumLoadBalancerIpPoolSpecBlocks#cidr
   */
  readonly cidr?: string;

  /**
   * @schema CiliumLoadBalancerIpPoolSpecBlocks#start
   */
  readonly start?: string;

  /**
   * @schema CiliumLoadBalancerIpPoolSpecBlocks#stop
   */
  readonly stop?: string;

}

/**
 * Converts an object of type 'CiliumLoadBalancerIpPoolSpecBlocks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumLoadBalancerIpPoolSpecBlocks(obj: CiliumLoadBalancerIpPoolSpecBlocks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'start': obj.start,
    'stop': obj.stop,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CiliumLoadBalancerIPPoolIPBlock describes a single IP block.
 *
 * @schema CiliumLoadBalancerIpPoolSpecCidrs
 */
export interface CiliumLoadBalancerIpPoolSpecCidrs {
  /**
   * @schema CiliumLoadBalancerIpPoolSpecCidrs#cidr
   */
  readonly cidr?: string;

  /**
   * @schema CiliumLoadBalancerIpPoolSpecCidrs#start
   */
  readonly start?: string;

  /**
   * @schema CiliumLoadBalancerIpPoolSpecCidrs#stop
   */
  readonly stop?: string;

}

/**
 * Converts an object of type 'CiliumLoadBalancerIpPoolSpecCidrs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumLoadBalancerIpPoolSpecCidrs(obj: CiliumLoadBalancerIpPoolSpecCidrs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'start': obj.start,
    'stop': obj.stop,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceSelector selects a set of services which are eligible to receive IPs from this
 *
 * @schema CiliumLoadBalancerIpPoolSpecServiceSelector
 */
export interface CiliumLoadBalancerIpPoolSpecServiceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumLoadBalancerIpPoolSpecServiceSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumLoadBalancerIpPoolSpecServiceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumLoadBalancerIpPoolSpecServiceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumLoadBalancerIpPoolSpecServiceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumLoadBalancerIpPoolSpecServiceSelector(obj: CiliumLoadBalancerIpPoolSpecServiceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumLoadBalancerIpPoolSpecServiceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumLoadBalancerIpPoolSpecServiceSelectorMatchExpressions
 */
export interface CiliumLoadBalancerIpPoolSpecServiceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumLoadBalancerIpPoolSpecServiceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumLoadBalancerIpPoolSpecServiceSelectorMatchExpressions#operator
   */
  readonly operator: CiliumLoadBalancerIpPoolSpecServiceSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumLoadBalancerIpPoolSpecServiceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumLoadBalancerIpPoolSpecServiceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumLoadBalancerIpPoolSpecServiceSelectorMatchExpressions(obj: CiliumLoadBalancerIpPoolSpecServiceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumLoadBalancerIpPoolSpecServiceSelectorMatchExpressionsOperator
 */
export enum CiliumLoadBalancerIpPoolSpecServiceSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}


/**
 * CiliumNetworkPolicy is a Kubernetes third-party resource with an extended version of NetworkPolicy.
 *
 * @schema CiliumNetworkPolicy
 */
export class CiliumNetworkPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CiliumNetworkPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cilium.io/v2',
    kind: 'CiliumNetworkPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "CiliumNetworkPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CiliumNetworkPolicyProps): any {
    return {
      ...CiliumNetworkPolicy.GVK,
      ...toJson_CiliumNetworkPolicyProps(props),
    };
  }

  /**
   * Defines a "CiliumNetworkPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CiliumNetworkPolicyProps) {
    super(scope, id, {
      ...CiliumNetworkPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CiliumNetworkPolicy.GVK,
      ...toJson_CiliumNetworkPolicyProps(resolved),
    };
  }
}

/**
 * CiliumNetworkPolicy is a Kubernetes third-party resource with an extended version of NetworkPolicy.
 *
 * @schema CiliumNetworkPolicy
 */
export interface CiliumNetworkPolicyProps {
  /**
   * @schema CiliumNetworkPolicy#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * Spec is the desired Cilium specific rule specification.
   *
   * @schema CiliumNetworkPolicy#spec
   */
  readonly spec?: CiliumNetworkPolicySpec;

  /**
   * Specs is a list of desired Cilium specific rule specification.
   *
   * @schema CiliumNetworkPolicy#specs
   */
  readonly specs?: CiliumNetworkPolicySpecs[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicyProps(obj: CiliumNetworkPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CiliumNetworkPolicySpec(obj.spec),
    'specs': obj.specs?.map(y => toJson_CiliumNetworkPolicySpecs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Spec is the desired Cilium specific rule specification.
 *
 * @schema CiliumNetworkPolicySpec
 */
export interface CiliumNetworkPolicySpec {
  /**
   * Description is a free form string, it can be used by the creator of the rule to store human readable explanation of the purpose of this rule. Rules cannot be identified by comment.
   *
   * @schema CiliumNetworkPolicySpec#description
   */
  readonly description?: string;

  /**
   * Egress is a list of EgressRule which are enforced at egress. If omitted or empty, this rule does not apply at egress.
   *
   * @schema CiliumNetworkPolicySpec#egress
   */
  readonly egress?: CiliumNetworkPolicySpecEgress[];

  /**
   * EgressDeny is a list of EgressDenyRule which are enforced at egress. Any rule inserted here will be denied regardless of the allowed egress rules in the 'egress' field. If omitted or empty, this rule does not apply at egress.
   *
   * @schema CiliumNetworkPolicySpec#egressDeny
   */
  readonly egressDeny?: CiliumNetworkPolicySpecEgressDeny[];

  /**
   * EndpointSelector selects all endpoints which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive.
   *
   * @schema CiliumNetworkPolicySpec#endpointSelector
   */
  readonly endpointSelector?: CiliumNetworkPolicySpecEndpointSelector;

  /**
   * Ingress is a list of IngressRule which are enforced at ingress. If omitted or empty, this rule does not apply at ingress.
   *
   * @schema CiliumNetworkPolicySpec#ingress
   */
  readonly ingress?: CiliumNetworkPolicySpecIngress[];

  /**
   * IngressDeny is a list of IngressDenyRule which are enforced at ingress. Any rule inserted here will be denied regardless of the allowed ingress rules in the 'ingress' field. If omitted or empty, this rule does not apply at ingress.
   *
   * @schema CiliumNetworkPolicySpec#ingressDeny
   */
  readonly ingressDeny?: CiliumNetworkPolicySpecIngressDeny[];

  /**
   * Labels is a list of optional strings which can be used to re-identify the rule or to store metadata. It is possible to lookup or delete strings based on labels. Labels are not required to be unique, multiple rules can have overlapping or identical labels.
   *
   * @schema CiliumNetworkPolicySpec#labels
   */
  readonly labels?: CiliumNetworkPolicySpecLabels[];

  /**
   * NodeSelector selects all nodes which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive. Can only be used in CiliumClusterwideNetworkPolicies.
   *
   * @schema CiliumNetworkPolicySpec#nodeSelector
   */
  readonly nodeSelector?: CiliumNetworkPolicySpecNodeSelector;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpec(obj: CiliumNetworkPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'egress': obj.egress?.map(y => toJson_CiliumNetworkPolicySpecEgress(y)),
    'egressDeny': obj.egressDeny?.map(y => toJson_CiliumNetworkPolicySpecEgressDeny(y)),
    'endpointSelector': toJson_CiliumNetworkPolicySpecEndpointSelector(obj.endpointSelector),
    'ingress': obj.ingress?.map(y => toJson_CiliumNetworkPolicySpecIngress(y)),
    'ingressDeny': obj.ingressDeny?.map(y => toJson_CiliumNetworkPolicySpecIngressDeny(y)),
    'labels': obj.labels?.map(y => toJson_CiliumNetworkPolicySpecLabels(y)),
    'nodeSelector': toJson_CiliumNetworkPolicySpecNodeSelector(obj.nodeSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rule is a policy rule which must be applied to all endpoints which match the labels contained in the endpointSelector
 * Each rule is split into an ingress section which contains all rules applicable at ingress, and an egress section applicable at egress. For rule types such as `L4Rule` and `CIDR` which can be applied at both ingress and egress, both ingress and egress side have to either specifically allow the connection or one side has to be omitted.
 * Either ingress, egress, or both can be provided. If both ingress and egress are omitted, the rule has no effect.
 *
 * @schema CiliumNetworkPolicySpecs
 */
export interface CiliumNetworkPolicySpecs {
  /**
   * Description is a free form string, it can be used by the creator of the rule to store human readable explanation of the purpose of this rule. Rules cannot be identified by comment.
   *
   * @schema CiliumNetworkPolicySpecs#description
   */
  readonly description?: string;

  /**
   * Egress is a list of EgressRule which are enforced at egress. If omitted or empty, this rule does not apply at egress.
   *
   * @schema CiliumNetworkPolicySpecs#egress
   */
  readonly egress?: CiliumNetworkPolicySpecsEgress[];

  /**
   * EgressDeny is a list of EgressDenyRule which are enforced at egress. Any rule inserted here will be denied regardless of the allowed egress rules in the 'egress' field. If omitted or empty, this rule does not apply at egress.
   *
   * @schema CiliumNetworkPolicySpecs#egressDeny
   */
  readonly egressDeny?: CiliumNetworkPolicySpecsEgressDeny[];

  /**
   * EndpointSelector selects all endpoints which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive.
   *
   * @schema CiliumNetworkPolicySpecs#endpointSelector
   */
  readonly endpointSelector?: CiliumNetworkPolicySpecsEndpointSelector;

  /**
   * Ingress is a list of IngressRule which are enforced at ingress. If omitted or empty, this rule does not apply at ingress.
   *
   * @schema CiliumNetworkPolicySpecs#ingress
   */
  readonly ingress?: CiliumNetworkPolicySpecsIngress[];

  /**
   * IngressDeny is a list of IngressDenyRule which are enforced at ingress. Any rule inserted here will be denied regardless of the allowed ingress rules in the 'ingress' field. If omitted or empty, this rule does not apply at ingress.
   *
   * @schema CiliumNetworkPolicySpecs#ingressDeny
   */
  readonly ingressDeny?: CiliumNetworkPolicySpecsIngressDeny[];

  /**
   * Labels is a list of optional strings which can be used to re-identify the rule or to store metadata. It is possible to lookup or delete strings based on labels. Labels are not required to be unique, multiple rules can have overlapping or identical labels.
   *
   * @schema CiliumNetworkPolicySpecs#labels
   */
  readonly labels?: CiliumNetworkPolicySpecsLabels[];

  /**
   * NodeSelector selects all nodes which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive. Can only be used in CiliumClusterwideNetworkPolicies.
   *
   * @schema CiliumNetworkPolicySpecs#nodeSelector
   */
  readonly nodeSelector?: CiliumNetworkPolicySpecsNodeSelector;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecs(obj: CiliumNetworkPolicySpecs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'egress': obj.egress?.map(y => toJson_CiliumNetworkPolicySpecsEgress(y)),
    'egressDeny': obj.egressDeny?.map(y => toJson_CiliumNetworkPolicySpecsEgressDeny(y)),
    'endpointSelector': toJson_CiliumNetworkPolicySpecsEndpointSelector(obj.endpointSelector),
    'ingress': obj.ingress?.map(y => toJson_CiliumNetworkPolicySpecsIngress(y)),
    'ingressDeny': obj.ingressDeny?.map(y => toJson_CiliumNetworkPolicySpecsIngressDeny(y)),
    'labels': obj.labels?.map(y => toJson_CiliumNetworkPolicySpecsLabels(y)),
    'nodeSelector': toJson_CiliumNetworkPolicySpecsNodeSelector(obj.nodeSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EgressRule contains all rule types which can be applied at egress, i.e. network traffic that originates inside the endpoint and exits the endpoint selected by the endpointSelector.
 * - All members of this structure are optional. If omitted or empty, the member will have no effect on the rule.
 * - If multiple members of the structure are specified, then all members must match in order for the rule to take effect. The exception to this rule is the ToRequires member; the effects of any Requires field in any rule will apply to all other rules as well.
 * - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are mutually exclusive. Only one of these members may be present within an individual rule.
 *
 * @schema CiliumNetworkPolicySpecEgress
 */
export interface CiliumNetworkPolicySpecEgress {
  /**
   * Authentication is the required authentication type for the allowed traffic, if any.
   *
   * @schema CiliumNetworkPolicySpecEgress#authentication
   */
  readonly authentication?: CiliumNetworkPolicySpecEgressAuthentication;

  /**
   * ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to connect to.
   * Example: Any endpoint with the label "app=httpd" is allowed to initiate type 8 ICMP connections.
   *
   * @schema CiliumNetworkPolicySpecEgress#icmps
   */
  readonly icmps?: CiliumNetworkPolicySpecEgressIcmps[];

  /**
   * ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules.  This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet.
   * Example: Any endpoint with the label "app=database-proxy" is allowed to initiate connections to 10.2.3.0/24
   *
   * @schema CiliumNetworkPolicySpecEgress#toCIDR
   */
  readonly toCidr?: string[];

  /**
   * ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet.
   * Example: Any endpoint with the label "app=database-proxy" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
   *
   * @schema CiliumNetworkPolicySpecEgress#toCIDRSet
   */
  readonly toCidrSet?: CiliumNetworkPolicySpecEgressToCidrSet[];

  /**
   * ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate.
   * Example: Any endpoint with the label "role=frontend" can communicate with any endpoint carrying the label "role=backend".
   *
   * @schema CiliumNetworkPolicySpecEgress#toEndpoints
   */
  readonly toEndpoints?: CiliumNetworkPolicySpecEgressToEndpoints[];

  /**
   * ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`, `health`,`unmanaged` and `all`.
   *
   * @schema CiliumNetworkPolicySpecEgress#toEntities
   */
  readonly toEntities?: CiliumNetworkPolicySpecEgressToEntities[];

  /**
   * ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result from DNS resolution of `ToFQDN.MatchName`s are added to the same EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and L7 rules within this EgressRule will also apply to these IPs. The DNS -> IP mapping is re-resolved periodically from within the cilium-agent, and the IPs in the DNS response are effected in the policy for selected pods as-is (i.e. the list of IPs is not modified in any way). Note: An explicit rule to allow for DNS traffic is needed for the pods, as ToFQDN counts as an egress rule and will enforce egress policy when PolicyEnforcment=default. Note: If the resolved IPs are IPs within the kubernetes cluster, the ToFQDN rule will not apply to that IP. Note: ToFQDN cannot occur in the same policy as other To* rules.
   *
   * @schema CiliumNetworkPolicySpecEgress#toFQDNs
   */
  readonly toFqdNs?: CiliumNetworkPolicySpecEgressToFqdNs[];

  /**
   * ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives:
   * Example: toGroups: - aws: securityGroupsIds: - 'sg-XXXXXXXXXXXXX'
   *
   * @schema CiliumNetworkPolicySpecEgress#toGroups
   */
  readonly toGroups?: CiliumNetworkPolicySpecEgressToGroups[];

  /**
   * ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to connect to.
   * Example: Any endpoint with the label "role=frontend" is allowed to initiate connections to destination port 8080/tcp
   *
   * @schema CiliumNetworkPolicySpecEgress#toPorts
   */
  readonly toPorts?: CiliumNetworkPolicySpecEgressToPorts[];

  /**
   * ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints.
   * Example: Any Endpoint with the label "team=A" requires any endpoint to which it communicates to also carry the label "team=A".
   *
   * @schema CiliumNetworkPolicySpecEgress#toRequires
   */
  readonly toRequires?: CiliumNetworkPolicySpecEgressToRequires[];

  /**
   * ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors.
   * Example: Any endpoint with the label "app=backend-app" is allowed to initiate connections to all cidrs backing the "external-service" service
   *
   * @schema CiliumNetworkPolicySpecEgress#toServices
   */
  readonly toServices?: CiliumNetworkPolicySpecEgressToServices[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgress(obj: CiliumNetworkPolicySpecEgress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authentication': toJson_CiliumNetworkPolicySpecEgressAuthentication(obj.authentication),
    'icmps': obj.icmps?.map(y => toJson_CiliumNetworkPolicySpecEgressIcmps(y)),
    'toCIDR': obj.toCidr?.map(y => y),
    'toCIDRSet': obj.toCidrSet?.map(y => toJson_CiliumNetworkPolicySpecEgressToCidrSet(y)),
    'toEndpoints': obj.toEndpoints?.map(y => toJson_CiliumNetworkPolicySpecEgressToEndpoints(y)),
    'toEntities': obj.toEntities?.map(y => y),
    'toFQDNs': obj.toFqdNs?.map(y => toJson_CiliumNetworkPolicySpecEgressToFqdNs(y)),
    'toGroups': obj.toGroups?.map(y => toJson_CiliumNetworkPolicySpecEgressToGroups(y)),
    'toPorts': obj.toPorts?.map(y => toJson_CiliumNetworkPolicySpecEgressToPorts(y)),
    'toRequires': obj.toRequires?.map(y => toJson_CiliumNetworkPolicySpecEgressToRequires(y)),
    'toServices': obj.toServices?.map(y => toJson_CiliumNetworkPolicySpecEgressToServices(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EgressDenyRule contains all rule types which can be applied at egress, i.e. network traffic that originates inside the endpoint and exits the endpoint selected by the endpointSelector.
 * - All members of this structure are optional. If omitted or empty, the member will have no effect on the rule.
 * - If multiple members of the structure are specified, then all members must match in order for the rule to take effect. The exception to this rule is the ToRequires member; the effects of any Requires field in any rule will apply to all other rules as well.
 * - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are mutually exclusive. Only one of these members may be present within an individual rule.
 *
 * @schema CiliumNetworkPolicySpecEgressDeny
 */
export interface CiliumNetworkPolicySpecEgressDeny {
  /**
   * ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to connect to.
   * Example: Any endpoint with the label "app=httpd" is not allowed to initiate type 8 ICMP connections.
   *
   * @schema CiliumNetworkPolicySpecEgressDeny#icmps
   */
  readonly icmps?: CiliumNetworkPolicySpecEgressDenyIcmps[];

  /**
   * ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules.  This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet.
   * Example: Any endpoint with the label "app=database-proxy" is allowed to initiate connections to 10.2.3.0/24
   *
   * @schema CiliumNetworkPolicySpecEgressDeny#toCIDR
   */
  readonly toCidr?: string[];

  /**
   * ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet.
   * Example: Any endpoint with the label "app=database-proxy" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
   *
   * @schema CiliumNetworkPolicySpecEgressDeny#toCIDRSet
   */
  readonly toCidrSet?: CiliumNetworkPolicySpecEgressDenyToCidrSet[];

  /**
   * ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate.
   * Example: Any endpoint with the label "role=frontend" can communicate with any endpoint carrying the label "role=backend".
   *
   * @schema CiliumNetworkPolicySpecEgressDeny#toEndpoints
   */
  readonly toEndpoints?: CiliumNetworkPolicySpecEgressDenyToEndpoints[];

  /**
   * ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`, `health`,`unmanaged` and `all`.
   *
   * @schema CiliumNetworkPolicySpecEgressDeny#toEntities
   */
  readonly toEntities?: CiliumNetworkPolicySpecEgressDenyToEntities[];

  /**
   * ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives:
   * Example: toGroups: - aws: securityGroupsIds: - 'sg-XXXXXXXXXXXXX'
   *
   * @schema CiliumNetworkPolicySpecEgressDeny#toGroups
   */
  readonly toGroups?: CiliumNetworkPolicySpecEgressDenyToGroups[];

  /**
   * ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to connect to.
   * Example: Any endpoint with the label "role=frontend" is not allowed to initiate connections to destination port 8080/tcp
   *
   * @schema CiliumNetworkPolicySpecEgressDeny#toPorts
   */
  readonly toPorts?: CiliumNetworkPolicySpecEgressDenyToPorts[];

  /**
   * ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints.
   * Example: Any Endpoint with the label "team=A" requires any endpoint to which it communicates to also carry the label "team=A".
   *
   * @schema CiliumNetworkPolicySpecEgressDeny#toRequires
   */
  readonly toRequires?: CiliumNetworkPolicySpecEgressDenyToRequires[];

  /**
   * ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors.
   * Example: Any endpoint with the label "app=backend-app" is allowed to initiate connections to all cidrs backing the "external-service" service
   *
   * @schema CiliumNetworkPolicySpecEgressDeny#toServices
   */
  readonly toServices?: CiliumNetworkPolicySpecEgressDenyToServices[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressDeny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressDeny(obj: CiliumNetworkPolicySpecEgressDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'icmps': obj.icmps?.map(y => toJson_CiliumNetworkPolicySpecEgressDenyIcmps(y)),
    'toCIDR': obj.toCidr?.map(y => y),
    'toCIDRSet': obj.toCidrSet?.map(y => toJson_CiliumNetworkPolicySpecEgressDenyToCidrSet(y)),
    'toEndpoints': obj.toEndpoints?.map(y => toJson_CiliumNetworkPolicySpecEgressDenyToEndpoints(y)),
    'toEntities': obj.toEntities?.map(y => y),
    'toGroups': obj.toGroups?.map(y => toJson_CiliumNetworkPolicySpecEgressDenyToGroups(y)),
    'toPorts': obj.toPorts?.map(y => toJson_CiliumNetworkPolicySpecEgressDenyToPorts(y)),
    'toRequires': obj.toRequires?.map(y => toJson_CiliumNetworkPolicySpecEgressDenyToRequires(y)),
    'toServices': obj.toServices?.map(y => toJson_CiliumNetworkPolicySpecEgressDenyToServices(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector selects all endpoints which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive.
 *
 * @schema CiliumNetworkPolicySpecEndpointSelector
 */
export interface CiliumNetworkPolicySpecEndpointSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecEndpointSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumNetworkPolicySpecEndpointSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecEndpointSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEndpointSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEndpointSelector(obj: CiliumNetworkPolicySpecEndpointSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNetworkPolicySpecEndpointSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IngressRule contains all rule types which can be applied at ingress, i.e. network traffic that originates outside of the endpoint and is entering the endpoint selected by the endpointSelector.
 * - All members of this structure are optional. If omitted or empty, the member will have no effect on the rule.
 * - If multiple members are set, all of them need to match in order for the rule to take effect. The exception to this rule is FromRequires field; the effects of any Requires field in any rule will apply to all other rules as well.
 * - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually exclusive. Only one of these members may be present within an individual rule.
 *
 * @schema CiliumNetworkPolicySpecIngress
 */
export interface CiliumNetworkPolicySpecIngress {
  /**
   * Authentication is the required authentication type for the allowed traffic, if any.
   *
   * @schema CiliumNetworkPolicySpecIngress#authentication
   */
  readonly authentication?: CiliumNetworkPolicySpecIngressAuthentication;

  /**
   * FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do *not* originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field.  This will match on the source IP address of incoming connections. Adding  a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are allowed between FromCIDR and FromCIDRSet.
   * Example: Any endpoint with the label "app=my-legacy-pet" is allowed to receive connections from 10.3.9.1
   *
   * @schema CiliumNetworkPolicySpecIngress#fromCIDR
   */
  readonly fromCidr?: string[];

  /**
   * FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
   * Example: Any endpoint with the label "app=my-legacy-pet" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
   *
   * @schema CiliumNetworkPolicySpecIngress#fromCIDRSet
   */
  readonly fromCidrSet?: CiliumNetworkPolicySpecIngressFromCidrSet[];

  /**
   * FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule.
   * Example: Any endpoint with the label "role=backend" can be consumed by any endpoint carrying the label "role=frontend".
   *
   * @schema CiliumNetworkPolicySpecIngress#fromEndpoints
   */
  readonly fromEndpoints?: CiliumNetworkPolicySpecIngressFromEndpoints[];

  /**
   * FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are `world`, `cluster` and `host`
   *
   * @schema CiliumNetworkPolicySpecIngress#fromEntities
   */
  readonly fromEntities?: CiliumNetworkPolicySpecIngressFromEntities[];

  /**
   * FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints.
   * Example: Any Endpoint with the label "team=A" requires consuming endpoint to also carry the label "team=A".
   *
   * @schema CiliumNetworkPolicySpecIngress#fromRequires
   */
  readonly fromRequires?: CiliumNetworkPolicySpecIngressFromRequires[];

  /**
   * ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to receive connections on.
   * Example: Any endpoint with the label "app=httpd" can only accept incoming type 8 ICMP connections.
   *
   * @schema CiliumNetworkPolicySpecIngress#icmps
   */
  readonly icmps?: CiliumNetworkPolicySpecIngressIcmps[];

  /**
   * ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to receive connections on.
   * Example: Any endpoint with the label "app=httpd" can only accept incoming connections on port 80/tcp.
   *
   * @schema CiliumNetworkPolicySpecIngress#toPorts
   */
  readonly toPorts?: CiliumNetworkPolicySpecIngressToPorts[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngress(obj: CiliumNetworkPolicySpecIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authentication': toJson_CiliumNetworkPolicySpecIngressAuthentication(obj.authentication),
    'fromCIDR': obj.fromCidr?.map(y => y),
    'fromCIDRSet': obj.fromCidrSet?.map(y => toJson_CiliumNetworkPolicySpecIngressFromCidrSet(y)),
    'fromEndpoints': obj.fromEndpoints?.map(y => toJson_CiliumNetworkPolicySpecIngressFromEndpoints(y)),
    'fromEntities': obj.fromEntities?.map(y => y),
    'fromRequires': obj.fromRequires?.map(y => toJson_CiliumNetworkPolicySpecIngressFromRequires(y)),
    'icmps': obj.icmps?.map(y => toJson_CiliumNetworkPolicySpecIngressIcmps(y)),
    'toPorts': obj.toPorts?.map(y => toJson_CiliumNetworkPolicySpecIngressToPorts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IngressDenyRule contains all rule types which can be applied at ingress, i.e. network traffic that originates outside of the endpoint and is entering the endpoint selected by the endpointSelector.
 * - All members of this structure are optional. If omitted or empty, the member will have no effect on the rule.
 * - If multiple members are set, all of them need to match in order for the rule to take effect. The exception to this rule is FromRequires field; the effects of any Requires field in any rule will apply to all other rules as well.
 * - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually exclusive. Only one of these members may be present within an individual rule.
 *
 * @schema CiliumNetworkPolicySpecIngressDeny
 */
export interface CiliumNetworkPolicySpecIngressDeny {
  /**
   * FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do *not* originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field.  This will match on the source IP address of incoming connections. Adding  a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are allowed between FromCIDR and FromCIDRSet.
   * Example: Any endpoint with the label "app=my-legacy-pet" is allowed to receive connections from 10.3.9.1
   *
   * @schema CiliumNetworkPolicySpecIngressDeny#fromCIDR
   */
  readonly fromCidr?: string[];

  /**
   * FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
   * Example: Any endpoint with the label "app=my-legacy-pet" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
   *
   * @schema CiliumNetworkPolicySpecIngressDeny#fromCIDRSet
   */
  readonly fromCidrSet?: CiliumNetworkPolicySpecIngressDenyFromCidrSet[];

  /**
   * FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule.
   * Example: Any endpoint with the label "role=backend" can be consumed by any endpoint carrying the label "role=frontend".
   *
   * @schema CiliumNetworkPolicySpecIngressDeny#fromEndpoints
   */
  readonly fromEndpoints?: CiliumNetworkPolicySpecIngressDenyFromEndpoints[];

  /**
   * FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are `world`, `cluster` and `host`
   *
   * @schema CiliumNetworkPolicySpecIngressDeny#fromEntities
   */
  readonly fromEntities?: CiliumNetworkPolicySpecIngressDenyFromEntities[];

  /**
   * FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints.
   * Example: Any Endpoint with the label "team=A" requires consuming endpoint to also carry the label "team=A".
   *
   * @schema CiliumNetworkPolicySpecIngressDeny#fromRequires
   */
  readonly fromRequires?: CiliumNetworkPolicySpecIngressDenyFromRequires[];

  /**
   * ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to receive connections on.
   * Example: Any endpoint with the label "app=httpd" can not accept incoming type 8 ICMP connections.
   *
   * @schema CiliumNetworkPolicySpecIngressDeny#icmps
   */
  readonly icmps?: CiliumNetworkPolicySpecIngressDenyIcmps[];

  /**
   * ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to receive connections on.
   * Example: Any endpoint with the label "app=httpd" can not accept incoming connections on port 80/tcp.
   *
   * @schema CiliumNetworkPolicySpecIngressDeny#toPorts
   */
  readonly toPorts?: CiliumNetworkPolicySpecIngressDenyToPorts[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressDeny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressDeny(obj: CiliumNetworkPolicySpecIngressDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromCIDR': obj.fromCidr?.map(y => y),
    'fromCIDRSet': obj.fromCidrSet?.map(y => toJson_CiliumNetworkPolicySpecIngressDenyFromCidrSet(y)),
    'fromEndpoints': obj.fromEndpoints?.map(y => toJson_CiliumNetworkPolicySpecIngressDenyFromEndpoints(y)),
    'fromEntities': obj.fromEntities?.map(y => y),
    'fromRequires': obj.fromRequires?.map(y => toJson_CiliumNetworkPolicySpecIngressDenyFromRequires(y)),
    'icmps': obj.icmps?.map(y => toJson_CiliumNetworkPolicySpecIngressDenyIcmps(y)),
    'toPorts': obj.toPorts?.map(y => toJson_CiliumNetworkPolicySpecIngressDenyToPorts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Label is the Cilium's representation of a container label.
 *
 * @schema CiliumNetworkPolicySpecLabels
 */
export interface CiliumNetworkPolicySpecLabels {
  /**
   * @schema CiliumNetworkPolicySpecLabels#key
   */
  readonly key: string;

  /**
   * Source can be one of the above values (e.g.: LabelSourceContainer).
   *
   * @schema CiliumNetworkPolicySpecLabels#source
   */
  readonly source?: string;

  /**
   * @schema CiliumNetworkPolicySpecLabels#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecLabels(obj: CiliumNetworkPolicySpecLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'source': obj.source,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodeSelector selects all nodes which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive. Can only be used in CiliumClusterwideNetworkPolicies.
 *
 * @schema CiliumNetworkPolicySpecNodeSelector
 */
export interface CiliumNetworkPolicySpecNodeSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecNodeSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumNetworkPolicySpecNodeSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecNodeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecNodeSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecNodeSelector(obj: CiliumNetworkPolicySpecNodeSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNetworkPolicySpecNodeSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EgressRule contains all rule types which can be applied at egress, i.e. network traffic that originates inside the endpoint and exits the endpoint selected by the endpointSelector.
 * - All members of this structure are optional. If omitted or empty, the member will have no effect on the rule.
 * - If multiple members of the structure are specified, then all members must match in order for the rule to take effect. The exception to this rule is the ToRequires member; the effects of any Requires field in any rule will apply to all other rules as well.
 * - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are mutually exclusive. Only one of these members may be present within an individual rule.
 *
 * @schema CiliumNetworkPolicySpecsEgress
 */
export interface CiliumNetworkPolicySpecsEgress {
  /**
   * Authentication is the required authentication type for the allowed traffic, if any.
   *
   * @schema CiliumNetworkPolicySpecsEgress#authentication
   */
  readonly authentication?: CiliumNetworkPolicySpecsEgressAuthentication;

  /**
   * ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to connect to.
   * Example: Any endpoint with the label "app=httpd" is allowed to initiate type 8 ICMP connections.
   *
   * @schema CiliumNetworkPolicySpecsEgress#icmps
   */
  readonly icmps?: CiliumNetworkPolicySpecsEgressIcmps[];

  /**
   * ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules.  This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet.
   * Example: Any endpoint with the label "app=database-proxy" is allowed to initiate connections to 10.2.3.0/24
   *
   * @schema CiliumNetworkPolicySpecsEgress#toCIDR
   */
  readonly toCidr?: string[];

  /**
   * ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet.
   * Example: Any endpoint with the label "app=database-proxy" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
   *
   * @schema CiliumNetworkPolicySpecsEgress#toCIDRSet
   */
  readonly toCidrSet?: CiliumNetworkPolicySpecsEgressToCidrSet[];

  /**
   * ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate.
   * Example: Any endpoint with the label "role=frontend" can communicate with any endpoint carrying the label "role=backend".
   *
   * @schema CiliumNetworkPolicySpecsEgress#toEndpoints
   */
  readonly toEndpoints?: CiliumNetworkPolicySpecsEgressToEndpoints[];

  /**
   * ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`, `health`,`unmanaged` and `all`.
   *
   * @schema CiliumNetworkPolicySpecsEgress#toEntities
   */
  readonly toEntities?: CiliumNetworkPolicySpecsEgressToEntities[];

  /**
   * ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result from DNS resolution of `ToFQDN.MatchName`s are added to the same EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and L7 rules within this EgressRule will also apply to these IPs. The DNS -> IP mapping is re-resolved periodically from within the cilium-agent, and the IPs in the DNS response are effected in the policy for selected pods as-is (i.e. the list of IPs is not modified in any way). Note: An explicit rule to allow for DNS traffic is needed for the pods, as ToFQDN counts as an egress rule and will enforce egress policy when PolicyEnforcment=default. Note: If the resolved IPs are IPs within the kubernetes cluster, the ToFQDN rule will not apply to that IP. Note: ToFQDN cannot occur in the same policy as other To* rules.
   *
   * @schema CiliumNetworkPolicySpecsEgress#toFQDNs
   */
  readonly toFqdNs?: CiliumNetworkPolicySpecsEgressToFqdNs[];

  /**
   * ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives:
   * Example: toGroups: - aws: securityGroupsIds: - 'sg-XXXXXXXXXXXXX'
   *
   * @schema CiliumNetworkPolicySpecsEgress#toGroups
   */
  readonly toGroups?: CiliumNetworkPolicySpecsEgressToGroups[];

  /**
   * ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to connect to.
   * Example: Any endpoint with the label "role=frontend" is allowed to initiate connections to destination port 8080/tcp
   *
   * @schema CiliumNetworkPolicySpecsEgress#toPorts
   */
  readonly toPorts?: CiliumNetworkPolicySpecsEgressToPorts[];

  /**
   * ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints.
   * Example: Any Endpoint with the label "team=A" requires any endpoint to which it communicates to also carry the label "team=A".
   *
   * @schema CiliumNetworkPolicySpecsEgress#toRequires
   */
  readonly toRequires?: CiliumNetworkPolicySpecsEgressToRequires[];

  /**
   * ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors.
   * Example: Any endpoint with the label "app=backend-app" is allowed to initiate connections to all cidrs backing the "external-service" service
   *
   * @schema CiliumNetworkPolicySpecsEgress#toServices
   */
  readonly toServices?: CiliumNetworkPolicySpecsEgressToServices[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgress(obj: CiliumNetworkPolicySpecsEgress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authentication': toJson_CiliumNetworkPolicySpecsEgressAuthentication(obj.authentication),
    'icmps': obj.icmps?.map(y => toJson_CiliumNetworkPolicySpecsEgressIcmps(y)),
    'toCIDR': obj.toCidr?.map(y => y),
    'toCIDRSet': obj.toCidrSet?.map(y => toJson_CiliumNetworkPolicySpecsEgressToCidrSet(y)),
    'toEndpoints': obj.toEndpoints?.map(y => toJson_CiliumNetworkPolicySpecsEgressToEndpoints(y)),
    'toEntities': obj.toEntities?.map(y => y),
    'toFQDNs': obj.toFqdNs?.map(y => toJson_CiliumNetworkPolicySpecsEgressToFqdNs(y)),
    'toGroups': obj.toGroups?.map(y => toJson_CiliumNetworkPolicySpecsEgressToGroups(y)),
    'toPorts': obj.toPorts?.map(y => toJson_CiliumNetworkPolicySpecsEgressToPorts(y)),
    'toRequires': obj.toRequires?.map(y => toJson_CiliumNetworkPolicySpecsEgressToRequires(y)),
    'toServices': obj.toServices?.map(y => toJson_CiliumNetworkPolicySpecsEgressToServices(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EgressDenyRule contains all rule types which can be applied at egress, i.e. network traffic that originates inside the endpoint and exits the endpoint selected by the endpointSelector.
 * - All members of this structure are optional. If omitted or empty, the member will have no effect on the rule.
 * - If multiple members of the structure are specified, then all members must match in order for the rule to take effect. The exception to this rule is the ToRequires member; the effects of any Requires field in any rule will apply to all other rules as well.
 * - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are mutually exclusive. Only one of these members may be present within an individual rule.
 *
 * @schema CiliumNetworkPolicySpecsEgressDeny
 */
export interface CiliumNetworkPolicySpecsEgressDeny {
  /**
   * ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to connect to.
   * Example: Any endpoint with the label "app=httpd" is not allowed to initiate type 8 ICMP connections.
   *
   * @schema CiliumNetworkPolicySpecsEgressDeny#icmps
   */
  readonly icmps?: CiliumNetworkPolicySpecsEgressDenyIcmps[];

  /**
   * ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules.  This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet.
   * Example: Any endpoint with the label "app=database-proxy" is allowed to initiate connections to 10.2.3.0/24
   *
   * @schema CiliumNetworkPolicySpecsEgressDeny#toCIDR
   */
  readonly toCidr?: string[];

  /**
   * ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet.
   * Example: Any endpoint with the label "app=database-proxy" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
   *
   * @schema CiliumNetworkPolicySpecsEgressDeny#toCIDRSet
   */
  readonly toCidrSet?: CiliumNetworkPolicySpecsEgressDenyToCidrSet[];

  /**
   * ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate.
   * Example: Any endpoint with the label "role=frontend" can communicate with any endpoint carrying the label "role=backend".
   *
   * @schema CiliumNetworkPolicySpecsEgressDeny#toEndpoints
   */
  readonly toEndpoints?: CiliumNetworkPolicySpecsEgressDenyToEndpoints[];

  /**
   * ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`, `health`,`unmanaged` and `all`.
   *
   * @schema CiliumNetworkPolicySpecsEgressDeny#toEntities
   */
  readonly toEntities?: CiliumNetworkPolicySpecsEgressDenyToEntities[];

  /**
   * ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives:
   * Example: toGroups: - aws: securityGroupsIds: - 'sg-XXXXXXXXXXXXX'
   *
   * @schema CiliumNetworkPolicySpecsEgressDeny#toGroups
   */
  readonly toGroups?: CiliumNetworkPolicySpecsEgressDenyToGroups[];

  /**
   * ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to connect to.
   * Example: Any endpoint with the label "role=frontend" is not allowed to initiate connections to destination port 8080/tcp
   *
   * @schema CiliumNetworkPolicySpecsEgressDeny#toPorts
   */
  readonly toPorts?: CiliumNetworkPolicySpecsEgressDenyToPorts[];

  /**
   * ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints.
   * Example: Any Endpoint with the label "team=A" requires any endpoint to which it communicates to also carry the label "team=A".
   *
   * @schema CiliumNetworkPolicySpecsEgressDeny#toRequires
   */
  readonly toRequires?: CiliumNetworkPolicySpecsEgressDenyToRequires[];

  /**
   * ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors.
   * Example: Any endpoint with the label "app=backend-app" is allowed to initiate connections to all cidrs backing the "external-service" service
   *
   * @schema CiliumNetworkPolicySpecsEgressDeny#toServices
   */
  readonly toServices?: CiliumNetworkPolicySpecsEgressDenyToServices[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressDeny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressDeny(obj: CiliumNetworkPolicySpecsEgressDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'icmps': obj.icmps?.map(y => toJson_CiliumNetworkPolicySpecsEgressDenyIcmps(y)),
    'toCIDR': obj.toCidr?.map(y => y),
    'toCIDRSet': obj.toCidrSet?.map(y => toJson_CiliumNetworkPolicySpecsEgressDenyToCidrSet(y)),
    'toEndpoints': obj.toEndpoints?.map(y => toJson_CiliumNetworkPolicySpecsEgressDenyToEndpoints(y)),
    'toEntities': obj.toEntities?.map(y => y),
    'toGroups': obj.toGroups?.map(y => toJson_CiliumNetworkPolicySpecsEgressDenyToGroups(y)),
    'toPorts': obj.toPorts?.map(y => toJson_CiliumNetworkPolicySpecsEgressDenyToPorts(y)),
    'toRequires': obj.toRequires?.map(y => toJson_CiliumNetworkPolicySpecsEgressDenyToRequires(y)),
    'toServices': obj.toServices?.map(y => toJson_CiliumNetworkPolicySpecsEgressDenyToServices(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector selects all endpoints which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive.
 *
 * @schema CiliumNetworkPolicySpecsEndpointSelector
 */
export interface CiliumNetworkPolicySpecsEndpointSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecsEndpointSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumNetworkPolicySpecsEndpointSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecsEndpointSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEndpointSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEndpointSelector(obj: CiliumNetworkPolicySpecsEndpointSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNetworkPolicySpecsEndpointSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IngressRule contains all rule types which can be applied at ingress, i.e. network traffic that originates outside of the endpoint and is entering the endpoint selected by the endpointSelector.
 * - All members of this structure are optional. If omitted or empty, the member will have no effect on the rule.
 * - If multiple members are set, all of them need to match in order for the rule to take effect. The exception to this rule is FromRequires field; the effects of any Requires field in any rule will apply to all other rules as well.
 * - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually exclusive. Only one of these members may be present within an individual rule.
 *
 * @schema CiliumNetworkPolicySpecsIngress
 */
export interface CiliumNetworkPolicySpecsIngress {
  /**
   * Authentication is the required authentication type for the allowed traffic, if any.
   *
   * @schema CiliumNetworkPolicySpecsIngress#authentication
   */
  readonly authentication?: CiliumNetworkPolicySpecsIngressAuthentication;

  /**
   * FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do *not* originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field.  This will match on the source IP address of incoming connections. Adding  a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are allowed between FromCIDR and FromCIDRSet.
   * Example: Any endpoint with the label "app=my-legacy-pet" is allowed to receive connections from 10.3.9.1
   *
   * @schema CiliumNetworkPolicySpecsIngress#fromCIDR
   */
  readonly fromCidr?: string[];

  /**
   * FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
   * Example: Any endpoint with the label "app=my-legacy-pet" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
   *
   * @schema CiliumNetworkPolicySpecsIngress#fromCIDRSet
   */
  readonly fromCidrSet?: CiliumNetworkPolicySpecsIngressFromCidrSet[];

  /**
   * FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule.
   * Example: Any endpoint with the label "role=backend" can be consumed by any endpoint carrying the label "role=frontend".
   *
   * @schema CiliumNetworkPolicySpecsIngress#fromEndpoints
   */
  readonly fromEndpoints?: CiliumNetworkPolicySpecsIngressFromEndpoints[];

  /**
   * FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are `world`, `cluster` and `host`
   *
   * @schema CiliumNetworkPolicySpecsIngress#fromEntities
   */
  readonly fromEntities?: CiliumNetworkPolicySpecsIngressFromEntities[];

  /**
   * FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints.
   * Example: Any Endpoint with the label "team=A" requires consuming endpoint to also carry the label "team=A".
   *
   * @schema CiliumNetworkPolicySpecsIngress#fromRequires
   */
  readonly fromRequires?: CiliumNetworkPolicySpecsIngressFromRequires[];

  /**
   * ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to receive connections on.
   * Example: Any endpoint with the label "app=httpd" can only accept incoming type 8 ICMP connections.
   *
   * @schema CiliumNetworkPolicySpecsIngress#icmps
   */
  readonly icmps?: CiliumNetworkPolicySpecsIngressIcmps[];

  /**
   * ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to receive connections on.
   * Example: Any endpoint with the label "app=httpd" can only accept incoming connections on port 80/tcp.
   *
   * @schema CiliumNetworkPolicySpecsIngress#toPorts
   */
  readonly toPorts?: CiliumNetworkPolicySpecsIngressToPorts[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngress(obj: CiliumNetworkPolicySpecsIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authentication': toJson_CiliumNetworkPolicySpecsIngressAuthentication(obj.authentication),
    'fromCIDR': obj.fromCidr?.map(y => y),
    'fromCIDRSet': obj.fromCidrSet?.map(y => toJson_CiliumNetworkPolicySpecsIngressFromCidrSet(y)),
    'fromEndpoints': obj.fromEndpoints?.map(y => toJson_CiliumNetworkPolicySpecsIngressFromEndpoints(y)),
    'fromEntities': obj.fromEntities?.map(y => y),
    'fromRequires': obj.fromRequires?.map(y => toJson_CiliumNetworkPolicySpecsIngressFromRequires(y)),
    'icmps': obj.icmps?.map(y => toJson_CiliumNetworkPolicySpecsIngressIcmps(y)),
    'toPorts': obj.toPorts?.map(y => toJson_CiliumNetworkPolicySpecsIngressToPorts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IngressDenyRule contains all rule types which can be applied at ingress, i.e. network traffic that originates outside of the endpoint and is entering the endpoint selected by the endpointSelector.
 * - All members of this structure are optional. If omitted or empty, the member will have no effect on the rule.
 * - If multiple members are set, all of them need to match in order for the rule to take effect. The exception to this rule is FromRequires field; the effects of any Requires field in any rule will apply to all other rules as well.
 * - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually exclusive. Only one of these members may be present within an individual rule.
 *
 * @schema CiliumNetworkPolicySpecsIngressDeny
 */
export interface CiliumNetworkPolicySpecsIngressDeny {
  /**
   * FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do *not* originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field.  This will match on the source IP address of incoming connections. Adding  a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are allowed between FromCIDR and FromCIDRSet.
   * Example: Any endpoint with the label "app=my-legacy-pet" is allowed to receive connections from 10.3.9.1
   *
   * @schema CiliumNetworkPolicySpecsIngressDeny#fromCIDR
   */
  readonly fromCidr?: string[];

  /**
   * FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
   * Example: Any endpoint with the label "app=my-legacy-pet" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
   *
   * @schema CiliumNetworkPolicySpecsIngressDeny#fromCIDRSet
   */
  readonly fromCidrSet?: CiliumNetworkPolicySpecsIngressDenyFromCidrSet[];

  /**
   * FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule.
   * Example: Any endpoint with the label "role=backend" can be consumed by any endpoint carrying the label "role=frontend".
   *
   * @schema CiliumNetworkPolicySpecsIngressDeny#fromEndpoints
   */
  readonly fromEndpoints?: CiliumNetworkPolicySpecsIngressDenyFromEndpoints[];

  /**
   * FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are `world`, `cluster` and `host`
   *
   * @schema CiliumNetworkPolicySpecsIngressDeny#fromEntities
   */
  readonly fromEntities?: CiliumNetworkPolicySpecsIngressDenyFromEntities[];

  /**
   * FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints.
   * Example: Any Endpoint with the label "team=A" requires consuming endpoint to also carry the label "team=A".
   *
   * @schema CiliumNetworkPolicySpecsIngressDeny#fromRequires
   */
  readonly fromRequires?: CiliumNetworkPolicySpecsIngressDenyFromRequires[];

  /**
   * ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to receive connections on.
   * Example: Any endpoint with the label "app=httpd" can not accept incoming type 8 ICMP connections.
   *
   * @schema CiliumNetworkPolicySpecsIngressDeny#icmps
   */
  readonly icmps?: CiliumNetworkPolicySpecsIngressDenyIcmps[];

  /**
   * ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to receive connections on.
   * Example: Any endpoint with the label "app=httpd" can not accept incoming connections on port 80/tcp.
   *
   * @schema CiliumNetworkPolicySpecsIngressDeny#toPorts
   */
  readonly toPorts?: CiliumNetworkPolicySpecsIngressDenyToPorts[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressDeny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressDeny(obj: CiliumNetworkPolicySpecsIngressDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromCIDR': obj.fromCidr?.map(y => y),
    'fromCIDRSet': obj.fromCidrSet?.map(y => toJson_CiliumNetworkPolicySpecsIngressDenyFromCidrSet(y)),
    'fromEndpoints': obj.fromEndpoints?.map(y => toJson_CiliumNetworkPolicySpecsIngressDenyFromEndpoints(y)),
    'fromEntities': obj.fromEntities?.map(y => y),
    'fromRequires': obj.fromRequires?.map(y => toJson_CiliumNetworkPolicySpecsIngressDenyFromRequires(y)),
    'icmps': obj.icmps?.map(y => toJson_CiliumNetworkPolicySpecsIngressDenyIcmps(y)),
    'toPorts': obj.toPorts?.map(y => toJson_CiliumNetworkPolicySpecsIngressDenyToPorts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Label is the Cilium's representation of a container label.
 *
 * @schema CiliumNetworkPolicySpecsLabels
 */
export interface CiliumNetworkPolicySpecsLabels {
  /**
   * @schema CiliumNetworkPolicySpecsLabels#key
   */
  readonly key: string;

  /**
   * Source can be one of the above values (e.g.: LabelSourceContainer).
   *
   * @schema CiliumNetworkPolicySpecsLabels#source
   */
  readonly source?: string;

  /**
   * @schema CiliumNetworkPolicySpecsLabels#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsLabels(obj: CiliumNetworkPolicySpecsLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'source': obj.source,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodeSelector selects all nodes which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive. Can only be used in CiliumClusterwideNetworkPolicies.
 *
 * @schema CiliumNetworkPolicySpecsNodeSelector
 */
export interface CiliumNetworkPolicySpecsNodeSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecsNodeSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumNetworkPolicySpecsNodeSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecsNodeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsNodeSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsNodeSelector(obj: CiliumNetworkPolicySpecsNodeSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNetworkPolicySpecsNodeSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication is the required authentication type for the allowed traffic, if any.
 *
 * @schema CiliumNetworkPolicySpecEgressAuthentication
 */
export interface CiliumNetworkPolicySpecEgressAuthentication {
  /**
   * Mode is the required authentication mode for the allowed traffic, if any.
   *
   * @schema CiliumNetworkPolicySpecEgressAuthentication#mode
   */
  readonly mode: CiliumNetworkPolicySpecEgressAuthenticationMode;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressAuthentication(obj: CiliumNetworkPolicySpecEgressAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPRule is a list of ICMP fields.
 *
 * @schema CiliumNetworkPolicySpecEgressIcmps
 */
export interface CiliumNetworkPolicySpecEgressIcmps {
  /**
   * Fields is a list of ICMP fields.
   *
   * @schema CiliumNetworkPolicySpecEgressIcmps#fields
   */
  readonly fields?: CiliumNetworkPolicySpecEgressIcmpsFields[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressIcmps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressIcmps(obj: CiliumNetworkPolicySpecEgressIcmps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fields': obj.fields?.map(y => toJson_CiliumNetworkPolicySpecEgressIcmpsFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.
 *
 * @schema CiliumNetworkPolicySpecEgressToCidrSet
 */
export interface CiliumNetworkPolicySpecEgressToCidrSet {
  /**
   * CIDR is a CIDR prefix / IP Block.
   *
   * @schema CiliumNetworkPolicySpecEgressToCidrSet#cidr
   */
  readonly cidr?: string;

  /**
   * CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.
   *
   * @schema CiliumNetworkPolicySpecEgressToCidrSet#cidrGroupRef
   */
  readonly cidrGroupRef?: string;

  /**
   * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.
   *
   * @schema CiliumNetworkPolicySpecEgressToCidrSet#except
   */
  readonly except?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToCidrSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToCidrSet(obj: CiliumNetworkPolicySpecEgressToCidrSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'cidrGroupRef': obj.cidrGroupRef,
    'except': obj.except?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumNetworkPolicySpecEgressToEndpoints
 */
export interface CiliumNetworkPolicySpecEgressToEndpoints {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecEgressToEndpoints#matchExpressions
   */
  readonly matchExpressions?: CiliumNetworkPolicySpecEgressToEndpointsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecEgressToEndpoints#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToEndpoints(obj: CiliumNetworkPolicySpecEgressToEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNetworkPolicySpecEgressToEndpointsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe "outside of cluster", "host", etc.
 *
 * @schema CiliumNetworkPolicySpecEgressToEntities
 */
export enum CiliumNetworkPolicySpecEgressToEntities {
  /** all */
  ALL = "all",
  /** world */
  WORLD = "world",
  /** cluster */
  CLUSTER = "cluster",
  /** host */
  HOST = "host",
  /** init */
  INIT = "init",
  /** ingress */
  INGRESS = "ingress",
  /** unmanaged */
  UNMANAGED = "unmanaged",
  /** remote-node */
  REMOTE_HYPHEN_NODE = "remote-node",
  /** health */
  HEALTH = "health",
  /** none */
  NONE = "none",
  /** kube-apiserver */
  KUBE_HYPHEN_APISERVER = "kube-apiserver",
}

/**
 * @schema CiliumNetworkPolicySpecEgressToFqdNs
 */
export interface CiliumNetworkPolicySpecEgressToFqdNs {
  /**
   * MatchName matches literal DNS names. A trailing "." is automatically added when missing.
   *
   * @schema CiliumNetworkPolicySpecEgressToFqdNs#matchName
   */
  readonly matchName?: string;

  /**
   * MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - "*" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a "*" as the leftmost character, without a following "." matches all subdomains as well as the name to the right. A trailing "." is automatically added when missing.
   * Examples: `*.cilium.io` matches subomains of cilium at that level www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io" except those containing "." separator, subcilium.io and sub-cilium.io match, www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with "sub" sub.cilium.io and subdomain.cilium.io match, www.cilium.io, blog.cilium.io, cilium.io and google.com do not
   *
   * @schema CiliumNetworkPolicySpecEgressToFqdNs#matchPattern
   */
  readonly matchPattern?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToFqdNs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToFqdNs(obj: CiliumNetworkPolicySpecEgressToFqdNs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchName': obj.matchName,
    'matchPattern': obj.matchPattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ToGroups structure to store all kinds of new integrations that needs a new derivative policy.
 *
 * @schema CiliumNetworkPolicySpecEgressToGroups
 */
export interface CiliumNetworkPolicySpecEgressToGroups {
  /**
   * AWSGroup is an structure that can be used to whitelisting information from AWS integration
   *
   * @schema CiliumNetworkPolicySpecEgressToGroups#aws
   */
  readonly aws?: CiliumNetworkPolicySpecEgressToGroupsAws;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToGroups' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToGroups(obj: CiliumNetworkPolicySpecEgressToGroups | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aws': toJson_CiliumNetworkPolicySpecEgressToGroupsAws(obj.aws),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortRule is a list of ports/protocol combinations with optional Layer 7 rules which must be met.
 *
 * @schema CiliumNetworkPolicySpecEgressToPorts
 */
export interface CiliumNetworkPolicySpecEgressToPorts {
  /**
   * listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.
   *
   * @schema CiliumNetworkPolicySpecEgressToPorts#listener
   */
  readonly listener?: CiliumNetworkPolicySpecEgressToPortsListener;

  /**
   * OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.
   *
   * @schema CiliumNetworkPolicySpecEgressToPorts#originatingTLS
   */
  readonly originatingTls?: CiliumNetworkPolicySpecEgressToPortsOriginatingTls;

  /**
   * Ports is a list of L4 port/protocol
   *
   * @schema CiliumNetworkPolicySpecEgressToPorts#ports
   */
  readonly ports?: CiliumNetworkPolicySpecEgressToPortsPorts[];

  /**
   * Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.
   *
   * @schema CiliumNetworkPolicySpecEgressToPorts#rules
   */
  readonly rules?: CiliumNetworkPolicySpecEgressToPortsRules;

  /**
   * ServerNames is a list of allowed TLS SNI values. If not empty, then TLS must be present and one of the provided SNIs must be indicated in the TLS handshake.
   *
   * @schema CiliumNetworkPolicySpecEgressToPorts#serverNames
   */
  readonly serverNames?: string[];

  /**
   * TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.
   *
   * @schema CiliumNetworkPolicySpecEgressToPorts#terminatingTLS
   */
  readonly terminatingTls?: CiliumNetworkPolicySpecEgressToPortsTerminatingTls;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToPorts(obj: CiliumNetworkPolicySpecEgressToPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'listener': toJson_CiliumNetworkPolicySpecEgressToPortsListener(obj.listener),
    'originatingTLS': toJson_CiliumNetworkPolicySpecEgressToPortsOriginatingTls(obj.originatingTls),
    'ports': obj.ports?.map(y => toJson_CiliumNetworkPolicySpecEgressToPortsPorts(y)),
    'rules': toJson_CiliumNetworkPolicySpecEgressToPortsRules(obj.rules),
    'serverNames': obj.serverNames?.map(y => y),
    'terminatingTLS': toJson_CiliumNetworkPolicySpecEgressToPortsTerminatingTls(obj.terminatingTls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumNetworkPolicySpecEgressToRequires
 */
export interface CiliumNetworkPolicySpecEgressToRequires {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecEgressToRequires#matchExpressions
   */
  readonly matchExpressions?: CiliumNetworkPolicySpecEgressToRequiresMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecEgressToRequires#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToRequires' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToRequires(obj: CiliumNetworkPolicySpecEgressToRequires | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNetworkPolicySpecEgressToRequiresMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Service wraps around selectors for services
 *
 * @schema CiliumNetworkPolicySpecEgressToServices
 */
export interface CiliumNetworkPolicySpecEgressToServices {
  /**
   * K8sService selects service by name and namespace pair
   *
   * @schema CiliumNetworkPolicySpecEgressToServices#k8sService
   */
  readonly k8SService?: CiliumNetworkPolicySpecEgressToServicesK8SService;

  /**
   * K8sServiceSelector selects services by k8s labels and namespace
   *
   * @schema CiliumNetworkPolicySpecEgressToServices#k8sServiceSelector
   */
  readonly k8SServiceSelector?: CiliumNetworkPolicySpecEgressToServicesK8SServiceSelector;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToServices(obj: CiliumNetworkPolicySpecEgressToServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'k8sService': toJson_CiliumNetworkPolicySpecEgressToServicesK8SService(obj.k8SService),
    'k8sServiceSelector': toJson_CiliumNetworkPolicySpecEgressToServicesK8SServiceSelector(obj.k8SServiceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPRule is a list of ICMP fields.
 *
 * @schema CiliumNetworkPolicySpecEgressDenyIcmps
 */
export interface CiliumNetworkPolicySpecEgressDenyIcmps {
  /**
   * Fields is a list of ICMP fields.
   *
   * @schema CiliumNetworkPolicySpecEgressDenyIcmps#fields
   */
  readonly fields?: CiliumNetworkPolicySpecEgressDenyIcmpsFields[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressDenyIcmps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressDenyIcmps(obj: CiliumNetworkPolicySpecEgressDenyIcmps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fields': obj.fields?.map(y => toJson_CiliumNetworkPolicySpecEgressDenyIcmpsFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.
 *
 * @schema CiliumNetworkPolicySpecEgressDenyToCidrSet
 */
export interface CiliumNetworkPolicySpecEgressDenyToCidrSet {
  /**
   * CIDR is a CIDR prefix / IP Block.
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToCidrSet#cidr
   */
  readonly cidr?: string;

  /**
   * CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToCidrSet#cidrGroupRef
   */
  readonly cidrGroupRef?: string;

  /**
   * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToCidrSet#except
   */
  readonly except?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressDenyToCidrSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressDenyToCidrSet(obj: CiliumNetworkPolicySpecEgressDenyToCidrSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'cidrGroupRef': obj.cidrGroupRef,
    'except': obj.except?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumNetworkPolicySpecEgressDenyToEndpoints
 */
export interface CiliumNetworkPolicySpecEgressDenyToEndpoints {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToEndpoints#matchExpressions
   */
  readonly matchExpressions?: CiliumNetworkPolicySpecEgressDenyToEndpointsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToEndpoints#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressDenyToEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressDenyToEndpoints(obj: CiliumNetworkPolicySpecEgressDenyToEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNetworkPolicySpecEgressDenyToEndpointsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe "outside of cluster", "host", etc.
 *
 * @schema CiliumNetworkPolicySpecEgressDenyToEntities
 */
export enum CiliumNetworkPolicySpecEgressDenyToEntities {
  /** all */
  ALL = "all",
  /** world */
  WORLD = "world",
  /** cluster */
  CLUSTER = "cluster",
  /** host */
  HOST = "host",
  /** init */
  INIT = "init",
  /** ingress */
  INGRESS = "ingress",
  /** unmanaged */
  UNMANAGED = "unmanaged",
  /** remote-node */
  REMOTE_HYPHEN_NODE = "remote-node",
  /** health */
  HEALTH = "health",
  /** none */
  NONE = "none",
  /** kube-apiserver */
  KUBE_HYPHEN_APISERVER = "kube-apiserver",
}

/**
 * ToGroups structure to store all kinds of new integrations that needs a new derivative policy.
 *
 * @schema CiliumNetworkPolicySpecEgressDenyToGroups
 */
export interface CiliumNetworkPolicySpecEgressDenyToGroups {
  /**
   * AWSGroup is an structure that can be used to whitelisting information from AWS integration
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToGroups#aws
   */
  readonly aws?: CiliumNetworkPolicySpecEgressDenyToGroupsAws;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressDenyToGroups' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressDenyToGroups(obj: CiliumNetworkPolicySpecEgressDenyToGroups | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aws': toJson_CiliumNetworkPolicySpecEgressDenyToGroupsAws(obj.aws),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortDenyRule is a list of ports/protocol that should be used for deny policies. This structure lacks the L7Rules since it's not supported in deny policies.
 *
 * @schema CiliumNetworkPolicySpecEgressDenyToPorts
 */
export interface CiliumNetworkPolicySpecEgressDenyToPorts {
  /**
   * Ports is a list of L4 port/protocol
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToPorts#ports
   */
  readonly ports?: CiliumNetworkPolicySpecEgressDenyToPortsPorts[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressDenyToPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressDenyToPorts(obj: CiliumNetworkPolicySpecEgressDenyToPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => toJson_CiliumNetworkPolicySpecEgressDenyToPortsPorts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumNetworkPolicySpecEgressDenyToRequires
 */
export interface CiliumNetworkPolicySpecEgressDenyToRequires {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToRequires#matchExpressions
   */
  readonly matchExpressions?: CiliumNetworkPolicySpecEgressDenyToRequiresMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToRequires#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressDenyToRequires' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressDenyToRequires(obj: CiliumNetworkPolicySpecEgressDenyToRequires | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNetworkPolicySpecEgressDenyToRequiresMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Service wraps around selectors for services
 *
 * @schema CiliumNetworkPolicySpecEgressDenyToServices
 */
export interface CiliumNetworkPolicySpecEgressDenyToServices {
  /**
   * K8sService selects service by name and namespace pair
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToServices#k8sService
   */
  readonly k8SService?: CiliumNetworkPolicySpecEgressDenyToServicesK8SService;

  /**
   * K8sServiceSelector selects services by k8s labels and namespace
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToServices#k8sServiceSelector
   */
  readonly k8SServiceSelector?: CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelector;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressDenyToServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressDenyToServices(obj: CiliumNetworkPolicySpecEgressDenyToServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'k8sService': toJson_CiliumNetworkPolicySpecEgressDenyToServicesK8SService(obj.k8SService),
    'k8sServiceSelector': toJson_CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelector(obj.k8SServiceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNetworkPolicySpecEndpointSelectorMatchExpressions
 */
export interface CiliumNetworkPolicySpecEndpointSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNetworkPolicySpecEndpointSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNetworkPolicySpecEndpointSelectorMatchExpressions#operator
   */
  readonly operator: CiliumNetworkPolicySpecEndpointSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNetworkPolicySpecEndpointSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEndpointSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEndpointSelectorMatchExpressions(obj: CiliumNetworkPolicySpecEndpointSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication is the required authentication type for the allowed traffic, if any.
 *
 * @schema CiliumNetworkPolicySpecIngressAuthentication
 */
export interface CiliumNetworkPolicySpecIngressAuthentication {
  /**
   * Mode is the required authentication mode for the allowed traffic, if any.
   *
   * @schema CiliumNetworkPolicySpecIngressAuthentication#mode
   */
  readonly mode: CiliumNetworkPolicySpecIngressAuthenticationMode;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressAuthentication(obj: CiliumNetworkPolicySpecIngressAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.
 *
 * @schema CiliumNetworkPolicySpecIngressFromCidrSet
 */
export interface CiliumNetworkPolicySpecIngressFromCidrSet {
  /**
   * CIDR is a CIDR prefix / IP Block.
   *
   * @schema CiliumNetworkPolicySpecIngressFromCidrSet#cidr
   */
  readonly cidr?: string;

  /**
   * CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.
   *
   * @schema CiliumNetworkPolicySpecIngressFromCidrSet#cidrGroupRef
   */
  readonly cidrGroupRef?: string;

  /**
   * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.
   *
   * @schema CiliumNetworkPolicySpecIngressFromCidrSet#except
   */
  readonly except?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressFromCidrSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressFromCidrSet(obj: CiliumNetworkPolicySpecIngressFromCidrSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'cidrGroupRef': obj.cidrGroupRef,
    'except': obj.except?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumNetworkPolicySpecIngressFromEndpoints
 */
export interface CiliumNetworkPolicySpecIngressFromEndpoints {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecIngressFromEndpoints#matchExpressions
   */
  readonly matchExpressions?: CiliumNetworkPolicySpecIngressFromEndpointsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecIngressFromEndpoints#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressFromEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressFromEndpoints(obj: CiliumNetworkPolicySpecIngressFromEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNetworkPolicySpecIngressFromEndpointsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe "outside of cluster", "host", etc.
 *
 * @schema CiliumNetworkPolicySpecIngressFromEntities
 */
export enum CiliumNetworkPolicySpecIngressFromEntities {
  /** all */
  ALL = "all",
  /** world */
  WORLD = "world",
  /** cluster */
  CLUSTER = "cluster",
  /** host */
  HOST = "host",
  /** init */
  INIT = "init",
  /** ingress */
  INGRESS = "ingress",
  /** unmanaged */
  UNMANAGED = "unmanaged",
  /** remote-node */
  REMOTE_HYPHEN_NODE = "remote-node",
  /** health */
  HEALTH = "health",
  /** none */
  NONE = "none",
  /** kube-apiserver */
  KUBE_HYPHEN_APISERVER = "kube-apiserver",
}

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumNetworkPolicySpecIngressFromRequires
 */
export interface CiliumNetworkPolicySpecIngressFromRequires {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecIngressFromRequires#matchExpressions
   */
  readonly matchExpressions?: CiliumNetworkPolicySpecIngressFromRequiresMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecIngressFromRequires#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressFromRequires' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressFromRequires(obj: CiliumNetworkPolicySpecIngressFromRequires | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNetworkPolicySpecIngressFromRequiresMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPRule is a list of ICMP fields.
 *
 * @schema CiliumNetworkPolicySpecIngressIcmps
 */
export interface CiliumNetworkPolicySpecIngressIcmps {
  /**
   * Fields is a list of ICMP fields.
   *
   * @schema CiliumNetworkPolicySpecIngressIcmps#fields
   */
  readonly fields?: CiliumNetworkPolicySpecIngressIcmpsFields[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressIcmps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressIcmps(obj: CiliumNetworkPolicySpecIngressIcmps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fields': obj.fields?.map(y => toJson_CiliumNetworkPolicySpecIngressIcmpsFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortRule is a list of ports/protocol combinations with optional Layer 7 rules which must be met.
 *
 * @schema CiliumNetworkPolicySpecIngressToPorts
 */
export interface CiliumNetworkPolicySpecIngressToPorts {
  /**
   * listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.
   *
   * @schema CiliumNetworkPolicySpecIngressToPorts#listener
   */
  readonly listener?: CiliumNetworkPolicySpecIngressToPortsListener;

  /**
   * OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.
   *
   * @schema CiliumNetworkPolicySpecIngressToPorts#originatingTLS
   */
  readonly originatingTls?: CiliumNetworkPolicySpecIngressToPortsOriginatingTls;

  /**
   * Ports is a list of L4 port/protocol
   *
   * @schema CiliumNetworkPolicySpecIngressToPorts#ports
   */
  readonly ports?: CiliumNetworkPolicySpecIngressToPortsPorts[];

  /**
   * Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.
   *
   * @schema CiliumNetworkPolicySpecIngressToPorts#rules
   */
  readonly rules?: CiliumNetworkPolicySpecIngressToPortsRules;

  /**
   * ServerNames is a list of allowed TLS SNI values. If not empty, then TLS must be present and one of the provided SNIs must be indicated in the TLS handshake.
   *
   * @schema CiliumNetworkPolicySpecIngressToPorts#serverNames
   */
  readonly serverNames?: string[];

  /**
   * TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.
   *
   * @schema CiliumNetworkPolicySpecIngressToPorts#terminatingTLS
   */
  readonly terminatingTls?: CiliumNetworkPolicySpecIngressToPortsTerminatingTls;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressToPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressToPorts(obj: CiliumNetworkPolicySpecIngressToPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'listener': toJson_CiliumNetworkPolicySpecIngressToPortsListener(obj.listener),
    'originatingTLS': toJson_CiliumNetworkPolicySpecIngressToPortsOriginatingTls(obj.originatingTls),
    'ports': obj.ports?.map(y => toJson_CiliumNetworkPolicySpecIngressToPortsPorts(y)),
    'rules': toJson_CiliumNetworkPolicySpecIngressToPortsRules(obj.rules),
    'serverNames': obj.serverNames?.map(y => y),
    'terminatingTLS': toJson_CiliumNetworkPolicySpecIngressToPortsTerminatingTls(obj.terminatingTls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.
 *
 * @schema CiliumNetworkPolicySpecIngressDenyFromCidrSet
 */
export interface CiliumNetworkPolicySpecIngressDenyFromCidrSet {
  /**
   * CIDR is a CIDR prefix / IP Block.
   *
   * @schema CiliumNetworkPolicySpecIngressDenyFromCidrSet#cidr
   */
  readonly cidr?: string;

  /**
   * CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.
   *
   * @schema CiliumNetworkPolicySpecIngressDenyFromCidrSet#cidrGroupRef
   */
  readonly cidrGroupRef?: string;

  /**
   * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.
   *
   * @schema CiliumNetworkPolicySpecIngressDenyFromCidrSet#except
   */
  readonly except?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressDenyFromCidrSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressDenyFromCidrSet(obj: CiliumNetworkPolicySpecIngressDenyFromCidrSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'cidrGroupRef': obj.cidrGroupRef,
    'except': obj.except?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumNetworkPolicySpecIngressDenyFromEndpoints
 */
export interface CiliumNetworkPolicySpecIngressDenyFromEndpoints {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecIngressDenyFromEndpoints#matchExpressions
   */
  readonly matchExpressions?: CiliumNetworkPolicySpecIngressDenyFromEndpointsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecIngressDenyFromEndpoints#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressDenyFromEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressDenyFromEndpoints(obj: CiliumNetworkPolicySpecIngressDenyFromEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNetworkPolicySpecIngressDenyFromEndpointsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe "outside of cluster", "host", etc.
 *
 * @schema CiliumNetworkPolicySpecIngressDenyFromEntities
 */
export enum CiliumNetworkPolicySpecIngressDenyFromEntities {
  /** all */
  ALL = "all",
  /** world */
  WORLD = "world",
  /** cluster */
  CLUSTER = "cluster",
  /** host */
  HOST = "host",
  /** init */
  INIT = "init",
  /** ingress */
  INGRESS = "ingress",
  /** unmanaged */
  UNMANAGED = "unmanaged",
  /** remote-node */
  REMOTE_HYPHEN_NODE = "remote-node",
  /** health */
  HEALTH = "health",
  /** none */
  NONE = "none",
  /** kube-apiserver */
  KUBE_HYPHEN_APISERVER = "kube-apiserver",
}

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumNetworkPolicySpecIngressDenyFromRequires
 */
export interface CiliumNetworkPolicySpecIngressDenyFromRequires {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecIngressDenyFromRequires#matchExpressions
   */
  readonly matchExpressions?: CiliumNetworkPolicySpecIngressDenyFromRequiresMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecIngressDenyFromRequires#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressDenyFromRequires' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressDenyFromRequires(obj: CiliumNetworkPolicySpecIngressDenyFromRequires | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNetworkPolicySpecIngressDenyFromRequiresMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPRule is a list of ICMP fields.
 *
 * @schema CiliumNetworkPolicySpecIngressDenyIcmps
 */
export interface CiliumNetworkPolicySpecIngressDenyIcmps {
  /**
   * Fields is a list of ICMP fields.
   *
   * @schema CiliumNetworkPolicySpecIngressDenyIcmps#fields
   */
  readonly fields?: CiliumNetworkPolicySpecIngressDenyIcmpsFields[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressDenyIcmps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressDenyIcmps(obj: CiliumNetworkPolicySpecIngressDenyIcmps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fields': obj.fields?.map(y => toJson_CiliumNetworkPolicySpecIngressDenyIcmpsFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortDenyRule is a list of ports/protocol that should be used for deny policies. This structure lacks the L7Rules since it's not supported in deny policies.
 *
 * @schema CiliumNetworkPolicySpecIngressDenyToPorts
 */
export interface CiliumNetworkPolicySpecIngressDenyToPorts {
  /**
   * Ports is a list of L4 port/protocol
   *
   * @schema CiliumNetworkPolicySpecIngressDenyToPorts#ports
   */
  readonly ports?: CiliumNetworkPolicySpecIngressDenyToPortsPorts[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressDenyToPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressDenyToPorts(obj: CiliumNetworkPolicySpecIngressDenyToPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => toJson_CiliumNetworkPolicySpecIngressDenyToPortsPorts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNetworkPolicySpecNodeSelectorMatchExpressions
 */
export interface CiliumNetworkPolicySpecNodeSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNetworkPolicySpecNodeSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNetworkPolicySpecNodeSelectorMatchExpressions#operator
   */
  readonly operator: CiliumNetworkPolicySpecNodeSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNetworkPolicySpecNodeSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecNodeSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecNodeSelectorMatchExpressions(obj: CiliumNetworkPolicySpecNodeSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication is the required authentication type for the allowed traffic, if any.
 *
 * @schema CiliumNetworkPolicySpecsEgressAuthentication
 */
export interface CiliumNetworkPolicySpecsEgressAuthentication {
  /**
   * Mode is the required authentication mode for the allowed traffic, if any.
   *
   * @schema CiliumNetworkPolicySpecsEgressAuthentication#mode
   */
  readonly mode: CiliumNetworkPolicySpecsEgressAuthenticationMode;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressAuthentication(obj: CiliumNetworkPolicySpecsEgressAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPRule is a list of ICMP fields.
 *
 * @schema CiliumNetworkPolicySpecsEgressIcmps
 */
export interface CiliumNetworkPolicySpecsEgressIcmps {
  /**
   * Fields is a list of ICMP fields.
   *
   * @schema CiliumNetworkPolicySpecsEgressIcmps#fields
   */
  readonly fields?: CiliumNetworkPolicySpecsEgressIcmpsFields[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressIcmps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressIcmps(obj: CiliumNetworkPolicySpecsEgressIcmps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fields': obj.fields?.map(y => toJson_CiliumNetworkPolicySpecsEgressIcmpsFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.
 *
 * @schema CiliumNetworkPolicySpecsEgressToCidrSet
 */
export interface CiliumNetworkPolicySpecsEgressToCidrSet {
  /**
   * CIDR is a CIDR prefix / IP Block.
   *
   * @schema CiliumNetworkPolicySpecsEgressToCidrSet#cidr
   */
  readonly cidr?: string;

  /**
   * CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.
   *
   * @schema CiliumNetworkPolicySpecsEgressToCidrSet#cidrGroupRef
   */
  readonly cidrGroupRef?: string;

  /**
   * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.
   *
   * @schema CiliumNetworkPolicySpecsEgressToCidrSet#except
   */
  readonly except?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToCidrSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToCidrSet(obj: CiliumNetworkPolicySpecsEgressToCidrSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'cidrGroupRef': obj.cidrGroupRef,
    'except': obj.except?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumNetworkPolicySpecsEgressToEndpoints
 */
export interface CiliumNetworkPolicySpecsEgressToEndpoints {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecsEgressToEndpoints#matchExpressions
   */
  readonly matchExpressions?: CiliumNetworkPolicySpecsEgressToEndpointsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecsEgressToEndpoints#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToEndpoints(obj: CiliumNetworkPolicySpecsEgressToEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNetworkPolicySpecsEgressToEndpointsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe "outside of cluster", "host", etc.
 *
 * @schema CiliumNetworkPolicySpecsEgressToEntities
 */
export enum CiliumNetworkPolicySpecsEgressToEntities {
  /** all */
  ALL = "all",
  /** world */
  WORLD = "world",
  /** cluster */
  CLUSTER = "cluster",
  /** host */
  HOST = "host",
  /** init */
  INIT = "init",
  /** ingress */
  INGRESS = "ingress",
  /** unmanaged */
  UNMANAGED = "unmanaged",
  /** remote-node */
  REMOTE_HYPHEN_NODE = "remote-node",
  /** health */
  HEALTH = "health",
  /** none */
  NONE = "none",
  /** kube-apiserver */
  KUBE_HYPHEN_APISERVER = "kube-apiserver",
}

/**
 * @schema CiliumNetworkPolicySpecsEgressToFqdNs
 */
export interface CiliumNetworkPolicySpecsEgressToFqdNs {
  /**
   * MatchName matches literal DNS names. A trailing "." is automatically added when missing.
   *
   * @schema CiliumNetworkPolicySpecsEgressToFqdNs#matchName
   */
  readonly matchName?: string;

  /**
   * MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - "*" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a "*" as the leftmost character, without a following "." matches all subdomains as well as the name to the right. A trailing "." is automatically added when missing.
   * Examples: `*.cilium.io` matches subomains of cilium at that level www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io" except those containing "." separator, subcilium.io and sub-cilium.io match, www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with "sub" sub.cilium.io and subdomain.cilium.io match, www.cilium.io, blog.cilium.io, cilium.io and google.com do not
   *
   * @schema CiliumNetworkPolicySpecsEgressToFqdNs#matchPattern
   */
  readonly matchPattern?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToFqdNs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToFqdNs(obj: CiliumNetworkPolicySpecsEgressToFqdNs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchName': obj.matchName,
    'matchPattern': obj.matchPattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ToGroups structure to store all kinds of new integrations that needs a new derivative policy.
 *
 * @schema CiliumNetworkPolicySpecsEgressToGroups
 */
export interface CiliumNetworkPolicySpecsEgressToGroups {
  /**
   * AWSGroup is an structure that can be used to whitelisting information from AWS integration
   *
   * @schema CiliumNetworkPolicySpecsEgressToGroups#aws
   */
  readonly aws?: CiliumNetworkPolicySpecsEgressToGroupsAws;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToGroups' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToGroups(obj: CiliumNetworkPolicySpecsEgressToGroups | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aws': toJson_CiliumNetworkPolicySpecsEgressToGroupsAws(obj.aws),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortRule is a list of ports/protocol combinations with optional Layer 7 rules which must be met.
 *
 * @schema CiliumNetworkPolicySpecsEgressToPorts
 */
export interface CiliumNetworkPolicySpecsEgressToPorts {
  /**
   * listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPorts#listener
   */
  readonly listener?: CiliumNetworkPolicySpecsEgressToPortsListener;

  /**
   * OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPorts#originatingTLS
   */
  readonly originatingTls?: CiliumNetworkPolicySpecsEgressToPortsOriginatingTls;

  /**
   * Ports is a list of L4 port/protocol
   *
   * @schema CiliumNetworkPolicySpecsEgressToPorts#ports
   */
  readonly ports?: CiliumNetworkPolicySpecsEgressToPortsPorts[];

  /**
   * Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPorts#rules
   */
  readonly rules?: CiliumNetworkPolicySpecsEgressToPortsRules;

  /**
   * ServerNames is a list of allowed TLS SNI values. If not empty, then TLS must be present and one of the provided SNIs must be indicated in the TLS handshake.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPorts#serverNames
   */
  readonly serverNames?: string[];

  /**
   * TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPorts#terminatingTLS
   */
  readonly terminatingTls?: CiliumNetworkPolicySpecsEgressToPortsTerminatingTls;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToPorts(obj: CiliumNetworkPolicySpecsEgressToPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'listener': toJson_CiliumNetworkPolicySpecsEgressToPortsListener(obj.listener),
    'originatingTLS': toJson_CiliumNetworkPolicySpecsEgressToPortsOriginatingTls(obj.originatingTls),
    'ports': obj.ports?.map(y => toJson_CiliumNetworkPolicySpecsEgressToPortsPorts(y)),
    'rules': toJson_CiliumNetworkPolicySpecsEgressToPortsRules(obj.rules),
    'serverNames': obj.serverNames?.map(y => y),
    'terminatingTLS': toJson_CiliumNetworkPolicySpecsEgressToPortsTerminatingTls(obj.terminatingTls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumNetworkPolicySpecsEgressToRequires
 */
export interface CiliumNetworkPolicySpecsEgressToRequires {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecsEgressToRequires#matchExpressions
   */
  readonly matchExpressions?: CiliumNetworkPolicySpecsEgressToRequiresMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecsEgressToRequires#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToRequires' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToRequires(obj: CiliumNetworkPolicySpecsEgressToRequires | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNetworkPolicySpecsEgressToRequiresMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Service wraps around selectors for services
 *
 * @schema CiliumNetworkPolicySpecsEgressToServices
 */
export interface CiliumNetworkPolicySpecsEgressToServices {
  /**
   * K8sService selects service by name and namespace pair
   *
   * @schema CiliumNetworkPolicySpecsEgressToServices#k8sService
   */
  readonly k8SService?: CiliumNetworkPolicySpecsEgressToServicesK8SService;

  /**
   * K8sServiceSelector selects services by k8s labels and namespace
   *
   * @schema CiliumNetworkPolicySpecsEgressToServices#k8sServiceSelector
   */
  readonly k8SServiceSelector?: CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelector;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToServices(obj: CiliumNetworkPolicySpecsEgressToServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'k8sService': toJson_CiliumNetworkPolicySpecsEgressToServicesK8SService(obj.k8SService),
    'k8sServiceSelector': toJson_CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelector(obj.k8SServiceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPRule is a list of ICMP fields.
 *
 * @schema CiliumNetworkPolicySpecsEgressDenyIcmps
 */
export interface CiliumNetworkPolicySpecsEgressDenyIcmps {
  /**
   * Fields is a list of ICMP fields.
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyIcmps#fields
   */
  readonly fields?: CiliumNetworkPolicySpecsEgressDenyIcmpsFields[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressDenyIcmps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressDenyIcmps(obj: CiliumNetworkPolicySpecsEgressDenyIcmps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fields': obj.fields?.map(y => toJson_CiliumNetworkPolicySpecsEgressDenyIcmpsFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.
 *
 * @schema CiliumNetworkPolicySpecsEgressDenyToCidrSet
 */
export interface CiliumNetworkPolicySpecsEgressDenyToCidrSet {
  /**
   * CIDR is a CIDR prefix / IP Block.
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToCidrSet#cidr
   */
  readonly cidr?: string;

  /**
   * CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToCidrSet#cidrGroupRef
   */
  readonly cidrGroupRef?: string;

  /**
   * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToCidrSet#except
   */
  readonly except?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressDenyToCidrSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressDenyToCidrSet(obj: CiliumNetworkPolicySpecsEgressDenyToCidrSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'cidrGroupRef': obj.cidrGroupRef,
    'except': obj.except?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumNetworkPolicySpecsEgressDenyToEndpoints
 */
export interface CiliumNetworkPolicySpecsEgressDenyToEndpoints {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToEndpoints#matchExpressions
   */
  readonly matchExpressions?: CiliumNetworkPolicySpecsEgressDenyToEndpointsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToEndpoints#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressDenyToEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressDenyToEndpoints(obj: CiliumNetworkPolicySpecsEgressDenyToEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNetworkPolicySpecsEgressDenyToEndpointsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe "outside of cluster", "host", etc.
 *
 * @schema CiliumNetworkPolicySpecsEgressDenyToEntities
 */
export enum CiliumNetworkPolicySpecsEgressDenyToEntities {
  /** all */
  ALL = "all",
  /** world */
  WORLD = "world",
  /** cluster */
  CLUSTER = "cluster",
  /** host */
  HOST = "host",
  /** init */
  INIT = "init",
  /** ingress */
  INGRESS = "ingress",
  /** unmanaged */
  UNMANAGED = "unmanaged",
  /** remote-node */
  REMOTE_HYPHEN_NODE = "remote-node",
  /** health */
  HEALTH = "health",
  /** none */
  NONE = "none",
  /** kube-apiserver */
  KUBE_HYPHEN_APISERVER = "kube-apiserver",
}

/**
 * ToGroups structure to store all kinds of new integrations that needs a new derivative policy.
 *
 * @schema CiliumNetworkPolicySpecsEgressDenyToGroups
 */
export interface CiliumNetworkPolicySpecsEgressDenyToGroups {
  /**
   * AWSGroup is an structure that can be used to whitelisting information from AWS integration
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToGroups#aws
   */
  readonly aws?: CiliumNetworkPolicySpecsEgressDenyToGroupsAws;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressDenyToGroups' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressDenyToGroups(obj: CiliumNetworkPolicySpecsEgressDenyToGroups | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aws': toJson_CiliumNetworkPolicySpecsEgressDenyToGroupsAws(obj.aws),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortDenyRule is a list of ports/protocol that should be used for deny policies. This structure lacks the L7Rules since it's not supported in deny policies.
 *
 * @schema CiliumNetworkPolicySpecsEgressDenyToPorts
 */
export interface CiliumNetworkPolicySpecsEgressDenyToPorts {
  /**
   * Ports is a list of L4 port/protocol
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToPorts#ports
   */
  readonly ports?: CiliumNetworkPolicySpecsEgressDenyToPortsPorts[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressDenyToPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressDenyToPorts(obj: CiliumNetworkPolicySpecsEgressDenyToPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => toJson_CiliumNetworkPolicySpecsEgressDenyToPortsPorts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumNetworkPolicySpecsEgressDenyToRequires
 */
export interface CiliumNetworkPolicySpecsEgressDenyToRequires {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToRequires#matchExpressions
   */
  readonly matchExpressions?: CiliumNetworkPolicySpecsEgressDenyToRequiresMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToRequires#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressDenyToRequires' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressDenyToRequires(obj: CiliumNetworkPolicySpecsEgressDenyToRequires | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNetworkPolicySpecsEgressDenyToRequiresMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Service wraps around selectors for services
 *
 * @schema CiliumNetworkPolicySpecsEgressDenyToServices
 */
export interface CiliumNetworkPolicySpecsEgressDenyToServices {
  /**
   * K8sService selects service by name and namespace pair
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToServices#k8sService
   */
  readonly k8SService?: CiliumNetworkPolicySpecsEgressDenyToServicesK8SService;

  /**
   * K8sServiceSelector selects services by k8s labels and namespace
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToServices#k8sServiceSelector
   */
  readonly k8SServiceSelector?: CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelector;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressDenyToServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressDenyToServices(obj: CiliumNetworkPolicySpecsEgressDenyToServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'k8sService': toJson_CiliumNetworkPolicySpecsEgressDenyToServicesK8SService(obj.k8SService),
    'k8sServiceSelector': toJson_CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelector(obj.k8SServiceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNetworkPolicySpecsEndpointSelectorMatchExpressions
 */
export interface CiliumNetworkPolicySpecsEndpointSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNetworkPolicySpecsEndpointSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNetworkPolicySpecsEndpointSelectorMatchExpressions#operator
   */
  readonly operator: CiliumNetworkPolicySpecsEndpointSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNetworkPolicySpecsEndpointSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEndpointSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEndpointSelectorMatchExpressions(obj: CiliumNetworkPolicySpecsEndpointSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication is the required authentication type for the allowed traffic, if any.
 *
 * @schema CiliumNetworkPolicySpecsIngressAuthentication
 */
export interface CiliumNetworkPolicySpecsIngressAuthentication {
  /**
   * Mode is the required authentication mode for the allowed traffic, if any.
   *
   * @schema CiliumNetworkPolicySpecsIngressAuthentication#mode
   */
  readonly mode: CiliumNetworkPolicySpecsIngressAuthenticationMode;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressAuthentication(obj: CiliumNetworkPolicySpecsIngressAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.
 *
 * @schema CiliumNetworkPolicySpecsIngressFromCidrSet
 */
export interface CiliumNetworkPolicySpecsIngressFromCidrSet {
  /**
   * CIDR is a CIDR prefix / IP Block.
   *
   * @schema CiliumNetworkPolicySpecsIngressFromCidrSet#cidr
   */
  readonly cidr?: string;

  /**
   * CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.
   *
   * @schema CiliumNetworkPolicySpecsIngressFromCidrSet#cidrGroupRef
   */
  readonly cidrGroupRef?: string;

  /**
   * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.
   *
   * @schema CiliumNetworkPolicySpecsIngressFromCidrSet#except
   */
  readonly except?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressFromCidrSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressFromCidrSet(obj: CiliumNetworkPolicySpecsIngressFromCidrSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'cidrGroupRef': obj.cidrGroupRef,
    'except': obj.except?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumNetworkPolicySpecsIngressFromEndpoints
 */
export interface CiliumNetworkPolicySpecsIngressFromEndpoints {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecsIngressFromEndpoints#matchExpressions
   */
  readonly matchExpressions?: CiliumNetworkPolicySpecsIngressFromEndpointsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecsIngressFromEndpoints#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressFromEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressFromEndpoints(obj: CiliumNetworkPolicySpecsIngressFromEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNetworkPolicySpecsIngressFromEndpointsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe "outside of cluster", "host", etc.
 *
 * @schema CiliumNetworkPolicySpecsIngressFromEntities
 */
export enum CiliumNetworkPolicySpecsIngressFromEntities {
  /** all */
  ALL = "all",
  /** world */
  WORLD = "world",
  /** cluster */
  CLUSTER = "cluster",
  /** host */
  HOST = "host",
  /** init */
  INIT = "init",
  /** ingress */
  INGRESS = "ingress",
  /** unmanaged */
  UNMANAGED = "unmanaged",
  /** remote-node */
  REMOTE_HYPHEN_NODE = "remote-node",
  /** health */
  HEALTH = "health",
  /** none */
  NONE = "none",
  /** kube-apiserver */
  KUBE_HYPHEN_APISERVER = "kube-apiserver",
}

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumNetworkPolicySpecsIngressFromRequires
 */
export interface CiliumNetworkPolicySpecsIngressFromRequires {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecsIngressFromRequires#matchExpressions
   */
  readonly matchExpressions?: CiliumNetworkPolicySpecsIngressFromRequiresMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecsIngressFromRequires#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressFromRequires' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressFromRequires(obj: CiliumNetworkPolicySpecsIngressFromRequires | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNetworkPolicySpecsIngressFromRequiresMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPRule is a list of ICMP fields.
 *
 * @schema CiliumNetworkPolicySpecsIngressIcmps
 */
export interface CiliumNetworkPolicySpecsIngressIcmps {
  /**
   * Fields is a list of ICMP fields.
   *
   * @schema CiliumNetworkPolicySpecsIngressIcmps#fields
   */
  readonly fields?: CiliumNetworkPolicySpecsIngressIcmpsFields[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressIcmps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressIcmps(obj: CiliumNetworkPolicySpecsIngressIcmps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fields': obj.fields?.map(y => toJson_CiliumNetworkPolicySpecsIngressIcmpsFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortRule is a list of ports/protocol combinations with optional Layer 7 rules which must be met.
 *
 * @schema CiliumNetworkPolicySpecsIngressToPorts
 */
export interface CiliumNetworkPolicySpecsIngressToPorts {
  /**
   * listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPorts#listener
   */
  readonly listener?: CiliumNetworkPolicySpecsIngressToPortsListener;

  /**
   * OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPorts#originatingTLS
   */
  readonly originatingTls?: CiliumNetworkPolicySpecsIngressToPortsOriginatingTls;

  /**
   * Ports is a list of L4 port/protocol
   *
   * @schema CiliumNetworkPolicySpecsIngressToPorts#ports
   */
  readonly ports?: CiliumNetworkPolicySpecsIngressToPortsPorts[];

  /**
   * Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPorts#rules
   */
  readonly rules?: CiliumNetworkPolicySpecsIngressToPortsRules;

  /**
   * ServerNames is a list of allowed TLS SNI values. If not empty, then TLS must be present and one of the provided SNIs must be indicated in the TLS handshake.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPorts#serverNames
   */
  readonly serverNames?: string[];

  /**
   * TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPorts#terminatingTLS
   */
  readonly terminatingTls?: CiliumNetworkPolicySpecsIngressToPortsTerminatingTls;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressToPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressToPorts(obj: CiliumNetworkPolicySpecsIngressToPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'listener': toJson_CiliumNetworkPolicySpecsIngressToPortsListener(obj.listener),
    'originatingTLS': toJson_CiliumNetworkPolicySpecsIngressToPortsOriginatingTls(obj.originatingTls),
    'ports': obj.ports?.map(y => toJson_CiliumNetworkPolicySpecsIngressToPortsPorts(y)),
    'rules': toJson_CiliumNetworkPolicySpecsIngressToPortsRules(obj.rules),
    'serverNames': obj.serverNames?.map(y => y),
    'terminatingTLS': toJson_CiliumNetworkPolicySpecsIngressToPortsTerminatingTls(obj.terminatingTls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.
 *
 * @schema CiliumNetworkPolicySpecsIngressDenyFromCidrSet
 */
export interface CiliumNetworkPolicySpecsIngressDenyFromCidrSet {
  /**
   * CIDR is a CIDR prefix / IP Block.
   *
   * @schema CiliumNetworkPolicySpecsIngressDenyFromCidrSet#cidr
   */
  readonly cidr?: string;

  /**
   * CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.
   *
   * @schema CiliumNetworkPolicySpecsIngressDenyFromCidrSet#cidrGroupRef
   */
  readonly cidrGroupRef?: string;

  /**
   * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.
   *
   * @schema CiliumNetworkPolicySpecsIngressDenyFromCidrSet#except
   */
  readonly except?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressDenyFromCidrSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressDenyFromCidrSet(obj: CiliumNetworkPolicySpecsIngressDenyFromCidrSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'cidrGroupRef': obj.cidrGroupRef,
    'except': obj.except?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumNetworkPolicySpecsIngressDenyFromEndpoints
 */
export interface CiliumNetworkPolicySpecsIngressDenyFromEndpoints {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecsIngressDenyFromEndpoints#matchExpressions
   */
  readonly matchExpressions?: CiliumNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecsIngressDenyFromEndpoints#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressDenyFromEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressDenyFromEndpoints(obj: CiliumNetworkPolicySpecsIngressDenyFromEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe "outside of cluster", "host", etc.
 *
 * @schema CiliumNetworkPolicySpecsIngressDenyFromEntities
 */
export enum CiliumNetworkPolicySpecsIngressDenyFromEntities {
  /** all */
  ALL = "all",
  /** world */
  WORLD = "world",
  /** cluster */
  CLUSTER = "cluster",
  /** host */
  HOST = "host",
  /** init */
  INIT = "init",
  /** ingress */
  INGRESS = "ingress",
  /** unmanaged */
  UNMANAGED = "unmanaged",
  /** remote-node */
  REMOTE_HYPHEN_NODE = "remote-node",
  /** health */
  HEALTH = "health",
  /** none */
  NONE = "none",
  /** kube-apiserver */
  KUBE_HYPHEN_APISERVER = "kube-apiserver",
}

/**
 * EndpointSelector is a wrapper for k8s LabelSelector.
 *
 * @schema CiliumNetworkPolicySpecsIngressDenyFromRequires
 */
export interface CiliumNetworkPolicySpecsIngressDenyFromRequires {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecsIngressDenyFromRequires#matchExpressions
   */
  readonly matchExpressions?: CiliumNetworkPolicySpecsIngressDenyFromRequiresMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecsIngressDenyFromRequires#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressDenyFromRequires' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressDenyFromRequires(obj: CiliumNetworkPolicySpecsIngressDenyFromRequires | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNetworkPolicySpecsIngressDenyFromRequiresMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPRule is a list of ICMP fields.
 *
 * @schema CiliumNetworkPolicySpecsIngressDenyIcmps
 */
export interface CiliumNetworkPolicySpecsIngressDenyIcmps {
  /**
   * Fields is a list of ICMP fields.
   *
   * @schema CiliumNetworkPolicySpecsIngressDenyIcmps#fields
   */
  readonly fields?: CiliumNetworkPolicySpecsIngressDenyIcmpsFields[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressDenyIcmps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressDenyIcmps(obj: CiliumNetworkPolicySpecsIngressDenyIcmps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fields': obj.fields?.map(y => toJson_CiliumNetworkPolicySpecsIngressDenyIcmpsFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortDenyRule is a list of ports/protocol that should be used for deny policies. This structure lacks the L7Rules since it's not supported in deny policies.
 *
 * @schema CiliumNetworkPolicySpecsIngressDenyToPorts
 */
export interface CiliumNetworkPolicySpecsIngressDenyToPorts {
  /**
   * Ports is a list of L4 port/protocol
   *
   * @schema CiliumNetworkPolicySpecsIngressDenyToPorts#ports
   */
  readonly ports?: CiliumNetworkPolicySpecsIngressDenyToPortsPorts[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressDenyToPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressDenyToPorts(obj: CiliumNetworkPolicySpecsIngressDenyToPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => toJson_CiliumNetworkPolicySpecsIngressDenyToPortsPorts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNetworkPolicySpecsNodeSelectorMatchExpressions
 */
export interface CiliumNetworkPolicySpecsNodeSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNetworkPolicySpecsNodeSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNetworkPolicySpecsNodeSelectorMatchExpressions#operator
   */
  readonly operator: CiliumNetworkPolicySpecsNodeSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNetworkPolicySpecsNodeSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsNodeSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsNodeSelectorMatchExpressions(obj: CiliumNetworkPolicySpecsNodeSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mode is the required authentication mode for the allowed traffic, if any.
 *
 * @schema CiliumNetworkPolicySpecEgressAuthenticationMode
 */
export enum CiliumNetworkPolicySpecEgressAuthenticationMode {
  /** disabled */
  DISABLED = "disabled",
  /** required */
  REQUIRED = "required",
  /** test-always-fail */
  TEST_HYPHEN_ALWAYS_HYPHEN_FAIL = "test-always-fail",
}

/**
 * ICMPField is a ICMP field.
 *
 * @schema CiliumNetworkPolicySpecEgressIcmpsFields
 */
export interface CiliumNetworkPolicySpecEgressIcmpsFields {
  /**
   * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
   *
   * @schema CiliumNetworkPolicySpecEgressIcmpsFields#family
   */
  readonly family?: CiliumNetworkPolicySpecEgressIcmpsFieldsFamily;

  /**
   * Type is a ICMP-type. It should be 0-255 (8bit).
   *
   * @schema CiliumNetworkPolicySpecEgressIcmpsFields#type
   */
  readonly type: number;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressIcmpsFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressIcmpsFields(obj: CiliumNetworkPolicySpecEgressIcmpsFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'family': obj.family,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNetworkPolicySpecEgressToEndpointsMatchExpressions
 */
export interface CiliumNetworkPolicySpecEgressToEndpointsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNetworkPolicySpecEgressToEndpointsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNetworkPolicySpecEgressToEndpointsMatchExpressions#operator
   */
  readonly operator: CiliumNetworkPolicySpecEgressToEndpointsMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNetworkPolicySpecEgressToEndpointsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToEndpointsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToEndpointsMatchExpressions(obj: CiliumNetworkPolicySpecEgressToEndpointsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSGroup is an structure that can be used to whitelisting information from AWS integration
 *
 * @schema CiliumNetworkPolicySpecEgressToGroupsAws
 */
export interface CiliumNetworkPolicySpecEgressToGroupsAws {
  /**
   * @schema CiliumNetworkPolicySpecEgressToGroupsAws#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema CiliumNetworkPolicySpecEgressToGroupsAws#region
   */
  readonly region?: string;

  /**
   * @schema CiliumNetworkPolicySpecEgressToGroupsAws#securityGroupsIds
   */
  readonly securityGroupsIds?: string[];

  /**
   * @schema CiliumNetworkPolicySpecEgressToGroupsAws#securityGroupsNames
   */
  readonly securityGroupsNames?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToGroupsAws' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToGroupsAws(obj: CiliumNetworkPolicySpecEgressToGroupsAws | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'region': obj.region,
    'securityGroupsIds': obj.securityGroupsIds?.map(y => y),
    'securityGroupsNames': obj.securityGroupsNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.
 *
 * @schema CiliumNetworkPolicySpecEgressToPortsListener
 */
export interface CiliumNetworkPolicySpecEgressToPortsListener {
  /**
   * EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsListener#envoyConfig
   */
  readonly envoyConfig: CiliumNetworkPolicySpecEgressToPortsListenerEnvoyConfig;

  /**
   * Name is the name of the listener.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsListener#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToPortsListener' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToPortsListener(obj: CiliumNetworkPolicySpecEgressToPortsListener | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'envoyConfig': toJson_CiliumNetworkPolicySpecEgressToPortsListenerEnvoyConfig(obj.envoyConfig),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.
 *
 * @schema CiliumNetworkPolicySpecEgressToPortsOriginatingTls
 */
export interface CiliumNetworkPolicySpecEgressToPortsOriginatingTls {
  /**
   * Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsOriginatingTls#certificate
   */
  readonly certificate?: string;

  /**
   * PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsOriginatingTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsOriginatingTls#secret
   */
  readonly secret: CiliumNetworkPolicySpecEgressToPortsOriginatingTlsSecret;

  /**
   * TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsOriginatingTls#trustedCA
   */
  readonly trustedCa?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToPortsOriginatingTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToPortsOriginatingTls(obj: CiliumNetworkPolicySpecEgressToPortsOriginatingTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'privateKey': obj.privateKey,
    'secret': toJson_CiliumNetworkPolicySpecEgressToPortsOriginatingTlsSecret(obj.secret),
    'trustedCA': obj.trustedCa,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortProtocol specifies an L4 port with an optional transport protocol
 *
 * @schema CiliumNetworkPolicySpecEgressToPortsPorts
 */
export interface CiliumNetworkPolicySpecEgressToPortsPorts {
  /**
   * Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form "1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsPorts#port
   */
  readonly port: string;

  /**
   * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
   * Matching on ICMP is not supported.
   * Named port specified for a container may narrow this down, but may not contradict this.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsPorts#protocol
   */
  readonly protocol?: CiliumNetworkPolicySpecEgressToPortsPortsProtocol;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToPortsPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToPortsPorts(obj: CiliumNetworkPolicySpecEgressToPortsPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.
 *
 * @schema CiliumNetworkPolicySpecEgressToPortsRules
 */
export interface CiliumNetworkPolicySpecEgressToPortsRules {
  /**
   * DNS-specific rules.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsRules#dns
   */
  readonly dns?: CiliumNetworkPolicySpecEgressToPortsRulesDns[];

  /**
   * HTTP specific rules.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsRules#http
   */
  readonly http?: CiliumNetworkPolicySpecEgressToPortsRulesHttp[];

  /**
   * Kafka-specific rules.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsRules#kafka
   */
  readonly kafka?: CiliumNetworkPolicySpecEgressToPortsRulesKafka[];

  /**
   * Key-value pair rules.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsRules#l7
   */
  readonly l7?: { [key: string]: string }[];

  /**
   * Name of the L7 protocol for which the Key-value pair rules apply.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsRules#l7proto
   */
  readonly l7Proto?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToPortsRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToPortsRules(obj: CiliumNetworkPolicySpecEgressToPortsRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dns': obj.dns?.map(y => toJson_CiliumNetworkPolicySpecEgressToPortsRulesDns(y)),
    'http': obj.http?.map(y => toJson_CiliumNetworkPolicySpecEgressToPortsRulesHttp(y)),
    'kafka': obj.kafka?.map(y => toJson_CiliumNetworkPolicySpecEgressToPortsRulesKafka(y)),
    'l7': obj.l7?.map(y => ((y) === undefined) ? undefined : (Object.entries(y).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {}))),
    'l7proto': obj.l7Proto,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.
 *
 * @schema CiliumNetworkPolicySpecEgressToPortsTerminatingTls
 */
export interface CiliumNetworkPolicySpecEgressToPortsTerminatingTls {
  /**
   * Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsTerminatingTls#certificate
   */
  readonly certificate?: string;

  /**
   * PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsTerminatingTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsTerminatingTls#secret
   */
  readonly secret: CiliumNetworkPolicySpecEgressToPortsTerminatingTlsSecret;

  /**
   * TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsTerminatingTls#trustedCA
   */
  readonly trustedCa?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToPortsTerminatingTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToPortsTerminatingTls(obj: CiliumNetworkPolicySpecEgressToPortsTerminatingTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'privateKey': obj.privateKey,
    'secret': toJson_CiliumNetworkPolicySpecEgressToPortsTerminatingTlsSecret(obj.secret),
    'trustedCA': obj.trustedCa,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNetworkPolicySpecEgressToRequiresMatchExpressions
 */
export interface CiliumNetworkPolicySpecEgressToRequiresMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNetworkPolicySpecEgressToRequiresMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNetworkPolicySpecEgressToRequiresMatchExpressions#operator
   */
  readonly operator: CiliumNetworkPolicySpecEgressToRequiresMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNetworkPolicySpecEgressToRequiresMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToRequiresMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToRequiresMatchExpressions(obj: CiliumNetworkPolicySpecEgressToRequiresMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * K8sService selects service by name and namespace pair
 *
 * @schema CiliumNetworkPolicySpecEgressToServicesK8SService
 */
export interface CiliumNetworkPolicySpecEgressToServicesK8SService {
  /**
   * @schema CiliumNetworkPolicySpecEgressToServicesK8SService#namespace
   */
  readonly namespace?: string;

  /**
   * @schema CiliumNetworkPolicySpecEgressToServicesK8SService#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToServicesK8SService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToServicesK8SService(obj: CiliumNetworkPolicySpecEgressToServicesK8SService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespace': obj.namespace,
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * K8sServiceSelector selects services by k8s labels and namespace
 *
 * @schema CiliumNetworkPolicySpecEgressToServicesK8SServiceSelector
 */
export interface CiliumNetworkPolicySpecEgressToServicesK8SServiceSelector {
  /**
   * @schema CiliumNetworkPolicySpecEgressToServicesK8SServiceSelector#namespace
   */
  readonly namespace?: string;

  /**
   * ServiceSelector is a label selector for k8s services
   *
   * @schema CiliumNetworkPolicySpecEgressToServicesK8SServiceSelector#selector
   */
  readonly selector: CiliumNetworkPolicySpecEgressToServicesK8SServiceSelectorSelector;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToServicesK8SServiceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToServicesK8SServiceSelector(obj: CiliumNetworkPolicySpecEgressToServicesK8SServiceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespace': obj.namespace,
    'selector': toJson_CiliumNetworkPolicySpecEgressToServicesK8SServiceSelectorSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPField is a ICMP field.
 *
 * @schema CiliumNetworkPolicySpecEgressDenyIcmpsFields
 */
export interface CiliumNetworkPolicySpecEgressDenyIcmpsFields {
  /**
   * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
   *
   * @schema CiliumNetworkPolicySpecEgressDenyIcmpsFields#family
   */
  readonly family?: CiliumNetworkPolicySpecEgressDenyIcmpsFieldsFamily;

  /**
   * Type is a ICMP-type. It should be 0-255 (8bit).
   *
   * @schema CiliumNetworkPolicySpecEgressDenyIcmpsFields#type
   */
  readonly type: number;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressDenyIcmpsFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressDenyIcmpsFields(obj: CiliumNetworkPolicySpecEgressDenyIcmpsFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'family': obj.family,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNetworkPolicySpecEgressDenyToEndpointsMatchExpressions
 */
export interface CiliumNetworkPolicySpecEgressDenyToEndpointsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToEndpointsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToEndpointsMatchExpressions#operator
   */
  readonly operator: CiliumNetworkPolicySpecEgressDenyToEndpointsMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToEndpointsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressDenyToEndpointsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressDenyToEndpointsMatchExpressions(obj: CiliumNetworkPolicySpecEgressDenyToEndpointsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSGroup is an structure that can be used to whitelisting information from AWS integration
 *
 * @schema CiliumNetworkPolicySpecEgressDenyToGroupsAws
 */
export interface CiliumNetworkPolicySpecEgressDenyToGroupsAws {
  /**
   * @schema CiliumNetworkPolicySpecEgressDenyToGroupsAws#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema CiliumNetworkPolicySpecEgressDenyToGroupsAws#region
   */
  readonly region?: string;

  /**
   * @schema CiliumNetworkPolicySpecEgressDenyToGroupsAws#securityGroupsIds
   */
  readonly securityGroupsIds?: string[];

  /**
   * @schema CiliumNetworkPolicySpecEgressDenyToGroupsAws#securityGroupsNames
   */
  readonly securityGroupsNames?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressDenyToGroupsAws' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressDenyToGroupsAws(obj: CiliumNetworkPolicySpecEgressDenyToGroupsAws | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'region': obj.region,
    'securityGroupsIds': obj.securityGroupsIds?.map(y => y),
    'securityGroupsNames': obj.securityGroupsNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortProtocol specifies an L4 port with an optional transport protocol
 *
 * @schema CiliumNetworkPolicySpecEgressDenyToPortsPorts
 */
export interface CiliumNetworkPolicySpecEgressDenyToPortsPorts {
  /**
   * Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form "1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToPortsPorts#port
   */
  readonly port: string;

  /**
   * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
   * Matching on ICMP is not supported.
   * Named port specified for a container may narrow this down, but may not contradict this.
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToPortsPorts#protocol
   */
  readonly protocol?: CiliumNetworkPolicySpecEgressDenyToPortsPortsProtocol;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressDenyToPortsPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressDenyToPortsPorts(obj: CiliumNetworkPolicySpecEgressDenyToPortsPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNetworkPolicySpecEgressDenyToRequiresMatchExpressions
 */
export interface CiliumNetworkPolicySpecEgressDenyToRequiresMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToRequiresMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToRequiresMatchExpressions#operator
   */
  readonly operator: CiliumNetworkPolicySpecEgressDenyToRequiresMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToRequiresMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressDenyToRequiresMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressDenyToRequiresMatchExpressions(obj: CiliumNetworkPolicySpecEgressDenyToRequiresMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * K8sService selects service by name and namespace pair
 *
 * @schema CiliumNetworkPolicySpecEgressDenyToServicesK8SService
 */
export interface CiliumNetworkPolicySpecEgressDenyToServicesK8SService {
  /**
   * @schema CiliumNetworkPolicySpecEgressDenyToServicesK8SService#namespace
   */
  readonly namespace?: string;

  /**
   * @schema CiliumNetworkPolicySpecEgressDenyToServicesK8SService#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressDenyToServicesK8SService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressDenyToServicesK8SService(obj: CiliumNetworkPolicySpecEgressDenyToServicesK8SService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespace': obj.namespace,
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * K8sServiceSelector selects services by k8s labels and namespace
 *
 * @schema CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelector
 */
export interface CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelector {
  /**
   * @schema CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelector#namespace
   */
  readonly namespace?: string;

  /**
   * ServiceSelector is a label selector for k8s services
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelector#selector
   */
  readonly selector: CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelector;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelector(obj: CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespace': obj.namespace,
    'selector': toJson_CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumNetworkPolicySpecEndpointSelectorMatchExpressionsOperator
 */
export enum CiliumNetworkPolicySpecEndpointSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * Mode is the required authentication mode for the allowed traffic, if any.
 *
 * @schema CiliumNetworkPolicySpecIngressAuthenticationMode
 */
export enum CiliumNetworkPolicySpecIngressAuthenticationMode {
  /** disabled */
  DISABLED = "disabled",
  /** required */
  REQUIRED = "required",
  /** test-always-fail */
  TEST_HYPHEN_ALWAYS_HYPHEN_FAIL = "test-always-fail",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNetworkPolicySpecIngressFromEndpointsMatchExpressions
 */
export interface CiliumNetworkPolicySpecIngressFromEndpointsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNetworkPolicySpecIngressFromEndpointsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNetworkPolicySpecIngressFromEndpointsMatchExpressions#operator
   */
  readonly operator: CiliumNetworkPolicySpecIngressFromEndpointsMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNetworkPolicySpecIngressFromEndpointsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressFromEndpointsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressFromEndpointsMatchExpressions(obj: CiliumNetworkPolicySpecIngressFromEndpointsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNetworkPolicySpecIngressFromRequiresMatchExpressions
 */
export interface CiliumNetworkPolicySpecIngressFromRequiresMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNetworkPolicySpecIngressFromRequiresMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNetworkPolicySpecIngressFromRequiresMatchExpressions#operator
   */
  readonly operator: CiliumNetworkPolicySpecIngressFromRequiresMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNetworkPolicySpecIngressFromRequiresMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressFromRequiresMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressFromRequiresMatchExpressions(obj: CiliumNetworkPolicySpecIngressFromRequiresMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPField is a ICMP field.
 *
 * @schema CiliumNetworkPolicySpecIngressIcmpsFields
 */
export interface CiliumNetworkPolicySpecIngressIcmpsFields {
  /**
   * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
   *
   * @schema CiliumNetworkPolicySpecIngressIcmpsFields#family
   */
  readonly family?: CiliumNetworkPolicySpecIngressIcmpsFieldsFamily;

  /**
   * Type is a ICMP-type. It should be 0-255 (8bit).
   *
   * @schema CiliumNetworkPolicySpecIngressIcmpsFields#type
   */
  readonly type: number;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressIcmpsFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressIcmpsFields(obj: CiliumNetworkPolicySpecIngressIcmpsFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'family': obj.family,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.
 *
 * @schema CiliumNetworkPolicySpecIngressToPortsListener
 */
export interface CiliumNetworkPolicySpecIngressToPortsListener {
  /**
   * EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsListener#envoyConfig
   */
  readonly envoyConfig: CiliumNetworkPolicySpecIngressToPortsListenerEnvoyConfig;

  /**
   * Name is the name of the listener.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsListener#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressToPortsListener' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressToPortsListener(obj: CiliumNetworkPolicySpecIngressToPortsListener | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'envoyConfig': toJson_CiliumNetworkPolicySpecIngressToPortsListenerEnvoyConfig(obj.envoyConfig),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.
 *
 * @schema CiliumNetworkPolicySpecIngressToPortsOriginatingTls
 */
export interface CiliumNetworkPolicySpecIngressToPortsOriginatingTls {
  /**
   * Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsOriginatingTls#certificate
   */
  readonly certificate?: string;

  /**
   * PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsOriginatingTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsOriginatingTls#secret
   */
  readonly secret: CiliumNetworkPolicySpecIngressToPortsOriginatingTlsSecret;

  /**
   * TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsOriginatingTls#trustedCA
   */
  readonly trustedCa?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressToPortsOriginatingTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressToPortsOriginatingTls(obj: CiliumNetworkPolicySpecIngressToPortsOriginatingTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'privateKey': obj.privateKey,
    'secret': toJson_CiliumNetworkPolicySpecIngressToPortsOriginatingTlsSecret(obj.secret),
    'trustedCA': obj.trustedCa,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortProtocol specifies an L4 port with an optional transport protocol
 *
 * @schema CiliumNetworkPolicySpecIngressToPortsPorts
 */
export interface CiliumNetworkPolicySpecIngressToPortsPorts {
  /**
   * Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form "1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsPorts#port
   */
  readonly port: string;

  /**
   * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
   * Matching on ICMP is not supported.
   * Named port specified for a container may narrow this down, but may not contradict this.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsPorts#protocol
   */
  readonly protocol?: CiliumNetworkPolicySpecIngressToPortsPortsProtocol;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressToPortsPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressToPortsPorts(obj: CiliumNetworkPolicySpecIngressToPortsPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.
 *
 * @schema CiliumNetworkPolicySpecIngressToPortsRules
 */
export interface CiliumNetworkPolicySpecIngressToPortsRules {
  /**
   * DNS-specific rules.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsRules#dns
   */
  readonly dns?: CiliumNetworkPolicySpecIngressToPortsRulesDns[];

  /**
   * HTTP specific rules.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsRules#http
   */
  readonly http?: CiliumNetworkPolicySpecIngressToPortsRulesHttp[];

  /**
   * Kafka-specific rules.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsRules#kafka
   */
  readonly kafka?: CiliumNetworkPolicySpecIngressToPortsRulesKafka[];

  /**
   * Key-value pair rules.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsRules#l7
   */
  readonly l7?: { [key: string]: string }[];

  /**
   * Name of the L7 protocol for which the Key-value pair rules apply.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsRules#l7proto
   */
  readonly l7Proto?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressToPortsRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressToPortsRules(obj: CiliumNetworkPolicySpecIngressToPortsRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dns': obj.dns?.map(y => toJson_CiliumNetworkPolicySpecIngressToPortsRulesDns(y)),
    'http': obj.http?.map(y => toJson_CiliumNetworkPolicySpecIngressToPortsRulesHttp(y)),
    'kafka': obj.kafka?.map(y => toJson_CiliumNetworkPolicySpecIngressToPortsRulesKafka(y)),
    'l7': obj.l7?.map(y => ((y) === undefined) ? undefined : (Object.entries(y).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {}))),
    'l7proto': obj.l7Proto,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.
 *
 * @schema CiliumNetworkPolicySpecIngressToPortsTerminatingTls
 */
export interface CiliumNetworkPolicySpecIngressToPortsTerminatingTls {
  /**
   * Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsTerminatingTls#certificate
   */
  readonly certificate?: string;

  /**
   * PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsTerminatingTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsTerminatingTls#secret
   */
  readonly secret: CiliumNetworkPolicySpecIngressToPortsTerminatingTlsSecret;

  /**
   * TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsTerminatingTls#trustedCA
   */
  readonly trustedCa?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressToPortsTerminatingTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressToPortsTerminatingTls(obj: CiliumNetworkPolicySpecIngressToPortsTerminatingTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'privateKey': obj.privateKey,
    'secret': toJson_CiliumNetworkPolicySpecIngressToPortsTerminatingTlsSecret(obj.secret),
    'trustedCA': obj.trustedCa,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNetworkPolicySpecIngressDenyFromEndpointsMatchExpressions
 */
export interface CiliumNetworkPolicySpecIngressDenyFromEndpointsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNetworkPolicySpecIngressDenyFromEndpointsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNetworkPolicySpecIngressDenyFromEndpointsMatchExpressions#operator
   */
  readonly operator: CiliumNetworkPolicySpecIngressDenyFromEndpointsMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNetworkPolicySpecIngressDenyFromEndpointsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressDenyFromEndpointsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressDenyFromEndpointsMatchExpressions(obj: CiliumNetworkPolicySpecIngressDenyFromEndpointsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNetworkPolicySpecIngressDenyFromRequiresMatchExpressions
 */
export interface CiliumNetworkPolicySpecIngressDenyFromRequiresMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNetworkPolicySpecIngressDenyFromRequiresMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNetworkPolicySpecIngressDenyFromRequiresMatchExpressions#operator
   */
  readonly operator: CiliumNetworkPolicySpecIngressDenyFromRequiresMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNetworkPolicySpecIngressDenyFromRequiresMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressDenyFromRequiresMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressDenyFromRequiresMatchExpressions(obj: CiliumNetworkPolicySpecIngressDenyFromRequiresMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPField is a ICMP field.
 *
 * @schema CiliumNetworkPolicySpecIngressDenyIcmpsFields
 */
export interface CiliumNetworkPolicySpecIngressDenyIcmpsFields {
  /**
   * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
   *
   * @schema CiliumNetworkPolicySpecIngressDenyIcmpsFields#family
   */
  readonly family?: CiliumNetworkPolicySpecIngressDenyIcmpsFieldsFamily;

  /**
   * Type is a ICMP-type. It should be 0-255 (8bit).
   *
   * @schema CiliumNetworkPolicySpecIngressDenyIcmpsFields#type
   */
  readonly type: number;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressDenyIcmpsFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressDenyIcmpsFields(obj: CiliumNetworkPolicySpecIngressDenyIcmpsFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'family': obj.family,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortProtocol specifies an L4 port with an optional transport protocol
 *
 * @schema CiliumNetworkPolicySpecIngressDenyToPortsPorts
 */
export interface CiliumNetworkPolicySpecIngressDenyToPortsPorts {
  /**
   * Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form "1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.
   *
   * @schema CiliumNetworkPolicySpecIngressDenyToPortsPorts#port
   */
  readonly port: string;

  /**
   * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
   * Matching on ICMP is not supported.
   * Named port specified for a container may narrow this down, but may not contradict this.
   *
   * @schema CiliumNetworkPolicySpecIngressDenyToPortsPorts#protocol
   */
  readonly protocol?: CiliumNetworkPolicySpecIngressDenyToPortsPortsProtocol;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressDenyToPortsPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressDenyToPortsPorts(obj: CiliumNetworkPolicySpecIngressDenyToPortsPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumNetworkPolicySpecNodeSelectorMatchExpressionsOperator
 */
export enum CiliumNetworkPolicySpecNodeSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * Mode is the required authentication mode for the allowed traffic, if any.
 *
 * @schema CiliumNetworkPolicySpecsEgressAuthenticationMode
 */
export enum CiliumNetworkPolicySpecsEgressAuthenticationMode {
  /** disabled */
  DISABLED = "disabled",
  /** required */
  REQUIRED = "required",
  /** test-always-fail */
  TEST_HYPHEN_ALWAYS_HYPHEN_FAIL = "test-always-fail",
}

/**
 * ICMPField is a ICMP field.
 *
 * @schema CiliumNetworkPolicySpecsEgressIcmpsFields
 */
export interface CiliumNetworkPolicySpecsEgressIcmpsFields {
  /**
   * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
   *
   * @schema CiliumNetworkPolicySpecsEgressIcmpsFields#family
   */
  readonly family?: CiliumNetworkPolicySpecsEgressIcmpsFieldsFamily;

  /**
   * Type is a ICMP-type. It should be 0-255 (8bit).
   *
   * @schema CiliumNetworkPolicySpecsEgressIcmpsFields#type
   */
  readonly type: number;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressIcmpsFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressIcmpsFields(obj: CiliumNetworkPolicySpecsEgressIcmpsFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'family': obj.family,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNetworkPolicySpecsEgressToEndpointsMatchExpressions
 */
export interface CiliumNetworkPolicySpecsEgressToEndpointsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNetworkPolicySpecsEgressToEndpointsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNetworkPolicySpecsEgressToEndpointsMatchExpressions#operator
   */
  readonly operator: CiliumNetworkPolicySpecsEgressToEndpointsMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNetworkPolicySpecsEgressToEndpointsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToEndpointsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToEndpointsMatchExpressions(obj: CiliumNetworkPolicySpecsEgressToEndpointsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSGroup is an structure that can be used to whitelisting information from AWS integration
 *
 * @schema CiliumNetworkPolicySpecsEgressToGroupsAws
 */
export interface CiliumNetworkPolicySpecsEgressToGroupsAws {
  /**
   * @schema CiliumNetworkPolicySpecsEgressToGroupsAws#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema CiliumNetworkPolicySpecsEgressToGroupsAws#region
   */
  readonly region?: string;

  /**
   * @schema CiliumNetworkPolicySpecsEgressToGroupsAws#securityGroupsIds
   */
  readonly securityGroupsIds?: string[];

  /**
   * @schema CiliumNetworkPolicySpecsEgressToGroupsAws#securityGroupsNames
   */
  readonly securityGroupsNames?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToGroupsAws' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToGroupsAws(obj: CiliumNetworkPolicySpecsEgressToGroupsAws | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'region': obj.region,
    'securityGroupsIds': obj.securityGroupsIds?.map(y => y),
    'securityGroupsNames': obj.securityGroupsNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.
 *
 * @schema CiliumNetworkPolicySpecsEgressToPortsListener
 */
export interface CiliumNetworkPolicySpecsEgressToPortsListener {
  /**
   * EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsListener#envoyConfig
   */
  readonly envoyConfig: CiliumNetworkPolicySpecsEgressToPortsListenerEnvoyConfig;

  /**
   * Name is the name of the listener.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsListener#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToPortsListener' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToPortsListener(obj: CiliumNetworkPolicySpecsEgressToPortsListener | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'envoyConfig': toJson_CiliumNetworkPolicySpecsEgressToPortsListenerEnvoyConfig(obj.envoyConfig),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.
 *
 * @schema CiliumNetworkPolicySpecsEgressToPortsOriginatingTls
 */
export interface CiliumNetworkPolicySpecsEgressToPortsOriginatingTls {
  /**
   * Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsOriginatingTls#certificate
   */
  readonly certificate?: string;

  /**
   * PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsOriginatingTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsOriginatingTls#secret
   */
  readonly secret: CiliumNetworkPolicySpecsEgressToPortsOriginatingTlsSecret;

  /**
   * TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsOriginatingTls#trustedCA
   */
  readonly trustedCa?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToPortsOriginatingTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToPortsOriginatingTls(obj: CiliumNetworkPolicySpecsEgressToPortsOriginatingTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'privateKey': obj.privateKey,
    'secret': toJson_CiliumNetworkPolicySpecsEgressToPortsOriginatingTlsSecret(obj.secret),
    'trustedCA': obj.trustedCa,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortProtocol specifies an L4 port with an optional transport protocol
 *
 * @schema CiliumNetworkPolicySpecsEgressToPortsPorts
 */
export interface CiliumNetworkPolicySpecsEgressToPortsPorts {
  /**
   * Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form "1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsPorts#port
   */
  readonly port: string;

  /**
   * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
   * Matching on ICMP is not supported.
   * Named port specified for a container may narrow this down, but may not contradict this.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsPorts#protocol
   */
  readonly protocol?: CiliumNetworkPolicySpecsEgressToPortsPortsProtocol;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToPortsPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToPortsPorts(obj: CiliumNetworkPolicySpecsEgressToPortsPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.
 *
 * @schema CiliumNetworkPolicySpecsEgressToPortsRules
 */
export interface CiliumNetworkPolicySpecsEgressToPortsRules {
  /**
   * DNS-specific rules.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsRules#dns
   */
  readonly dns?: CiliumNetworkPolicySpecsEgressToPortsRulesDns[];

  /**
   * HTTP specific rules.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsRules#http
   */
  readonly http?: CiliumNetworkPolicySpecsEgressToPortsRulesHttp[];

  /**
   * Kafka-specific rules.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsRules#kafka
   */
  readonly kafka?: CiliumNetworkPolicySpecsEgressToPortsRulesKafka[];

  /**
   * Key-value pair rules.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsRules#l7
   */
  readonly l7?: { [key: string]: string }[];

  /**
   * Name of the L7 protocol for which the Key-value pair rules apply.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsRules#l7proto
   */
  readonly l7Proto?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToPortsRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToPortsRules(obj: CiliumNetworkPolicySpecsEgressToPortsRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dns': obj.dns?.map(y => toJson_CiliumNetworkPolicySpecsEgressToPortsRulesDns(y)),
    'http': obj.http?.map(y => toJson_CiliumNetworkPolicySpecsEgressToPortsRulesHttp(y)),
    'kafka': obj.kafka?.map(y => toJson_CiliumNetworkPolicySpecsEgressToPortsRulesKafka(y)),
    'l7': obj.l7?.map(y => ((y) === undefined) ? undefined : (Object.entries(y).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {}))),
    'l7proto': obj.l7Proto,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.
 *
 * @schema CiliumNetworkPolicySpecsEgressToPortsTerminatingTls
 */
export interface CiliumNetworkPolicySpecsEgressToPortsTerminatingTls {
  /**
   * Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsTerminatingTls#certificate
   */
  readonly certificate?: string;

  /**
   * PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsTerminatingTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsTerminatingTls#secret
   */
  readonly secret: CiliumNetworkPolicySpecsEgressToPortsTerminatingTlsSecret;

  /**
   * TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsTerminatingTls#trustedCA
   */
  readonly trustedCa?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToPortsTerminatingTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToPortsTerminatingTls(obj: CiliumNetworkPolicySpecsEgressToPortsTerminatingTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'privateKey': obj.privateKey,
    'secret': toJson_CiliumNetworkPolicySpecsEgressToPortsTerminatingTlsSecret(obj.secret),
    'trustedCA': obj.trustedCa,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNetworkPolicySpecsEgressToRequiresMatchExpressions
 */
export interface CiliumNetworkPolicySpecsEgressToRequiresMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNetworkPolicySpecsEgressToRequiresMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNetworkPolicySpecsEgressToRequiresMatchExpressions#operator
   */
  readonly operator: CiliumNetworkPolicySpecsEgressToRequiresMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNetworkPolicySpecsEgressToRequiresMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToRequiresMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToRequiresMatchExpressions(obj: CiliumNetworkPolicySpecsEgressToRequiresMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * K8sService selects service by name and namespace pair
 *
 * @schema CiliumNetworkPolicySpecsEgressToServicesK8SService
 */
export interface CiliumNetworkPolicySpecsEgressToServicesK8SService {
  /**
   * @schema CiliumNetworkPolicySpecsEgressToServicesK8SService#namespace
   */
  readonly namespace?: string;

  /**
   * @schema CiliumNetworkPolicySpecsEgressToServicesK8SService#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToServicesK8SService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToServicesK8SService(obj: CiliumNetworkPolicySpecsEgressToServicesK8SService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespace': obj.namespace,
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * K8sServiceSelector selects services by k8s labels and namespace
 *
 * @schema CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelector
 */
export interface CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelector {
  /**
   * @schema CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelector#namespace
   */
  readonly namespace?: string;

  /**
   * ServiceSelector is a label selector for k8s services
   *
   * @schema CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelector#selector
   */
  readonly selector: CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelector;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelector(obj: CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespace': obj.namespace,
    'selector': toJson_CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPField is a ICMP field.
 *
 * @schema CiliumNetworkPolicySpecsEgressDenyIcmpsFields
 */
export interface CiliumNetworkPolicySpecsEgressDenyIcmpsFields {
  /**
   * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyIcmpsFields#family
   */
  readonly family?: CiliumNetworkPolicySpecsEgressDenyIcmpsFieldsFamily;

  /**
   * Type is a ICMP-type. It should be 0-255 (8bit).
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyIcmpsFields#type
   */
  readonly type: number;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressDenyIcmpsFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressDenyIcmpsFields(obj: CiliumNetworkPolicySpecsEgressDenyIcmpsFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'family': obj.family,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNetworkPolicySpecsEgressDenyToEndpointsMatchExpressions
 */
export interface CiliumNetworkPolicySpecsEgressDenyToEndpointsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToEndpointsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToEndpointsMatchExpressions#operator
   */
  readonly operator: CiliumNetworkPolicySpecsEgressDenyToEndpointsMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToEndpointsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressDenyToEndpointsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressDenyToEndpointsMatchExpressions(obj: CiliumNetworkPolicySpecsEgressDenyToEndpointsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSGroup is an structure that can be used to whitelisting information from AWS integration
 *
 * @schema CiliumNetworkPolicySpecsEgressDenyToGroupsAws
 */
export interface CiliumNetworkPolicySpecsEgressDenyToGroupsAws {
  /**
   * @schema CiliumNetworkPolicySpecsEgressDenyToGroupsAws#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema CiliumNetworkPolicySpecsEgressDenyToGroupsAws#region
   */
  readonly region?: string;

  /**
   * @schema CiliumNetworkPolicySpecsEgressDenyToGroupsAws#securityGroupsIds
   */
  readonly securityGroupsIds?: string[];

  /**
   * @schema CiliumNetworkPolicySpecsEgressDenyToGroupsAws#securityGroupsNames
   */
  readonly securityGroupsNames?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressDenyToGroupsAws' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressDenyToGroupsAws(obj: CiliumNetworkPolicySpecsEgressDenyToGroupsAws | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'region': obj.region,
    'securityGroupsIds': obj.securityGroupsIds?.map(y => y),
    'securityGroupsNames': obj.securityGroupsNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortProtocol specifies an L4 port with an optional transport protocol
 *
 * @schema CiliumNetworkPolicySpecsEgressDenyToPortsPorts
 */
export interface CiliumNetworkPolicySpecsEgressDenyToPortsPorts {
  /**
   * Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form "1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToPortsPorts#port
   */
  readonly port: string;

  /**
   * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
   * Matching on ICMP is not supported.
   * Named port specified for a container may narrow this down, but may not contradict this.
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToPortsPorts#protocol
   */
  readonly protocol?: CiliumNetworkPolicySpecsEgressDenyToPortsPortsProtocol;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressDenyToPortsPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressDenyToPortsPorts(obj: CiliumNetworkPolicySpecsEgressDenyToPortsPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNetworkPolicySpecsEgressDenyToRequiresMatchExpressions
 */
export interface CiliumNetworkPolicySpecsEgressDenyToRequiresMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToRequiresMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToRequiresMatchExpressions#operator
   */
  readonly operator: CiliumNetworkPolicySpecsEgressDenyToRequiresMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToRequiresMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressDenyToRequiresMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressDenyToRequiresMatchExpressions(obj: CiliumNetworkPolicySpecsEgressDenyToRequiresMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * K8sService selects service by name and namespace pair
 *
 * @schema CiliumNetworkPolicySpecsEgressDenyToServicesK8SService
 */
export interface CiliumNetworkPolicySpecsEgressDenyToServicesK8SService {
  /**
   * @schema CiliumNetworkPolicySpecsEgressDenyToServicesK8SService#namespace
   */
  readonly namespace?: string;

  /**
   * @schema CiliumNetworkPolicySpecsEgressDenyToServicesK8SService#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressDenyToServicesK8SService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressDenyToServicesK8SService(obj: CiliumNetworkPolicySpecsEgressDenyToServicesK8SService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespace': obj.namespace,
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * K8sServiceSelector selects services by k8s labels and namespace
 *
 * @schema CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelector
 */
export interface CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelector {
  /**
   * @schema CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelector#namespace
   */
  readonly namespace?: string;

  /**
   * ServiceSelector is a label selector for k8s services
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelector#selector
   */
  readonly selector: CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelector;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelector(obj: CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespace': obj.namespace,
    'selector': toJson_CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumNetworkPolicySpecsEndpointSelectorMatchExpressionsOperator
 */
export enum CiliumNetworkPolicySpecsEndpointSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * Mode is the required authentication mode for the allowed traffic, if any.
 *
 * @schema CiliumNetworkPolicySpecsIngressAuthenticationMode
 */
export enum CiliumNetworkPolicySpecsIngressAuthenticationMode {
  /** disabled */
  DISABLED = "disabled",
  /** required */
  REQUIRED = "required",
  /** test-always-fail */
  TEST_HYPHEN_ALWAYS_HYPHEN_FAIL = "test-always-fail",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNetworkPolicySpecsIngressFromEndpointsMatchExpressions
 */
export interface CiliumNetworkPolicySpecsIngressFromEndpointsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNetworkPolicySpecsIngressFromEndpointsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNetworkPolicySpecsIngressFromEndpointsMatchExpressions#operator
   */
  readonly operator: CiliumNetworkPolicySpecsIngressFromEndpointsMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNetworkPolicySpecsIngressFromEndpointsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressFromEndpointsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressFromEndpointsMatchExpressions(obj: CiliumNetworkPolicySpecsIngressFromEndpointsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNetworkPolicySpecsIngressFromRequiresMatchExpressions
 */
export interface CiliumNetworkPolicySpecsIngressFromRequiresMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNetworkPolicySpecsIngressFromRequiresMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNetworkPolicySpecsIngressFromRequiresMatchExpressions#operator
   */
  readonly operator: CiliumNetworkPolicySpecsIngressFromRequiresMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNetworkPolicySpecsIngressFromRequiresMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressFromRequiresMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressFromRequiresMatchExpressions(obj: CiliumNetworkPolicySpecsIngressFromRequiresMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPField is a ICMP field.
 *
 * @schema CiliumNetworkPolicySpecsIngressIcmpsFields
 */
export interface CiliumNetworkPolicySpecsIngressIcmpsFields {
  /**
   * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
   *
   * @schema CiliumNetworkPolicySpecsIngressIcmpsFields#family
   */
  readonly family?: CiliumNetworkPolicySpecsIngressIcmpsFieldsFamily;

  /**
   * Type is a ICMP-type. It should be 0-255 (8bit).
   *
   * @schema CiliumNetworkPolicySpecsIngressIcmpsFields#type
   */
  readonly type: number;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressIcmpsFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressIcmpsFields(obj: CiliumNetworkPolicySpecsIngressIcmpsFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'family': obj.family,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.
 *
 * @schema CiliumNetworkPolicySpecsIngressToPortsListener
 */
export interface CiliumNetworkPolicySpecsIngressToPortsListener {
  /**
   * EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsListener#envoyConfig
   */
  readonly envoyConfig: CiliumNetworkPolicySpecsIngressToPortsListenerEnvoyConfig;

  /**
   * Name is the name of the listener.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsListener#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressToPortsListener' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressToPortsListener(obj: CiliumNetworkPolicySpecsIngressToPortsListener | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'envoyConfig': toJson_CiliumNetworkPolicySpecsIngressToPortsListenerEnvoyConfig(obj.envoyConfig),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.
 *
 * @schema CiliumNetworkPolicySpecsIngressToPortsOriginatingTls
 */
export interface CiliumNetworkPolicySpecsIngressToPortsOriginatingTls {
  /**
   * Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsOriginatingTls#certificate
   */
  readonly certificate?: string;

  /**
   * PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsOriginatingTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsOriginatingTls#secret
   */
  readonly secret: CiliumNetworkPolicySpecsIngressToPortsOriginatingTlsSecret;

  /**
   * TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsOriginatingTls#trustedCA
   */
  readonly trustedCa?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressToPortsOriginatingTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressToPortsOriginatingTls(obj: CiliumNetworkPolicySpecsIngressToPortsOriginatingTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'privateKey': obj.privateKey,
    'secret': toJson_CiliumNetworkPolicySpecsIngressToPortsOriginatingTlsSecret(obj.secret),
    'trustedCA': obj.trustedCa,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortProtocol specifies an L4 port with an optional transport protocol
 *
 * @schema CiliumNetworkPolicySpecsIngressToPortsPorts
 */
export interface CiliumNetworkPolicySpecsIngressToPortsPorts {
  /**
   * Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form "1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsPorts#port
   */
  readonly port: string;

  /**
   * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
   * Matching on ICMP is not supported.
   * Named port specified for a container may narrow this down, but may not contradict this.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsPorts#protocol
   */
  readonly protocol?: CiliumNetworkPolicySpecsIngressToPortsPortsProtocol;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressToPortsPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressToPortsPorts(obj: CiliumNetworkPolicySpecsIngressToPortsPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.
 *
 * @schema CiliumNetworkPolicySpecsIngressToPortsRules
 */
export interface CiliumNetworkPolicySpecsIngressToPortsRules {
  /**
   * DNS-specific rules.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsRules#dns
   */
  readonly dns?: CiliumNetworkPolicySpecsIngressToPortsRulesDns[];

  /**
   * HTTP specific rules.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsRules#http
   */
  readonly http?: CiliumNetworkPolicySpecsIngressToPortsRulesHttp[];

  /**
   * Kafka-specific rules.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsRules#kafka
   */
  readonly kafka?: CiliumNetworkPolicySpecsIngressToPortsRulesKafka[];

  /**
   * Key-value pair rules.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsRules#l7
   */
  readonly l7?: { [key: string]: string }[];

  /**
   * Name of the L7 protocol for which the Key-value pair rules apply.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsRules#l7proto
   */
  readonly l7Proto?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressToPortsRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressToPortsRules(obj: CiliumNetworkPolicySpecsIngressToPortsRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dns': obj.dns?.map(y => toJson_CiliumNetworkPolicySpecsIngressToPortsRulesDns(y)),
    'http': obj.http?.map(y => toJson_CiliumNetworkPolicySpecsIngressToPortsRulesHttp(y)),
    'kafka': obj.kafka?.map(y => toJson_CiliumNetworkPolicySpecsIngressToPortsRulesKafka(y)),
    'l7': obj.l7?.map(y => ((y) === undefined) ? undefined : (Object.entries(y).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {}))),
    'l7proto': obj.l7Proto,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.
 *
 * @schema CiliumNetworkPolicySpecsIngressToPortsTerminatingTls
 */
export interface CiliumNetworkPolicySpecsIngressToPortsTerminatingTls {
  /**
   * Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsTerminatingTls#certificate
   */
  readonly certificate?: string;

  /**
   * PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsTerminatingTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsTerminatingTls#secret
   */
  readonly secret: CiliumNetworkPolicySpecsIngressToPortsTerminatingTlsSecret;

  /**
   * TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsTerminatingTls#trustedCA
   */
  readonly trustedCa?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressToPortsTerminatingTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressToPortsTerminatingTls(obj: CiliumNetworkPolicySpecsIngressToPortsTerminatingTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'privateKey': obj.privateKey,
    'secret': toJson_CiliumNetworkPolicySpecsIngressToPortsTerminatingTlsSecret(obj.secret),
    'trustedCA': obj.trustedCa,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressions
 */
export interface CiliumNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressions#operator
   */
  readonly operator: CiliumNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressions(obj: CiliumNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNetworkPolicySpecsIngressDenyFromRequiresMatchExpressions
 */
export interface CiliumNetworkPolicySpecsIngressDenyFromRequiresMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNetworkPolicySpecsIngressDenyFromRequiresMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNetworkPolicySpecsIngressDenyFromRequiresMatchExpressions#operator
   */
  readonly operator: CiliumNetworkPolicySpecsIngressDenyFromRequiresMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNetworkPolicySpecsIngressDenyFromRequiresMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressDenyFromRequiresMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressDenyFromRequiresMatchExpressions(obj: CiliumNetworkPolicySpecsIngressDenyFromRequiresMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ICMPField is a ICMP field.
 *
 * @schema CiliumNetworkPolicySpecsIngressDenyIcmpsFields
 */
export interface CiliumNetworkPolicySpecsIngressDenyIcmpsFields {
  /**
   * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
   *
   * @schema CiliumNetworkPolicySpecsIngressDenyIcmpsFields#family
   */
  readonly family?: CiliumNetworkPolicySpecsIngressDenyIcmpsFieldsFamily;

  /**
   * Type is a ICMP-type. It should be 0-255 (8bit).
   *
   * @schema CiliumNetworkPolicySpecsIngressDenyIcmpsFields#type
   */
  readonly type: number;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressDenyIcmpsFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressDenyIcmpsFields(obj: CiliumNetworkPolicySpecsIngressDenyIcmpsFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'family': obj.family,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortProtocol specifies an L4 port with an optional transport protocol
 *
 * @schema CiliumNetworkPolicySpecsIngressDenyToPortsPorts
 */
export interface CiliumNetworkPolicySpecsIngressDenyToPortsPorts {
  /**
   * Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form "1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.
   *
   * @schema CiliumNetworkPolicySpecsIngressDenyToPortsPorts#port
   */
  readonly port: string;

  /**
   * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
   * Matching on ICMP is not supported.
   * Named port specified for a container may narrow this down, but may not contradict this.
   *
   * @schema CiliumNetworkPolicySpecsIngressDenyToPortsPorts#protocol
   */
  readonly protocol?: CiliumNetworkPolicySpecsIngressDenyToPortsPortsProtocol;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressDenyToPortsPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressDenyToPortsPorts(obj: CiliumNetworkPolicySpecsIngressDenyToPortsPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumNetworkPolicySpecsNodeSelectorMatchExpressionsOperator
 */
export enum CiliumNetworkPolicySpecsNodeSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
 *
 * @schema CiliumNetworkPolicySpecEgressIcmpsFieldsFamily
 */
export enum CiliumNetworkPolicySpecEgressIcmpsFieldsFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumNetworkPolicySpecEgressToEndpointsMatchExpressionsOperator
 */
export enum CiliumNetworkPolicySpecEgressToEndpointsMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.
 *
 * @schema CiliumNetworkPolicySpecEgressToPortsListenerEnvoyConfig
 */
export interface CiliumNetworkPolicySpecEgressToPortsListenerEnvoyConfig {
  /**
   * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
   *
   * @default CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
   * @schema CiliumNetworkPolicySpecEgressToPortsListenerEnvoyConfig#kind
   */
  readonly kind?: CiliumNetworkPolicySpecEgressToPortsListenerEnvoyConfigKind;

  /**
   * Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where the listener is defined in.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsListenerEnvoyConfig#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToPortsListenerEnvoyConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToPortsListenerEnvoyConfig(obj: CiliumNetworkPolicySpecEgressToPortsListenerEnvoyConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
 *
 * @schema CiliumNetworkPolicySpecEgressToPortsOriginatingTlsSecret
 */
export interface CiliumNetworkPolicySpecEgressToPortsOriginatingTlsSecret {
  /**
   * Name is the name of the secret.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsOriginatingTlsSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., "default").
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsOriginatingTlsSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToPortsOriginatingTlsSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToPortsOriginatingTlsSecret(obj: CiliumNetworkPolicySpecEgressToPortsOriginatingTlsSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
 * Matching on ICMP is not supported.
 * Named port specified for a container may narrow this down, but may not contradict this.
 *
 * @schema CiliumNetworkPolicySpecEgressToPortsPortsProtocol
 */
export enum CiliumNetworkPolicySpecEgressToPortsPortsProtocol {
  /** TCP */
  TCP = "TCP",
  /** UDP */
  UDP = "UDP",
  /** SCTP */
  SCTP = "SCTP",
  /** ANY */
  ANY = "ANY",
}

/**
 * PortRuleDNS is a list of allowed DNS lookups.
 *
 * @schema CiliumNetworkPolicySpecEgressToPortsRulesDns
 */
export interface CiliumNetworkPolicySpecEgressToPortsRulesDns {
  /**
   * MatchName matches literal DNS names. A trailing "." is automatically added when missing.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsRulesDns#matchName
   */
  readonly matchName?: string;

  /**
   * MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - "*" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a "*" as the leftmost character, without a following "." matches all subdomains as well as the name to the right. A trailing "." is automatically added when missing.
   * Examples: `*.cilium.io` matches subomains of cilium at that level www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io" except those containing "." separator, subcilium.io and sub-cilium.io match, www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with "sub" sub.cilium.io and subdomain.cilium.io match, www.cilium.io, blog.cilium.io, cilium.io and google.com do not
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsRulesDns#matchPattern
   */
  readonly matchPattern?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToPortsRulesDns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToPortsRulesDns(obj: CiliumNetworkPolicySpecEgressToPortsRulesDns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchName': obj.matchName,
    'matchPattern': obj.matchPattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortRuleHTTP is a list of HTTP protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect.
 * All fields of this type are extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional "path" part of a URL as defined by RFC 3986.
 *
 * @schema CiliumNetworkPolicySpecEgressToPortsRulesHttp
 */
export interface CiliumNetworkPolicySpecEgressToPortsRulesHttp {
  /**
   * HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsRulesHttp#headerMatches
   */
  readonly headerMatches?: CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches[];

  /**
   * Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsRulesHttp#headers
   */
  readonly headers?: string[];

  /**
   * Host is an extended POSIX regex matched against the host header of a request, e.g. "foo.com"
   * If omitted or empty, the value of the host header is ignored.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsRulesHttp#host
   */
  readonly host?: string;

  /**
   * Method is an extended POSIX regex matched against the method of a request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
   * If omitted or empty, all methods are allowed.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsRulesHttp#method
   */
  readonly method?: string;

  /**
   * Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional "path" part of a URL as defined by RFC 3986.
   * If omitted or empty, all paths are all allowed.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsRulesHttp#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToPortsRulesHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToPortsRulesHttp(obj: CiliumNetworkPolicySpecEgressToPortsRulesHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerMatches': obj.headerMatches?.map(y => toJson_CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches(y)),
    'headers': obj.headers?.map(y => y),
    'host': obj.host,
    'method': obj.method,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortRule is a list of Kafka protocol constraints. All fields are optional, if all fields are empty or missing, the rule will match all Kafka messages.
 *
 * @schema CiliumNetworkPolicySpecEgressToPortsRulesKafka
 */
export interface CiliumNetworkPolicySpecEgressToPortsRulesKafka {
  /**
   * APIKey is a case-insensitive string matched against the key of a request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys
   * If omitted or empty, and if Role is not specified, then all keys are allowed.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsRulesKafka#apiKey
   */
  readonly apiKey?: string;

  /**
   * APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer.
   * If omitted or empty, all versions are allowed.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsRulesKafka#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * ClientID is the client identifier as provided in the request.
   * From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client.
   * If omitted or empty, all client identifiers are allowed.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsRulesKafka#clientID
   */
  readonly clientId?: string;

  /**
   * Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as "produce" or "consume". A Role automatically expands into all APIKeys required to perform the specified higher-level operation.
   * The following values are supported: - "produce": Allow producing to the topics specified in the rule - "consume": Allow consuming from the topics specified in the rule
   * This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule.
   * If omitted or empty, and if APIKey is not specified, then all keys are allowed.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsRulesKafka#role
   */
  readonly role?: CiliumNetworkPolicySpecEgressToPortsRulesKafkaRole;

  /**
   * Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected.
   * This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _.
   * Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255.
   * If omitted or empty, all topics are allowed.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsRulesKafka#topic
   */
  readonly topic?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToPortsRulesKafka' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToPortsRulesKafka(obj: CiliumNetworkPolicySpecEgressToPortsRulesKafka | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': obj.apiKey,
    'apiVersion': obj.apiVersion,
    'clientID': obj.clientId,
    'role': obj.role,
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
 *
 * @schema CiliumNetworkPolicySpecEgressToPortsTerminatingTlsSecret
 */
export interface CiliumNetworkPolicySpecEgressToPortsTerminatingTlsSecret {
  /**
   * Name is the name of the secret.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsTerminatingTlsSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., "default").
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsTerminatingTlsSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToPortsTerminatingTlsSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToPortsTerminatingTlsSecret(obj: CiliumNetworkPolicySpecEgressToPortsTerminatingTlsSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumNetworkPolicySpecEgressToRequiresMatchExpressionsOperator
 */
export enum CiliumNetworkPolicySpecEgressToRequiresMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * ServiceSelector is a label selector for k8s services
 *
 * @schema CiliumNetworkPolicySpecEgressToServicesK8SServiceSelectorSelector
 */
export interface CiliumNetworkPolicySpecEgressToServicesK8SServiceSelectorSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecEgressToServicesK8SServiceSelectorSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecEgressToServicesK8SServiceSelectorSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToServicesK8SServiceSelectorSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToServicesK8SServiceSelectorSelector(obj: CiliumNetworkPolicySpecEgressToServicesK8SServiceSelectorSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
 *
 * @schema CiliumNetworkPolicySpecEgressDenyIcmpsFieldsFamily
 */
export enum CiliumNetworkPolicySpecEgressDenyIcmpsFieldsFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumNetworkPolicySpecEgressDenyToEndpointsMatchExpressionsOperator
 */
export enum CiliumNetworkPolicySpecEgressDenyToEndpointsMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
 * Matching on ICMP is not supported.
 * Named port specified for a container may narrow this down, but may not contradict this.
 *
 * @schema CiliumNetworkPolicySpecEgressDenyToPortsPortsProtocol
 */
export enum CiliumNetworkPolicySpecEgressDenyToPortsPortsProtocol {
  /** TCP */
  TCP = "TCP",
  /** UDP */
  UDP = "UDP",
  /** SCTP */
  SCTP = "SCTP",
  /** ANY */
  ANY = "ANY",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumNetworkPolicySpecEgressDenyToRequiresMatchExpressionsOperator
 */
export enum CiliumNetworkPolicySpecEgressDenyToRequiresMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * ServiceSelector is a label selector for k8s services
 *
 * @schema CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelector
 */
export interface CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelector(obj: CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumNetworkPolicySpecIngressFromEndpointsMatchExpressionsOperator
 */
export enum CiliumNetworkPolicySpecIngressFromEndpointsMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumNetworkPolicySpecIngressFromRequiresMatchExpressionsOperator
 */
export enum CiliumNetworkPolicySpecIngressFromRequiresMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
 *
 * @schema CiliumNetworkPolicySpecIngressIcmpsFieldsFamily
 */
export enum CiliumNetworkPolicySpecIngressIcmpsFieldsFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.
 *
 * @schema CiliumNetworkPolicySpecIngressToPortsListenerEnvoyConfig
 */
export interface CiliumNetworkPolicySpecIngressToPortsListenerEnvoyConfig {
  /**
   * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
   *
   * @default CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
   * @schema CiliumNetworkPolicySpecIngressToPortsListenerEnvoyConfig#kind
   */
  readonly kind?: CiliumNetworkPolicySpecIngressToPortsListenerEnvoyConfigKind;

  /**
   * Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where the listener is defined in.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsListenerEnvoyConfig#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressToPortsListenerEnvoyConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressToPortsListenerEnvoyConfig(obj: CiliumNetworkPolicySpecIngressToPortsListenerEnvoyConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
 *
 * @schema CiliumNetworkPolicySpecIngressToPortsOriginatingTlsSecret
 */
export interface CiliumNetworkPolicySpecIngressToPortsOriginatingTlsSecret {
  /**
   * Name is the name of the secret.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsOriginatingTlsSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., "default").
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsOriginatingTlsSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressToPortsOriginatingTlsSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressToPortsOriginatingTlsSecret(obj: CiliumNetworkPolicySpecIngressToPortsOriginatingTlsSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
 * Matching on ICMP is not supported.
 * Named port specified for a container may narrow this down, but may not contradict this.
 *
 * @schema CiliumNetworkPolicySpecIngressToPortsPortsProtocol
 */
export enum CiliumNetworkPolicySpecIngressToPortsPortsProtocol {
  /** TCP */
  TCP = "TCP",
  /** UDP */
  UDP = "UDP",
  /** SCTP */
  SCTP = "SCTP",
  /** ANY */
  ANY = "ANY",
}

/**
 * PortRuleDNS is a list of allowed DNS lookups.
 *
 * @schema CiliumNetworkPolicySpecIngressToPortsRulesDns
 */
export interface CiliumNetworkPolicySpecIngressToPortsRulesDns {
  /**
   * MatchName matches literal DNS names. A trailing "." is automatically added when missing.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsRulesDns#matchName
   */
  readonly matchName?: string;

  /**
   * MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - "*" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a "*" as the leftmost character, without a following "." matches all subdomains as well as the name to the right. A trailing "." is automatically added when missing.
   * Examples: `*.cilium.io` matches subomains of cilium at that level www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io" except those containing "." separator, subcilium.io and sub-cilium.io match, www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with "sub" sub.cilium.io and subdomain.cilium.io match, www.cilium.io, blog.cilium.io, cilium.io and google.com do not
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsRulesDns#matchPattern
   */
  readonly matchPattern?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressToPortsRulesDns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressToPortsRulesDns(obj: CiliumNetworkPolicySpecIngressToPortsRulesDns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchName': obj.matchName,
    'matchPattern': obj.matchPattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortRuleHTTP is a list of HTTP protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect.
 * All fields of this type are extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional "path" part of a URL as defined by RFC 3986.
 *
 * @schema CiliumNetworkPolicySpecIngressToPortsRulesHttp
 */
export interface CiliumNetworkPolicySpecIngressToPortsRulesHttp {
  /**
   * HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsRulesHttp#headerMatches
   */
  readonly headerMatches?: CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches[];

  /**
   * Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsRulesHttp#headers
   */
  readonly headers?: string[];

  /**
   * Host is an extended POSIX regex matched against the host header of a request, e.g. "foo.com"
   * If omitted or empty, the value of the host header is ignored.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsRulesHttp#host
   */
  readonly host?: string;

  /**
   * Method is an extended POSIX regex matched against the method of a request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
   * If omitted or empty, all methods are allowed.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsRulesHttp#method
   */
  readonly method?: string;

  /**
   * Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional "path" part of a URL as defined by RFC 3986.
   * If omitted or empty, all paths are all allowed.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsRulesHttp#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressToPortsRulesHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressToPortsRulesHttp(obj: CiliumNetworkPolicySpecIngressToPortsRulesHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerMatches': obj.headerMatches?.map(y => toJson_CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches(y)),
    'headers': obj.headers?.map(y => y),
    'host': obj.host,
    'method': obj.method,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortRule is a list of Kafka protocol constraints. All fields are optional, if all fields are empty or missing, the rule will match all Kafka messages.
 *
 * @schema CiliumNetworkPolicySpecIngressToPortsRulesKafka
 */
export interface CiliumNetworkPolicySpecIngressToPortsRulesKafka {
  /**
   * APIKey is a case-insensitive string matched against the key of a request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys
   * If omitted or empty, and if Role is not specified, then all keys are allowed.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsRulesKafka#apiKey
   */
  readonly apiKey?: string;

  /**
   * APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer.
   * If omitted or empty, all versions are allowed.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsRulesKafka#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * ClientID is the client identifier as provided in the request.
   * From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client.
   * If omitted or empty, all client identifiers are allowed.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsRulesKafka#clientID
   */
  readonly clientId?: string;

  /**
   * Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as "produce" or "consume". A Role automatically expands into all APIKeys required to perform the specified higher-level operation.
   * The following values are supported: - "produce": Allow producing to the topics specified in the rule - "consume": Allow consuming from the topics specified in the rule
   * This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule.
   * If omitted or empty, and if APIKey is not specified, then all keys are allowed.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsRulesKafka#role
   */
  readonly role?: CiliumNetworkPolicySpecIngressToPortsRulesKafkaRole;

  /**
   * Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected.
   * This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _.
   * Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255.
   * If omitted or empty, all topics are allowed.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsRulesKafka#topic
   */
  readonly topic?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressToPortsRulesKafka' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressToPortsRulesKafka(obj: CiliumNetworkPolicySpecIngressToPortsRulesKafka | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': obj.apiKey,
    'apiVersion': obj.apiVersion,
    'clientID': obj.clientId,
    'role': obj.role,
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
 *
 * @schema CiliumNetworkPolicySpecIngressToPortsTerminatingTlsSecret
 */
export interface CiliumNetworkPolicySpecIngressToPortsTerminatingTlsSecret {
  /**
   * Name is the name of the secret.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsTerminatingTlsSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., "default").
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsTerminatingTlsSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressToPortsTerminatingTlsSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressToPortsTerminatingTlsSecret(obj: CiliumNetworkPolicySpecIngressToPortsTerminatingTlsSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumNetworkPolicySpecIngressDenyFromEndpointsMatchExpressionsOperator
 */
export enum CiliumNetworkPolicySpecIngressDenyFromEndpointsMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumNetworkPolicySpecIngressDenyFromRequiresMatchExpressionsOperator
 */
export enum CiliumNetworkPolicySpecIngressDenyFromRequiresMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
 *
 * @schema CiliumNetworkPolicySpecIngressDenyIcmpsFieldsFamily
 */
export enum CiliumNetworkPolicySpecIngressDenyIcmpsFieldsFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
 * Matching on ICMP is not supported.
 * Named port specified for a container may narrow this down, but may not contradict this.
 *
 * @schema CiliumNetworkPolicySpecIngressDenyToPortsPortsProtocol
 */
export enum CiliumNetworkPolicySpecIngressDenyToPortsPortsProtocol {
  /** TCP */
  TCP = "TCP",
  /** UDP */
  UDP = "UDP",
  /** SCTP */
  SCTP = "SCTP",
  /** ANY */
  ANY = "ANY",
}

/**
 * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
 *
 * @schema CiliumNetworkPolicySpecsEgressIcmpsFieldsFamily
 */
export enum CiliumNetworkPolicySpecsEgressIcmpsFieldsFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumNetworkPolicySpecsEgressToEndpointsMatchExpressionsOperator
 */
export enum CiliumNetworkPolicySpecsEgressToEndpointsMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.
 *
 * @schema CiliumNetworkPolicySpecsEgressToPortsListenerEnvoyConfig
 */
export interface CiliumNetworkPolicySpecsEgressToPortsListenerEnvoyConfig {
  /**
   * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
   *
   * @default CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
   * @schema CiliumNetworkPolicySpecsEgressToPortsListenerEnvoyConfig#kind
   */
  readonly kind?: CiliumNetworkPolicySpecsEgressToPortsListenerEnvoyConfigKind;

  /**
   * Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where the listener is defined in.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsListenerEnvoyConfig#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToPortsListenerEnvoyConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToPortsListenerEnvoyConfig(obj: CiliumNetworkPolicySpecsEgressToPortsListenerEnvoyConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
 *
 * @schema CiliumNetworkPolicySpecsEgressToPortsOriginatingTlsSecret
 */
export interface CiliumNetworkPolicySpecsEgressToPortsOriginatingTlsSecret {
  /**
   * Name is the name of the secret.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsOriginatingTlsSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., "default").
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsOriginatingTlsSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToPortsOriginatingTlsSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToPortsOriginatingTlsSecret(obj: CiliumNetworkPolicySpecsEgressToPortsOriginatingTlsSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
 * Matching on ICMP is not supported.
 * Named port specified for a container may narrow this down, but may not contradict this.
 *
 * @schema CiliumNetworkPolicySpecsEgressToPortsPortsProtocol
 */
export enum CiliumNetworkPolicySpecsEgressToPortsPortsProtocol {
  /** TCP */
  TCP = "TCP",
  /** UDP */
  UDP = "UDP",
  /** SCTP */
  SCTP = "SCTP",
  /** ANY */
  ANY = "ANY",
}

/**
 * PortRuleDNS is a list of allowed DNS lookups.
 *
 * @schema CiliumNetworkPolicySpecsEgressToPortsRulesDns
 */
export interface CiliumNetworkPolicySpecsEgressToPortsRulesDns {
  /**
   * MatchName matches literal DNS names. A trailing "." is automatically added when missing.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsRulesDns#matchName
   */
  readonly matchName?: string;

  /**
   * MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - "*" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a "*" as the leftmost character, without a following "." matches all subdomains as well as the name to the right. A trailing "." is automatically added when missing.
   * Examples: `*.cilium.io` matches subomains of cilium at that level www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io" except those containing "." separator, subcilium.io and sub-cilium.io match, www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with "sub" sub.cilium.io and subdomain.cilium.io match, www.cilium.io, blog.cilium.io, cilium.io and google.com do not
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsRulesDns#matchPattern
   */
  readonly matchPattern?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToPortsRulesDns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToPortsRulesDns(obj: CiliumNetworkPolicySpecsEgressToPortsRulesDns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchName': obj.matchName,
    'matchPattern': obj.matchPattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortRuleHTTP is a list of HTTP protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect.
 * All fields of this type are extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional "path" part of a URL as defined by RFC 3986.
 *
 * @schema CiliumNetworkPolicySpecsEgressToPortsRulesHttp
 */
export interface CiliumNetworkPolicySpecsEgressToPortsRulesHttp {
  /**
   * HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsRulesHttp#headerMatches
   */
  readonly headerMatches?: CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches[];

  /**
   * Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsRulesHttp#headers
   */
  readonly headers?: string[];

  /**
   * Host is an extended POSIX regex matched against the host header of a request, e.g. "foo.com"
   * If omitted or empty, the value of the host header is ignored.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsRulesHttp#host
   */
  readonly host?: string;

  /**
   * Method is an extended POSIX regex matched against the method of a request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
   * If omitted or empty, all methods are allowed.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsRulesHttp#method
   */
  readonly method?: string;

  /**
   * Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional "path" part of a URL as defined by RFC 3986.
   * If omitted or empty, all paths are all allowed.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsRulesHttp#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToPortsRulesHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToPortsRulesHttp(obj: CiliumNetworkPolicySpecsEgressToPortsRulesHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerMatches': obj.headerMatches?.map(y => toJson_CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches(y)),
    'headers': obj.headers?.map(y => y),
    'host': obj.host,
    'method': obj.method,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortRule is a list of Kafka protocol constraints. All fields are optional, if all fields are empty or missing, the rule will match all Kafka messages.
 *
 * @schema CiliumNetworkPolicySpecsEgressToPortsRulesKafka
 */
export interface CiliumNetworkPolicySpecsEgressToPortsRulesKafka {
  /**
   * APIKey is a case-insensitive string matched against the key of a request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys
   * If omitted or empty, and if Role is not specified, then all keys are allowed.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsRulesKafka#apiKey
   */
  readonly apiKey?: string;

  /**
   * APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer.
   * If omitted or empty, all versions are allowed.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsRulesKafka#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * ClientID is the client identifier as provided in the request.
   * From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client.
   * If omitted or empty, all client identifiers are allowed.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsRulesKafka#clientID
   */
  readonly clientId?: string;

  /**
   * Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as "produce" or "consume". A Role automatically expands into all APIKeys required to perform the specified higher-level operation.
   * The following values are supported: - "produce": Allow producing to the topics specified in the rule - "consume": Allow consuming from the topics specified in the rule
   * This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule.
   * If omitted or empty, and if APIKey is not specified, then all keys are allowed.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsRulesKafka#role
   */
  readonly role?: CiliumNetworkPolicySpecsEgressToPortsRulesKafkaRole;

  /**
   * Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected.
   * This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _.
   * Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255.
   * If omitted or empty, all topics are allowed.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsRulesKafka#topic
   */
  readonly topic?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToPortsRulesKafka' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToPortsRulesKafka(obj: CiliumNetworkPolicySpecsEgressToPortsRulesKafka | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': obj.apiKey,
    'apiVersion': obj.apiVersion,
    'clientID': obj.clientId,
    'role': obj.role,
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
 *
 * @schema CiliumNetworkPolicySpecsEgressToPortsTerminatingTlsSecret
 */
export interface CiliumNetworkPolicySpecsEgressToPortsTerminatingTlsSecret {
  /**
   * Name is the name of the secret.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsTerminatingTlsSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., "default").
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsTerminatingTlsSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToPortsTerminatingTlsSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToPortsTerminatingTlsSecret(obj: CiliumNetworkPolicySpecsEgressToPortsTerminatingTlsSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumNetworkPolicySpecsEgressToRequiresMatchExpressionsOperator
 */
export enum CiliumNetworkPolicySpecsEgressToRequiresMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * ServiceSelector is a label selector for k8s services
 *
 * @schema CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelector
 */
export interface CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelector(obj: CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
 *
 * @schema CiliumNetworkPolicySpecsEgressDenyIcmpsFieldsFamily
 */
export enum CiliumNetworkPolicySpecsEgressDenyIcmpsFieldsFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumNetworkPolicySpecsEgressDenyToEndpointsMatchExpressionsOperator
 */
export enum CiliumNetworkPolicySpecsEgressDenyToEndpointsMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
 * Matching on ICMP is not supported.
 * Named port specified for a container may narrow this down, but may not contradict this.
 *
 * @schema CiliumNetworkPolicySpecsEgressDenyToPortsPortsProtocol
 */
export enum CiliumNetworkPolicySpecsEgressDenyToPortsPortsProtocol {
  /** TCP */
  TCP = "TCP",
  /** UDP */
  UDP = "UDP",
  /** SCTP */
  SCTP = "SCTP",
  /** ANY */
  ANY = "ANY",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumNetworkPolicySpecsEgressDenyToRequiresMatchExpressionsOperator
 */
export enum CiliumNetworkPolicySpecsEgressDenyToRequiresMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * ServiceSelector is a label selector for k8s services
 *
 * @schema CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelector
 */
export interface CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelector(obj: CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumNetworkPolicySpecsIngressFromEndpointsMatchExpressionsOperator
 */
export enum CiliumNetworkPolicySpecsIngressFromEndpointsMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumNetworkPolicySpecsIngressFromRequiresMatchExpressionsOperator
 */
export enum CiliumNetworkPolicySpecsIngressFromRequiresMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
 *
 * @schema CiliumNetworkPolicySpecsIngressIcmpsFieldsFamily
 */
export enum CiliumNetworkPolicySpecsIngressIcmpsFieldsFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.
 *
 * @schema CiliumNetworkPolicySpecsIngressToPortsListenerEnvoyConfig
 */
export interface CiliumNetworkPolicySpecsIngressToPortsListenerEnvoyConfig {
  /**
   * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
   *
   * @default CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
   * @schema CiliumNetworkPolicySpecsIngressToPortsListenerEnvoyConfig#kind
   */
  readonly kind?: CiliumNetworkPolicySpecsIngressToPortsListenerEnvoyConfigKind;

  /**
   * Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where the listener is defined in.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsListenerEnvoyConfig#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressToPortsListenerEnvoyConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressToPortsListenerEnvoyConfig(obj: CiliumNetworkPolicySpecsIngressToPortsListenerEnvoyConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
 *
 * @schema CiliumNetworkPolicySpecsIngressToPortsOriginatingTlsSecret
 */
export interface CiliumNetworkPolicySpecsIngressToPortsOriginatingTlsSecret {
  /**
   * Name is the name of the secret.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsOriginatingTlsSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., "default").
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsOriginatingTlsSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressToPortsOriginatingTlsSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressToPortsOriginatingTlsSecret(obj: CiliumNetworkPolicySpecsIngressToPortsOriginatingTlsSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
 * Matching on ICMP is not supported.
 * Named port specified for a container may narrow this down, but may not contradict this.
 *
 * @schema CiliumNetworkPolicySpecsIngressToPortsPortsProtocol
 */
export enum CiliumNetworkPolicySpecsIngressToPortsPortsProtocol {
  /** TCP */
  TCP = "TCP",
  /** UDP */
  UDP = "UDP",
  /** SCTP */
  SCTP = "SCTP",
  /** ANY */
  ANY = "ANY",
}

/**
 * PortRuleDNS is a list of allowed DNS lookups.
 *
 * @schema CiliumNetworkPolicySpecsIngressToPortsRulesDns
 */
export interface CiliumNetworkPolicySpecsIngressToPortsRulesDns {
  /**
   * MatchName matches literal DNS names. A trailing "." is automatically added when missing.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsRulesDns#matchName
   */
  readonly matchName?: string;

  /**
   * MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - "*" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a "*" as the leftmost character, without a following "." matches all subdomains as well as the name to the right. A trailing "." is automatically added when missing.
   * Examples: `*.cilium.io` matches subomains of cilium at that level www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io" except those containing "." separator, subcilium.io and sub-cilium.io match, www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with "sub" sub.cilium.io and subdomain.cilium.io match, www.cilium.io, blog.cilium.io, cilium.io and google.com do not
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsRulesDns#matchPattern
   */
  readonly matchPattern?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressToPortsRulesDns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressToPortsRulesDns(obj: CiliumNetworkPolicySpecsIngressToPortsRulesDns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchName': obj.matchName,
    'matchPattern': obj.matchPattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortRuleHTTP is a list of HTTP protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect.
 * All fields of this type are extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional "path" part of a URL as defined by RFC 3986.
 *
 * @schema CiliumNetworkPolicySpecsIngressToPortsRulesHttp
 */
export interface CiliumNetworkPolicySpecsIngressToPortsRulesHttp {
  /**
   * HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsRulesHttp#headerMatches
   */
  readonly headerMatches?: CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches[];

  /**
   * Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsRulesHttp#headers
   */
  readonly headers?: string[];

  /**
   * Host is an extended POSIX regex matched against the host header of a request, e.g. "foo.com"
   * If omitted or empty, the value of the host header is ignored.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsRulesHttp#host
   */
  readonly host?: string;

  /**
   * Method is an extended POSIX regex matched against the method of a request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
   * If omitted or empty, all methods are allowed.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsRulesHttp#method
   */
  readonly method?: string;

  /**
   * Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional "path" part of a URL as defined by RFC 3986.
   * If omitted or empty, all paths are all allowed.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsRulesHttp#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressToPortsRulesHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressToPortsRulesHttp(obj: CiliumNetworkPolicySpecsIngressToPortsRulesHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerMatches': obj.headerMatches?.map(y => toJson_CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches(y)),
    'headers': obj.headers?.map(y => y),
    'host': obj.host,
    'method': obj.method,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortRule is a list of Kafka protocol constraints. All fields are optional, if all fields are empty or missing, the rule will match all Kafka messages.
 *
 * @schema CiliumNetworkPolicySpecsIngressToPortsRulesKafka
 */
export interface CiliumNetworkPolicySpecsIngressToPortsRulesKafka {
  /**
   * APIKey is a case-insensitive string matched against the key of a request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys
   * If omitted or empty, and if Role is not specified, then all keys are allowed.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsRulesKafka#apiKey
   */
  readonly apiKey?: string;

  /**
   * APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer.
   * If omitted or empty, all versions are allowed.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsRulesKafka#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * ClientID is the client identifier as provided in the request.
   * From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client.
   * If omitted or empty, all client identifiers are allowed.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsRulesKafka#clientID
   */
  readonly clientId?: string;

  /**
   * Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as "produce" or "consume". A Role automatically expands into all APIKeys required to perform the specified higher-level operation.
   * The following values are supported: - "produce": Allow producing to the topics specified in the rule - "consume": Allow consuming from the topics specified in the rule
   * This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule.
   * If omitted or empty, and if APIKey is not specified, then all keys are allowed.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsRulesKafka#role
   */
  readonly role?: CiliumNetworkPolicySpecsIngressToPortsRulesKafkaRole;

  /**
   * Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected.
   * This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _.
   * Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255.
   * If omitted or empty, all topics are allowed.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsRulesKafka#topic
   */
  readonly topic?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressToPortsRulesKafka' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressToPortsRulesKafka(obj: CiliumNetworkPolicySpecsIngressToPortsRulesKafka | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': obj.apiKey,
    'apiVersion': obj.apiVersion,
    'clientID': obj.clientId,
    'role': obj.role,
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt'  - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate.
 *
 * @schema CiliumNetworkPolicySpecsIngressToPortsTerminatingTlsSecret
 */
export interface CiliumNetworkPolicySpecsIngressToPortsTerminatingTlsSecret {
  /**
   * Name is the name of the secret.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsTerminatingTlsSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., "default").
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsTerminatingTlsSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressToPortsTerminatingTlsSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressToPortsTerminatingTlsSecret(obj: CiliumNetworkPolicySpecsIngressToPortsTerminatingTlsSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressionsOperator
 */
export enum CiliumNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumNetworkPolicySpecsIngressDenyFromRequiresMatchExpressionsOperator
 */
export enum CiliumNetworkPolicySpecsIngressDenyFromRequiresMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.
 *
 * @schema CiliumNetworkPolicySpecsIngressDenyIcmpsFieldsFamily
 */
export enum CiliumNetworkPolicySpecsIngressDenyIcmpsFieldsFamily {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
 * Matching on ICMP is not supported.
 * Named port specified for a container may narrow this down, but may not contradict this.
 *
 * @schema CiliumNetworkPolicySpecsIngressDenyToPortsPortsProtocol
 */
export enum CiliumNetworkPolicySpecsIngressDenyToPortsPortsProtocol {
  /** TCP */
  TCP = "TCP",
  /** UDP */
  UDP = "UDP",
  /** SCTP */
  SCTP = "SCTP",
  /** ANY */
  ANY = "ANY",
}

/**
 * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
 *
 * @default CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
 * @schema CiliumNetworkPolicySpecEgressToPortsListenerEnvoyConfigKind
 */
export enum CiliumNetworkPolicySpecEgressToPortsListenerEnvoyConfigKind {
  /** CiliumEnvoyConfig */
  CILIUM_ENVOY_CONFIG = "CiliumEnvoyConfig",
  /** CiliumClusterwideEnvoyConfig */
  CILIUM_CLUSTERWIDE_ENVOY_CONFIG = "CiliumClusterwideEnvoyConfig",
}

/**
 * HeaderMatch extends the HeaderValue for matching requirement of a named header field against an immediate string, a secret value, or a regex.  If none of the optional fields is present, then the header value is not matched, only presence of the header is enough.
 *
 * @schema CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches
 */
export interface CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches {
  /**
   * Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches#mismatch
   */
  readonly mismatch?: CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesMismatch;

  /**
   * Name identifies the header.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches#name
   */
  readonly name: string;

  /**
   * Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no "Value" specified, the match will fail.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches#secret
   */
  readonly secret?: CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecret;

  /**
   * Value matches the exact value of the header. Can be specified either alone or together with "Secret"; will be used as the header value if the secret can not be found in the latter case.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches(obj: CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mismatch': obj.mismatch,
    'name': obj.name,
    'secret': toJson_CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecret(obj.secret),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as "produce" or "consume". A Role automatically expands into all APIKeys required to perform the specified higher-level operation.
 * The following values are supported: - "produce": Allow producing to the topics specified in the rule - "consume": Allow consuming from the topics specified in the rule
 * This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule.
 * If omitted or empty, and if APIKey is not specified, then all keys are allowed.
 *
 * @schema CiliumNetworkPolicySpecEgressToPortsRulesKafkaRole
 */
export enum CiliumNetworkPolicySpecEgressToPortsRulesKafkaRole {
  /** produce */
  PRODUCE = "produce",
  /** consume */
  CONSUME = "consume",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressions
 */
export interface CiliumNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressions#operator
   */
  readonly operator: CiliumNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressions(obj: CiliumNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions
 */
export interface CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions#operator
   */
  readonly operator: CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions(obj: CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
 *
 * @default CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
 * @schema CiliumNetworkPolicySpecIngressToPortsListenerEnvoyConfigKind
 */
export enum CiliumNetworkPolicySpecIngressToPortsListenerEnvoyConfigKind {
  /** CiliumEnvoyConfig */
  CILIUM_ENVOY_CONFIG = "CiliumEnvoyConfig",
  /** CiliumClusterwideEnvoyConfig */
  CILIUM_CLUSTERWIDE_ENVOY_CONFIG = "CiliumClusterwideEnvoyConfig",
}

/**
 * HeaderMatch extends the HeaderValue for matching requirement of a named header field against an immediate string, a secret value, or a regex.  If none of the optional fields is present, then the header value is not matched, only presence of the header is enough.
 *
 * @schema CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches
 */
export interface CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches {
  /**
   * Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches#mismatch
   */
  readonly mismatch?: CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesMismatch;

  /**
   * Name identifies the header.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches#name
   */
  readonly name: string;

  /**
   * Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no "Value" specified, the match will fail.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches#secret
   */
  readonly secret?: CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecret;

  /**
   * Value matches the exact value of the header. Can be specified either alone or together with "Secret"; will be used as the header value if the secret can not be found in the latter case.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches(obj: CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mismatch': obj.mismatch,
    'name': obj.name,
    'secret': toJson_CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecret(obj.secret),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as "produce" or "consume". A Role automatically expands into all APIKeys required to perform the specified higher-level operation.
 * The following values are supported: - "produce": Allow producing to the topics specified in the rule - "consume": Allow consuming from the topics specified in the rule
 * This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule.
 * If omitted or empty, and if APIKey is not specified, then all keys are allowed.
 *
 * @schema CiliumNetworkPolicySpecIngressToPortsRulesKafkaRole
 */
export enum CiliumNetworkPolicySpecIngressToPortsRulesKafkaRole {
  /** produce */
  PRODUCE = "produce",
  /** consume */
  CONSUME = "consume",
}

/**
 * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
 *
 * @default CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
 * @schema CiliumNetworkPolicySpecsEgressToPortsListenerEnvoyConfigKind
 */
export enum CiliumNetworkPolicySpecsEgressToPortsListenerEnvoyConfigKind {
  /** CiliumEnvoyConfig */
  CILIUM_ENVOY_CONFIG = "CiliumEnvoyConfig",
  /** CiliumClusterwideEnvoyConfig */
  CILIUM_CLUSTERWIDE_ENVOY_CONFIG = "CiliumClusterwideEnvoyConfig",
}

/**
 * HeaderMatch extends the HeaderValue for matching requirement of a named header field against an immediate string, a secret value, or a regex.  If none of the optional fields is present, then the header value is not matched, only presence of the header is enough.
 *
 * @schema CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches
 */
export interface CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches {
  /**
   * Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches#mismatch
   */
  readonly mismatch?: CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesMismatch;

  /**
   * Name identifies the header.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches#name
   */
  readonly name: string;

  /**
   * Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no "Value" specified, the match will fail.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches#secret
   */
  readonly secret?: CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecret;

  /**
   * Value matches the exact value of the header. Can be specified either alone or together with "Secret"; will be used as the header value if the secret can not be found in the latter case.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches(obj: CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mismatch': obj.mismatch,
    'name': obj.name,
    'secret': toJson_CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecret(obj.secret),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as "produce" or "consume". A Role automatically expands into all APIKeys required to perform the specified higher-level operation.
 * The following values are supported: - "produce": Allow producing to the topics specified in the rule - "consume": Allow consuming from the topics specified in the rule
 * This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule.
 * If omitted or empty, and if APIKey is not specified, then all keys are allowed.
 *
 * @schema CiliumNetworkPolicySpecsEgressToPortsRulesKafkaRole
 */
export enum CiliumNetworkPolicySpecsEgressToPortsRulesKafkaRole {
  /** produce */
  PRODUCE = "produce",
  /** consume */
  CONSUME = "consume",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressions
 */
export interface CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressions#operator
   */
  readonly operator: CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressions(obj: CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions
 */
export interface CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions#operator
   */
  readonly operator: CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressionsOperator;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions(obj: CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
 *
 * @default CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.
 * @schema CiliumNetworkPolicySpecsIngressToPortsListenerEnvoyConfigKind
 */
export enum CiliumNetworkPolicySpecsIngressToPortsListenerEnvoyConfigKind {
  /** CiliumEnvoyConfig */
  CILIUM_ENVOY_CONFIG = "CiliumEnvoyConfig",
  /** CiliumClusterwideEnvoyConfig */
  CILIUM_CLUSTERWIDE_ENVOY_CONFIG = "CiliumClusterwideEnvoyConfig",
}

/**
 * HeaderMatch extends the HeaderValue for matching requirement of a named header field against an immediate string, a secret value, or a regex.  If none of the optional fields is present, then the header value is not matched, only presence of the header is enough.
 *
 * @schema CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches
 */
export interface CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches {
  /**
   * Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches#mismatch
   */
  readonly mismatch?: CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesMismatch;

  /**
   * Name identifies the header.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches#name
   */
  readonly name: string;

  /**
   * Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no "Value" specified, the match will fail.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches#secret
   */
  readonly secret?: CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecret;

  /**
   * Value matches the exact value of the header. Can be specified either alone or together with "Secret"; will be used as the header value if the secret can not be found in the latter case.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches(obj: CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mismatch': obj.mismatch,
    'name': obj.name,
    'secret': toJson_CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecret(obj.secret),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as "produce" or "consume". A Role automatically expands into all APIKeys required to perform the specified higher-level operation.
 * The following values are supported: - "produce": Allow producing to the topics specified in the rule - "consume": Allow consuming from the topics specified in the rule
 * This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule.
 * If omitted or empty, and if APIKey is not specified, then all keys are allowed.
 *
 * @schema CiliumNetworkPolicySpecsIngressToPortsRulesKafkaRole
 */
export enum CiliumNetworkPolicySpecsIngressToPortsRulesKafkaRole {
  /** produce */
  PRODUCE = "produce",
  /** consume */
  CONSUME = "consume",
}

/**
 * Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.
 *
 * @schema CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesMismatch
 */
export enum CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesMismatch {
  /** LOG */
  LOG = "LOG",
  /** ADD */
  ADD = "ADD",
  /** DELETE */
  DELETE = "DELETE",
  /** REPLACE */
  REPLACE = "REPLACE",
}

/**
 * Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no "Value" specified, the match will fail.
 *
 * @schema CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecret
 */
export interface CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecret {
  /**
   * Name is the name of the secret.
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., "default").
   *
   * @schema CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecret(obj: CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressionsOperator
 */
export enum CiliumNetworkPolicySpecEgressToServicesK8SServiceSelectorSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressionsOperator
 */
export enum CiliumNetworkPolicySpecEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.
 *
 * @schema CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesMismatch
 */
export enum CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesMismatch {
  /** LOG */
  LOG = "LOG",
  /** ADD */
  ADD = "ADD",
  /** DELETE */
  DELETE = "DELETE",
  /** REPLACE */
  REPLACE = "REPLACE",
}

/**
 * Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no "Value" specified, the match will fail.
 *
 * @schema CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecret
 */
export interface CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecret {
  /**
   * Name is the name of the secret.
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., "default").
   *
   * @schema CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecret(obj: CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.
 *
 * @schema CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesMismatch
 */
export enum CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesMismatch {
  /** LOG */
  LOG = "LOG",
  /** ADD */
  ADD = "ADD",
  /** DELETE */
  DELETE = "DELETE",
  /** REPLACE */
  REPLACE = "REPLACE",
}

/**
 * Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no "Value" specified, the match will fail.
 *
 * @schema CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecret
 */
export interface CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecret {
  /**
   * Name is the name of the secret.
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., "default").
   *
   * @schema CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecret(obj: CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressionsOperator
 */
export enum CiliumNetworkPolicySpecsEgressToServicesK8SServiceSelectorSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
 *
 * @schema CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressionsOperator
 */
export enum CiliumNetworkPolicySpecsEgressDenyToServicesK8SServiceSelectorSelectorMatchExpressionsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
}

/**
 * Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.
 *
 * @schema CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesMismatch
 */
export enum CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesMismatch {
  /** LOG */
  LOG = "LOG",
  /** ADD */
  ADD = "ADD",
  /** DELETE */
  DELETE = "DELETE",
  /** REPLACE */
  REPLACE = "REPLACE",
}

/**
 * Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no "Value" specified, the match will fail.
 *
 * @schema CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecret
 */
export interface CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecret {
  /**
   * Name is the name of the secret.
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecret#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., "default").
   *
   * @schema CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecret(obj: CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * CiliumNode represents a node managed by Cilium. It contains a specification to control various node specific configuration aspects and a status section to represent the status of the node.
 *
 * @schema CiliumNode
 */
export class CiliumNode extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CiliumNode"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cilium.io/v2',
    kind: 'CiliumNode',
  }

  /**
   * Renders a Kubernetes manifest for "CiliumNode".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CiliumNodeProps): any {
    return {
      ...CiliumNode.GVK,
      ...toJson_CiliumNodeProps(props),
    };
  }

  /**
   * Defines a "CiliumNode" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CiliumNodeProps) {
    super(scope, id, {
      ...CiliumNode.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CiliumNode.GVK,
      ...toJson_CiliumNodeProps(resolved),
    };
  }
}

/**
 * CiliumNode represents a node managed by Cilium. It contains a specification to control various node specific configuration aspects and a status section to represent the status of the node.
 *
 * @schema CiliumNode
 */
export interface CiliumNodeProps {
  /**
   * @schema CiliumNode#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * Spec defines the desired specification/configuration of the node.
   *
   * @schema CiliumNode#spec
   */
  readonly spec: CiliumNodeSpec;

}

/**
 * Converts an object of type 'CiliumNodeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNodeProps(obj: CiliumNodeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CiliumNodeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Spec defines the desired specification/configuration of the node.
 *
 * @schema CiliumNodeSpec
 */
export interface CiliumNodeSpec {
  /**
   * Addresses is the list of all node addresses.
   *
   * @schema CiliumNodeSpec#addresses
   */
  readonly addresses?: CiliumNodeSpecAddresses[];

  /**
   * AlibabaCloud is the AlibabaCloud IPAM specific configuration.
   *
   * @schema CiliumNodeSpec#alibaba-cloud
   */
  readonly alibabaCloud?: CiliumNodeSpecAlibabaCloud;

  /**
   * Azure is the Azure IPAM specific configuration.
   *
   * @schema CiliumNodeSpec#azure
   */
  readonly azure?: CiliumNodeSpecAzure;

  /**
   * BootID is a unique node identifier generated on boot
   *
   * @schema CiliumNodeSpec#bootid
   */
  readonly bootid?: string;

  /**
   * Encryption is the encryption configuration of the node.
   *
   * @schema CiliumNodeSpec#encryption
   */
  readonly encryption?: CiliumNodeSpecEncryption;

  /**
   * ENI is the AWS ENI specific configuration.
   *
   * @schema CiliumNodeSpec#eni
   */
  readonly eni?: CiliumNodeSpecEni;

  /**
   * HealthAddressing is the addressing information for health connectivity checking.
   *
   * @schema CiliumNodeSpec#health
   */
  readonly health?: CiliumNodeSpecHealth;

  /**
   * IngressAddressing is the addressing information for Ingress listener.
   *
   * @schema CiliumNodeSpec#ingress
   */
  readonly ingress?: CiliumNodeSpecIngress;

  /**
   * InstanceID is the identifier of the node. This is different from the node name which is typically the FQDN of the node. The InstanceID typically refers to the identifier used by the cloud provider or some other means of identification.
   *
   * @schema CiliumNodeSpec#instance-id
   */
  readonly instanceId?: string;

  /**
   * IPAM is the address management specification. This section can be populated by a user or it can be automatically populated by an IPAM operator.
   *
   * @schema CiliumNodeSpec#ipam
   */
  readonly ipam?: CiliumNodeSpecIpam;

  /**
   * NodeIdentity is the Cilium numeric identity allocated for the node, if any.
   *
   * @schema CiliumNodeSpec#nodeidentity
   */
  readonly nodeidentity?: number;

}

/**
 * Converts an object of type 'CiliumNodeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNodeSpec(obj: CiliumNodeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addresses': obj.addresses?.map(y => toJson_CiliumNodeSpecAddresses(y)),
    'alibaba-cloud': toJson_CiliumNodeSpecAlibabaCloud(obj.alibabaCloud),
    'azure': toJson_CiliumNodeSpecAzure(obj.azure),
    'bootid': obj.bootid,
    'encryption': toJson_CiliumNodeSpecEncryption(obj.encryption),
    'eni': toJson_CiliumNodeSpecEni(obj.eni),
    'health': toJson_CiliumNodeSpecHealth(obj.health),
    'ingress': toJson_CiliumNodeSpecIngress(obj.ingress),
    'instance-id': obj.instanceId,
    'ipam': toJson_CiliumNodeSpecIpam(obj.ipam),
    'nodeidentity': obj.nodeidentity,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodeAddress is a node address.
 *
 * @schema CiliumNodeSpecAddresses
 */
export interface CiliumNodeSpecAddresses {
  /**
   * IP is an IP of a node
   *
   * @schema CiliumNodeSpecAddresses#ip
   */
  readonly ip?: string;

  /**
   * Type is the type of the node address
   *
   * @schema CiliumNodeSpecAddresses#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CiliumNodeSpecAddresses' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNodeSpecAddresses(obj: CiliumNodeSpecAddresses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ip': obj.ip,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AlibabaCloud is the AlibabaCloud IPAM specific configuration.
 *
 * @schema CiliumNodeSpecAlibabaCloud
 */
export interface CiliumNodeSpecAlibabaCloud {
  /**
   * AvailabilityZone is the availability zone to use when allocating ENIs.
   *
   * @schema CiliumNodeSpecAlibabaCloud#availability-zone
   */
  readonly availabilityZone?: string;

  /**
   * CIDRBlock is vpc ipv4 CIDR
   *
   * @schema CiliumNodeSpecAlibabaCloud#cidr-block
   */
  readonly cidrBlock?: string;

  /**
   * InstanceType is the ECS instance type, e.g. "ecs.g6.2xlarge"
   *
   * @schema CiliumNodeSpecAlibabaCloud#instance-type
   */
  readonly instanceType?: string;

  /**
   * SecurityGroupTags is the list of tags to use when evaluating which security groups to use for the ENI.
   *
   * @schema CiliumNodeSpecAlibabaCloud#security-group-tags
   */
  readonly securityGroupTags?: { [key: string]: string };

  /**
   * SecurityGroups is the list of security groups to attach to any ENI that is created and attached to the instance.
   *
   * @schema CiliumNodeSpecAlibabaCloud#security-groups
   */
  readonly securityGroups?: string[];

  /**
   * VPCID is the VPC ID to use when allocating ENIs.
   *
   * @schema CiliumNodeSpecAlibabaCloud#vpc-id
   */
  readonly vpcId?: string;

  /**
   * VSwitchTags is the list of tags to use when evaluating which vSwitch to use for the ENI.
   *
   * @schema CiliumNodeSpecAlibabaCloud#vswitch-tags
   */
  readonly vswitchTags?: { [key: string]: string };

  /**
   * VSwitches is the ID of vSwitch available for ENI
   *
   * @schema CiliumNodeSpecAlibabaCloud#vswitches
   */
  readonly vswitches?: string[];

}

/**
 * Converts an object of type 'CiliumNodeSpecAlibabaCloud' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNodeSpecAlibabaCloud(obj: CiliumNodeSpecAlibabaCloud | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availability-zone': obj.availabilityZone,
    'cidr-block': obj.cidrBlock,
    'instance-type': obj.instanceType,
    'security-group-tags': ((obj.securityGroupTags) === undefined) ? undefined : (Object.entries(obj.securityGroupTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'security-groups': obj.securityGroups?.map(y => y),
    'vpc-id': obj.vpcId,
    'vswitch-tags': ((obj.vswitchTags) === undefined) ? undefined : (Object.entries(obj.vswitchTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vswitches': obj.vswitches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Azure is the Azure IPAM specific configuration.
 *
 * @schema CiliumNodeSpecAzure
 */
export interface CiliumNodeSpecAzure {
  /**
   * InterfaceName is the name of the interface the cilium-operator will use to allocate all the IPs on
   *
   * @schema CiliumNodeSpecAzure#interface-name
   */
  readonly interfaceName?: string;

}

/**
 * Converts an object of type 'CiliumNodeSpecAzure' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNodeSpecAzure(obj: CiliumNodeSpecAzure | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interface-name': obj.interfaceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Encryption is the encryption configuration of the node.
 *
 * @schema CiliumNodeSpecEncryption
 */
export interface CiliumNodeSpecEncryption {
  /**
   * Key is the index to the key to use for encryption or 0 if encryption is disabled.
   *
   * @schema CiliumNodeSpecEncryption#key
   */
  readonly key?: number;

}

/**
 * Converts an object of type 'CiliumNodeSpecEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNodeSpecEncryption(obj: CiliumNodeSpecEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ENI is the AWS ENI specific configuration.
 *
 * @schema CiliumNodeSpecEni
 */
export interface CiliumNodeSpecEni {
  /**
   * AvailabilityZone is the availability zone to use when allocating ENIs.
   *
   * @schema CiliumNodeSpecEni#availability-zone
   */
  readonly availabilityZone?: string;

  /**
   * DeleteOnTermination defines that the ENI should be deleted when the associated instance is terminated. If the parameter is not set the default behavior is to delete the ENI on instance termination.
   *
   * @schema CiliumNodeSpecEni#delete-on-termination
   */
  readonly deleteOnTermination?: boolean;

  /**
   * DisablePrefixDelegation determines whether ENI prefix delegation should be disabled on this node.
   *
   * @schema CiliumNodeSpecEni#disable-prefix-delegation
   */
  readonly disablePrefixDelegation?: boolean;

  /**
   * ExcludeInterfaceTags is the list of tags to use when excluding ENIs for Cilium IP allocation. Any interface matching this set of tags will not be managed by Cilium.
   *
   * @schema CiliumNodeSpecEni#exclude-interface-tags
   */
  readonly excludeInterfaceTags?: { [key: string]: string };

  /**
   * FirstInterfaceIndex is the index of the first ENI to use for IP allocation, e.g. if the node has eth0, eth1, eth2 and FirstInterfaceIndex is set to 1, then only eth1 and eth2 will be used for IP allocation, eth0 will be ignored for PodIP allocation.
   *
   * @schema CiliumNodeSpecEni#first-interface-index
   */
  readonly firstInterfaceIndex?: number;

  /**
   * InstanceID is the AWS InstanceId of the node. The InstanceID is used to retrieve AWS metadata for the node.
   * OBSOLETE: This field is obsolete, please use Spec.InstanceID
   *
   * @schema CiliumNodeSpecEni#instance-id
   */
  readonly instanceId?: string;

  /**
   * InstanceType is the AWS EC2 instance type, e.g. "m5.large"
   *
   * @schema CiliumNodeSpecEni#instance-type
   */
  readonly instanceType?: string;

  /**
   * MaxAboveWatermark is the maximum number of addresses to allocate beyond the addresses needed to reach the PreAllocate watermark. Going above the watermark can help reduce the number of API calls to allocate IPs, e.g. when a new ENI is allocated, as many secondary IPs as possible are allocated. Limiting the amount can help reduce waste of IPs.
   * OBSOLETE: This field is obsolete, please use Spec.IPAM.MaxAboveWatermark
   *
   * @schema CiliumNodeSpecEni#max-above-watermark
   */
  readonly maxAboveWatermark?: number;

  /**
   * MinAllocate is the minimum number of IPs that must be allocated when the node is first bootstrapped. It defines the minimum base socket of addresses that must be available. After reaching this watermark, the PreAllocate and MaxAboveWatermark logic takes over to continue allocating IPs.
   * OBSOLETE: This field is obsolete, please use Spec.IPAM.MinAllocate
   *
   * @schema CiliumNodeSpecEni#min-allocate
   */
  readonly minAllocate?: number;

  /**
   * NodeSubnetID is the subnet of the primary ENI the instance was brought up with. It is used as a sensible default subnet to create ENIs in.
   *
   * @schema CiliumNodeSpecEni#node-subnet-id
   */
  readonly nodeSubnetId?: string;

  /**
   * PreAllocate defines the number of IP addresses that must be available for allocation in the IPAMspec. It defines the buffer of addresses available immediately without requiring cilium-operator to get involved.
   * OBSOLETE: This field is obsolete, please use Spec.IPAM.PreAllocate
   *
   * @schema CiliumNodeSpecEni#pre-allocate
   */
  readonly preAllocate?: number;

  /**
   * SecurityGroupTags is the list of tags to use when evaliating what AWS security groups to use for the ENI.
   *
   * @schema CiliumNodeSpecEni#security-group-tags
   */
  readonly securityGroupTags?: { [key: string]: string };

  /**
   * SecurityGroups is the list of security groups to attach to any ENI that is created and attached to the instance.
   *
   * @schema CiliumNodeSpecEni#security-groups
   */
  readonly securityGroups?: string[];

  /**
   * SubnetIDs is the list of subnet ids to use when evaluating what AWS subnets to use for ENI and IP allocation.
   *
   * @schema CiliumNodeSpecEni#subnet-ids
   */
  readonly subnetIds?: string[];

  /**
   * SubnetTags is the list of tags to use when evaluating what AWS subnets to use for ENI and IP allocation.
   *
   * @schema CiliumNodeSpecEni#subnet-tags
   */
  readonly subnetTags?: { [key: string]: string };

  /**
   * UsePrimaryAddress determines whether an ENI's primary address should be available for allocations on the node
   *
   * @schema CiliumNodeSpecEni#use-primary-address
   */
  readonly usePrimaryAddress?: boolean;

  /**
   * VpcID is the VPC ID to use when allocating ENIs.
   *
   * @schema CiliumNodeSpecEni#vpc-id
   */
  readonly vpcId?: string;

}

/**
 * Converts an object of type 'CiliumNodeSpecEni' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNodeSpecEni(obj: CiliumNodeSpecEni | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availability-zone': obj.availabilityZone,
    'delete-on-termination': obj.deleteOnTermination,
    'disable-prefix-delegation': obj.disablePrefixDelegation,
    'exclude-interface-tags': ((obj.excludeInterfaceTags) === undefined) ? undefined : (Object.entries(obj.excludeInterfaceTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'first-interface-index': obj.firstInterfaceIndex,
    'instance-id': obj.instanceId,
    'instance-type': obj.instanceType,
    'max-above-watermark': obj.maxAboveWatermark,
    'min-allocate': obj.minAllocate,
    'node-subnet-id': obj.nodeSubnetId,
    'pre-allocate': obj.preAllocate,
    'security-group-tags': ((obj.securityGroupTags) === undefined) ? undefined : (Object.entries(obj.securityGroupTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'security-groups': obj.securityGroups?.map(y => y),
    'subnet-ids': obj.subnetIds?.map(y => y),
    'subnet-tags': ((obj.subnetTags) === undefined) ? undefined : (Object.entries(obj.subnetTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'use-primary-address': obj.usePrimaryAddress,
    'vpc-id': obj.vpcId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HealthAddressing is the addressing information for health connectivity checking.
 *
 * @schema CiliumNodeSpecHealth
 */
export interface CiliumNodeSpecHealth {
  /**
   * IPv4 is the IPv4 address of the IPv4 health endpoint.
   *
   * @schema CiliumNodeSpecHealth#ipv4
   */
  readonly ipv4?: string;

  /**
   * IPv6 is the IPv6 address of the IPv4 health endpoint.
   *
   * @schema CiliumNodeSpecHealth#ipv6
   */
  readonly ipv6?: string;

}

/**
 * Converts an object of type 'CiliumNodeSpecHealth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNodeSpecHealth(obj: CiliumNodeSpecHealth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipv4': obj.ipv4,
    'ipv6': obj.ipv6,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IngressAddressing is the addressing information for Ingress listener.
 *
 * @schema CiliumNodeSpecIngress
 */
export interface CiliumNodeSpecIngress {
  /**
   * @schema CiliumNodeSpecIngress#ipv4
   */
  readonly ipv4?: string;

  /**
   * @schema CiliumNodeSpecIngress#ipv6
   */
  readonly ipv6?: string;

}

/**
 * Converts an object of type 'CiliumNodeSpecIngress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNodeSpecIngress(obj: CiliumNodeSpecIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipv4': obj.ipv4,
    'ipv6': obj.ipv6,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPAM is the address management specification. This section can be populated by a user or it can be automatically populated by an IPAM operator.
 *
 * @schema CiliumNodeSpecIpam
 */
export interface CiliumNodeSpecIpam {
  /**
   * MaxAboveWatermark is the maximum number of addresses to allocate beyond the addresses needed to reach the PreAllocate watermark. Going above the watermark can help reduce the number of API calls to allocate IPs, e.g. when a new ENI is allocated, as many secondary IPs as possible are allocated. Limiting the amount can help reduce waste of IPs.
   *
   * @schema CiliumNodeSpecIpam#max-above-watermark
   */
  readonly maxAboveWatermark?: number;

  /**
   * MaxAllocate is the maximum number of IPs that can be allocated to the node. When the current amount of allocated IPs will approach this value, the considered value for PreAllocate will decrease down to 0 in order to not attempt to allocate more addresses than defined.
   *
   * @schema CiliumNodeSpecIpam#max-allocate
   */
  readonly maxAllocate?: number;

  /**
   * MinAllocate is the minimum number of IPs that must be allocated when the node is first bootstrapped. It defines the minimum base socket of addresses that must be available. After reaching this watermark, the PreAllocate and MaxAboveWatermark logic takes over to continue allocating IPs.
   *
   * @schema CiliumNodeSpecIpam#min-allocate
   */
  readonly minAllocate?: number;

  /**
   * PodCIDRs is the list of CIDRs available to the node for allocation. When an IP is used, the IP will be added to Status.IPAM.Used
   *
   * @schema CiliumNodeSpecIpam#podCIDRs
   */
  readonly podCidRs?: string[];

  /**
   * Pool is the list of IPs available to the node for allocation. When an IP is used, the IP will remain on this list but will be added to Status.IPAM.Used
   *
   * @schema CiliumNodeSpecIpam#pool
   */
  readonly pool?: { [key: string]: CiliumNodeSpecIpamPool };

  /**
   * Pools contains the list of assigned IPAM pools for this node.
   *
   * @schema CiliumNodeSpecIpam#pools
   */
  readonly pools?: CiliumNodeSpecIpamPools;

  /**
   * PreAllocate defines the number of IP addresses that must be available for allocation in the IPAMspec. It defines the buffer of addresses available immediately without requiring cilium-operator to get involved.
   *
   * @schema CiliumNodeSpecIpam#pre-allocate
   */
  readonly preAllocate?: number;

}

/**
 * Converts an object of type 'CiliumNodeSpecIpam' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNodeSpecIpam(obj: CiliumNodeSpecIpam | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max-above-watermark': obj.maxAboveWatermark,
    'max-allocate': obj.maxAllocate,
    'min-allocate': obj.minAllocate,
    'podCIDRs': obj.podCidRs?.map(y => y),
    'pool': ((obj.pool) === undefined) ? undefined : (Object.entries(obj.pool).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_CiliumNodeSpecIpamPool(i[1]) }), {})),
    'pools': toJson_CiliumNodeSpecIpamPools(obj.pools),
    'pre-allocate': obj.preAllocate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AllocationIP is an IP which is available for allocation, or already has been allocated
 *
 * @schema CiliumNodeSpecIpamPool
 */
export interface CiliumNodeSpecIpamPool {
  /**
   * Owner is the owner of the IP. This field is set if the IP has been allocated. It will be set to the pod name or another identifier representing the usage of the IP
   * The owner field is left blank for an entry in Spec.IPAM.Pool and filled out as the IP is used and also added to Status.IPAM.Used.
   *
   * @schema CiliumNodeSpecIpamPool#owner
   */
  readonly owner?: string;

  /**
   * Resource is set for both available and allocated IPs, it represents what resource the IP is associated with, e.g. in combination with AWS ENI, this will refer to the ID of the ENI
   *
   * @schema CiliumNodeSpecIpamPool#resource
   */
  readonly resource?: string;

}

/**
 * Converts an object of type 'CiliumNodeSpecIpamPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNodeSpecIpamPool(obj: CiliumNodeSpecIpamPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'owner': obj.owner,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pools contains the list of assigned IPAM pools for this node.
 *
 * @schema CiliumNodeSpecIpamPools
 */
export interface CiliumNodeSpecIpamPools {
  /**
   * Allocated contains the list of pooled CIDR assigned to this node. The operator will add new pod CIDRs to this field, whereas the agent will remove CIDRs it has released.
   *
   * @schema CiliumNodeSpecIpamPools#allocated
   */
  readonly allocated?: CiliumNodeSpecIpamPoolsAllocated[];

  /**
   * Requested contains a list of IPAM pool requests, i.e. indicates how many addresses this node requests out of each pool listed here. This field is owned and written to by cilium-agent and read by the operator.
   *
   * @schema CiliumNodeSpecIpamPools#requested
   */
  readonly requested?: CiliumNodeSpecIpamPoolsRequested[];

}

/**
 * Converts an object of type 'CiliumNodeSpecIpamPools' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNodeSpecIpamPools(obj: CiliumNodeSpecIpamPools | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allocated': obj.allocated?.map(y => toJson_CiliumNodeSpecIpamPoolsAllocated(y)),
    'requested': obj.requested?.map(y => toJson_CiliumNodeSpecIpamPoolsRequested(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPAMPoolAllocation describes an allocation of an IPAM pool from the operator to the node. It contains the assigned PodCIDRs allocated from this pool
 *
 * @schema CiliumNodeSpecIpamPoolsAllocated
 */
export interface CiliumNodeSpecIpamPoolsAllocated {
  /**
   * CIDRs contains a list of pod CIDRs currently allocated from this pool
   *
   * @schema CiliumNodeSpecIpamPoolsAllocated#cidrs
   */
  readonly cidrs?: string[];

  /**
   * Pool is the name of the IPAM pool backing this allocation
   *
   * @schema CiliumNodeSpecIpamPoolsAllocated#pool
   */
  readonly pool: string;

}

/**
 * Converts an object of type 'CiliumNodeSpecIpamPoolsAllocated' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNodeSpecIpamPoolsAllocated(obj: CiliumNodeSpecIpamPoolsAllocated | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrs': obj.cidrs?.map(y => y),
    'pool': obj.pool,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CiliumNodeSpecIpamPoolsRequested
 */
export interface CiliumNodeSpecIpamPoolsRequested {
  /**
   * Needed indicates how many IPs out of the above Pool this node requests from the operator. The operator runs a reconciliation loop to ensure each node always has enough PodCIDRs allocated in each pool to fulfill the requested number of IPs here.
   *
   * @schema CiliumNodeSpecIpamPoolsRequested#needed
   */
  readonly needed?: CiliumNodeSpecIpamPoolsRequestedNeeded;

  /**
   * Pool is the name of the IPAM pool backing this request
   *
   * @schema CiliumNodeSpecIpamPoolsRequested#pool
   */
  readonly pool: string;

}

/**
 * Converts an object of type 'CiliumNodeSpecIpamPoolsRequested' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNodeSpecIpamPoolsRequested(obj: CiliumNodeSpecIpamPoolsRequested | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'needed': toJson_CiliumNodeSpecIpamPoolsRequestedNeeded(obj.needed),
    'pool': obj.pool,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Needed indicates how many IPs out of the above Pool this node requests from the operator. The operator runs a reconciliation loop to ensure each node always has enough PodCIDRs allocated in each pool to fulfill the requested number of IPs here.
 *
 * @schema CiliumNodeSpecIpamPoolsRequestedNeeded
 */
export interface CiliumNodeSpecIpamPoolsRequestedNeeded {
  /**
   * IPv4Addrs contains the number of requested IPv4 addresses out of a given pool
   *
   * @schema CiliumNodeSpecIpamPoolsRequestedNeeded#ipv4-addrs
   */
  readonly ipv4Addrs?: number;

  /**
   * IPv6Addrs contains the number of requested IPv6 addresses out of a given pool
   *
   * @schema CiliumNodeSpecIpamPoolsRequestedNeeded#ipv6-addrs
   */
  readonly ipv6Addrs?: number;

}

/**
 * Converts an object of type 'CiliumNodeSpecIpamPoolsRequestedNeeded' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNodeSpecIpamPoolsRequestedNeeded(obj: CiliumNodeSpecIpamPoolsRequestedNeeded | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipv4-addrs': obj.ipv4Addrs,
    'ipv6-addrs': obj.ipv6Addrs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * CiliumNodeConfig is a list of configuration key-value pairs. It is applied to nodes indicated by a label selector. 
 If multiple overrides apply to the same node, they will be ordered by name with later Overrides overwriting any conflicting keys.
 *
 * @schema CiliumNodeConfig
 */
export class CiliumNodeConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CiliumNodeConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cilium.io/v2alpha1',
    kind: 'CiliumNodeConfig',
  }

  /**
   * Renders a Kubernetes manifest for "CiliumNodeConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CiliumNodeConfigProps): any {
    return {
      ...CiliumNodeConfig.GVK,
      ...toJson_CiliumNodeConfigProps(props),
    };
  }

  /**
   * Defines a "CiliumNodeConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CiliumNodeConfigProps) {
    super(scope, id, {
      ...CiliumNodeConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CiliumNodeConfig.GVK,
      ...toJson_CiliumNodeConfigProps(resolved),
    };
  }
}

/**
 * CiliumNodeConfig is a list of configuration key-value pairs. It is applied to nodes indicated by a label selector.
 * If multiple overrides apply to the same node, they will be ordered by name with later Overrides overwriting any conflicting keys.
 *
 * @schema CiliumNodeConfig
 */
export interface CiliumNodeConfigProps {
  /**
   * @schema CiliumNodeConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec is the desired Cilium configuration overrides for a given node
   *
   * @schema CiliumNodeConfig#spec
   */
  readonly spec: CiliumNodeConfigSpec;

}

/**
 * Converts an object of type 'CiliumNodeConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNodeConfigProps(obj: CiliumNodeConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CiliumNodeConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Spec is the desired Cilium configuration overrides for a given node
 *
 * @schema CiliumNodeConfigSpec
 */
export interface CiliumNodeConfigSpec {
  /**
   * Defaults is treated the same as the cilium-config ConfigMap - a set of key-value pairs parsed by the agent and operator processes. Each key must be a valid config-map data field (i.e. a-z, A-Z, -, _, and .)
   *
   * @default treated the same as the cilium-config ConfigMap - a set of key-value pairs parsed by the agent and operator processes. Each key must be a valid config-map data field (i.e. a-z, A-Z, -, _, and .)
   * @schema CiliumNodeConfigSpec#defaults
   */
  readonly defaults: { [key: string]: string };

  /**
   * NodeSelector is a label selector that determines to which nodes this configuration applies. If not supplied, then this config applies to no nodes. If empty, then it applies to all nodes.
   *
   * @schema CiliumNodeConfigSpec#nodeSelector
   */
  readonly nodeSelector: CiliumNodeConfigSpecNodeSelector;

}

/**
 * Converts an object of type 'CiliumNodeConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNodeConfigSpec(obj: CiliumNodeConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaults': ((obj.defaults) === undefined) ? undefined : (Object.entries(obj.defaults).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'nodeSelector': toJson_CiliumNodeConfigSpecNodeSelector(obj.nodeSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodeSelector is a label selector that determines to which nodes this configuration applies. If not supplied, then this config applies to no nodes. If empty, then it applies to all nodes.
 *
 * @schema CiliumNodeConfigSpecNodeSelector
 */
export interface CiliumNodeConfigSpecNodeSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema CiliumNodeConfigSpecNodeSelector#matchExpressions
   */
  readonly matchExpressions?: CiliumNodeConfigSpecNodeSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema CiliumNodeConfigSpecNodeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CiliumNodeConfigSpecNodeSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNodeConfigSpecNodeSelector(obj: CiliumNodeConfigSpecNodeSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_CiliumNodeConfigSpecNodeSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema CiliumNodeConfigSpecNodeSelectorMatchExpressions
 */
export interface CiliumNodeConfigSpecNodeSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema CiliumNodeConfigSpecNodeSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema CiliumNodeConfigSpecNodeSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema CiliumNodeConfigSpecNodeSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'CiliumNodeConfigSpecNodeSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumNodeConfigSpecNodeSelectorMatchExpressions(obj: CiliumNodeConfigSpecNodeSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * CiliumPodIPPool defines an IP pool that can be used for pooled IPAM (i.e. the multi-pool IPAM mode).
 *
 * @schema CiliumPodIPPool
 */
export class CiliumPodIpPool extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CiliumPodIPPool"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cilium.io/v2alpha1',
    kind: 'CiliumPodIPPool',
  }

  /**
   * Renders a Kubernetes manifest for "CiliumPodIPPool".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CiliumPodIpPoolProps): any {
    return {
      ...CiliumPodIpPool.GVK,
      ...toJson_CiliumPodIpPoolProps(props),
    };
  }

  /**
   * Defines a "CiliumPodIPPool" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CiliumPodIpPoolProps) {
    super(scope, id, {
      ...CiliumPodIpPool.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CiliumPodIpPool.GVK,
      ...toJson_CiliumPodIpPoolProps(resolved),
    };
  }
}

/**
 * CiliumPodIPPool defines an IP pool that can be used for pooled IPAM (i.e. the multi-pool IPAM mode).
 *
 * @schema CiliumPodIPPool
 */
export interface CiliumPodIpPoolProps {
  /**
   * @schema CiliumPodIPPool#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema CiliumPodIPPool#spec
   */
  readonly spec: CiliumPodIpPoolSpec;

}

/**
 * Converts an object of type 'CiliumPodIpPoolProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumPodIpPoolProps(obj: CiliumPodIpPoolProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CiliumPodIpPoolSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CiliumPodIpPoolSpec
 */
export interface CiliumPodIpPoolSpec {
  /**
   * IPv4 specifies the IPv4 CIDRs and mask sizes of the pool
   *
   * @schema CiliumPodIpPoolSpec#ipv4
   */
  readonly ipv4?: CiliumPodIpPoolSpecIpv4;

  /**
   * IPv6 specifies the IPv6 CIDRs and mask sizes of the pool
   *
   * @schema CiliumPodIpPoolSpec#ipv6
   */
  readonly ipv6?: CiliumPodIpPoolSpecIpv6;

}

/**
 * Converts an object of type 'CiliumPodIpPoolSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumPodIpPoolSpec(obj: CiliumPodIpPoolSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipv4': toJson_CiliumPodIpPoolSpecIpv4(obj.ipv4),
    'ipv6': toJson_CiliumPodIpPoolSpecIpv6(obj.ipv6),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPv4 specifies the IPv4 CIDRs and mask sizes of the pool
 *
 * @schema CiliumPodIpPoolSpecIpv4
 */
export interface CiliumPodIpPoolSpecIpv4 {
  /**
   * CIDRs is a list of IPv4 CIDRs that are part of the pool.
   *
   * @schema CiliumPodIpPoolSpecIpv4#cidrs
   */
  readonly cidrs: string[];

  /**
   * MaskSize is the mask size of the pool.
   *
   * @schema CiliumPodIpPoolSpecIpv4#maskSize
   */
  readonly maskSize: number;

}

/**
 * Converts an object of type 'CiliumPodIpPoolSpecIpv4' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumPodIpPoolSpecIpv4(obj: CiliumPodIpPoolSpecIpv4 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrs': obj.cidrs?.map(y => y),
    'maskSize': obj.maskSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPv6 specifies the IPv6 CIDRs and mask sizes of the pool
 *
 * @schema CiliumPodIpPoolSpecIpv6
 */
export interface CiliumPodIpPoolSpecIpv6 {
  /**
   * CIDRs is a list of IPv6 CIDRs that are part of the pool.
   *
   * @schema CiliumPodIpPoolSpecIpv6#cidrs
   */
  readonly cidrs: string[];

  /**
   * MaskSize is the mask size of the pool.
   *
   * @schema CiliumPodIpPoolSpecIpv6#maskSize
   */
  readonly maskSize: number;

}

/**
 * Converts an object of type 'CiliumPodIpPoolSpecIpv6' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CiliumPodIpPoolSpecIpv6(obj: CiliumPodIpPoolSpecIpv6 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrs': obj.cidrs?.map(y => y),
    'maskSize': obj.maskSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

