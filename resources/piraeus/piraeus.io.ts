// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * LinstorCluster is the Schema for the linstorclusters API
 *
 * @schema LinstorCluster
 */
export class LinstorCluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LinstorCluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'piraeus.io/v1',
    kind: 'LinstorCluster',
  }

  /**
   * Renders a Kubernetes manifest for "LinstorCluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LinstorClusterProps = {}): any {
    return {
      ...LinstorCluster.GVK,
      ...toJson_LinstorClusterProps(props),
    };
  }

  /**
   * Defines a "LinstorCluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LinstorClusterProps = {}) {
    super(scope, id, {
      ...LinstorCluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LinstorCluster.GVK,
      ...toJson_LinstorClusterProps(resolved),
    };
  }
}

/**
 * LinstorCluster is the Schema for the linstorclusters API
 *
 * @schema LinstorCluster
 */
export interface LinstorClusterProps {
  /**
   * @schema LinstorCluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LinstorClusterSpec defines the desired state of LinstorCluster
   *
   * @schema LinstorCluster#spec
   */
  readonly spec?: LinstorClusterSpec;

}

/**
 * Converts an object of type 'LinstorClusterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorClusterProps(obj: LinstorClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LinstorClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LinstorClusterSpec defines the desired state of LinstorCluster
 *
 * @schema LinstorClusterSpec
 */
export interface LinstorClusterSpec {
  /**
   * ApiTLS secures the LINSTOR API.
   *
   * This configures the TLS key and certificate used to secure the LINSTOR API.
   *
   * @schema LinstorClusterSpec#apiTLS
   */
  readonly apiTls?: LinstorClusterSpecApiTls;

  /**
   * Controller controls the deployment of the LINSTOR Controller Deployment.
   *
   * @schema LinstorClusterSpec#controller
   */
  readonly controller?: LinstorClusterSpecController;

  /**
   * CSIController controls the deployment of the CSI Controller Deployment.
   *
   * @schema LinstorClusterSpec#csiController
   */
  readonly csiController?: LinstorClusterSpecCsiController;

  /**
   * CSINode controls the deployment of the CSI Node DaemonSet.
   *
   * @schema LinstorClusterSpec#csiNode
   */
  readonly csiNode?: LinstorClusterSpecCsiNode;

  /**
   * ExternalController references an external controller.
   * When set, the Operator will skip deploying a LINSTOR Controller and instead use the external cluster
   * to register satellites.
   *
   * @schema LinstorClusterSpec#externalController
   */
  readonly externalController?: LinstorClusterSpecExternalController;

  /**
   * HighAvailabilityController controls the deployment of the High Availability Controller DaemonSet.
   *
   * @schema LinstorClusterSpec#highAvailabilityController
   */
  readonly highAvailabilityController?: LinstorClusterSpecHighAvailabilityController;

  /**
   * InternalTLS secures the connection between LINSTOR Controller and Satellite.
   *
   * This configures the client certificate used when the Controller connects to a Satellite. This only has an effect
   * when the Satellite is configured to for secure connections using `LinstorSatellite.spec.internalTLS`.
   *
   * @schema LinstorClusterSpec#internalTLS
   */
  readonly internalTls?: LinstorClusterSpecInternalTls;

  /**
   * LinstorPassphraseSecret used to configure the LINSTOR master passphrase.
   *
   * The referenced secret must contain a single key "MASTER_PASSPHRASE". The master passphrase is used to
   * * Derive encryption keys for volumes using the LUKS layer.
   * * Store credentials for accessing remotes for backups.
   * See https://linbit.com/drbd-user-guide/linstor-guide-1_0-en/#s-encrypt_commands for more information.
   *
   * @schema LinstorClusterSpec#linstorPassphraseSecret
   */
  readonly linstorPassphraseSecret?: string;

  /**
   * NodeAffinity selects the nodes on which LINSTOR Satellite will be deployed.
   * See https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema LinstorClusterSpec#nodeAffinity
   */
  readonly nodeAffinity?: LinstorClusterSpecNodeAffinity;

  /**
   * NodeSelector selects the nodes on which LINSTOR Satellites will be deployed.
   * See https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema LinstorClusterSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Patches is a list of kustomize patches to apply.
   *
   * See https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/patches/ for how to create patches.
   *
   * @schema LinstorClusterSpec#patches
   */
  readonly patches?: LinstorClusterSpecPatches[];

  /**
   * Properties to apply on the cluster level.
   *
   * Use to create default settings for DRBD that should apply to all resources or to configure some other cluster
   * wide default.
   *
   * @schema LinstorClusterSpec#properties
   */
  readonly properties?: LinstorClusterSpecProperties[];

  /**
   * Repository used to pull workload images.
   *
   * @schema LinstorClusterSpec#repository
   */
  readonly repository?: string;

}

/**
 * Converts an object of type 'LinstorClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorClusterSpec(obj: LinstorClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiTLS': toJson_LinstorClusterSpecApiTls(obj.apiTls),
    'controller': toJson_LinstorClusterSpecController(obj.controller),
    'csiController': toJson_LinstorClusterSpecCsiController(obj.csiController),
    'csiNode': toJson_LinstorClusterSpecCsiNode(obj.csiNode),
    'externalController': toJson_LinstorClusterSpecExternalController(obj.externalController),
    'highAvailabilityController': toJson_LinstorClusterSpecHighAvailabilityController(obj.highAvailabilityController),
    'internalTLS': toJson_LinstorClusterSpecInternalTls(obj.internalTls),
    'linstorPassphraseSecret': obj.linstorPassphraseSecret,
    'nodeAffinity': toJson_LinstorClusterSpecNodeAffinity(obj.nodeAffinity),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'patches': obj.patches?.map(y => toJson_LinstorClusterSpecPatches(y)),
    'properties': obj.properties?.map(y => toJson_LinstorClusterSpecProperties(y)),
    'repository': obj.repository,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ApiTLS secures the LINSTOR API.
 *
 * This configures the TLS key and certificate used to secure the LINSTOR API.
 *
 * @schema LinstorClusterSpecApiTls
 */
export interface LinstorClusterSpecApiTls {
  /**
   * ApiSecretName references a secret holding the TLS key and certificate used to protect the API.
   * Defaults to "linstor-api-tls".
   *
   * @default linstor-api-tls".
   * @schema LinstorClusterSpecApiTls#apiSecretName
   */
  readonly apiSecretName?: string;

  /**
   * CAReference configures the CA certificate to use when validating TLS certificates.
   * If not set, the TLS secret is expected to contain a "ca.crt" containing the CA certificate.
   *
   * @schema LinstorClusterSpecApiTls#caReference
   */
  readonly caReference?: LinstorClusterSpecApiTlsCaReference;

  /**
   * CertManager references a cert-manager Issuer or ClusterIssuer.
   * If set, cert-manager.io/Certificate resources will be created, provisioning the secrets referenced in
   * *SecretName using the issuer configured here.
   *
   * @schema LinstorClusterSpecApiTls#certManager
   */
  readonly certManager?: LinstorClusterSpecApiTlsCertManager;

  /**
   * ClientSecretName references a secret holding the TLS key and certificate used by the operator to configure
   * the cluster. Defaults to "linstor-client-tls".
   *
   * @default linstor-client-tls".
   * @schema LinstorClusterSpecApiTls#clientSecretName
   */
  readonly clientSecretName?: string;

  /**
   * CsiControllerSecretName references a secret holding the TLS key and certificate used by the CSI Controller
   * to provision volumes. Defaults to "linstor-csi-controller-tls".
   *
   * @default linstor-csi-controller-tls".
   * @schema LinstorClusterSpecApiTls#csiControllerSecretName
   */
  readonly csiControllerSecretName?: string;

  /**
   * CsiNodeSecretName references a secret holding the TLS key and certificate used by the CSI Nodes to query
   * the volume state. Defaults to "linstor-csi-node-tls".
   *
   * @default linstor-csi-node-tls".
   * @schema LinstorClusterSpecApiTls#csiNodeSecretName
   */
  readonly csiNodeSecretName?: string;

}

/**
 * Converts an object of type 'LinstorClusterSpecApiTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorClusterSpecApiTls(obj: LinstorClusterSpecApiTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiSecretName': obj.apiSecretName,
    'caReference': toJson_LinstorClusterSpecApiTlsCaReference(obj.caReference),
    'certManager': toJson_LinstorClusterSpecApiTlsCertManager(obj.certManager),
    'clientSecretName': obj.clientSecretName,
    'csiControllerSecretName': obj.csiControllerSecretName,
    'csiNodeSecretName': obj.csiNodeSecretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Controller controls the deployment of the LINSTOR Controller Deployment.
 *
 * @schema LinstorClusterSpecController
 */
export interface LinstorClusterSpecController {
  /**
   * Enable the component.
   *
   * @schema LinstorClusterSpecController#enabled
   */
  readonly enabled?: boolean;

  /**
   * Template to apply to Pods of the component.
   *
   * The template is applied as a patch to the default deployment, so it can be "sparse", not listing any
   * containers or volumes that should remain unchanged.
   * See https://kubernetes.io/docs/concepts/workloads/pods/#pod-templates
   *
   * @schema LinstorClusterSpecController#podTemplate
   */
  readonly podTemplate?: any;

}

/**
 * Converts an object of type 'LinstorClusterSpecController' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorClusterSpecController(obj: LinstorClusterSpecController | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'podTemplate': obj.podTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CSIController controls the deployment of the CSI Controller Deployment.
 *
 * @schema LinstorClusterSpecCsiController
 */
export interface LinstorClusterSpecCsiController {
  /**
   * Enable the component.
   *
   * @schema LinstorClusterSpecCsiController#enabled
   */
  readonly enabled?: boolean;

  /**
   * Template to apply to Pods of the component.
   *
   * The template is applied as a patch to the default deployment, so it can be "sparse", not listing any
   * containers or volumes that should remain unchanged.
   * See https://kubernetes.io/docs/concepts/workloads/pods/#pod-templates
   *
   * @schema LinstorClusterSpecCsiController#podTemplate
   */
  readonly podTemplate?: any;

}

/**
 * Converts an object of type 'LinstorClusterSpecCsiController' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorClusterSpecCsiController(obj: LinstorClusterSpecCsiController | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'podTemplate': obj.podTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CSINode controls the deployment of the CSI Node DaemonSet.
 *
 * @schema LinstorClusterSpecCsiNode
 */
export interface LinstorClusterSpecCsiNode {
  /**
   * Enable the component.
   *
   * @schema LinstorClusterSpecCsiNode#enabled
   */
  readonly enabled?: boolean;

  /**
   * Template to apply to Pods of the component.
   *
   * The template is applied as a patch to the default deployment, so it can be "sparse", not listing any
   * containers or volumes that should remain unchanged.
   * See https://kubernetes.io/docs/concepts/workloads/pods/#pod-templates
   *
   * @schema LinstorClusterSpecCsiNode#podTemplate
   */
  readonly podTemplate?: any;

}

/**
 * Converts an object of type 'LinstorClusterSpecCsiNode' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorClusterSpecCsiNode(obj: LinstorClusterSpecCsiNode | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'podTemplate': obj.podTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalController references an external controller.
 * When set, the Operator will skip deploying a LINSTOR Controller and instead use the external cluster
 * to register satellites.
 *
 * @schema LinstorClusterSpecExternalController
 */
export interface LinstorClusterSpecExternalController {
  /**
   * URL of the external controller.
   *
   * @schema LinstorClusterSpecExternalController#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'LinstorClusterSpecExternalController' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorClusterSpecExternalController(obj: LinstorClusterSpecExternalController | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HighAvailabilityController controls the deployment of the High Availability Controller DaemonSet.
 *
 * @schema LinstorClusterSpecHighAvailabilityController
 */
export interface LinstorClusterSpecHighAvailabilityController {
  /**
   * Enable the component.
   *
   * @schema LinstorClusterSpecHighAvailabilityController#enabled
   */
  readonly enabled?: boolean;

  /**
   * Template to apply to Pods of the component.
   *
   * The template is applied as a patch to the default deployment, so it can be "sparse", not listing any
   * containers or volumes that should remain unchanged.
   * See https://kubernetes.io/docs/concepts/workloads/pods/#pod-templates
   *
   * @schema LinstorClusterSpecHighAvailabilityController#podTemplate
   */
  readonly podTemplate?: any;

}

/**
 * Converts an object of type 'LinstorClusterSpecHighAvailabilityController' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorClusterSpecHighAvailabilityController(obj: LinstorClusterSpecHighAvailabilityController | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'podTemplate': obj.podTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InternalTLS secures the connection between LINSTOR Controller and Satellite.
 *
 * This configures the client certificate used when the Controller connects to a Satellite. This only has an effect
 * when the Satellite is configured to for secure connections using `LinstorSatellite.spec.internalTLS`.
 *
 * @schema LinstorClusterSpecInternalTls
 */
export interface LinstorClusterSpecInternalTls {
  /**
   * CAReference configures the CA certificate to use when validating TLS certificates.
   * If not set, the TLS secret is expected to contain a "ca.crt" containing the CA certificate.
   *
   * @schema LinstorClusterSpecInternalTls#caReference
   */
  readonly caReference?: LinstorClusterSpecInternalTlsCaReference;

  /**
   * CertManager references a cert-manager Issuer or ClusterIssuer.
   * If set, a Certificate resource will be created, provisioning the secret references in SecretName using the
   * issuer configured here.
   *
   * @schema LinstorClusterSpecInternalTls#certManager
   */
  readonly certManager?: LinstorClusterSpecInternalTlsCertManager;

  /**
   * SecretName references a secret holding the TLS key and certificates.
   *
   * @schema LinstorClusterSpecInternalTls#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'LinstorClusterSpecInternalTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorClusterSpecInternalTls(obj: LinstorClusterSpecInternalTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caReference': toJson_LinstorClusterSpecInternalTlsCaReference(obj.caReference),
    'certManager': toJson_LinstorClusterSpecInternalTlsCertManager(obj.certManager),
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodeAffinity selects the nodes on which LINSTOR Satellite will be deployed.
 * See https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
 *
 * @schema LinstorClusterSpecNodeAffinity
 */
export interface LinstorClusterSpecNodeAffinity {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema LinstorClusterSpecNodeAffinity#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: LinstorClusterSpecNodeAffinityNodeSelectorTerms[];

}

/**
 * Converts an object of type 'LinstorClusterSpecNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorClusterSpecNodeAffinity(obj: LinstorClusterSpecNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_LinstorClusterSpecNodeAffinityNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Patch represent either a Strategic Merge Patch or a JSON patch and its targets.
 *
 * @schema LinstorClusterSpecPatches
 */
export interface LinstorClusterSpecPatches {
  /**
   * Options is a list of options for the patch
   *
   * @schema LinstorClusterSpecPatches#options
   */
  readonly options?: { [key: string]: boolean };

  /**
   * Patch is the content of a patch.
   *
   * @schema LinstorClusterSpecPatches#patch
   */
  readonly patch: string;

  /**
   * Target points to the resources that the patch is applied to
   *
   * @schema LinstorClusterSpecPatches#target
   */
  readonly target?: LinstorClusterSpecPatchesTarget;

}

/**
 * Converts an object of type 'LinstorClusterSpecPatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorClusterSpecPatches(obj: LinstorClusterSpecPatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'patch': obj.patch,
    'target': toJson_LinstorClusterSpecPatchesTarget(obj.target),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LinstorClusterSpecProperties
 */
export interface LinstorClusterSpecProperties {
  /**
   * Name of the property to set.
   *
   * @schema LinstorClusterSpecProperties#name
   */
  readonly name: string;

  /**
   * Value to set the property to.
   *
   * @schema LinstorClusterSpecProperties#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'LinstorClusterSpecProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorClusterSpecProperties(obj: LinstorClusterSpecProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CAReference configures the CA certificate to use when validating TLS certificates.
 * If not set, the TLS secret is expected to contain a "ca.crt" containing the CA certificate.
 *
 * @schema LinstorClusterSpecApiTlsCaReference
 */
export interface LinstorClusterSpecApiTlsCaReference {
  /**
   * Key to select in the resource.
   * Defaults to ca.crt if not specified.
   *
   * @default ca.crt if not specified.
   * @schema LinstorClusterSpecApiTlsCaReference#key
   */
  readonly key?: string;

  /**
   * Kind of the resource containing the CA Certificate, either a ConfigMap or Secret.
   *
   * @schema LinstorClusterSpecApiTlsCaReference#kind
   */
  readonly kind?: LinstorClusterSpecApiTlsCaReferenceKind;

  /**
   * Name of the resource containing the CA Certificate.
   *
   * @schema LinstorClusterSpecApiTlsCaReference#name
   */
  readonly name: string;

  /**
   * Optional specifies whether the resource and its key must exist.
   *
   * @schema LinstorClusterSpecApiTlsCaReference#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'LinstorClusterSpecApiTlsCaReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorClusterSpecApiTlsCaReference(obj: LinstorClusterSpecApiTlsCaReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'kind': obj.kind,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertManager references a cert-manager Issuer or ClusterIssuer.
 * If set, cert-manager.io/Certificate resources will be created, provisioning the secrets referenced in
 * *SecretName using the issuer configured here.
 *
 * @schema LinstorClusterSpecApiTlsCertManager
 */
export interface LinstorClusterSpecApiTlsCertManager {
  /**
   * Group of the resource being referred to.
   *
   * @schema LinstorClusterSpecApiTlsCertManager#group
   */
  readonly group?: string;

  /**
   * Kind of the resource being referred to.
   *
   * @schema LinstorClusterSpecApiTlsCertManager#kind
   */
  readonly kind?: string;

  /**
   * Name of the resource being referred to.
   *
   * @schema LinstorClusterSpecApiTlsCertManager#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LinstorClusterSpecApiTlsCertManager' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorClusterSpecApiTlsCertManager(obj: LinstorClusterSpecApiTlsCertManager | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CAReference configures the CA certificate to use when validating TLS certificates.
 * If not set, the TLS secret is expected to contain a "ca.crt" containing the CA certificate.
 *
 * @schema LinstorClusterSpecInternalTlsCaReference
 */
export interface LinstorClusterSpecInternalTlsCaReference {
  /**
   * Key to select in the resource.
   * Defaults to ca.crt if not specified.
   *
   * @default ca.crt if not specified.
   * @schema LinstorClusterSpecInternalTlsCaReference#key
   */
  readonly key?: string;

  /**
   * Kind of the resource containing the CA Certificate, either a ConfigMap or Secret.
   *
   * @schema LinstorClusterSpecInternalTlsCaReference#kind
   */
  readonly kind?: LinstorClusterSpecInternalTlsCaReferenceKind;

  /**
   * Name of the resource containing the CA Certificate.
   *
   * @schema LinstorClusterSpecInternalTlsCaReference#name
   */
  readonly name: string;

  /**
   * Optional specifies whether the resource and its key must exist.
   *
   * @schema LinstorClusterSpecInternalTlsCaReference#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'LinstorClusterSpecInternalTlsCaReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorClusterSpecInternalTlsCaReference(obj: LinstorClusterSpecInternalTlsCaReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'kind': obj.kind,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertManager references a cert-manager Issuer or ClusterIssuer.
 * If set, a Certificate resource will be created, provisioning the secret references in SecretName using the
 * issuer configured here.
 *
 * @schema LinstorClusterSpecInternalTlsCertManager
 */
export interface LinstorClusterSpecInternalTlsCertManager {
  /**
   * Group of the resource being referred to.
   *
   * @schema LinstorClusterSpecInternalTlsCertManager#group
   */
  readonly group?: string;

  /**
   * Kind of the resource being referred to.
   *
   * @schema LinstorClusterSpecInternalTlsCertManager#kind
   */
  readonly kind?: string;

  /**
   * Name of the resource being referred to.
   *
   * @schema LinstorClusterSpecInternalTlsCertManager#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LinstorClusterSpecInternalTlsCertManager' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorClusterSpecInternalTlsCertManager(obj: LinstorClusterSpecInternalTlsCertManager | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema LinstorClusterSpecNodeAffinityNodeSelectorTerms
 */
export interface LinstorClusterSpecNodeAffinityNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema LinstorClusterSpecNodeAffinityNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: LinstorClusterSpecNodeAffinityNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema LinstorClusterSpecNodeAffinityNodeSelectorTerms#matchFields
   */
  readonly matchFields?: LinstorClusterSpecNodeAffinityNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'LinstorClusterSpecNodeAffinityNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorClusterSpecNodeAffinityNodeSelectorTerms(obj: LinstorClusterSpecNodeAffinityNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_LinstorClusterSpecNodeAffinityNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_LinstorClusterSpecNodeAffinityNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Target points to the resources that the patch is applied to
 *
 * @schema LinstorClusterSpecPatchesTarget
 */
export interface LinstorClusterSpecPatchesTarget {
  /**
   * AnnotationSelector is a string that follows the label selection expression
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api
   * It matches against the resource annotations.
   *
   * @schema LinstorClusterSpecPatchesTarget#annotationSelector
   */
  readonly annotationSelector?: string;

  /**
   * @schema LinstorClusterSpecPatchesTarget#group
   */
  readonly group?: string;

  /**
   * @schema LinstorClusterSpecPatchesTarget#kind
   */
  readonly kind?: string;

  /**
   * LabelSelector is a string that follows the label selection expression
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api
   * It matches against the resource labels.
   *
   * @schema LinstorClusterSpecPatchesTarget#labelSelector
   */
  readonly labelSelector?: string;

  /**
   * Name of the resource.
   *
   * @schema LinstorClusterSpecPatchesTarget#name
   */
  readonly name?: string;

  /**
   * Namespace the resource belongs to, if it can belong to a namespace.
   *
   * @schema LinstorClusterSpecPatchesTarget#namespace
   */
  readonly namespace?: string;

  /**
   * @schema LinstorClusterSpecPatchesTarget#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'LinstorClusterSpecPatchesTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorClusterSpecPatchesTarget(obj: LinstorClusterSpecPatchesTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotationSelector': obj.annotationSelector,
    'group': obj.group,
    'kind': obj.kind,
    'labelSelector': obj.labelSelector,
    'name': obj.name,
    'namespace': obj.namespace,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kind of the resource containing the CA Certificate, either a ConfigMap or Secret.
 *
 * @schema LinstorClusterSpecApiTlsCaReferenceKind
 */
export enum LinstorClusterSpecApiTlsCaReferenceKind {
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
  /** Secret */
  SECRET = "Secret",
}

/**
 * Kind of the resource containing the CA Certificate, either a ConfigMap or Secret.
 *
 * @schema LinstorClusterSpecInternalTlsCaReferenceKind
 */
export enum LinstorClusterSpecInternalTlsCaReferenceKind {
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
  /** Secret */
  SECRET = "Secret",
}

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema LinstorClusterSpecNodeAffinityNodeSelectorTermsMatchExpressions
 */
export interface LinstorClusterSpecNodeAffinityNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema LinstorClusterSpecNodeAffinityNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema LinstorClusterSpecNodeAffinityNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema LinstorClusterSpecNodeAffinityNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'LinstorClusterSpecNodeAffinityNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorClusterSpecNodeAffinityNodeSelectorTermsMatchExpressions(obj: LinstorClusterSpecNodeAffinityNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema LinstorClusterSpecNodeAffinityNodeSelectorTermsMatchFields
 */
export interface LinstorClusterSpecNodeAffinityNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema LinstorClusterSpecNodeAffinityNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema LinstorClusterSpecNodeAffinityNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema LinstorClusterSpecNodeAffinityNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'LinstorClusterSpecNodeAffinityNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorClusterSpecNodeAffinityNodeSelectorTermsMatchFields(obj: LinstorClusterSpecNodeAffinityNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * LinstorNodeConnection is the Schema for the linstornodeconnections API
 *
 * @schema LinstorNodeConnection
 */
export class LinstorNodeConnection extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LinstorNodeConnection"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'piraeus.io/v1',
    kind: 'LinstorNodeConnection',
  }

  /**
   * Renders a Kubernetes manifest for "LinstorNodeConnection".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LinstorNodeConnectionProps = {}): any {
    return {
      ...LinstorNodeConnection.GVK,
      ...toJson_LinstorNodeConnectionProps(props),
    };
  }

  /**
   * Defines a "LinstorNodeConnection" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LinstorNodeConnectionProps = {}) {
    super(scope, id, {
      ...LinstorNodeConnection.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LinstorNodeConnection.GVK,
      ...toJson_LinstorNodeConnectionProps(resolved),
    };
  }
}

/**
 * LinstorNodeConnection is the Schema for the linstornodeconnections API
 *
 * @schema LinstorNodeConnection
 */
export interface LinstorNodeConnectionProps {
  /**
   * @schema LinstorNodeConnection#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LinstorNodeConnectionSpec defines the desired state of LinstorNodeConnection
   *
   * @schema LinstorNodeConnection#spec
   */
  readonly spec?: LinstorNodeConnectionSpec;

}

/**
 * Converts an object of type 'LinstorNodeConnectionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorNodeConnectionProps(obj: LinstorNodeConnectionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LinstorNodeConnectionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LinstorNodeConnectionSpec defines the desired state of LinstorNodeConnection
 *
 * @schema LinstorNodeConnectionSpec
 */
export interface LinstorNodeConnectionSpec {
  /**
   * Paths configure the network path used when connecting two nodes.
   *
   * @schema LinstorNodeConnectionSpec#paths
   */
  readonly paths?: LinstorNodeConnectionSpecPaths[];

  /**
   * Properties to apply for the node connection.
   *
   * Use to create default settings for DRBD that should apply to all resources connections between a set of
   * cluster nodes.
   *
   * @schema LinstorNodeConnectionSpec#properties
   */
  readonly properties?: LinstorNodeConnectionSpecProperties[];

  /**
   * Selector selects which pair of Satellites the connection should apply to.
   * If not given, the connection will be applied to all connections.
   *
   * @schema LinstorNodeConnectionSpec#selector
   */
  readonly selector?: LinstorNodeConnectionSpecSelector[];

}

/**
 * Converts an object of type 'LinstorNodeConnectionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorNodeConnectionSpec(obj: LinstorNodeConnectionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'paths': obj.paths?.map(y => toJson_LinstorNodeConnectionSpecPaths(y)),
    'properties': obj.properties?.map(y => toJson_LinstorNodeConnectionSpecProperties(y)),
    'selector': obj.selector?.map(y => toJson_LinstorNodeConnectionSpecSelector(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LinstorNodeConnectionSpecPaths
 */
export interface LinstorNodeConnectionSpecPaths {
  /**
   * Interface to use on both nodes.
   *
   * @schema LinstorNodeConnectionSpecPaths#interface
   */
  readonly interface: string;

  /**
   * Name of the path.
   *
   * @schema LinstorNodeConnectionSpecPaths#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LinstorNodeConnectionSpecPaths' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorNodeConnectionSpecPaths(obj: LinstorNodeConnectionSpecPaths | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interface': obj.interface,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LinstorNodeConnectionSpecProperties
 */
export interface LinstorNodeConnectionSpecProperties {
  /**
   * Name of the property to set.
   *
   * @schema LinstorNodeConnectionSpecProperties#name
   */
  readonly name: string;

  /**
   * Value to set the property to.
   *
   * @schema LinstorNodeConnectionSpecProperties#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'LinstorNodeConnectionSpecProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorNodeConnectionSpecProperties(obj: LinstorNodeConnectionSpecProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SelectorTerm matches pairs of nodes by checking that the nodes match all specified requirements.
 *
 * @schema LinstorNodeConnectionSpecSelector
 */
export interface LinstorNodeConnectionSpecSelector {
  /**
   * MatchLabels is a list of match expressions that the node pairs must meet.
   *
   * @schema LinstorNodeConnectionSpecSelector#matchLabels
   */
  readonly matchLabels: LinstorNodeConnectionSpecSelectorMatchLabels[];

}

/**
 * Converts an object of type 'LinstorNodeConnectionSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorNodeConnectionSpecSelector(obj: LinstorNodeConnectionSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': obj.matchLabels?.map(y => toJson_LinstorNodeConnectionSpecSelectorMatchLabels(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LinstorNodeConnectionSpecSelectorMatchLabels
 */
export interface LinstorNodeConnectionSpecSelectorMatchLabels {
  /**
   * Key is the name of a node label.
   *
   * @schema LinstorNodeConnectionSpecSelectorMatchLabels#key
   */
  readonly key: string;

  /**
   * Op to apply to the label.
   * Exists (default) checks for the presence of the label on both nodes in the pair.
   * DoesNotExist checks that the label is not present on either node in the pair.
   * In checks for the presence of the label value given by Values on both nodes in the pair.
   * NotIn checks that both nodes in the pair do not have any of the label values given by Values.
   * Same checks that the label value is equal in the node pair.
   * NotSame checks that the label value is not equal in the node pair.
   *
   * @schema LinstorNodeConnectionSpecSelectorMatchLabels#op
   */
  readonly op?: LinstorNodeConnectionSpecSelectorMatchLabelsOp;

  /**
   * Values to match on, using the provided Op.
   *
   * @schema LinstorNodeConnectionSpecSelectorMatchLabels#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'LinstorNodeConnectionSpecSelectorMatchLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorNodeConnectionSpecSelectorMatchLabels(obj: LinstorNodeConnectionSpecSelectorMatchLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'op': obj.op,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Op to apply to the label.
 * Exists (default) checks for the presence of the label on both nodes in the pair.
 * DoesNotExist checks that the label is not present on either node in the pair.
 * In checks for the presence of the label value given by Values on both nodes in the pair.
 * NotIn checks that both nodes in the pair do not have any of the label values given by Values.
 * Same checks that the label value is equal in the node pair.
 * NotSame checks that the label value is not equal in the node pair.
 *
 * @schema LinstorNodeConnectionSpecSelectorMatchLabelsOp
 */
export enum LinstorNodeConnectionSpecSelectorMatchLabelsOp {
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Same */
  SAME = "Same",
  /** NotSame */
  NOT_SAME = "NotSame",
}


/**
 * LinstorSatellite is the Schema for the linstorsatellites API
 *
 * @schema LinstorSatellite
 */
export class LinstorSatellite extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LinstorSatellite"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'piraeus.io/v1',
    kind: 'LinstorSatellite',
  }

  /**
   * Renders a Kubernetes manifest for "LinstorSatellite".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LinstorSatelliteProps = {}): any {
    return {
      ...LinstorSatellite.GVK,
      ...toJson_LinstorSatelliteProps(props),
    };
  }

  /**
   * Defines a "LinstorSatellite" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LinstorSatelliteProps = {}) {
    super(scope, id, {
      ...LinstorSatellite.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LinstorSatellite.GVK,
      ...toJson_LinstorSatelliteProps(resolved),
    };
  }
}

/**
 * LinstorSatellite is the Schema for the linstorsatellites API
 *
 * @schema LinstorSatellite
 */
export interface LinstorSatelliteProps {
  /**
   * @schema LinstorSatellite#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LinstorSatelliteSpec defines the desired state of LinstorSatellite
   *
   * @schema LinstorSatellite#spec
   */
  readonly spec?: LinstorSatelliteSpec;

}

/**
 * Converts an object of type 'LinstorSatelliteProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteProps(obj: LinstorSatelliteProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LinstorSatelliteSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LinstorSatelliteSpec defines the desired state of LinstorSatellite
 *
 * @schema LinstorSatelliteSpec
 */
export interface LinstorSatelliteSpec {
  /**
   * ClusterRef references the LinstorCluster used to create this LinstorSatellite.
   *
   * @schema LinstorSatelliteSpec#clusterRef
   */
  readonly clusterRef: LinstorSatelliteSpecClusterRef;

  /**
   * InternalTLS configures secure communication for the LINSTOR Satellite.
   *
   * If set, the control traffic between LINSTOR Controller and Satellite will be encrypted using mTLS.
   * The Controller will use the client key from `LinstorCluster.spec.internalTLS` when connecting.
   *
   * @schema LinstorSatelliteSpec#internalTLS
   */
  readonly internalTls?: LinstorSatelliteSpecInternalTls;

  /**
   * Patches is a list of kustomize patches to apply.
   *
   * See https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/patches/ for how to create patches.
   *
   * @schema LinstorSatelliteSpec#patches
   */
  readonly patches?: LinstorSatelliteSpecPatches[];

  /**
   * Properties is a list of properties to set on the node.
   *
   * @schema LinstorSatelliteSpec#properties
   */
  readonly properties?: LinstorSatelliteSpecProperties[];

  /**
   * Repository used to pull workload images.
   *
   * @schema LinstorSatelliteSpec#repository
   */
  readonly repository?: string;

  /**
   * StoragePools is a list of storage pools to configure on the node.
   *
   * @schema LinstorSatelliteSpec#storagePools
   */
  readonly storagePools?: LinstorSatelliteSpecStoragePools[];

}

/**
 * Converts an object of type 'LinstorSatelliteSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteSpec(obj: LinstorSatelliteSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterRef': toJson_LinstorSatelliteSpecClusterRef(obj.clusterRef),
    'internalTLS': toJson_LinstorSatelliteSpecInternalTls(obj.internalTls),
    'patches': obj.patches?.map(y => toJson_LinstorSatelliteSpecPatches(y)),
    'properties': obj.properties?.map(y => toJson_LinstorSatelliteSpecProperties(y)),
    'repository': obj.repository,
    'storagePools': obj.storagePools?.map(y => toJson_LinstorSatelliteSpecStoragePools(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterRef references the LinstorCluster used to create this LinstorSatellite.
 *
 * @schema LinstorSatelliteSpecClusterRef
 */
export interface LinstorSatelliteSpecClusterRef {
  /**
   * CAReference configures the CA certificate to use when validating TLS certificates.
   * If not set, the TLS secret is expected to contain a "ca.crt" containing the CA certificate.
   *
   * @schema LinstorSatelliteSpecClusterRef#caReference
   */
  readonly caReference?: LinstorSatelliteSpecClusterRefCaReference;

  /**
   * ClientSecretName references the secret used by the operator to validate the https endpoint.
   *
   * @schema LinstorSatelliteSpecClusterRef#clientSecretName
   */
  readonly clientSecretName?: string;

  /**
   * ExternalController references an external controller.
   * When set, the Operator uses the external cluster to register satellites.
   *
   * @schema LinstorSatelliteSpecClusterRef#externalController
   */
  readonly externalController?: LinstorSatelliteSpecClusterRefExternalController;

  /**
   * Name of the LinstorCluster resource controlling this satellite.
   *
   * @schema LinstorSatelliteSpecClusterRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'LinstorSatelliteSpecClusterRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteSpecClusterRef(obj: LinstorSatelliteSpecClusterRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caReference': toJson_LinstorSatelliteSpecClusterRefCaReference(obj.caReference),
    'clientSecretName': obj.clientSecretName,
    'externalController': toJson_LinstorSatelliteSpecClusterRefExternalController(obj.externalController),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InternalTLS configures secure communication for the LINSTOR Satellite.
 *
 * If set, the control traffic between LINSTOR Controller and Satellite will be encrypted using mTLS.
 * The Controller will use the client key from `LinstorCluster.spec.internalTLS` when connecting.
 *
 * @schema LinstorSatelliteSpecInternalTls
 */
export interface LinstorSatelliteSpecInternalTls {
  /**
   * CAReference configures the CA certificate to use when validating TLS certificates.
   * If not set, the TLS secret is expected to contain a "ca.crt" containing the CA certificate.
   *
   * @schema LinstorSatelliteSpecInternalTls#caReference
   */
  readonly caReference?: LinstorSatelliteSpecInternalTlsCaReference;

  /**
   * CertManager references a cert-manager Issuer or ClusterIssuer.
   * If set, a Certificate resource will be created, provisioning the secret references in SecretName using the
   * issuer configured here.
   *
   * @schema LinstorSatelliteSpecInternalTls#certManager
   */
  readonly certManager?: LinstorSatelliteSpecInternalTlsCertManager;

  /**
   * SecretName references a secret holding the TLS key and certificates.
   *
   * @schema LinstorSatelliteSpecInternalTls#secretName
   */
  readonly secretName?: string;

  /**
   * TLSHandshakeDaemon enables tlshd for establishing TLS sessions for use by DRBD.
   *
   * If enabled, adds a new sidecar to the LINSTOR Satellite that runs the tlshd handshake daemon.
   * The daemon uses the TLS certificate and key to establish secure connections on behalf of DRBD.
   *
   * @schema LinstorSatelliteSpecInternalTls#tlsHandshakeDaemon
   */
  readonly tlsHandshakeDaemon?: boolean;

}

/**
 * Converts an object of type 'LinstorSatelliteSpecInternalTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteSpecInternalTls(obj: LinstorSatelliteSpecInternalTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caReference': toJson_LinstorSatelliteSpecInternalTlsCaReference(obj.caReference),
    'certManager': toJson_LinstorSatelliteSpecInternalTlsCertManager(obj.certManager),
    'secretName': obj.secretName,
    'tlsHandshakeDaemon': obj.tlsHandshakeDaemon,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Patch represent either a Strategic Merge Patch or a JSON patch and its targets.
 *
 * @schema LinstorSatelliteSpecPatches
 */
export interface LinstorSatelliteSpecPatches {
  /**
   * Options is a list of options for the patch
   *
   * @schema LinstorSatelliteSpecPatches#options
   */
  readonly options?: { [key: string]: boolean };

  /**
   * Patch is the content of a patch.
   *
   * @schema LinstorSatelliteSpecPatches#patch
   */
  readonly patch: string;

  /**
   * Target points to the resources that the patch is applied to
   *
   * @schema LinstorSatelliteSpecPatches#target
   */
  readonly target?: LinstorSatelliteSpecPatchesTarget;

}

/**
 * Converts an object of type 'LinstorSatelliteSpecPatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteSpecPatches(obj: LinstorSatelliteSpecPatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'patch': obj.patch,
    'target': toJson_LinstorSatelliteSpecPatchesTarget(obj.target),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LinstorSatelliteSpecProperties
 */
export interface LinstorSatelliteSpecProperties {
  /**
   * ExpandFrom can reference multiple resource fields at once.
   * It either sets the property to an aggregate value based on matched resource fields, or expands to multiple
   * properties.
   *
   * @schema LinstorSatelliteSpecProperties#expandFrom
   */
  readonly expandFrom?: LinstorSatelliteSpecPropertiesExpandFrom;

  /**
   * Name of the property to set.
   *
   * @schema LinstorSatelliteSpecProperties#name
   */
  readonly name: string;

  /**
   * Optional values are only set if they have a non-empty value
   *
   * @schema LinstorSatelliteSpecProperties#optional
   */
  readonly optional?: boolean;

  /**
   * Value to set the property to.
   *
   * @schema LinstorSatelliteSpecProperties#value
   */
  readonly value?: string;

  /**
   * ValueFrom sets the value from an existing resource.
   *
   * @schema LinstorSatelliteSpecProperties#valueFrom
   */
  readonly valueFrom?: LinstorSatelliteSpecPropertiesValueFrom;

}

/**
 * Converts an object of type 'LinstorSatelliteSpecProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteSpecProperties(obj: LinstorSatelliteSpecProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expandFrom': toJson_LinstorSatelliteSpecPropertiesExpandFrom(obj.expandFrom),
    'name': obj.name,
    'optional': obj.optional,
    'value': obj.value,
    'valueFrom': toJson_LinstorSatelliteSpecPropertiesValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LinstorSatelliteSpecStoragePools
 */
export interface LinstorSatelliteSpecStoragePools {
  /**
   * Configures a file system based storage pool, allocating a regular file per volume.
   *
   * @schema LinstorSatelliteSpecStoragePools#filePool
   */
  readonly filePool?: LinstorSatelliteSpecStoragePoolsFilePool;

  /**
   * Configures a file system based storage pool, allocating a sparse file per volume.
   *
   * @schema LinstorSatelliteSpecStoragePools#fileThinPool
   */
  readonly fileThinPool?: LinstorSatelliteSpecStoragePoolsFileThinPool;

  /**
   * Configures a LVM Volume Group as storage pool.
   *
   * @schema LinstorSatelliteSpecStoragePools#lvmPool
   */
  readonly lvmPool?: LinstorSatelliteSpecStoragePoolsLvmPool;

  /**
   * Configures a LVM Thin Pool as storage pool.
   *
   * @schema LinstorSatelliteSpecStoragePools#lvmThinPool
   */
  readonly lvmThinPool?: LinstorSatelliteSpecStoragePoolsLvmThinPool;

  /**
   * Name of the storage pool in linstor.
   *
   * @schema LinstorSatelliteSpecStoragePools#name
   */
  readonly name: string;

  /**
   * Properties to set on the storage pool.
   *
   * @schema LinstorSatelliteSpecStoragePools#properties
   */
  readonly properties?: LinstorSatelliteSpecStoragePoolsProperties[];

  /**
   * @schema LinstorSatelliteSpecStoragePools#source
   */
  readonly source?: LinstorSatelliteSpecStoragePoolsSource;

  /**
   * Configures a ZFS system based storage pool, allocating zvols from the given zpool.
   *
   * @schema LinstorSatelliteSpecStoragePools#zfsPool
   */
  readonly zfsPool?: LinstorSatelliteSpecStoragePoolsZfsPool;

  /**
   * Configures a ZFS system based storage pool, allocating sparse zvols from the given zpool.
   *
   * @schema LinstorSatelliteSpecStoragePools#zfsThinPool
   */
  readonly zfsThinPool?: LinstorSatelliteSpecStoragePoolsZfsThinPool;

}

/**
 * Converts an object of type 'LinstorSatelliteSpecStoragePools' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteSpecStoragePools(obj: LinstorSatelliteSpecStoragePools | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filePool': toJson_LinstorSatelliteSpecStoragePoolsFilePool(obj.filePool),
    'fileThinPool': toJson_LinstorSatelliteSpecStoragePoolsFileThinPool(obj.fileThinPool),
    'lvmPool': toJson_LinstorSatelliteSpecStoragePoolsLvmPool(obj.lvmPool),
    'lvmThinPool': toJson_LinstorSatelliteSpecStoragePoolsLvmThinPool(obj.lvmThinPool),
    'name': obj.name,
    'properties': obj.properties?.map(y => toJson_LinstorSatelliteSpecStoragePoolsProperties(y)),
    'source': toJson_LinstorSatelliteSpecStoragePoolsSource(obj.source),
    'zfsPool': toJson_LinstorSatelliteSpecStoragePoolsZfsPool(obj.zfsPool),
    'zfsThinPool': toJson_LinstorSatelliteSpecStoragePoolsZfsThinPool(obj.zfsThinPool),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CAReference configures the CA certificate to use when validating TLS certificates.
 * If not set, the TLS secret is expected to contain a "ca.crt" containing the CA certificate.
 *
 * @schema LinstorSatelliteSpecClusterRefCaReference
 */
export interface LinstorSatelliteSpecClusterRefCaReference {
  /**
   * Key to select in the resource.
   * Defaults to ca.crt if not specified.
   *
   * @default ca.crt if not specified.
   * @schema LinstorSatelliteSpecClusterRefCaReference#key
   */
  readonly key?: string;

  /**
   * Kind of the resource containing the CA Certificate, either a ConfigMap or Secret.
   *
   * @schema LinstorSatelliteSpecClusterRefCaReference#kind
   */
  readonly kind?: LinstorSatelliteSpecClusterRefCaReferenceKind;

  /**
   * Name of the resource containing the CA Certificate.
   *
   * @schema LinstorSatelliteSpecClusterRefCaReference#name
   */
  readonly name: string;

  /**
   * Optional specifies whether the resource and its key must exist.
   *
   * @schema LinstorSatelliteSpecClusterRefCaReference#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'LinstorSatelliteSpecClusterRefCaReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteSpecClusterRefCaReference(obj: LinstorSatelliteSpecClusterRefCaReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'kind': obj.kind,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalController references an external controller.
 * When set, the Operator uses the external cluster to register satellites.
 *
 * @schema LinstorSatelliteSpecClusterRefExternalController
 */
export interface LinstorSatelliteSpecClusterRefExternalController {
  /**
   * URL of the external controller.
   *
   * @schema LinstorSatelliteSpecClusterRefExternalController#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'LinstorSatelliteSpecClusterRefExternalController' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteSpecClusterRefExternalController(obj: LinstorSatelliteSpecClusterRefExternalController | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CAReference configures the CA certificate to use when validating TLS certificates.
 * If not set, the TLS secret is expected to contain a "ca.crt" containing the CA certificate.
 *
 * @schema LinstorSatelliteSpecInternalTlsCaReference
 */
export interface LinstorSatelliteSpecInternalTlsCaReference {
  /**
   * Key to select in the resource.
   * Defaults to ca.crt if not specified.
   *
   * @default ca.crt if not specified.
   * @schema LinstorSatelliteSpecInternalTlsCaReference#key
   */
  readonly key?: string;

  /**
   * Kind of the resource containing the CA Certificate, either a ConfigMap or Secret.
   *
   * @schema LinstorSatelliteSpecInternalTlsCaReference#kind
   */
  readonly kind?: LinstorSatelliteSpecInternalTlsCaReferenceKind;

  /**
   * Name of the resource containing the CA Certificate.
   *
   * @schema LinstorSatelliteSpecInternalTlsCaReference#name
   */
  readonly name: string;

  /**
   * Optional specifies whether the resource and its key must exist.
   *
   * @schema LinstorSatelliteSpecInternalTlsCaReference#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'LinstorSatelliteSpecInternalTlsCaReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteSpecInternalTlsCaReference(obj: LinstorSatelliteSpecInternalTlsCaReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'kind': obj.kind,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertManager references a cert-manager Issuer or ClusterIssuer.
 * If set, a Certificate resource will be created, provisioning the secret references in SecretName using the
 * issuer configured here.
 *
 * @schema LinstorSatelliteSpecInternalTlsCertManager
 */
export interface LinstorSatelliteSpecInternalTlsCertManager {
  /**
   * Group of the resource being referred to.
   *
   * @schema LinstorSatelliteSpecInternalTlsCertManager#group
   */
  readonly group?: string;

  /**
   * Kind of the resource being referred to.
   *
   * @schema LinstorSatelliteSpecInternalTlsCertManager#kind
   */
  readonly kind?: string;

  /**
   * Name of the resource being referred to.
   *
   * @schema LinstorSatelliteSpecInternalTlsCertManager#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LinstorSatelliteSpecInternalTlsCertManager' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteSpecInternalTlsCertManager(obj: LinstorSatelliteSpecInternalTlsCertManager | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Target points to the resources that the patch is applied to
 *
 * @schema LinstorSatelliteSpecPatchesTarget
 */
export interface LinstorSatelliteSpecPatchesTarget {
  /**
   * AnnotationSelector is a string that follows the label selection expression
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api
   * It matches against the resource annotations.
   *
   * @schema LinstorSatelliteSpecPatchesTarget#annotationSelector
   */
  readonly annotationSelector?: string;

  /**
   * @schema LinstorSatelliteSpecPatchesTarget#group
   */
  readonly group?: string;

  /**
   * @schema LinstorSatelliteSpecPatchesTarget#kind
   */
  readonly kind?: string;

  /**
   * LabelSelector is a string that follows the label selection expression
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api
   * It matches against the resource labels.
   *
   * @schema LinstorSatelliteSpecPatchesTarget#labelSelector
   */
  readonly labelSelector?: string;

  /**
   * Name of the resource.
   *
   * @schema LinstorSatelliteSpecPatchesTarget#name
   */
  readonly name?: string;

  /**
   * Namespace the resource belongs to, if it can belong to a namespace.
   *
   * @schema LinstorSatelliteSpecPatchesTarget#namespace
   */
  readonly namespace?: string;

  /**
   * @schema LinstorSatelliteSpecPatchesTarget#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'LinstorSatelliteSpecPatchesTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteSpecPatchesTarget(obj: LinstorSatelliteSpecPatchesTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotationSelector': obj.annotationSelector,
    'group': obj.group,
    'kind': obj.kind,
    'labelSelector': obj.labelSelector,
    'name': obj.name,
    'namespace': obj.namespace,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExpandFrom can reference multiple resource fields at once.
 * It either sets the property to an aggregate value based on matched resource fields, or expands to multiple
 * properties.
 *
 * @schema LinstorSatelliteSpecPropertiesExpandFrom
 */
export interface LinstorSatelliteSpecPropertiesExpandFrom {
  /**
   * Delimiter used to join multiple key and value pairs together.
   *
   * @schema LinstorSatelliteSpecPropertiesExpandFrom#delimiter
   */
  readonly delimiter?: string;

  /**
   * NameTemplate defines how the property key is expanded.
   * If set, the template is appended to the defined property name, creating multiple properties instead of one
   * aggregate.
   * * $1 is replaced with the matched key.
   * * $2 is replaced with the matched value.
   *
   * @schema LinstorSatelliteSpecPropertiesExpandFrom#nameTemplate
   */
  readonly nameTemplate?: string;

  /**
   * Select a field of the node. Supports `metadata.name`, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`.
   *
   * @schema LinstorSatelliteSpecPropertiesExpandFrom#nodeFieldRef
   */
  readonly nodeFieldRef: string;

  /**
   * ValueTemplate defines how the property value is expanded.
   * * $1 is replaced with the matched key.
   * * $2 is replaced with the matched value.
   *
   * @schema LinstorSatelliteSpecPropertiesExpandFrom#valueTemplate
   */
  readonly valueTemplate?: string;

}

/**
 * Converts an object of type 'LinstorSatelliteSpecPropertiesExpandFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteSpecPropertiesExpandFrom(obj: LinstorSatelliteSpecPropertiesExpandFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'delimiter': obj.delimiter,
    'nameTemplate': obj.nameTemplate,
    'nodeFieldRef': obj.nodeFieldRef,
    'valueTemplate': obj.valueTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ValueFrom sets the value from an existing resource.
 *
 * @schema LinstorSatelliteSpecPropertiesValueFrom
 */
export interface LinstorSatelliteSpecPropertiesValueFrom {
  /**
   * Select a field of the node. Supports `metadata.name`, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`.
   *
   * @schema LinstorSatelliteSpecPropertiesValueFrom#nodeFieldRef
   */
  readonly nodeFieldRef: string;

}

/**
 * Converts an object of type 'LinstorSatelliteSpecPropertiesValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteSpecPropertiesValueFrom(obj: LinstorSatelliteSpecPropertiesValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeFieldRef': obj.nodeFieldRef,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures a file system based storage pool, allocating a regular file per volume.
 *
 * @schema LinstorSatelliteSpecStoragePoolsFilePool
 */
export interface LinstorSatelliteSpecStoragePoolsFilePool {
  /**
   * Directory is the path to the host directory used to store volume data.
   *
   * @schema LinstorSatelliteSpecStoragePoolsFilePool#directory
   */
  readonly directory?: string;

}

/**
 * Converts an object of type 'LinstorSatelliteSpecStoragePoolsFilePool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteSpecStoragePoolsFilePool(obj: LinstorSatelliteSpecStoragePoolsFilePool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures a file system based storage pool, allocating a sparse file per volume.
 *
 * @schema LinstorSatelliteSpecStoragePoolsFileThinPool
 */
export interface LinstorSatelliteSpecStoragePoolsFileThinPool {
  /**
   * Directory is the path to the host directory used to store volume data.
   *
   * @schema LinstorSatelliteSpecStoragePoolsFileThinPool#directory
   */
  readonly directory?: string;

}

/**
 * Converts an object of type 'LinstorSatelliteSpecStoragePoolsFileThinPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteSpecStoragePoolsFileThinPool(obj: LinstorSatelliteSpecStoragePoolsFileThinPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures a LVM Volume Group as storage pool.
 *
 * @schema LinstorSatelliteSpecStoragePoolsLvmPool
 */
export interface LinstorSatelliteSpecStoragePoolsLvmPool {
  /**
   * @schema LinstorSatelliteSpecStoragePoolsLvmPool#volumeGroup
   */
  readonly volumeGroup?: string;

}

/**
 * Converts an object of type 'LinstorSatelliteSpecStoragePoolsLvmPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteSpecStoragePoolsLvmPool(obj: LinstorSatelliteSpecStoragePoolsLvmPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeGroup': obj.volumeGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures a LVM Thin Pool as storage pool.
 *
 * @schema LinstorSatelliteSpecStoragePoolsLvmThinPool
 */
export interface LinstorSatelliteSpecStoragePoolsLvmThinPool {
  /**
   * ThinPool is the name of the thinpool LV (without VG prefix).
   *
   * @schema LinstorSatelliteSpecStoragePoolsLvmThinPool#thinPool
   */
  readonly thinPool?: string;

  /**
   * @schema LinstorSatelliteSpecStoragePoolsLvmThinPool#volumeGroup
   */
  readonly volumeGroup?: string;

}

/**
 * Converts an object of type 'LinstorSatelliteSpecStoragePoolsLvmThinPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteSpecStoragePoolsLvmThinPool(obj: LinstorSatelliteSpecStoragePoolsLvmThinPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'thinPool': obj.thinPool,
    'volumeGroup': obj.volumeGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LinstorSatelliteSpecStoragePoolsProperties
 */
export interface LinstorSatelliteSpecStoragePoolsProperties {
  /**
   * ExpandFrom can reference multiple resource fields at once.
   * It either sets the property to an aggregate value based on matched resource fields, or expands to multiple
   * properties.
   *
   * @schema LinstorSatelliteSpecStoragePoolsProperties#expandFrom
   */
  readonly expandFrom?: LinstorSatelliteSpecStoragePoolsPropertiesExpandFrom;

  /**
   * Name of the property to set.
   *
   * @schema LinstorSatelliteSpecStoragePoolsProperties#name
   */
  readonly name: string;

  /**
   * Optional values are only set if they have a non-empty value
   *
   * @schema LinstorSatelliteSpecStoragePoolsProperties#optional
   */
  readonly optional?: boolean;

  /**
   * Value to set the property to.
   *
   * @schema LinstorSatelliteSpecStoragePoolsProperties#value
   */
  readonly value?: string;

  /**
   * ValueFrom sets the value from an existing resource.
   *
   * @schema LinstorSatelliteSpecStoragePoolsProperties#valueFrom
   */
  readonly valueFrom?: LinstorSatelliteSpecStoragePoolsPropertiesValueFrom;

}

/**
 * Converts an object of type 'LinstorSatelliteSpecStoragePoolsProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteSpecStoragePoolsProperties(obj: LinstorSatelliteSpecStoragePoolsProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expandFrom': toJson_LinstorSatelliteSpecStoragePoolsPropertiesExpandFrom(obj.expandFrom),
    'name': obj.name,
    'optional': obj.optional,
    'value': obj.value,
    'valueFrom': toJson_LinstorSatelliteSpecStoragePoolsPropertiesValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LinstorSatelliteSpecStoragePoolsSource
 */
export interface LinstorSatelliteSpecStoragePoolsSource {
  /**
   * HostDevices is a list of device paths used to configure the given pool.
   *
   * @schema LinstorSatelliteSpecStoragePoolsSource#hostDevices
   */
  readonly hostDevices?: string[];

}

/**
 * Converts an object of type 'LinstorSatelliteSpecStoragePoolsSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteSpecStoragePoolsSource(obj: LinstorSatelliteSpecStoragePoolsSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostDevices': obj.hostDevices?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures a ZFS system based storage pool, allocating zvols from the given zpool.
 *
 * @schema LinstorSatelliteSpecStoragePoolsZfsPool
 */
export interface LinstorSatelliteSpecStoragePoolsZfsPool {
  /**
   * ZPool is the name of the ZFS zpool.
   *
   * @schema LinstorSatelliteSpecStoragePoolsZfsPool#zPool
   */
  readonly zPool?: string;

}

/**
 * Converts an object of type 'LinstorSatelliteSpecStoragePoolsZfsPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteSpecStoragePoolsZfsPool(obj: LinstorSatelliteSpecStoragePoolsZfsPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'zPool': obj.zPool,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures a ZFS system based storage pool, allocating sparse zvols from the given zpool.
 *
 * @schema LinstorSatelliteSpecStoragePoolsZfsThinPool
 */
export interface LinstorSatelliteSpecStoragePoolsZfsThinPool {
  /**
   * ZPool is the name of the ZFS zpool.
   *
   * @schema LinstorSatelliteSpecStoragePoolsZfsThinPool#zPool
   */
  readonly zPool?: string;

}

/**
 * Converts an object of type 'LinstorSatelliteSpecStoragePoolsZfsThinPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteSpecStoragePoolsZfsThinPool(obj: LinstorSatelliteSpecStoragePoolsZfsThinPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'zPool': obj.zPool,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kind of the resource containing the CA Certificate, either a ConfigMap or Secret.
 *
 * @schema LinstorSatelliteSpecClusterRefCaReferenceKind
 */
export enum LinstorSatelliteSpecClusterRefCaReferenceKind {
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
  /** Secret */
  SECRET = "Secret",
}

/**
 * Kind of the resource containing the CA Certificate, either a ConfigMap or Secret.
 *
 * @schema LinstorSatelliteSpecInternalTlsCaReferenceKind
 */
export enum LinstorSatelliteSpecInternalTlsCaReferenceKind {
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
  /** Secret */
  SECRET = "Secret",
}

/**
 * ExpandFrom can reference multiple resource fields at once.
 * It either sets the property to an aggregate value based on matched resource fields, or expands to multiple
 * properties.
 *
 * @schema LinstorSatelliteSpecStoragePoolsPropertiesExpandFrom
 */
export interface LinstorSatelliteSpecStoragePoolsPropertiesExpandFrom {
  /**
   * Delimiter used to join multiple key and value pairs together.
   *
   * @schema LinstorSatelliteSpecStoragePoolsPropertiesExpandFrom#delimiter
   */
  readonly delimiter?: string;

  /**
   * NameTemplate defines how the property key is expanded.
   * If set, the template is appended to the defined property name, creating multiple properties instead of one
   * aggregate.
   * * $1 is replaced with the matched key.
   * * $2 is replaced with the matched value.
   *
   * @schema LinstorSatelliteSpecStoragePoolsPropertiesExpandFrom#nameTemplate
   */
  readonly nameTemplate?: string;

  /**
   * Select a field of the node. Supports `metadata.name`, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`.
   *
   * @schema LinstorSatelliteSpecStoragePoolsPropertiesExpandFrom#nodeFieldRef
   */
  readonly nodeFieldRef: string;

  /**
   * ValueTemplate defines how the property value is expanded.
   * * $1 is replaced with the matched key.
   * * $2 is replaced with the matched value.
   *
   * @schema LinstorSatelliteSpecStoragePoolsPropertiesExpandFrom#valueTemplate
   */
  readonly valueTemplate?: string;

}

/**
 * Converts an object of type 'LinstorSatelliteSpecStoragePoolsPropertiesExpandFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteSpecStoragePoolsPropertiesExpandFrom(obj: LinstorSatelliteSpecStoragePoolsPropertiesExpandFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'delimiter': obj.delimiter,
    'nameTemplate': obj.nameTemplate,
    'nodeFieldRef': obj.nodeFieldRef,
    'valueTemplate': obj.valueTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ValueFrom sets the value from an existing resource.
 *
 * @schema LinstorSatelliteSpecStoragePoolsPropertiesValueFrom
 */
export interface LinstorSatelliteSpecStoragePoolsPropertiesValueFrom {
  /**
   * Select a field of the node. Supports `metadata.name`, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`.
   *
   * @schema LinstorSatelliteSpecStoragePoolsPropertiesValueFrom#nodeFieldRef
   */
  readonly nodeFieldRef: string;

}

/**
 * Converts an object of type 'LinstorSatelliteSpecStoragePoolsPropertiesValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteSpecStoragePoolsPropertiesValueFrom(obj: LinstorSatelliteSpecStoragePoolsPropertiesValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeFieldRef': obj.nodeFieldRef,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * LinstorSatelliteConfiguration is the Schema for the linstorsatelliteconfigurations API
 *
 * @schema LinstorSatelliteConfiguration
 */
export class LinstorSatelliteConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LinstorSatelliteConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'piraeus.io/v1',
    kind: 'LinstorSatelliteConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "LinstorSatelliteConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LinstorSatelliteConfigurationProps = {}): any {
    return {
      ...LinstorSatelliteConfiguration.GVK,
      ...toJson_LinstorSatelliteConfigurationProps(props),
    };
  }

  /**
   * Defines a "LinstorSatelliteConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LinstorSatelliteConfigurationProps = {}) {
    super(scope, id, {
      ...LinstorSatelliteConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LinstorSatelliteConfiguration.GVK,
      ...toJson_LinstorSatelliteConfigurationProps(resolved),
    };
  }
}

/**
 * LinstorSatelliteConfiguration is the Schema for the linstorsatelliteconfigurations API
 *
 * @schema LinstorSatelliteConfiguration
 */
export interface LinstorSatelliteConfigurationProps {
  /**
   * @schema LinstorSatelliteConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LinstorSatelliteConfigurationSpec defines a partial, desired state of a LinstorSatelliteSpec.
   *
   * All the LinstorSatelliteConfiguration resources with matching NodeSelector will
   * be merged into a single LinstorSatelliteSpec.
   *
   * @schema LinstorSatelliteConfiguration#spec
   */
  readonly spec?: LinstorSatelliteConfigurationSpec;

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationProps(obj: LinstorSatelliteConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LinstorSatelliteConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LinstorSatelliteConfigurationSpec defines a partial, desired state of a LinstorSatelliteSpec.
 *
 * All the LinstorSatelliteConfiguration resources with matching NodeSelector will
 * be merged into a single LinstorSatelliteSpec.
 *
 * @schema LinstorSatelliteConfigurationSpec
 */
export interface LinstorSatelliteConfigurationSpec {
  /**
   * InternalTLS configures secure communication for the LINSTOR Satellite.
   *
   * If set, the control traffic between LINSTOR Controller and Satellite will be encrypted using mTLS.
   *
   * @schema LinstorSatelliteConfigurationSpec#internalTLS
   */
  readonly internalTls?: LinstorSatelliteConfigurationSpecInternalTls;

  /**
   * NodeAffinity selects which LinstorSatellite resources this spec should be applied to.
   * See https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema LinstorSatelliteConfigurationSpec#nodeAffinity
   */
  readonly nodeAffinity?: LinstorSatelliteConfigurationSpecNodeAffinity;

  /**
   * NodeSelector selects which LinstorSatellite resources this spec should be applied to.
   * See https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema LinstorSatelliteConfigurationSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Patches is a list of kustomize patches to apply.
   *
   * See https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/patches/ for how to create patches.
   *
   * @schema LinstorSatelliteConfigurationSpec#patches
   */
  readonly patches?: LinstorSatelliteConfigurationSpecPatches[];

  /**
   * Template to apply to Satellite Pods.
   *
   * The template is applied as a patch to the default resource, so it can be "sparse", not listing any
   * containers or volumes that should remain unchanged.
   * See https://kubernetes.io/docs/concepts/workloads/pods/#pod-templates
   *
   * @schema LinstorSatelliteConfigurationSpec#podTemplate
   */
  readonly podTemplate?: any;

  /**
   * Properties is a list of properties to set on the node.
   *
   * @schema LinstorSatelliteConfigurationSpec#properties
   */
  readonly properties?: LinstorSatelliteConfigurationSpecProperties[];

  /**
   * StoragePools is a list of storage pools to configure on the node.
   *
   * @schema LinstorSatelliteConfigurationSpec#storagePools
   */
  readonly storagePools?: LinstorSatelliteConfigurationSpecStoragePools[];

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationSpec(obj: LinstorSatelliteConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'internalTLS': toJson_LinstorSatelliteConfigurationSpecInternalTls(obj.internalTls),
    'nodeAffinity': toJson_LinstorSatelliteConfigurationSpecNodeAffinity(obj.nodeAffinity),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'patches': obj.patches?.map(y => toJson_LinstorSatelliteConfigurationSpecPatches(y)),
    'podTemplate': obj.podTemplate,
    'properties': obj.properties?.map(y => toJson_LinstorSatelliteConfigurationSpecProperties(y)),
    'storagePools': obj.storagePools?.map(y => toJson_LinstorSatelliteConfigurationSpecStoragePools(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InternalTLS configures secure communication for the LINSTOR Satellite.
 *
 * If set, the control traffic between LINSTOR Controller and Satellite will be encrypted using mTLS.
 *
 * @schema LinstorSatelliteConfigurationSpecInternalTls
 */
export interface LinstorSatelliteConfigurationSpecInternalTls {
  /**
   * CAReference configures the CA certificate to use when validating TLS certificates.
   * If not set, the TLS secret is expected to contain a "ca.crt" containing the CA certificate.
   *
   * @schema LinstorSatelliteConfigurationSpecInternalTls#caReference
   */
  readonly caReference?: LinstorSatelliteConfigurationSpecInternalTlsCaReference;

  /**
   * CertManager references a cert-manager Issuer or ClusterIssuer.
   * If set, a Certificate resource will be created, provisioning the secret references in SecretName using the
   * issuer configured here.
   *
   * @schema LinstorSatelliteConfigurationSpecInternalTls#certManager
   */
  readonly certManager?: LinstorSatelliteConfigurationSpecInternalTlsCertManager;

  /**
   * SecretName references a secret holding the TLS key and certificates.
   *
   * @schema LinstorSatelliteConfigurationSpecInternalTls#secretName
   */
  readonly secretName?: string;

  /**
   * TLSHandshakeDaemon enables tlshd for establishing TLS sessions for use by DRBD.
   *
   * If enabled, adds a new sidecar to the LINSTOR Satellite that runs the tlshd handshake daemon.
   * The daemon uses the TLS certificate and key to establish secure connections on behalf of DRBD.
   *
   * @schema LinstorSatelliteConfigurationSpecInternalTls#tlsHandshakeDaemon
   */
  readonly tlsHandshakeDaemon?: boolean;

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationSpecInternalTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationSpecInternalTls(obj: LinstorSatelliteConfigurationSpecInternalTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caReference': toJson_LinstorSatelliteConfigurationSpecInternalTlsCaReference(obj.caReference),
    'certManager': toJson_LinstorSatelliteConfigurationSpecInternalTlsCertManager(obj.certManager),
    'secretName': obj.secretName,
    'tlsHandshakeDaemon': obj.tlsHandshakeDaemon,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodeAffinity selects which LinstorSatellite resources this spec should be applied to.
 * See https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
 *
 * @schema LinstorSatelliteConfigurationSpecNodeAffinity
 */
export interface LinstorSatelliteConfigurationSpecNodeAffinity {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema LinstorSatelliteConfigurationSpecNodeAffinity#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTerms[];

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationSpecNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationSpecNodeAffinity(obj: LinstorSatelliteConfigurationSpecNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Patch represent either a Strategic Merge Patch or a JSON patch and its targets.
 *
 * @schema LinstorSatelliteConfigurationSpecPatches
 */
export interface LinstorSatelliteConfigurationSpecPatches {
  /**
   * Options is a list of options for the patch
   *
   * @schema LinstorSatelliteConfigurationSpecPatches#options
   */
  readonly options?: { [key: string]: boolean };

  /**
   * Patch is the content of a patch.
   *
   * @schema LinstorSatelliteConfigurationSpecPatches#patch
   */
  readonly patch: string;

  /**
   * Target points to the resources that the patch is applied to
   *
   * @schema LinstorSatelliteConfigurationSpecPatches#target
   */
  readonly target?: LinstorSatelliteConfigurationSpecPatchesTarget;

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationSpecPatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationSpecPatches(obj: LinstorSatelliteConfigurationSpecPatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'patch': obj.patch,
    'target': toJson_LinstorSatelliteConfigurationSpecPatchesTarget(obj.target),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LinstorSatelliteConfigurationSpecProperties
 */
export interface LinstorSatelliteConfigurationSpecProperties {
  /**
   * ExpandFrom can reference multiple resource fields at once.
   * It either sets the property to an aggregate value based on matched resource fields, or expands to multiple
   * properties.
   *
   * @schema LinstorSatelliteConfigurationSpecProperties#expandFrom
   */
  readonly expandFrom?: LinstorSatelliteConfigurationSpecPropertiesExpandFrom;

  /**
   * Name of the property to set.
   *
   * @schema LinstorSatelliteConfigurationSpecProperties#name
   */
  readonly name: string;

  /**
   * Optional values are only set if they have a non-empty value
   *
   * @schema LinstorSatelliteConfigurationSpecProperties#optional
   */
  readonly optional?: boolean;

  /**
   * Value to set the property to.
   *
   * @schema LinstorSatelliteConfigurationSpecProperties#value
   */
  readonly value?: string;

  /**
   * ValueFrom sets the value from an existing resource.
   *
   * @schema LinstorSatelliteConfigurationSpecProperties#valueFrom
   */
  readonly valueFrom?: LinstorSatelliteConfigurationSpecPropertiesValueFrom;

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationSpecProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationSpecProperties(obj: LinstorSatelliteConfigurationSpecProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expandFrom': toJson_LinstorSatelliteConfigurationSpecPropertiesExpandFrom(obj.expandFrom),
    'name': obj.name,
    'optional': obj.optional,
    'value': obj.value,
    'valueFrom': toJson_LinstorSatelliteConfigurationSpecPropertiesValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LinstorSatelliteConfigurationSpecStoragePools
 */
export interface LinstorSatelliteConfigurationSpecStoragePools {
  /**
   * Configures a file system based storage pool, allocating a regular file per volume.
   *
   * @schema LinstorSatelliteConfigurationSpecStoragePools#filePool
   */
  readonly filePool?: LinstorSatelliteConfigurationSpecStoragePoolsFilePool;

  /**
   * Configures a file system based storage pool, allocating a sparse file per volume.
   *
   * @schema LinstorSatelliteConfigurationSpecStoragePools#fileThinPool
   */
  readonly fileThinPool?: LinstorSatelliteConfigurationSpecStoragePoolsFileThinPool;

  /**
   * Configures a LVM Volume Group as storage pool.
   *
   * @schema LinstorSatelliteConfigurationSpecStoragePools#lvmPool
   */
  readonly lvmPool?: LinstorSatelliteConfigurationSpecStoragePoolsLvmPool;

  /**
   * Configures a LVM Thin Pool as storage pool.
   *
   * @schema LinstorSatelliteConfigurationSpecStoragePools#lvmThinPool
   */
  readonly lvmThinPool?: LinstorSatelliteConfigurationSpecStoragePoolsLvmThinPool;

  /**
   * Name of the storage pool in linstor.
   *
   * @schema LinstorSatelliteConfigurationSpecStoragePools#name
   */
  readonly name: string;

  /**
   * Properties to set on the storage pool.
   *
   * @schema LinstorSatelliteConfigurationSpecStoragePools#properties
   */
  readonly properties?: LinstorSatelliteConfigurationSpecStoragePoolsProperties[];

  /**
   * @schema LinstorSatelliteConfigurationSpecStoragePools#source
   */
  readonly source?: LinstorSatelliteConfigurationSpecStoragePoolsSource;

  /**
   * Configures a ZFS system based storage pool, allocating zvols from the given zpool.
   *
   * @schema LinstorSatelliteConfigurationSpecStoragePools#zfsPool
   */
  readonly zfsPool?: LinstorSatelliteConfigurationSpecStoragePoolsZfsPool;

  /**
   * Configures a ZFS system based storage pool, allocating sparse zvols from the given zpool.
   *
   * @schema LinstorSatelliteConfigurationSpecStoragePools#zfsThinPool
   */
  readonly zfsThinPool?: LinstorSatelliteConfigurationSpecStoragePoolsZfsThinPool;

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationSpecStoragePools' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationSpecStoragePools(obj: LinstorSatelliteConfigurationSpecStoragePools | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filePool': toJson_LinstorSatelliteConfigurationSpecStoragePoolsFilePool(obj.filePool),
    'fileThinPool': toJson_LinstorSatelliteConfigurationSpecStoragePoolsFileThinPool(obj.fileThinPool),
    'lvmPool': toJson_LinstorSatelliteConfigurationSpecStoragePoolsLvmPool(obj.lvmPool),
    'lvmThinPool': toJson_LinstorSatelliteConfigurationSpecStoragePoolsLvmThinPool(obj.lvmThinPool),
    'name': obj.name,
    'properties': obj.properties?.map(y => toJson_LinstorSatelliteConfigurationSpecStoragePoolsProperties(y)),
    'source': toJson_LinstorSatelliteConfigurationSpecStoragePoolsSource(obj.source),
    'zfsPool': toJson_LinstorSatelliteConfigurationSpecStoragePoolsZfsPool(obj.zfsPool),
    'zfsThinPool': toJson_LinstorSatelliteConfigurationSpecStoragePoolsZfsThinPool(obj.zfsThinPool),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CAReference configures the CA certificate to use when validating TLS certificates.
 * If not set, the TLS secret is expected to contain a "ca.crt" containing the CA certificate.
 *
 * @schema LinstorSatelliteConfigurationSpecInternalTlsCaReference
 */
export interface LinstorSatelliteConfigurationSpecInternalTlsCaReference {
  /**
   * Key to select in the resource.
   * Defaults to ca.crt if not specified.
   *
   * @default ca.crt if not specified.
   * @schema LinstorSatelliteConfigurationSpecInternalTlsCaReference#key
   */
  readonly key?: string;

  /**
   * Kind of the resource containing the CA Certificate, either a ConfigMap or Secret.
   *
   * @schema LinstorSatelliteConfigurationSpecInternalTlsCaReference#kind
   */
  readonly kind?: LinstorSatelliteConfigurationSpecInternalTlsCaReferenceKind;

  /**
   * Name of the resource containing the CA Certificate.
   *
   * @schema LinstorSatelliteConfigurationSpecInternalTlsCaReference#name
   */
  readonly name: string;

  /**
   * Optional specifies whether the resource and its key must exist.
   *
   * @schema LinstorSatelliteConfigurationSpecInternalTlsCaReference#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationSpecInternalTlsCaReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationSpecInternalTlsCaReference(obj: LinstorSatelliteConfigurationSpecInternalTlsCaReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'kind': obj.kind,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertManager references a cert-manager Issuer or ClusterIssuer.
 * If set, a Certificate resource will be created, provisioning the secret references in SecretName using the
 * issuer configured here.
 *
 * @schema LinstorSatelliteConfigurationSpecInternalTlsCertManager
 */
export interface LinstorSatelliteConfigurationSpecInternalTlsCertManager {
  /**
   * Group of the resource being referred to.
   *
   * @schema LinstorSatelliteConfigurationSpecInternalTlsCertManager#group
   */
  readonly group?: string;

  /**
   * Kind of the resource being referred to.
   *
   * @schema LinstorSatelliteConfigurationSpecInternalTlsCertManager#kind
   */
  readonly kind?: string;

  /**
   * Name of the resource being referred to.
   *
   * @schema LinstorSatelliteConfigurationSpecInternalTlsCertManager#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationSpecInternalTlsCertManager' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationSpecInternalTlsCertManager(obj: LinstorSatelliteConfigurationSpecInternalTlsCertManager | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTerms
 */
export interface LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTerms#matchFields
   */
  readonly matchFields?: LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTerms(obj: LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Target points to the resources that the patch is applied to
 *
 * @schema LinstorSatelliteConfigurationSpecPatchesTarget
 */
export interface LinstorSatelliteConfigurationSpecPatchesTarget {
  /**
   * AnnotationSelector is a string that follows the label selection expression
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api
   * It matches against the resource annotations.
   *
   * @schema LinstorSatelliteConfigurationSpecPatchesTarget#annotationSelector
   */
  readonly annotationSelector?: string;

  /**
   * @schema LinstorSatelliteConfigurationSpecPatchesTarget#group
   */
  readonly group?: string;

  /**
   * @schema LinstorSatelliteConfigurationSpecPatchesTarget#kind
   */
  readonly kind?: string;

  /**
   * LabelSelector is a string that follows the label selection expression
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api
   * It matches against the resource labels.
   *
   * @schema LinstorSatelliteConfigurationSpecPatchesTarget#labelSelector
   */
  readonly labelSelector?: string;

  /**
   * Name of the resource.
   *
   * @schema LinstorSatelliteConfigurationSpecPatchesTarget#name
   */
  readonly name?: string;

  /**
   * Namespace the resource belongs to, if it can belong to a namespace.
   *
   * @schema LinstorSatelliteConfigurationSpecPatchesTarget#namespace
   */
  readonly namespace?: string;

  /**
   * @schema LinstorSatelliteConfigurationSpecPatchesTarget#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationSpecPatchesTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationSpecPatchesTarget(obj: LinstorSatelliteConfigurationSpecPatchesTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotationSelector': obj.annotationSelector,
    'group': obj.group,
    'kind': obj.kind,
    'labelSelector': obj.labelSelector,
    'name': obj.name,
    'namespace': obj.namespace,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExpandFrom can reference multiple resource fields at once.
 * It either sets the property to an aggregate value based on matched resource fields, or expands to multiple
 * properties.
 *
 * @schema LinstorSatelliteConfigurationSpecPropertiesExpandFrom
 */
export interface LinstorSatelliteConfigurationSpecPropertiesExpandFrom {
  /**
   * Delimiter used to join multiple key and value pairs together.
   *
   * @schema LinstorSatelliteConfigurationSpecPropertiesExpandFrom#delimiter
   */
  readonly delimiter?: string;

  /**
   * NameTemplate defines how the property key is expanded.
   * If set, the template is appended to the defined property name, creating multiple properties instead of one
   * aggregate.
   * * $1 is replaced with the matched key.
   * * $2 is replaced with the matched value.
   *
   * @schema LinstorSatelliteConfigurationSpecPropertiesExpandFrom#nameTemplate
   */
  readonly nameTemplate?: string;

  /**
   * Select a field of the node. Supports `metadata.name`, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`.
   *
   * @schema LinstorSatelliteConfigurationSpecPropertiesExpandFrom#nodeFieldRef
   */
  readonly nodeFieldRef: string;

  /**
   * ValueTemplate defines how the property value is expanded.
   * * $1 is replaced with the matched key.
   * * $2 is replaced with the matched value.
   *
   * @schema LinstorSatelliteConfigurationSpecPropertiesExpandFrom#valueTemplate
   */
  readonly valueTemplate?: string;

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationSpecPropertiesExpandFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationSpecPropertiesExpandFrom(obj: LinstorSatelliteConfigurationSpecPropertiesExpandFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'delimiter': obj.delimiter,
    'nameTemplate': obj.nameTemplate,
    'nodeFieldRef': obj.nodeFieldRef,
    'valueTemplate': obj.valueTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ValueFrom sets the value from an existing resource.
 *
 * @schema LinstorSatelliteConfigurationSpecPropertiesValueFrom
 */
export interface LinstorSatelliteConfigurationSpecPropertiesValueFrom {
  /**
   * Select a field of the node. Supports `metadata.name`, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`.
   *
   * @schema LinstorSatelliteConfigurationSpecPropertiesValueFrom#nodeFieldRef
   */
  readonly nodeFieldRef: string;

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationSpecPropertiesValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationSpecPropertiesValueFrom(obj: LinstorSatelliteConfigurationSpecPropertiesValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeFieldRef': obj.nodeFieldRef,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures a file system based storage pool, allocating a regular file per volume.
 *
 * @schema LinstorSatelliteConfigurationSpecStoragePoolsFilePool
 */
export interface LinstorSatelliteConfigurationSpecStoragePoolsFilePool {
  /**
   * Directory is the path to the host directory used to store volume data.
   *
   * @schema LinstorSatelliteConfigurationSpecStoragePoolsFilePool#directory
   */
  readonly directory?: string;

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationSpecStoragePoolsFilePool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationSpecStoragePoolsFilePool(obj: LinstorSatelliteConfigurationSpecStoragePoolsFilePool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures a file system based storage pool, allocating a sparse file per volume.
 *
 * @schema LinstorSatelliteConfigurationSpecStoragePoolsFileThinPool
 */
export interface LinstorSatelliteConfigurationSpecStoragePoolsFileThinPool {
  /**
   * Directory is the path to the host directory used to store volume data.
   *
   * @schema LinstorSatelliteConfigurationSpecStoragePoolsFileThinPool#directory
   */
  readonly directory?: string;

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationSpecStoragePoolsFileThinPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationSpecStoragePoolsFileThinPool(obj: LinstorSatelliteConfigurationSpecStoragePoolsFileThinPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures a LVM Volume Group as storage pool.
 *
 * @schema LinstorSatelliteConfigurationSpecStoragePoolsLvmPool
 */
export interface LinstorSatelliteConfigurationSpecStoragePoolsLvmPool {
  /**
   * @schema LinstorSatelliteConfigurationSpecStoragePoolsLvmPool#volumeGroup
   */
  readonly volumeGroup?: string;

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationSpecStoragePoolsLvmPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationSpecStoragePoolsLvmPool(obj: LinstorSatelliteConfigurationSpecStoragePoolsLvmPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeGroup': obj.volumeGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures a LVM Thin Pool as storage pool.
 *
 * @schema LinstorSatelliteConfigurationSpecStoragePoolsLvmThinPool
 */
export interface LinstorSatelliteConfigurationSpecStoragePoolsLvmThinPool {
  /**
   * ThinPool is the name of the thinpool LV (without VG prefix).
   *
   * @schema LinstorSatelliteConfigurationSpecStoragePoolsLvmThinPool#thinPool
   */
  readonly thinPool?: string;

  /**
   * @schema LinstorSatelliteConfigurationSpecStoragePoolsLvmThinPool#volumeGroup
   */
  readonly volumeGroup?: string;

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationSpecStoragePoolsLvmThinPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationSpecStoragePoolsLvmThinPool(obj: LinstorSatelliteConfigurationSpecStoragePoolsLvmThinPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'thinPool': obj.thinPool,
    'volumeGroup': obj.volumeGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LinstorSatelliteConfigurationSpecStoragePoolsProperties
 */
export interface LinstorSatelliteConfigurationSpecStoragePoolsProperties {
  /**
   * ExpandFrom can reference multiple resource fields at once.
   * It either sets the property to an aggregate value based on matched resource fields, or expands to multiple
   * properties.
   *
   * @schema LinstorSatelliteConfigurationSpecStoragePoolsProperties#expandFrom
   */
  readonly expandFrom?: LinstorSatelliteConfigurationSpecStoragePoolsPropertiesExpandFrom;

  /**
   * Name of the property to set.
   *
   * @schema LinstorSatelliteConfigurationSpecStoragePoolsProperties#name
   */
  readonly name: string;

  /**
   * Optional values are only set if they have a non-empty value
   *
   * @schema LinstorSatelliteConfigurationSpecStoragePoolsProperties#optional
   */
  readonly optional?: boolean;

  /**
   * Value to set the property to.
   *
   * @schema LinstorSatelliteConfigurationSpecStoragePoolsProperties#value
   */
  readonly value?: string;

  /**
   * ValueFrom sets the value from an existing resource.
   *
   * @schema LinstorSatelliteConfigurationSpecStoragePoolsProperties#valueFrom
   */
  readonly valueFrom?: LinstorSatelliteConfigurationSpecStoragePoolsPropertiesValueFrom;

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationSpecStoragePoolsProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationSpecStoragePoolsProperties(obj: LinstorSatelliteConfigurationSpecStoragePoolsProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expandFrom': toJson_LinstorSatelliteConfigurationSpecStoragePoolsPropertiesExpandFrom(obj.expandFrom),
    'name': obj.name,
    'optional': obj.optional,
    'value': obj.value,
    'valueFrom': toJson_LinstorSatelliteConfigurationSpecStoragePoolsPropertiesValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LinstorSatelliteConfigurationSpecStoragePoolsSource
 */
export interface LinstorSatelliteConfigurationSpecStoragePoolsSource {
  /**
   * HostDevices is a list of device paths used to configure the given pool.
   *
   * @schema LinstorSatelliteConfigurationSpecStoragePoolsSource#hostDevices
   */
  readonly hostDevices?: string[];

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationSpecStoragePoolsSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationSpecStoragePoolsSource(obj: LinstorSatelliteConfigurationSpecStoragePoolsSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostDevices': obj.hostDevices?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures a ZFS system based storage pool, allocating zvols from the given zpool.
 *
 * @schema LinstorSatelliteConfigurationSpecStoragePoolsZfsPool
 */
export interface LinstorSatelliteConfigurationSpecStoragePoolsZfsPool {
  /**
   * ZPool is the name of the ZFS zpool.
   *
   * @schema LinstorSatelliteConfigurationSpecStoragePoolsZfsPool#zPool
   */
  readonly zPool?: string;

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationSpecStoragePoolsZfsPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationSpecStoragePoolsZfsPool(obj: LinstorSatelliteConfigurationSpecStoragePoolsZfsPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'zPool': obj.zPool,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures a ZFS system based storage pool, allocating sparse zvols from the given zpool.
 *
 * @schema LinstorSatelliteConfigurationSpecStoragePoolsZfsThinPool
 */
export interface LinstorSatelliteConfigurationSpecStoragePoolsZfsThinPool {
  /**
   * ZPool is the name of the ZFS zpool.
   *
   * @schema LinstorSatelliteConfigurationSpecStoragePoolsZfsThinPool#zPool
   */
  readonly zPool?: string;

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationSpecStoragePoolsZfsThinPool' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationSpecStoragePoolsZfsThinPool(obj: LinstorSatelliteConfigurationSpecStoragePoolsZfsThinPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'zPool': obj.zPool,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kind of the resource containing the CA Certificate, either a ConfigMap or Secret.
 *
 * @schema LinstorSatelliteConfigurationSpecInternalTlsCaReferenceKind
 */
export enum LinstorSatelliteConfigurationSpecInternalTlsCaReferenceKind {
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
  /** Secret */
  SECRET = "Secret",
}

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTermsMatchExpressions
 */
export interface LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTermsMatchExpressions(obj: LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTermsMatchFields
 */
export interface LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTermsMatchFields(obj: LinstorSatelliteConfigurationSpecNodeAffinityNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExpandFrom can reference multiple resource fields at once.
 * It either sets the property to an aggregate value based on matched resource fields, or expands to multiple
 * properties.
 *
 * @schema LinstorSatelliteConfigurationSpecStoragePoolsPropertiesExpandFrom
 */
export interface LinstorSatelliteConfigurationSpecStoragePoolsPropertiesExpandFrom {
  /**
   * Delimiter used to join multiple key and value pairs together.
   *
   * @schema LinstorSatelliteConfigurationSpecStoragePoolsPropertiesExpandFrom#delimiter
   */
  readonly delimiter?: string;

  /**
   * NameTemplate defines how the property key is expanded.
   * If set, the template is appended to the defined property name, creating multiple properties instead of one
   * aggregate.
   * * $1 is replaced with the matched key.
   * * $2 is replaced with the matched value.
   *
   * @schema LinstorSatelliteConfigurationSpecStoragePoolsPropertiesExpandFrom#nameTemplate
   */
  readonly nameTemplate?: string;

  /**
   * Select a field of the node. Supports `metadata.name`, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`.
   *
   * @schema LinstorSatelliteConfigurationSpecStoragePoolsPropertiesExpandFrom#nodeFieldRef
   */
  readonly nodeFieldRef: string;

  /**
   * ValueTemplate defines how the property value is expanded.
   * * $1 is replaced with the matched key.
   * * $2 is replaced with the matched value.
   *
   * @schema LinstorSatelliteConfigurationSpecStoragePoolsPropertiesExpandFrom#valueTemplate
   */
  readonly valueTemplate?: string;

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationSpecStoragePoolsPropertiesExpandFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationSpecStoragePoolsPropertiesExpandFrom(obj: LinstorSatelliteConfigurationSpecStoragePoolsPropertiesExpandFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'delimiter': obj.delimiter,
    'nameTemplate': obj.nameTemplate,
    'nodeFieldRef': obj.nodeFieldRef,
    'valueTemplate': obj.valueTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ValueFrom sets the value from an existing resource.
 *
 * @schema LinstorSatelliteConfigurationSpecStoragePoolsPropertiesValueFrom
 */
export interface LinstorSatelliteConfigurationSpecStoragePoolsPropertiesValueFrom {
  /**
   * Select a field of the node. Supports `metadata.name`, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`.
   *
   * @schema LinstorSatelliteConfigurationSpecStoragePoolsPropertiesValueFrom#nodeFieldRef
   */
  readonly nodeFieldRef: string;

}

/**
 * Converts an object of type 'LinstorSatelliteConfigurationSpecStoragePoolsPropertiesValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinstorSatelliteConfigurationSpecStoragePoolsPropertiesValueFrom(obj: LinstorSatelliteConfigurationSpecStoragePoolsPropertiesValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeFieldRef': obj.nodeFieldRef,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

