// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 *
 *
 * @schema Bundle
 */
export class Bundle extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Bundle"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'trust.cert-manager.io/v1alpha1',
    kind: 'Bundle',
  }

  /**
   * Renders a Kubernetes manifest for "Bundle".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BundleProps): any {
    return {
      ...Bundle.GVK,
      ...toJson_BundleProps(props),
    };
  }

  /**
   * Defines a "Bundle" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BundleProps) {
    super(scope, id, {
      ...Bundle.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Bundle.GVK,
      ...toJson_BundleProps(resolved),
    };
  }
}

/**
 * @schema Bundle
 */
export interface BundleProps {
  /**
   * @schema Bundle#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Desired state of the Bundle resource.
   *
   * @schema Bundle#spec
   */
  readonly spec: BundleSpec;

}

/**
 * Converts an object of type 'BundleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BundleProps(obj: BundleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BundleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Desired state of the Bundle resource.
 *
 * @schema BundleSpec
 */
export interface BundleSpec {
  /**
   * Sources is a set of references to data whose data will sync to the target.
   *
   * @schema BundleSpec#sources
   */
  readonly sources: BundleSpecSources[];

  /**
   * Target is the target location in all namespaces to sync source data to.
   *
   * @schema BundleSpec#target
   */
  readonly target: BundleSpecTarget;

}

/**
 * Converts an object of type 'BundleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BundleSpec(obj: BundleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sources': obj.sources?.map(y => toJson_BundleSpecSources(y)),
    'target': toJson_BundleSpecTarget(obj.target),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BundleSource is the set of sources whose data will be appended and synced to
 * the BundleTarget in all Namespaces.
 *
 * @schema BundleSpecSources
 */
export interface BundleSpecSources {
  /**
   * ConfigMap is a reference (by name) to a ConfigMap's `data` key, or to a
   * list of ConfigMap's `data` key using label selector, in the trust Namespace.
   *
   * @schema BundleSpecSources#configMap
   */
  readonly configMap?: BundleSpecSourcesConfigMap;

  /**
   * InLine is a simple string to append as the source data.
   *
   * @schema BundleSpecSources#inLine
   */
  readonly inLine?: string;

  /**
   * Secret is a reference (by name) to a Secret's `data` key, or to a
   * list of Secret's `data` key using label selector, in the trust Namespace.
   *
   * @schema BundleSpecSources#secret
   */
  readonly secret?: BundleSpecSourcesSecret;

  /**
   * UseDefaultCAs, when true, requests the default CA bundle to be used as a source.
   * Default CAs are available if trust-manager was installed via Helm
   * or was otherwise set up to include a package-injecting init container by using the
   * "--default-package-location" flag when starting the trust-manager controller.
   * If default CAs were not configured at start-up, any request to use the default
   * CAs will fail.
   * The version of the default CA package which is used for a Bundle is stored in the
   * defaultCAPackageVersion field of the Bundle's status field.
   *
   * @schema BundleSpecSources#useDefaultCAs
   */
  readonly useDefaultCAs?: boolean;

}

/**
 * Converts an object of type 'BundleSpecSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BundleSpecSources(obj: BundleSpecSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_BundleSpecSourcesConfigMap(obj.configMap),
    'inLine': obj.inLine,
    'secret': toJson_BundleSpecSourcesSecret(obj.secret),
    'useDefaultCAs': obj.useDefaultCAs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Target is the target location in all namespaces to sync source data to.
 *
 * @schema BundleSpecTarget
 */
export interface BundleSpecTarget {
  /**
   * AdditionalFormats specifies any additional formats to write to the target
   *
   * @schema BundleSpecTarget#additionalFormats
   */
  readonly additionalFormats?: BundleSpecTargetAdditionalFormats;

  /**
   * ConfigMap is the target ConfigMap in Namespaces that all Bundle source
   * data will be synced to.
   *
   * @schema BundleSpecTarget#configMap
   */
  readonly configMap?: BundleSpecTargetConfigMap;

  /**
   * NamespaceSelector will, if set, only sync the target resource in
   * Namespaces which match the selector.
   *
   * @schema BundleSpecTarget#namespaceSelector
   */
  readonly namespaceSelector?: BundleSpecTargetNamespaceSelector;

  /**
   * Secret is the target Secret that all Bundle source data will be synced to.
   * Using Secrets as targets is only supported if enabled at trust-manager startup.
   * By default, trust-manager has no permissions for writing to secrets and can only read secrets in the trust namespace.
   *
   * @schema BundleSpecTarget#secret
   */
  readonly secret?: BundleSpecTargetSecret;

}

/**
 * Converts an object of type 'BundleSpecTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BundleSpecTarget(obj: BundleSpecTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalFormats': toJson_BundleSpecTargetAdditionalFormats(obj.additionalFormats),
    'configMap': toJson_BundleSpecTargetConfigMap(obj.configMap),
    'namespaceSelector': toJson_BundleSpecTargetNamespaceSelector(obj.namespaceSelector),
    'secret': toJson_BundleSpecTargetSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap is a reference (by name) to a ConfigMap's `data` key, or to a
 * list of ConfigMap's `data` key using label selector, in the trust Namespace.
 *
 * @schema BundleSpecSourcesConfigMap
 */
export interface BundleSpecSourcesConfigMap {
  /**
   * Key is the key of the entry in the object's `data` field to be used.
   *
   * @schema BundleSpecSourcesConfigMap#key
   */
  readonly key: string;

  /**
   * Name is the name of the source object in the trust Namespace.
   * This field must be left empty when `selector` is set
   *
   * @schema BundleSpecSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * Selector is the label selector to use to fetch a list of objects. Must not be set
   * when `Name` is set.
   *
   * @schema BundleSpecSourcesConfigMap#selector
   */
  readonly selector?: BundleSpecSourcesConfigMapSelector;

}

/**
 * Converts an object of type 'BundleSpecSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BundleSpecSourcesConfigMap(obj: BundleSpecSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'selector': toJson_BundleSpecSourcesConfigMapSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret is a reference (by name) to a Secret's `data` key, or to a
 * list of Secret's `data` key using label selector, in the trust Namespace.
 *
 * @schema BundleSpecSourcesSecret
 */
export interface BundleSpecSourcesSecret {
  /**
   * Key is the key of the entry in the object's `data` field to be used.
   *
   * @schema BundleSpecSourcesSecret#key
   */
  readonly key: string;

  /**
   * Name is the name of the source object in the trust Namespace.
   * This field must be left empty when `selector` is set
   *
   * @schema BundleSpecSourcesSecret#name
   */
  readonly name?: string;

  /**
   * Selector is the label selector to use to fetch a list of objects. Must not be set
   * when `Name` is set.
   *
   * @schema BundleSpecSourcesSecret#selector
   */
  readonly selector?: BundleSpecSourcesSecretSelector;

}

/**
 * Converts an object of type 'BundleSpecSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BundleSpecSourcesSecret(obj: BundleSpecSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'selector': toJson_BundleSpecSourcesSecretSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AdditionalFormats specifies any additional formats to write to the target
 *
 * @schema BundleSpecTargetAdditionalFormats
 */
export interface BundleSpecTargetAdditionalFormats {
  /**
   * JKS requests a JKS-formatted binary trust bundle to be written to the target.
   * The bundle has "changeit" as the default password.
   * For more information refer to this link https://cert-manager.io/docs/faq/#keystore-passwords
   *
   * @schema BundleSpecTargetAdditionalFormats#jks
   */
  readonly jks?: BundleSpecTargetAdditionalFormatsJks;

  /**
   * PKCS12 requests a PKCS12-formatted binary trust bundle to be written to the target.
   * The bundle is by default created without a password.
   *
   * @schema BundleSpecTargetAdditionalFormats#pkcs12
   */
  readonly pkcs12?: BundleSpecTargetAdditionalFormatsPkcs12;

}

/**
 * Converts an object of type 'BundleSpecTargetAdditionalFormats' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BundleSpecTargetAdditionalFormats(obj: BundleSpecTargetAdditionalFormats | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jks': toJson_BundleSpecTargetAdditionalFormatsJks(obj.jks),
    'pkcs12': toJson_BundleSpecTargetAdditionalFormatsPkcs12(obj.pkcs12),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap is the target ConfigMap in Namespaces that all Bundle source
 * data will be synced to.
 *
 * @schema BundleSpecTargetConfigMap
 */
export interface BundleSpecTargetConfigMap {
  /**
   * Key is the key of the entry in the object's `data` field to be used.
   *
   * @schema BundleSpecTargetConfigMap#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'BundleSpecTargetConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BundleSpecTargetConfigMap(obj: BundleSpecTargetConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamespaceSelector will, if set, only sync the target resource in
 * Namespaces which match the selector.
 *
 * @schema BundleSpecTargetNamespaceSelector
 */
export interface BundleSpecTargetNamespaceSelector {
  /**
   * MatchLabels matches on the set of labels that must be present on a
   * Namespace for the Bundle target to be synced there.
   *
   * @schema BundleSpecTargetNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'BundleSpecTargetNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BundleSpecTargetNamespaceSelector(obj: BundleSpecTargetNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret is the target Secret that all Bundle source data will be synced to.
 * Using Secrets as targets is only supported if enabled at trust-manager startup.
 * By default, trust-manager has no permissions for writing to secrets and can only read secrets in the trust namespace.
 *
 * @schema BundleSpecTargetSecret
 */
export interface BundleSpecTargetSecret {
  /**
   * Key is the key of the entry in the object's `data` field to be used.
   *
   * @schema BundleSpecTargetSecret#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'BundleSpecTargetSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BundleSpecTargetSecret(obj: BundleSpecTargetSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector is the label selector to use to fetch a list of objects. Must not be set
 * when `Name` is set.
 *
 * @schema BundleSpecSourcesConfigMapSelector
 */
export interface BundleSpecSourcesConfigMapSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema BundleSpecSourcesConfigMapSelector#matchExpressions
   */
  readonly matchExpressions?: BundleSpecSourcesConfigMapSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema BundleSpecSourcesConfigMapSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'BundleSpecSourcesConfigMapSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BundleSpecSourcesConfigMapSelector(obj: BundleSpecSourcesConfigMapSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_BundleSpecSourcesConfigMapSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector is the label selector to use to fetch a list of objects. Must not be set
 * when `Name` is set.
 *
 * @schema BundleSpecSourcesSecretSelector
 */
export interface BundleSpecSourcesSecretSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema BundleSpecSourcesSecretSelector#matchExpressions
   */
  readonly matchExpressions?: BundleSpecSourcesSecretSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema BundleSpecSourcesSecretSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'BundleSpecSourcesSecretSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BundleSpecSourcesSecretSelector(obj: BundleSpecSourcesSecretSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_BundleSpecSourcesSecretSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JKS requests a JKS-formatted binary trust bundle to be written to the target.
 * The bundle has "changeit" as the default password.
 * For more information refer to this link https://cert-manager.io/docs/faq/#keystore-passwords
 *
 * @schema BundleSpecTargetAdditionalFormatsJks
 */
export interface BundleSpecTargetAdditionalFormatsJks {
  /**
   * Key is the key of the entry in the object's `data` field to be used.
   *
   * @schema BundleSpecTargetAdditionalFormatsJks#key
   */
  readonly key: string;

  /**
   * Password for JKS trust store
   *
   * @schema BundleSpecTargetAdditionalFormatsJks#password
   */
  readonly password?: string;

}

/**
 * Converts an object of type 'BundleSpecTargetAdditionalFormatsJks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BundleSpecTargetAdditionalFormatsJks(obj: BundleSpecTargetAdditionalFormatsJks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'password': obj.password,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PKCS12 requests a PKCS12-formatted binary trust bundle to be written to the target.
 * The bundle is by default created without a password.
 *
 * @schema BundleSpecTargetAdditionalFormatsPkcs12
 */
export interface BundleSpecTargetAdditionalFormatsPkcs12 {
  /**
   * Key is the key of the entry in the object's `data` field to be used.
   *
   * @schema BundleSpecTargetAdditionalFormatsPkcs12#key
   */
  readonly key: string;

  /**
   * Password for PKCS12 trust store
   *
   * @schema BundleSpecTargetAdditionalFormatsPkcs12#password
   */
  readonly password?: string;

}

/**
 * Converts an object of type 'BundleSpecTargetAdditionalFormatsPkcs12' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BundleSpecTargetAdditionalFormatsPkcs12(obj: BundleSpecTargetAdditionalFormatsPkcs12 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'password': obj.password,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema BundleSpecSourcesConfigMapSelectorMatchExpressions
 */
export interface BundleSpecSourcesConfigMapSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema BundleSpecSourcesConfigMapSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema BundleSpecSourcesConfigMapSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema BundleSpecSourcesConfigMapSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'BundleSpecSourcesConfigMapSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BundleSpecSourcesConfigMapSelectorMatchExpressions(obj: BundleSpecSourcesConfigMapSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema BundleSpecSourcesSecretSelectorMatchExpressions
 */
export interface BundleSpecSourcesSecretSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema BundleSpecSourcesSecretSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema BundleSpecSourcesSecretSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema BundleSpecSourcesSecretSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'BundleSpecSourcesSecretSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BundleSpecSourcesSecretSelectorMatchExpressions(obj: BundleSpecSourcesSecretSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

