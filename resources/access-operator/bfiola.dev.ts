// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Access specifies the current connectivity to cluster resources
 *
 * @schema Access
 */
export class Access extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Access"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'bfiola.dev/v1',
    kind: 'Access',
  }

  /**
   * Renders a Kubernetes manifest for "Access".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AccessProps): any {
    return {
      ...Access.GVK,
      ...toJson_AccessProps(props),
    };
  }

  /**
   * Defines a "Access" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AccessProps) {
    super(scope, id, {
      ...Access.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Access.GVK,
      ...toJson_AccessProps(resolved),
    };
  }
}

/**
 * Access specifies the current connectivity to cluster resources
 *
 * @schema Access
 */
export interface AccessProps {
  /**
   * @schema Access#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AccessSpec defines the desired state of Access
   *
   * @schema Access#spec
   */
  readonly spec: AccessSpec;

}

/**
 * Converts an object of type 'AccessProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessProps(obj: AccessProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AccessSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessSpec defines the desired state of Access
 *
 * @schema AccessSpec
 */
export interface AccessSpec {
  /**
   * @schema AccessSpec#dns
   */
  readonly dns: string;

  /**
   * IngressSpec describes the Ingress the user wishes to exist.
   *
   * @schema AccessSpec#ingressTemplate
   */
  readonly ingressTemplate?: AccessSpecIngressTemplate;

  /**
   * @schema AccessSpec#members
   */
  readonly members: AccessSpecMembers[];

  /**
   * SecretKeyRef defines a reference to a key of a secret resource
   *
   * @schema AccessSpec#passwordRef
   */
  readonly passwordRef: AccessSpecPasswordRef;

  /**
   * @schema AccessSpec#serviceTemplates
   */
  readonly serviceTemplates?: AccessSpecServiceTemplates[];

  /**
   * @schema AccessSpec#ttl
   */
  readonly ttl: string;

}

/**
 * Converts an object of type 'AccessSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessSpec(obj: AccessSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dns': obj.dns,
    'ingressTemplate': toJson_AccessSpecIngressTemplate(obj.ingressTemplate),
    'members': obj.members?.map(y => toJson_AccessSpecMembers(y)),
    'passwordRef': toJson_AccessSpecPasswordRef(obj.passwordRef),
    'serviceTemplates': obj.serviceTemplates?.map(y => toJson_AccessSpecServiceTemplates(y)),
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IngressSpec describes the Ingress the user wishes to exist.
 *
 * @schema AccessSpecIngressTemplate
 */
export interface AccessSpecIngressTemplate {
  /**
   * defaultBackend is the backend that should handle requests that don't
   * match any rule. If Rules are not specified, DefaultBackend must be specified.
   * If DefaultBackend is not set, the handling of requests that do not match any
   * of the rules will be up to the Ingress controller.
   *
   * @schema AccessSpecIngressTemplate#defaultBackend
   */
  readonly defaultBackend?: AccessSpecIngressTemplateDefaultBackend;

  /**
   * ingressClassName is the name of an IngressClass cluster resource. Ingress
   * controller implementations use this field to know whether they should be
   * serving this Ingress resource, by a transitive connection
   * (controller -> IngressClass -> Ingress resource). Although the
   * `kubernetes.io/ingress.class` annotation (simple constant name) was never
   * formally defined, it was widely supported by Ingress controllers to create
   * a direct binding between Ingress controller and Ingress resources. Newly
   * created Ingress resources should prefer using the field. However, even
   * though the annotation is officially deprecated, for backwards compatibility
   * reasons, ingress controllers should still honor that annotation if present.
   *
   * @schema AccessSpecIngressTemplate#ingressClassName
   */
  readonly ingressClassName?: string;

  /**
   * rules is a list of host rules used to configure the Ingress. If unspecified,
   * or no rule matches, all traffic is sent to the default backend.
   *
   * @schema AccessSpecIngressTemplate#rules
   */
  readonly rules?: AccessSpecIngressTemplateRules[];

  /**
   * tls represents the TLS configuration. Currently the Ingress only supports a
   * single TLS port, 443. If multiple members of this list specify different hosts,
   * they will be multiplexed on the same port according to the hostname specified
   * through the SNI TLS extension, if the ingress controller fulfilling the
   * ingress supports SNI.
   *
   * @schema AccessSpecIngressTemplate#tls
   */
  readonly tls?: AccessSpecIngressTemplateTls[];

}

/**
 * Converts an object of type 'AccessSpecIngressTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessSpecIngressTemplate(obj: AccessSpecIngressTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultBackend': toJson_AccessSpecIngressTemplateDefaultBackend(obj.defaultBackend),
    'ingressClassName': obj.ingressClassName,
    'rules': obj.rules?.map(y => toJson_AccessSpecIngressTemplateRules(y)),
    'tls': obj.tls?.map(y => toJson_AccessSpecIngressTemplateTls(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessSpecMembers
 */
export interface AccessSpecMembers {
  /**
   * @schema AccessSpecMembers#cidr
   */
  readonly cidr: string;

  /**
   * @schema AccessSpecMembers#expires
   */
  readonly expires: string;

}

/**
 * Converts an object of type 'AccessSpecMembers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessSpecMembers(obj: AccessSpecMembers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'expires': obj.expires,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeyRef defines a reference to a key of a secret resource
 *
 * @schema AccessSpecPasswordRef
 */
export interface AccessSpecPasswordRef {
  /**
   * @schema AccessSpecPasswordRef#key
   */
  readonly key: string;

  /**
   * @schema AccessSpecPasswordRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AccessSpecPasswordRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessSpecPasswordRef(obj: AccessSpecPasswordRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceSpec describes the attributes that a user creates on a service.
 *
 * @schema AccessSpecServiceTemplates
 */
export interface AccessSpecServiceTemplates {
  /**
   * allocateLoadBalancerNodePorts defines if NodePorts will be automatically
   * allocated for services with type LoadBalancer.  Default is "true". It
   * may be set to "false" if the cluster load-balancer does not rely on
   * NodePorts.  If the caller requests specific NodePorts (by specifying a
   * value), those requests will be respected, regardless of this field.
   * This field may only be set for services with type LoadBalancer and will
   * be cleared if the type is changed to any other type.
   *
   * @default true". It
   * @schema AccessSpecServiceTemplates#allocateLoadBalancerNodePorts
   */
  readonly allocateLoadBalancerNodePorts?: boolean;

  /**
   * clusterIP is the IP address of the service and is usually assigned
   * randomly. If an address is specified manually, is in-range (as per
   * system configuration), and is not in use, it will be allocated to the
   * service; otherwise creation of the service will fail. This field may not
   * be changed through updates unless the type field is also being changed
   * to ExternalName (which requires this field to be blank) or the type
   * field is being changed from ExternalName (in which case this field may
   * optionally be specified, as describe above).  Valid values are "None",
   * empty string (""), or a valid IP address. Setting this to "None" makes a
   * "headless service" (no virtual IP), which is useful when direct endpoint
   * connections are preferred and proxying is not required.  Only applies to
   * types ClusterIP, NodePort, and LoadBalancer. If this field is specified
   * when creating a Service of type ExternalName, creation will fail. This
   * field will be wiped when updating a Service to type ExternalName.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   *
   * @schema AccessSpecServiceTemplates#clusterIP
   */
  readonly clusterIp?: string;

  /**
   * ClusterIPs is a list of IP addresses assigned to this service, and are
   * usually assigned randomly.  If an address is specified manually, is
   * in-range (as per system configuration), and is not in use, it will be
   * allocated to the service; otherwise creation of the service will fail.
   * This field may not be changed through updates unless the type field is
   * also being changed to ExternalName (which requires this field to be
   * empty) or the type field is being changed from ExternalName (in which
   * case this field may optionally be specified, as describe above).  Valid
   * values are "None", empty string (""), or a valid IP address.  Setting
   * this to "None" makes a "headless service" (no virtual IP), which is
   * useful when direct endpoint connections are preferred and proxying is
   * not required.  Only applies to types ClusterIP, NodePort, and
   * LoadBalancer. If this field is specified when creating a Service of type
   * ExternalName, creation will fail. This field will be wiped when updating
   * a Service to type ExternalName.  If this field is not specified, it will
   * be initialized from the clusterIP field.  If this field is specified,
   * clients must ensure that clusterIPs[0] and clusterIP have the same
   * value.
   *
   * This field may hold a maximum of two entries (dual-stack IPs, in either order).
   * These IPs must correspond to the values of the ipFamilies field. Both
   * clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   *
   * @schema AccessSpecServiceTemplates#clusterIPs
   */
  readonly clusterIPs?: string[];

  /**
   * externalIPs is a list of IP addresses for which nodes in the cluster
   * will also accept traffic for this service.  These IPs are not managed by
   * Kubernetes.  The user is responsible for ensuring that traffic arrives
   * at a node with this IP.  A common example is external load-balancers
   * that are not part of the Kubernetes system.
   *
   * @schema AccessSpecServiceTemplates#externalIPs
   */
  readonly externalIPs?: string[];

  /**
   * externalName is the external reference that discovery mechanisms will
   * return as an alias for this service (e.g. a DNS CNAME record). No
   * proxying will be involved.  Must be a lowercase RFC-1123 hostname
   * (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
   *
   * @schema AccessSpecServiceTemplates#externalName
   */
  readonly externalName?: string;

  /**
   * externalTrafficPolicy describes how nodes distribute service traffic they
   * receive on one of the Service's "externally-facing" addresses (NodePorts,
   * ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
   * the service in a way that assumes that external load balancers will take care
   * of balancing the service traffic between nodes, and so each node will deliver
   * traffic only to the node-local endpoints of the service, without masquerading
   * the client source IP. (Traffic mistakenly sent to a node with no endpoints will
   * be dropped.) The default value, "Cluster", uses the standard behavior of
   * routing to all endpoints evenly (possibly modified by topology and other
   * features). Note that traffic sent to an External IP or LoadBalancer IP from
   * within the cluster will always get "Cluster" semantics, but clients sending to
   * a NodePort from within the cluster may need to take traffic policy into account
   * when picking a node.
   *
   * @schema AccessSpecServiceTemplates#externalTrafficPolicy
   */
  readonly externalTrafficPolicy?: string;

  /**
   * healthCheckNodePort specifies the healthcheck nodePort for the service.
   * This only applies when type is set to LoadBalancer and
   * externalTrafficPolicy is set to Local. If a value is specified, is
   * in-range, and is not in use, it will be used.  If not specified, a value
   * will be automatically allocated.  External systems (e.g. load-balancers)
   * can use this port to determine if a given node holds endpoints for this
   * service or not.  If this field is specified when creating a Service
   * which does not need it, creation will fail. This field will be wiped
   * when updating a Service to no longer need it (e.g. changing type).
   * This field cannot be updated once set.
   *
   * @schema AccessSpecServiceTemplates#healthCheckNodePort
   */
  readonly healthCheckNodePort?: number;

  /**
   * InternalTrafficPolicy describes how nodes distribute service traffic they
   * receive on the ClusterIP. If set to "Local", the proxy will assume that pods
   * only want to talk to endpoints of the service on the same node as the pod,
   * dropping the traffic if there are no local endpoints. The default value,
   * "Cluster", uses the standard behavior of routing to all endpoints evenly
   * (possibly modified by topology and other features).
   *
   * @schema AccessSpecServiceTemplates#internalTrafficPolicy
   */
  readonly internalTrafficPolicy?: string;

  /**
   * IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
   * service. This field is usually assigned automatically based on cluster
   * configuration and the ipFamilyPolicy field. If this field is specified
   * manually, the requested family is available in the cluster,
   * and ipFamilyPolicy allows it, it will be used; otherwise creation of
   * the service will fail. This field is conditionally mutable: it allows
   * for adding or removing a secondary IP family, but it does not allow
   * changing the primary IP family of the Service. Valid values are "IPv4"
   * and "IPv6".  This field only applies to Services of types ClusterIP,
   * NodePort, and LoadBalancer, and does apply to "headless" services.
   * This field will be wiped when updating a Service to type ExternalName.
   *
   * This field may hold a maximum of two entries (dual-stack families, in
   * either order).  These families must correspond to the values of the
   * clusterIPs field, if specified. Both clusterIPs and ipFamilies are
   * governed by the ipFamilyPolicy field.
   *
   * @schema AccessSpecServiceTemplates#ipFamilies
   */
  readonly ipFamilies?: string[];

  /**
   * IPFamilyPolicy represents the dual-stack-ness requested or required by
   * this Service. If there is no value provided, then this field will be set
   * to SingleStack. Services can be "SingleStack" (a single IP family),
   * "PreferDualStack" (two IP families on dual-stack configured clusters or
   * a single IP family on single-stack clusters), or "RequireDualStack"
   * (two IP families on dual-stack configured clusters, otherwise fail). The
   * ipFamilies and clusterIPs fields depend on the value of this field. This
   * field will be wiped when updating a service to type ExternalName.
   *
   * @schema AccessSpecServiceTemplates#ipFamilyPolicy
   */
  readonly ipFamilyPolicy?: string;

  /**
   * loadBalancerClass is the class of the load balancer implementation this Service belongs to.
   * If specified, the value of this field must be a label-style identifier, with an optional prefix,
   * e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
   * This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
   * balancer implementation is used, today this is typically done through the cloud provider integration,
   * but should apply for any default implementation. If set, it is assumed that a load balancer
   * implementation is watching for Services with a matching class. Any default load balancer
   * implementation (e.g. cloud providers) should ignore Services that set this field.
   * This field can only be set when creating or updating a Service to type 'LoadBalancer'.
   * Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
   *
   * @schema AccessSpecServiceTemplates#loadBalancerClass
   */
  readonly loadBalancerClass?: string;

  /**
   * Only applies to Service Type: LoadBalancer.
   * This feature depends on whether the underlying cloud-provider supports specifying
   * the loadBalancerIP when a load balancer is created.
   * This field will be ignored if the cloud-provider does not support the feature.
   * Deprecated: This field was under-specified and its meaning varies across implementations.
   * Using it is non-portable and it may not support dual-stack.
   * Users are encouraged to use implementation-specific annotations when available.
   *
   * @schema AccessSpecServiceTemplates#loadBalancerIP
   */
  readonly loadBalancerIp?: string;

  /**
   * If specified and supported by the platform, this will restrict traffic through the cloud-provider
   * load-balancer will be restricted to the specified client IPs. This field will be ignored if the
   * cloud-provider does not support the feature."
   * More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
   *
   * @schema AccessSpecServiceTemplates#loadBalancerSourceRanges
   */
  readonly loadBalancerSourceRanges?: string[];

  /**
   * The list of ports that are exposed by this service.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   *
   * @schema AccessSpecServiceTemplates#ports
   */
  readonly ports?: AccessSpecServiceTemplatesPorts[];

  /**
   * publishNotReadyAddresses indicates that any agent which deals with endpoints for this
   * Service should disregard any indications of ready/not-ready.
   * The primary use case for setting this field is for a StatefulSet's Headless Service to
   * propagate SRV DNS records for its Pods for the purpose of peer discovery.
   * The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
   * Services interpret this to mean that all endpoints are considered "ready" even if the
   * Pods themselves are not. Agents which consume only Kubernetes generated endpoints
   * through the Endpoints or EndpointSlice resources can safely assume this behavior.
   *
   * @schema AccessSpecServiceTemplates#publishNotReadyAddresses
   */
  readonly publishNotReadyAddresses?: boolean;

  /**
   * Route service traffic to pods with label keys and values matching this
   * selector. If empty or not present, the service is assumed to have an
   * external process managing its endpoints, which Kubernetes will not
   * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
   * Ignored if type is ExternalName.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/
   *
   * @schema AccessSpecServiceTemplates#selector
   */
  readonly selector?: { [key: string]: string };

  /**
   * Supports "ClientIP" and "None". Used to maintain session affinity.
   * Enable client IP based session affinity.
   * Must be ClientIP or None.
   * Defaults to None.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   *
   * @default None.
   * @schema AccessSpecServiceTemplates#sessionAffinity
   */
  readonly sessionAffinity?: string;

  /**
   * sessionAffinityConfig contains the configurations of session affinity.
   *
   * @schema AccessSpecServiceTemplates#sessionAffinityConfig
   */
  readonly sessionAffinityConfig?: AccessSpecServiceTemplatesSessionAffinityConfig;

  /**
   * TrafficDistribution offers a way to express preferences for how traffic is
   * distributed to Service endpoints. Implementations can use this field as a
   * hint, but are not required to guarantee strict adherence. If the field is
   * not set, the implementation will apply its default routing strategy. If set
   * to "PreferClose", implementations should prioritize endpoints that are
   * topologically close (e.g., same zone).
   * This is an alpha field and requires enabling ServiceTrafficDistribution feature.
   *
   * @schema AccessSpecServiceTemplates#trafficDistribution
   */
  readonly trafficDistribution?: string;

  /**
   * type determines how the Service is exposed. Defaults to ClusterIP. Valid
   * options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
   * "ClusterIP" allocates a cluster-internal IP address for load-balancing
   * to endpoints. Endpoints are determined by the selector or if that is not
   * specified, by manual construction of an Endpoints object or
   * EndpointSlice objects. If clusterIP is "None", no virtual IP is
   * allocated and the endpoints are published as a set of endpoints rather
   * than a virtual IP.
   * "NodePort" builds on ClusterIP and allocates a port on every node which
   * routes to the same endpoints as the clusterIP.
   * "LoadBalancer" builds on NodePort and creates an external load-balancer
   * (if supported in the current cloud) which routes to the same endpoints
   * as the clusterIP.
   * "ExternalName" aliases this service to the specified externalName.
   * Several other fields do not apply to ExternalName services.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
   *
   * @default ClusterIP. Valid
   * @schema AccessSpecServiceTemplates#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AccessSpecServiceTemplates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessSpecServiceTemplates(obj: AccessSpecServiceTemplates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allocateLoadBalancerNodePorts': obj.allocateLoadBalancerNodePorts,
    'clusterIP': obj.clusterIp,
    'clusterIPs': obj.clusterIPs?.map(y => y),
    'externalIPs': obj.externalIPs?.map(y => y),
    'externalName': obj.externalName,
    'externalTrafficPolicy': obj.externalTrafficPolicy,
    'healthCheckNodePort': obj.healthCheckNodePort,
    'internalTrafficPolicy': obj.internalTrafficPolicy,
    'ipFamilies': obj.ipFamilies?.map(y => y),
    'ipFamilyPolicy': obj.ipFamilyPolicy,
    'loadBalancerClass': obj.loadBalancerClass,
    'loadBalancerIP': obj.loadBalancerIp,
    'loadBalancerSourceRanges': obj.loadBalancerSourceRanges?.map(y => y),
    'ports': obj.ports?.map(y => toJson_AccessSpecServiceTemplatesPorts(y)),
    'publishNotReadyAddresses': obj.publishNotReadyAddresses,
    'selector': ((obj.selector) === undefined) ? undefined : (Object.entries(obj.selector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'sessionAffinity': obj.sessionAffinity,
    'sessionAffinityConfig': toJson_AccessSpecServiceTemplatesSessionAffinityConfig(obj.sessionAffinityConfig),
    'trafficDistribution': obj.trafficDistribution,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * defaultBackend is the backend that should handle requests that don't
 * match any rule. If Rules are not specified, DefaultBackend must be specified.
 * If DefaultBackend is not set, the handling of requests that do not match any
 * of the rules will be up to the Ingress controller.
 *
 * @schema AccessSpecIngressTemplateDefaultBackend
 */
export interface AccessSpecIngressTemplateDefaultBackend {
  /**
   * resource is an ObjectRef to another Kubernetes resource in the namespace
   * of the Ingress object. If resource is specified, a service.Name and
   * service.Port must not be specified.
   * This is a mutually exclusive setting with "Service".
   *
   * @schema AccessSpecIngressTemplateDefaultBackend#resource
   */
  readonly resource?: AccessSpecIngressTemplateDefaultBackendResource;

  /**
   * service references a service as a backend.
   * This is a mutually exclusive setting with "Resource".
   *
   * @schema AccessSpecIngressTemplateDefaultBackend#service
   */
  readonly service?: AccessSpecIngressTemplateDefaultBackendService;

}

/**
 * Converts an object of type 'AccessSpecIngressTemplateDefaultBackend' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessSpecIngressTemplateDefaultBackend(obj: AccessSpecIngressTemplateDefaultBackend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resource': toJson_AccessSpecIngressTemplateDefaultBackendResource(obj.resource),
    'service': toJson_AccessSpecIngressTemplateDefaultBackendService(obj.service),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IngressRule represents the rules mapping the paths under a specified host to
 * the related backend services. Incoming requests are first evaluated for a host
 * match, then routed to the backend associated with the matching IngressRuleValue.
 *
 * @schema AccessSpecIngressTemplateRules
 */
export interface AccessSpecIngressTemplateRules {
  /**
   * host is the fully qualified domain name of a network host, as defined by RFC 3986.
   * Note the following deviations from the "host" part of the
   * URI as defined in RFC 3986:
   * 1. IPs are not allowed. Currently an IngressRuleValue can only apply to
   * the IP in the Spec of the parent Ingress.
   * 2. The `:` delimiter is not respected because ports are not allowed.
   * Currently the port of an Ingress is implicitly :80 for http and
   * :443 for https.
   * Both these may change in the future.
   * Incoming requests are matched against the host before the
   * IngressRuleValue. If the host is unspecified, the Ingress routes all
   * traffic based on the specified IngressRuleValue.
   *
   * host can be "precise" which is a domain name without the terminating dot of
   * a network host (e.g. "foo.bar.com") or "wildcard", which is a domain name
   * prefixed with a single wildcard label (e.g. "*.foo.com").
   * The wildcard character '*' must appear by itself as the first DNS label and
   * matches only a single label. You cannot have a wildcard label by itself (e.g. Host == "*").
   * Requests will be matched against the Host field in the following way:
   * 1. If host is precise, the request matches this rule if the http host header is equal to Host.
   * 2. If host is a wildcard, then the request matches this rule if the http host header
   * is to equal to the suffix (removing the first label) of the wildcard rule.
   *
   * @schema AccessSpecIngressTemplateRules#host
   */
  readonly host?: string;

  /**
   * HTTPIngressRuleValue is a list of http selectors pointing to backends.
   * In the example: http://<host>/<path>?<searchpart> -> backend where
   * where parts of the url correspond to RFC 3986, this resource will be used
   * to match against everything after the last '/' and before the first '?'
   * or '#'.
   *
   * @schema AccessSpecIngressTemplateRules#http
   */
  readonly http?: AccessSpecIngressTemplateRulesHttp;

}

/**
 * Converts an object of type 'AccessSpecIngressTemplateRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessSpecIngressTemplateRules(obj: AccessSpecIngressTemplateRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'http': toJson_AccessSpecIngressTemplateRulesHttp(obj.http),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IngressTLS describes the transport layer security associated with an ingress.
 *
 * @schema AccessSpecIngressTemplateTls
 */
export interface AccessSpecIngressTemplateTls {
  /**
   * hosts is a list of hosts included in the TLS certificate. The values in
   * this list must match the name/s used in the tlsSecret. Defaults to the
   * wildcard host setting for the loadbalancer controller fulfilling this
   * Ingress, if left unspecified.
   *
   * @default the
   * @schema AccessSpecIngressTemplateTls#hosts
   */
  readonly hosts?: string[];

  /**
   * secretName is the name of the secret used to terminate TLS traffic on
   * port 443. Field is left optional to allow TLS routing based on SNI
   * hostname alone. If the SNI host in a listener conflicts with the "Host"
   * header field used by an IngressRule, the SNI host is used for termination
   * and value of the "Host" header is used for routing.
   *
   * @schema AccessSpecIngressTemplateTls#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'AccessSpecIngressTemplateTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessSpecIngressTemplateTls(obj: AccessSpecIngressTemplateTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hosts': obj.hosts?.map(y => y),
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServicePort contains information on service's port.
 *
 * @schema AccessSpecServiceTemplatesPorts
 */
export interface AccessSpecServiceTemplatesPorts {
  /**
   * The application protocol for this port.
   * This is used as a hint for implementations to offer richer behavior for protocols that they understand.
   * This field follows standard Kubernetes label syntax.
   * Valid values are either:
   *
   * * Un-prefixed protocol names - reserved for IANA standard service names (as per
   * RFC-6335 and https://www.iana.org/assignments/service-names).
   *
   * * Kubernetes-defined prefixed names:
   * * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
   * * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
   * * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
   *
   * * Other protocols should use implementation-defined prefixed names such as
   * mycompany.com/my-custom-protocol.
   *
   * @schema AccessSpecServiceTemplatesPorts#appProtocol
   */
  readonly appProtocol?: string;

  /**
   * The name of this port within the service. This must be a DNS_LABEL.
   * All ports within a ServiceSpec must have unique names. When considering
   * the endpoints for a Service, this must match the 'name' field in the
   * EndpointPort.
   * Optional if only one ServicePort is defined on this service.
   *
   * @schema AccessSpecServiceTemplatesPorts#name
   */
  readonly name?: string;

  /**
   * The port on each node on which this service is exposed when type is
   * NodePort or LoadBalancer.  Usually assigned by the system. If a value is
   * specified, in-range, and not in use it will be used, otherwise the
   * operation will fail.  If not specified, a port will be allocated if this
   * Service requires one.  If this field is specified when creating a
   * Service which does not need it, creation will fail. This field will be
   * wiped when updating a Service to no longer need it (e.g. changing type
   * from NodePort to ClusterIP).
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
   *
   * @schema AccessSpecServiceTemplatesPorts#nodePort
   */
  readonly nodePort?: number;

  /**
   * The port that will be exposed by this service.
   *
   * @schema AccessSpecServiceTemplatesPorts#port
   */
  readonly port: number;

  /**
   * The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
   * Default is TCP.
   *
   * @default TCP.
   * @schema AccessSpecServiceTemplatesPorts#protocol
   */
  readonly protocol?: string;

  /**
   * Number or name of the port to access on the pods targeted by the service.
   * Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   * If this is a string, it will be looked up as a named port in the
   * target Pod's container ports. If this is not specified, the value
   * of the 'port' field is used (an identity map).
   * This field is ignored for services with clusterIP=None, and should be
   * omitted or set equal to the 'port' field.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
   *
   * @schema AccessSpecServiceTemplatesPorts#targetPort
   */
  readonly targetPort?: AccessSpecServiceTemplatesPortsTargetPort;

}

/**
 * Converts an object of type 'AccessSpecServiceTemplatesPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessSpecServiceTemplatesPorts(obj: AccessSpecServiceTemplatesPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appProtocol': obj.appProtocol,
    'name': obj.name,
    'nodePort': obj.nodePort,
    'port': obj.port,
    'protocol': obj.protocol,
    'targetPort': obj.targetPort?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * sessionAffinityConfig contains the configurations of session affinity.
 *
 * @schema AccessSpecServiceTemplatesSessionAffinityConfig
 */
export interface AccessSpecServiceTemplatesSessionAffinityConfig {
  /**
   * clientIP contains the configurations of Client IP based session affinity.
   *
   * @schema AccessSpecServiceTemplatesSessionAffinityConfig#clientIP
   */
  readonly clientIp?: AccessSpecServiceTemplatesSessionAffinityConfigClientIp;

}

/**
 * Converts an object of type 'AccessSpecServiceTemplatesSessionAffinityConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessSpecServiceTemplatesSessionAffinityConfig(obj: AccessSpecServiceTemplatesSessionAffinityConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientIP': toJson_AccessSpecServiceTemplatesSessionAffinityConfigClientIp(obj.clientIp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * resource is an ObjectRef to another Kubernetes resource in the namespace
 * of the Ingress object. If resource is specified, a service.Name and
 * service.Port must not be specified.
 * This is a mutually exclusive setting with "Service".
 *
 * @schema AccessSpecIngressTemplateDefaultBackendResource
 */
export interface AccessSpecIngressTemplateDefaultBackendResource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema AccessSpecIngressTemplateDefaultBackendResource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema AccessSpecIngressTemplateDefaultBackendResource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema AccessSpecIngressTemplateDefaultBackendResource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AccessSpecIngressTemplateDefaultBackendResource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessSpecIngressTemplateDefaultBackendResource(obj: AccessSpecIngressTemplateDefaultBackendResource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * service references a service as a backend.
 * This is a mutually exclusive setting with "Resource".
 *
 * @schema AccessSpecIngressTemplateDefaultBackendService
 */
export interface AccessSpecIngressTemplateDefaultBackendService {
  /**
   * name is the referenced service. The service must exist in
   * the same namespace as the Ingress object.
   *
   * @schema AccessSpecIngressTemplateDefaultBackendService#name
   */
  readonly name: string;

  /**
   * port of the referenced service. A port name or port number
   * is required for a IngressServiceBackend.
   *
   * @schema AccessSpecIngressTemplateDefaultBackendService#port
   */
  readonly port?: AccessSpecIngressTemplateDefaultBackendServicePort;

}

/**
 * Converts an object of type 'AccessSpecIngressTemplateDefaultBackendService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessSpecIngressTemplateDefaultBackendService(obj: AccessSpecIngressTemplateDefaultBackendService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'port': toJson_AccessSpecIngressTemplateDefaultBackendServicePort(obj.port),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPIngressRuleValue is a list of http selectors pointing to backends.
 * In the example: http://<host>/<path>?<searchpart> -> backend where
 * where parts of the url correspond to RFC 3986, this resource will be used
 * to match against everything after the last '/' and before the first '?'
 * or '#'.
 *
 * @schema AccessSpecIngressTemplateRulesHttp
 */
export interface AccessSpecIngressTemplateRulesHttp {
  /**
   * paths is a collection of paths that map requests to backends.
   *
   * @schema AccessSpecIngressTemplateRulesHttp#paths
   */
  readonly paths: AccessSpecIngressTemplateRulesHttpPaths[];

}

/**
 * Converts an object of type 'AccessSpecIngressTemplateRulesHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessSpecIngressTemplateRulesHttp(obj: AccessSpecIngressTemplateRulesHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'paths': obj.paths?.map(y => toJson_AccessSpecIngressTemplateRulesHttpPaths(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Number or name of the port to access on the pods targeted by the service.
 * Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 * If this is a string, it will be looked up as a named port in the
 * target Pod's container ports. If this is not specified, the value
 * of the 'port' field is used (an identity map).
 * This field is ignored for services with clusterIP=None, and should be
 * omitted or set equal to the 'port' field.
 * More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
 *
 * @schema AccessSpecServiceTemplatesPortsTargetPort
 */
export class AccessSpecServiceTemplatesPortsTargetPort {
  public static fromNumber(value: number): AccessSpecServiceTemplatesPortsTargetPort {
    return new AccessSpecServiceTemplatesPortsTargetPort(value);
  }
  public static fromString(value: string): AccessSpecServiceTemplatesPortsTargetPort {
    return new AccessSpecServiceTemplatesPortsTargetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * clientIP contains the configurations of Client IP based session affinity.
 *
 * @schema AccessSpecServiceTemplatesSessionAffinityConfigClientIp
 */
export interface AccessSpecServiceTemplatesSessionAffinityConfigClientIp {
  /**
   * timeoutSeconds specifies the seconds of ClientIP type session sticky time.
   * The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
   * Default value is 10800(for 3 hours).
   *
   * @schema AccessSpecServiceTemplatesSessionAffinityConfigClientIp#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'AccessSpecServiceTemplatesSessionAffinityConfigClientIp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessSpecServiceTemplatesSessionAffinityConfigClientIp(obj: AccessSpecServiceTemplatesSessionAffinityConfigClientIp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * port of the referenced service. A port name or port number
 * is required for a IngressServiceBackend.
 *
 * @schema AccessSpecIngressTemplateDefaultBackendServicePort
 */
export interface AccessSpecIngressTemplateDefaultBackendServicePort {
  /**
   * name is the name of the port on the Service.
   * This is a mutually exclusive setting with "Number".
   *
   * @schema AccessSpecIngressTemplateDefaultBackendServicePort#name
   */
  readonly name?: string;

  /**
   * number is the numerical port number (e.g. 80) on the Service.
   * This is a mutually exclusive setting with "Name".
   *
   * @schema AccessSpecIngressTemplateDefaultBackendServicePort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'AccessSpecIngressTemplateDefaultBackendServicePort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessSpecIngressTemplateDefaultBackendServicePort(obj: AccessSpecIngressTemplateDefaultBackendServicePort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPIngressPath associates a path with a backend. Incoming urls matching the
 * path are forwarded to the backend.
 *
 * @schema AccessSpecIngressTemplateRulesHttpPaths
 */
export interface AccessSpecIngressTemplateRulesHttpPaths {
  /**
   * backend defines the referenced service endpoint to which the traffic
   * will be forwarded to.
   *
   * @schema AccessSpecIngressTemplateRulesHttpPaths#backend
   */
  readonly backend: AccessSpecIngressTemplateRulesHttpPathsBackend;

  /**
   * path is matched against the path of an incoming request. Currently it can
   * contain characters disallowed from the conventional "path" part of a URL
   * as defined by RFC 3986. Paths must begin with a '/' and must be present
   * when using PathType with value "Exact" or "Prefix".
   *
   * @schema AccessSpecIngressTemplateRulesHttpPaths#path
   */
  readonly path?: string;

  /**
   * pathType determines the interpretation of the path matching. PathType can
   * be one of the following values:
   * * Exact: Matches the URL path exactly.
   * * Prefix: Matches based on a URL path prefix split by '/'. Matching is
   * done on a path element by element basis. A path element refers is the
   * list of labels in the path split by the '/' separator. A request is a
   * match for path p if every p is an element-wise prefix of p of the
   * request path. Note that if the last element of the path is a substring
   * of the last element in request path, it is not a match (e.g. /foo/bar
   * matches /foo/bar/baz, but does not match /foo/barbaz).
   * * ImplementationSpecific: Interpretation of the Path matching is up to
   * the IngressClass. Implementations can treat this as a separate PathType
   * or treat it identically to Prefix or Exact path types.
   * Implementations are required to support all path types.
   *
   * @schema AccessSpecIngressTemplateRulesHttpPaths#pathType
   */
  readonly pathType: string;

}

/**
 * Converts an object of type 'AccessSpecIngressTemplateRulesHttpPaths' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessSpecIngressTemplateRulesHttpPaths(obj: AccessSpecIngressTemplateRulesHttpPaths | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backend': toJson_AccessSpecIngressTemplateRulesHttpPathsBackend(obj.backend),
    'path': obj.path,
    'pathType': obj.pathType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * backend defines the referenced service endpoint to which the traffic
 * will be forwarded to.
 *
 * @schema AccessSpecIngressTemplateRulesHttpPathsBackend
 */
export interface AccessSpecIngressTemplateRulesHttpPathsBackend {
  /**
   * resource is an ObjectRef to another Kubernetes resource in the namespace
   * of the Ingress object. If resource is specified, a service.Name and
   * service.Port must not be specified.
   * This is a mutually exclusive setting with "Service".
   *
   * @schema AccessSpecIngressTemplateRulesHttpPathsBackend#resource
   */
  readonly resource?: AccessSpecIngressTemplateRulesHttpPathsBackendResource;

  /**
   * service references a service as a backend.
   * This is a mutually exclusive setting with "Resource".
   *
   * @schema AccessSpecIngressTemplateRulesHttpPathsBackend#service
   */
  readonly service?: AccessSpecIngressTemplateRulesHttpPathsBackendService;

}

/**
 * Converts an object of type 'AccessSpecIngressTemplateRulesHttpPathsBackend' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessSpecIngressTemplateRulesHttpPathsBackend(obj: AccessSpecIngressTemplateRulesHttpPathsBackend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resource': toJson_AccessSpecIngressTemplateRulesHttpPathsBackendResource(obj.resource),
    'service': toJson_AccessSpecIngressTemplateRulesHttpPathsBackendService(obj.service),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * resource is an ObjectRef to another Kubernetes resource in the namespace
 * of the Ingress object. If resource is specified, a service.Name and
 * service.Port must not be specified.
 * This is a mutually exclusive setting with "Service".
 *
 * @schema AccessSpecIngressTemplateRulesHttpPathsBackendResource
 */
export interface AccessSpecIngressTemplateRulesHttpPathsBackendResource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema AccessSpecIngressTemplateRulesHttpPathsBackendResource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema AccessSpecIngressTemplateRulesHttpPathsBackendResource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema AccessSpecIngressTemplateRulesHttpPathsBackendResource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AccessSpecIngressTemplateRulesHttpPathsBackendResource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessSpecIngressTemplateRulesHttpPathsBackendResource(obj: AccessSpecIngressTemplateRulesHttpPathsBackendResource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * service references a service as a backend.
 * This is a mutually exclusive setting with "Resource".
 *
 * @schema AccessSpecIngressTemplateRulesHttpPathsBackendService
 */
export interface AccessSpecIngressTemplateRulesHttpPathsBackendService {
  /**
   * name is the referenced service. The service must exist in
   * the same namespace as the Ingress object.
   *
   * @schema AccessSpecIngressTemplateRulesHttpPathsBackendService#name
   */
  readonly name: string;

  /**
   * port of the referenced service. A port name or port number
   * is required for a IngressServiceBackend.
   *
   * @schema AccessSpecIngressTemplateRulesHttpPathsBackendService#port
   */
  readonly port?: AccessSpecIngressTemplateRulesHttpPathsBackendServicePort;

}

/**
 * Converts an object of type 'AccessSpecIngressTemplateRulesHttpPathsBackendService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessSpecIngressTemplateRulesHttpPathsBackendService(obj: AccessSpecIngressTemplateRulesHttpPathsBackendService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'port': toJson_AccessSpecIngressTemplateRulesHttpPathsBackendServicePort(obj.port),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * port of the referenced service. A port name or port number
 * is required for a IngressServiceBackend.
 *
 * @schema AccessSpecIngressTemplateRulesHttpPathsBackendServicePort
 */
export interface AccessSpecIngressTemplateRulesHttpPathsBackendServicePort {
  /**
   * name is the name of the port on the Service.
   * This is a mutually exclusive setting with "Number".
   *
   * @schema AccessSpecIngressTemplateRulesHttpPathsBackendServicePort#name
   */
  readonly name?: string;

  /**
   * number is the numerical port number (e.g. 80) on the Service.
   * This is a mutually exclusive setting with "Name".
   *
   * @schema AccessSpecIngressTemplateRulesHttpPathsBackendServicePort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'AccessSpecIngressTemplateRulesHttpPathsBackendServicePort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessSpecIngressTemplateRulesHttpPathsBackendServicePort(obj: AccessSpecIngressTemplateRulesHttpPathsBackendServicePort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * AccessClaim specifies desired connectivity to cluster resources
 *
 * @schema AccessClaim
 */
export class AccessClaim extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AccessClaim"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'bfiola.dev/v1',
    kind: 'AccessClaim',
  }

  /**
   * Renders a Kubernetes manifest for "AccessClaim".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AccessClaimProps): any {
    return {
      ...AccessClaim.GVK,
      ...toJson_AccessClaimProps(props),
    };
  }

  /**
   * Defines a "AccessClaim" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AccessClaimProps) {
    super(scope, id, {
      ...AccessClaim.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AccessClaim.GVK,
      ...toJson_AccessClaimProps(resolved),
    };
  }
}

/**
 * AccessClaim specifies desired connectivity to cluster resources
 *
 * @schema AccessClaim
 */
export interface AccessClaimProps {
  /**
   * @schema AccessClaim#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AccessClaimSpec defines the desired state of AccessClaim
   *
   * @schema AccessClaim#spec
   */
  readonly spec: AccessClaimSpec;

}

/**
 * Converts an object of type 'AccessClaimProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessClaimProps(obj: AccessClaimProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AccessClaimSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessClaimSpec defines the desired state of AccessClaim
 *
 * @schema AccessClaimSpec
 */
export interface AccessClaimSpec {
  /**
   * @schema AccessClaimSpec#dns
   */
  readonly dns: string;

  /**
   * IngressSpec describes the Ingress the user wishes to exist.
   *
   * @schema AccessClaimSpec#ingressTemplate
   */
  readonly ingressTemplate?: AccessClaimSpecIngressTemplate;

  /**
   * SecretKeyRef defines a reference to a key of a secret resource
   *
   * @schema AccessClaimSpec#passwordRef
   */
  readonly passwordRef: AccessClaimSpecPasswordRef;

  /**
   * @schema AccessClaimSpec#serviceTemplates
   */
  readonly serviceTemplates?: AccessClaimSpecServiceTemplates[];

  /**
   * @schema AccessClaimSpec#ttl
   */
  readonly ttl: string;

}

/**
 * Converts an object of type 'AccessClaimSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessClaimSpec(obj: AccessClaimSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dns': obj.dns,
    'ingressTemplate': toJson_AccessClaimSpecIngressTemplate(obj.ingressTemplate),
    'passwordRef': toJson_AccessClaimSpecPasswordRef(obj.passwordRef),
    'serviceTemplates': obj.serviceTemplates?.map(y => toJson_AccessClaimSpecServiceTemplates(y)),
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IngressSpec describes the Ingress the user wishes to exist.
 *
 * @schema AccessClaimSpecIngressTemplate
 */
export interface AccessClaimSpecIngressTemplate {
  /**
   * defaultBackend is the backend that should handle requests that don't
   * match any rule. If Rules are not specified, DefaultBackend must be specified.
   * If DefaultBackend is not set, the handling of requests that do not match any
   * of the rules will be up to the Ingress controller.
   *
   * @schema AccessClaimSpecIngressTemplate#defaultBackend
   */
  readonly defaultBackend?: AccessClaimSpecIngressTemplateDefaultBackend;

  /**
   * ingressClassName is the name of an IngressClass cluster resource. Ingress
   * controller implementations use this field to know whether they should be
   * serving this Ingress resource, by a transitive connection
   * (controller -> IngressClass -> Ingress resource). Although the
   * `kubernetes.io/ingress.class` annotation (simple constant name) was never
   * formally defined, it was widely supported by Ingress controllers to create
   * a direct binding between Ingress controller and Ingress resources. Newly
   * created Ingress resources should prefer using the field. However, even
   * though the annotation is officially deprecated, for backwards compatibility
   * reasons, ingress controllers should still honor that annotation if present.
   *
   * @schema AccessClaimSpecIngressTemplate#ingressClassName
   */
  readonly ingressClassName?: string;

  /**
   * rules is a list of host rules used to configure the Ingress. If unspecified,
   * or no rule matches, all traffic is sent to the default backend.
   *
   * @schema AccessClaimSpecIngressTemplate#rules
   */
  readonly rules?: AccessClaimSpecIngressTemplateRules[];

  /**
   * tls represents the TLS configuration. Currently the Ingress only supports a
   * single TLS port, 443. If multiple members of this list specify different hosts,
   * they will be multiplexed on the same port according to the hostname specified
   * through the SNI TLS extension, if the ingress controller fulfilling the
   * ingress supports SNI.
   *
   * @schema AccessClaimSpecIngressTemplate#tls
   */
  readonly tls?: AccessClaimSpecIngressTemplateTls[];

}

/**
 * Converts an object of type 'AccessClaimSpecIngressTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessClaimSpecIngressTemplate(obj: AccessClaimSpecIngressTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultBackend': toJson_AccessClaimSpecIngressTemplateDefaultBackend(obj.defaultBackend),
    'ingressClassName': obj.ingressClassName,
    'rules': obj.rules?.map(y => toJson_AccessClaimSpecIngressTemplateRules(y)),
    'tls': obj.tls?.map(y => toJson_AccessClaimSpecIngressTemplateTls(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeyRef defines a reference to a key of a secret resource
 *
 * @schema AccessClaimSpecPasswordRef
 */
export interface AccessClaimSpecPasswordRef {
  /**
   * @schema AccessClaimSpecPasswordRef#key
   */
  readonly key: string;

  /**
   * @schema AccessClaimSpecPasswordRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AccessClaimSpecPasswordRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessClaimSpecPasswordRef(obj: AccessClaimSpecPasswordRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceSpec describes the attributes that a user creates on a service.
 *
 * @schema AccessClaimSpecServiceTemplates
 */
export interface AccessClaimSpecServiceTemplates {
  /**
   * allocateLoadBalancerNodePorts defines if NodePorts will be automatically
   * allocated for services with type LoadBalancer.  Default is "true". It
   * may be set to "false" if the cluster load-balancer does not rely on
   * NodePorts.  If the caller requests specific NodePorts (by specifying a
   * value), those requests will be respected, regardless of this field.
   * This field may only be set for services with type LoadBalancer and will
   * be cleared if the type is changed to any other type.
   *
   * @default true". It
   * @schema AccessClaimSpecServiceTemplates#allocateLoadBalancerNodePorts
   */
  readonly allocateLoadBalancerNodePorts?: boolean;

  /**
   * clusterIP is the IP address of the service and is usually assigned
   * randomly. If an address is specified manually, is in-range (as per
   * system configuration), and is not in use, it will be allocated to the
   * service; otherwise creation of the service will fail. This field may not
   * be changed through updates unless the type field is also being changed
   * to ExternalName (which requires this field to be blank) or the type
   * field is being changed from ExternalName (in which case this field may
   * optionally be specified, as describe above).  Valid values are "None",
   * empty string (""), or a valid IP address. Setting this to "None" makes a
   * "headless service" (no virtual IP), which is useful when direct endpoint
   * connections are preferred and proxying is not required.  Only applies to
   * types ClusterIP, NodePort, and LoadBalancer. If this field is specified
   * when creating a Service of type ExternalName, creation will fail. This
   * field will be wiped when updating a Service to type ExternalName.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   *
   * @schema AccessClaimSpecServiceTemplates#clusterIP
   */
  readonly clusterIp?: string;

  /**
   * ClusterIPs is a list of IP addresses assigned to this service, and are
   * usually assigned randomly.  If an address is specified manually, is
   * in-range (as per system configuration), and is not in use, it will be
   * allocated to the service; otherwise creation of the service will fail.
   * This field may not be changed through updates unless the type field is
   * also being changed to ExternalName (which requires this field to be
   * empty) or the type field is being changed from ExternalName (in which
   * case this field may optionally be specified, as describe above).  Valid
   * values are "None", empty string (""), or a valid IP address.  Setting
   * this to "None" makes a "headless service" (no virtual IP), which is
   * useful when direct endpoint connections are preferred and proxying is
   * not required.  Only applies to types ClusterIP, NodePort, and
   * LoadBalancer. If this field is specified when creating a Service of type
   * ExternalName, creation will fail. This field will be wiped when updating
   * a Service to type ExternalName.  If this field is not specified, it will
   * be initialized from the clusterIP field.  If this field is specified,
   * clients must ensure that clusterIPs[0] and clusterIP have the same
   * value.
   *
   * This field may hold a maximum of two entries (dual-stack IPs, in either order).
   * These IPs must correspond to the values of the ipFamilies field. Both
   * clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   *
   * @schema AccessClaimSpecServiceTemplates#clusterIPs
   */
  readonly clusterIPs?: string[];

  /**
   * externalIPs is a list of IP addresses for which nodes in the cluster
   * will also accept traffic for this service.  These IPs are not managed by
   * Kubernetes.  The user is responsible for ensuring that traffic arrives
   * at a node with this IP.  A common example is external load-balancers
   * that are not part of the Kubernetes system.
   *
   * @schema AccessClaimSpecServiceTemplates#externalIPs
   */
  readonly externalIPs?: string[];

  /**
   * externalName is the external reference that discovery mechanisms will
   * return as an alias for this service (e.g. a DNS CNAME record). No
   * proxying will be involved.  Must be a lowercase RFC-1123 hostname
   * (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
   *
   * @schema AccessClaimSpecServiceTemplates#externalName
   */
  readonly externalName?: string;

  /**
   * externalTrafficPolicy describes how nodes distribute service traffic they
   * receive on one of the Service's "externally-facing" addresses (NodePorts,
   * ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
   * the service in a way that assumes that external load balancers will take care
   * of balancing the service traffic between nodes, and so each node will deliver
   * traffic only to the node-local endpoints of the service, without masquerading
   * the client source IP. (Traffic mistakenly sent to a node with no endpoints will
   * be dropped.) The default value, "Cluster", uses the standard behavior of
   * routing to all endpoints evenly (possibly modified by topology and other
   * features). Note that traffic sent to an External IP or LoadBalancer IP from
   * within the cluster will always get "Cluster" semantics, but clients sending to
   * a NodePort from within the cluster may need to take traffic policy into account
   * when picking a node.
   *
   * @schema AccessClaimSpecServiceTemplates#externalTrafficPolicy
   */
  readonly externalTrafficPolicy?: string;

  /**
   * healthCheckNodePort specifies the healthcheck nodePort for the service.
   * This only applies when type is set to LoadBalancer and
   * externalTrafficPolicy is set to Local. If a value is specified, is
   * in-range, and is not in use, it will be used.  If not specified, a value
   * will be automatically allocated.  External systems (e.g. load-balancers)
   * can use this port to determine if a given node holds endpoints for this
   * service or not.  If this field is specified when creating a Service
   * which does not need it, creation will fail. This field will be wiped
   * when updating a Service to no longer need it (e.g. changing type).
   * This field cannot be updated once set.
   *
   * @schema AccessClaimSpecServiceTemplates#healthCheckNodePort
   */
  readonly healthCheckNodePort?: number;

  /**
   * InternalTrafficPolicy describes how nodes distribute service traffic they
   * receive on the ClusterIP. If set to "Local", the proxy will assume that pods
   * only want to talk to endpoints of the service on the same node as the pod,
   * dropping the traffic if there are no local endpoints. The default value,
   * "Cluster", uses the standard behavior of routing to all endpoints evenly
   * (possibly modified by topology and other features).
   *
   * @schema AccessClaimSpecServiceTemplates#internalTrafficPolicy
   */
  readonly internalTrafficPolicy?: string;

  /**
   * IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
   * service. This field is usually assigned automatically based on cluster
   * configuration and the ipFamilyPolicy field. If this field is specified
   * manually, the requested family is available in the cluster,
   * and ipFamilyPolicy allows it, it will be used; otherwise creation of
   * the service will fail. This field is conditionally mutable: it allows
   * for adding or removing a secondary IP family, but it does not allow
   * changing the primary IP family of the Service. Valid values are "IPv4"
   * and "IPv6".  This field only applies to Services of types ClusterIP,
   * NodePort, and LoadBalancer, and does apply to "headless" services.
   * This field will be wiped when updating a Service to type ExternalName.
   *
   * This field may hold a maximum of two entries (dual-stack families, in
   * either order).  These families must correspond to the values of the
   * clusterIPs field, if specified. Both clusterIPs and ipFamilies are
   * governed by the ipFamilyPolicy field.
   *
   * @schema AccessClaimSpecServiceTemplates#ipFamilies
   */
  readonly ipFamilies?: string[];

  /**
   * IPFamilyPolicy represents the dual-stack-ness requested or required by
   * this Service. If there is no value provided, then this field will be set
   * to SingleStack. Services can be "SingleStack" (a single IP family),
   * "PreferDualStack" (two IP families on dual-stack configured clusters or
   * a single IP family on single-stack clusters), or "RequireDualStack"
   * (two IP families on dual-stack configured clusters, otherwise fail). The
   * ipFamilies and clusterIPs fields depend on the value of this field. This
   * field will be wiped when updating a service to type ExternalName.
   *
   * @schema AccessClaimSpecServiceTemplates#ipFamilyPolicy
   */
  readonly ipFamilyPolicy?: string;

  /**
   * loadBalancerClass is the class of the load balancer implementation this Service belongs to.
   * If specified, the value of this field must be a label-style identifier, with an optional prefix,
   * e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
   * This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
   * balancer implementation is used, today this is typically done through the cloud provider integration,
   * but should apply for any default implementation. If set, it is assumed that a load balancer
   * implementation is watching for Services with a matching class. Any default load balancer
   * implementation (e.g. cloud providers) should ignore Services that set this field.
   * This field can only be set when creating or updating a Service to type 'LoadBalancer'.
   * Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
   *
   * @schema AccessClaimSpecServiceTemplates#loadBalancerClass
   */
  readonly loadBalancerClass?: string;

  /**
   * Only applies to Service Type: LoadBalancer.
   * This feature depends on whether the underlying cloud-provider supports specifying
   * the loadBalancerIP when a load balancer is created.
   * This field will be ignored if the cloud-provider does not support the feature.
   * Deprecated: This field was under-specified and its meaning varies across implementations.
   * Using it is non-portable and it may not support dual-stack.
   * Users are encouraged to use implementation-specific annotations when available.
   *
   * @schema AccessClaimSpecServiceTemplates#loadBalancerIP
   */
  readonly loadBalancerIp?: string;

  /**
   * If specified and supported by the platform, this will restrict traffic through the cloud-provider
   * load-balancer will be restricted to the specified client IPs. This field will be ignored if the
   * cloud-provider does not support the feature."
   * More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
   *
   * @schema AccessClaimSpecServiceTemplates#loadBalancerSourceRanges
   */
  readonly loadBalancerSourceRanges?: string[];

  /**
   * The list of ports that are exposed by this service.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   *
   * @schema AccessClaimSpecServiceTemplates#ports
   */
  readonly ports?: AccessClaimSpecServiceTemplatesPorts[];

  /**
   * publishNotReadyAddresses indicates that any agent which deals with endpoints for this
   * Service should disregard any indications of ready/not-ready.
   * The primary use case for setting this field is for a StatefulSet's Headless Service to
   * propagate SRV DNS records for its Pods for the purpose of peer discovery.
   * The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
   * Services interpret this to mean that all endpoints are considered "ready" even if the
   * Pods themselves are not. Agents which consume only Kubernetes generated endpoints
   * through the Endpoints or EndpointSlice resources can safely assume this behavior.
   *
   * @schema AccessClaimSpecServiceTemplates#publishNotReadyAddresses
   */
  readonly publishNotReadyAddresses?: boolean;

  /**
   * Route service traffic to pods with label keys and values matching this
   * selector. If empty or not present, the service is assumed to have an
   * external process managing its endpoints, which Kubernetes will not
   * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
   * Ignored if type is ExternalName.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/
   *
   * @schema AccessClaimSpecServiceTemplates#selector
   */
  readonly selector?: { [key: string]: string };

  /**
   * Supports "ClientIP" and "None". Used to maintain session affinity.
   * Enable client IP based session affinity.
   * Must be ClientIP or None.
   * Defaults to None.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   *
   * @default None.
   * @schema AccessClaimSpecServiceTemplates#sessionAffinity
   */
  readonly sessionAffinity?: string;

  /**
   * sessionAffinityConfig contains the configurations of session affinity.
   *
   * @schema AccessClaimSpecServiceTemplates#sessionAffinityConfig
   */
  readonly sessionAffinityConfig?: AccessClaimSpecServiceTemplatesSessionAffinityConfig;

  /**
   * TrafficDistribution offers a way to express preferences for how traffic is
   * distributed to Service endpoints. Implementations can use this field as a
   * hint, but are not required to guarantee strict adherence. If the field is
   * not set, the implementation will apply its default routing strategy. If set
   * to "PreferClose", implementations should prioritize endpoints that are
   * topologically close (e.g., same zone).
   * This is an alpha field and requires enabling ServiceTrafficDistribution feature.
   *
   * @schema AccessClaimSpecServiceTemplates#trafficDistribution
   */
  readonly trafficDistribution?: string;

  /**
   * type determines how the Service is exposed. Defaults to ClusterIP. Valid
   * options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
   * "ClusterIP" allocates a cluster-internal IP address for load-balancing
   * to endpoints. Endpoints are determined by the selector or if that is not
   * specified, by manual construction of an Endpoints object or
   * EndpointSlice objects. If clusterIP is "None", no virtual IP is
   * allocated and the endpoints are published as a set of endpoints rather
   * than a virtual IP.
   * "NodePort" builds on ClusterIP and allocates a port on every node which
   * routes to the same endpoints as the clusterIP.
   * "LoadBalancer" builds on NodePort and creates an external load-balancer
   * (if supported in the current cloud) which routes to the same endpoints
   * as the clusterIP.
   * "ExternalName" aliases this service to the specified externalName.
   * Several other fields do not apply to ExternalName services.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
   *
   * @default ClusterIP. Valid
   * @schema AccessClaimSpecServiceTemplates#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AccessClaimSpecServiceTemplates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessClaimSpecServiceTemplates(obj: AccessClaimSpecServiceTemplates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allocateLoadBalancerNodePorts': obj.allocateLoadBalancerNodePorts,
    'clusterIP': obj.clusterIp,
    'clusterIPs': obj.clusterIPs?.map(y => y),
    'externalIPs': obj.externalIPs?.map(y => y),
    'externalName': obj.externalName,
    'externalTrafficPolicy': obj.externalTrafficPolicy,
    'healthCheckNodePort': obj.healthCheckNodePort,
    'internalTrafficPolicy': obj.internalTrafficPolicy,
    'ipFamilies': obj.ipFamilies?.map(y => y),
    'ipFamilyPolicy': obj.ipFamilyPolicy,
    'loadBalancerClass': obj.loadBalancerClass,
    'loadBalancerIP': obj.loadBalancerIp,
    'loadBalancerSourceRanges': obj.loadBalancerSourceRanges?.map(y => y),
    'ports': obj.ports?.map(y => toJson_AccessClaimSpecServiceTemplatesPorts(y)),
    'publishNotReadyAddresses': obj.publishNotReadyAddresses,
    'selector': ((obj.selector) === undefined) ? undefined : (Object.entries(obj.selector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'sessionAffinity': obj.sessionAffinity,
    'sessionAffinityConfig': toJson_AccessClaimSpecServiceTemplatesSessionAffinityConfig(obj.sessionAffinityConfig),
    'trafficDistribution': obj.trafficDistribution,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * defaultBackend is the backend that should handle requests that don't
 * match any rule. If Rules are not specified, DefaultBackend must be specified.
 * If DefaultBackend is not set, the handling of requests that do not match any
 * of the rules will be up to the Ingress controller.
 *
 * @schema AccessClaimSpecIngressTemplateDefaultBackend
 */
export interface AccessClaimSpecIngressTemplateDefaultBackend {
  /**
   * resource is an ObjectRef to another Kubernetes resource in the namespace
   * of the Ingress object. If resource is specified, a service.Name and
   * service.Port must not be specified.
   * This is a mutually exclusive setting with "Service".
   *
   * @schema AccessClaimSpecIngressTemplateDefaultBackend#resource
   */
  readonly resource?: AccessClaimSpecIngressTemplateDefaultBackendResource;

  /**
   * service references a service as a backend.
   * This is a mutually exclusive setting with "Resource".
   *
   * @schema AccessClaimSpecIngressTemplateDefaultBackend#service
   */
  readonly service?: AccessClaimSpecIngressTemplateDefaultBackendService;

}

/**
 * Converts an object of type 'AccessClaimSpecIngressTemplateDefaultBackend' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessClaimSpecIngressTemplateDefaultBackend(obj: AccessClaimSpecIngressTemplateDefaultBackend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resource': toJson_AccessClaimSpecIngressTemplateDefaultBackendResource(obj.resource),
    'service': toJson_AccessClaimSpecIngressTemplateDefaultBackendService(obj.service),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IngressRule represents the rules mapping the paths under a specified host to
 * the related backend services. Incoming requests are first evaluated for a host
 * match, then routed to the backend associated with the matching IngressRuleValue.
 *
 * @schema AccessClaimSpecIngressTemplateRules
 */
export interface AccessClaimSpecIngressTemplateRules {
  /**
   * host is the fully qualified domain name of a network host, as defined by RFC 3986.
   * Note the following deviations from the "host" part of the
   * URI as defined in RFC 3986:
   * 1. IPs are not allowed. Currently an IngressRuleValue can only apply to
   * the IP in the Spec of the parent Ingress.
   * 2. The `:` delimiter is not respected because ports are not allowed.
   * Currently the port of an Ingress is implicitly :80 for http and
   * :443 for https.
   * Both these may change in the future.
   * Incoming requests are matched against the host before the
   * IngressRuleValue. If the host is unspecified, the Ingress routes all
   * traffic based on the specified IngressRuleValue.
   *
   * host can be "precise" which is a domain name without the terminating dot of
   * a network host (e.g. "foo.bar.com") or "wildcard", which is a domain name
   * prefixed with a single wildcard label (e.g. "*.foo.com").
   * The wildcard character '*' must appear by itself as the first DNS label and
   * matches only a single label. You cannot have a wildcard label by itself (e.g. Host == "*").
   * Requests will be matched against the Host field in the following way:
   * 1. If host is precise, the request matches this rule if the http host header is equal to Host.
   * 2. If host is a wildcard, then the request matches this rule if the http host header
   * is to equal to the suffix (removing the first label) of the wildcard rule.
   *
   * @schema AccessClaimSpecIngressTemplateRules#host
   */
  readonly host?: string;

  /**
   * HTTPIngressRuleValue is a list of http selectors pointing to backends.
   * In the example: http://<host>/<path>?<searchpart> -> backend where
   * where parts of the url correspond to RFC 3986, this resource will be used
   * to match against everything after the last '/' and before the first '?'
   * or '#'.
   *
   * @schema AccessClaimSpecIngressTemplateRules#http
   */
  readonly http?: AccessClaimSpecIngressTemplateRulesHttp;

}

/**
 * Converts an object of type 'AccessClaimSpecIngressTemplateRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessClaimSpecIngressTemplateRules(obj: AccessClaimSpecIngressTemplateRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'http': toJson_AccessClaimSpecIngressTemplateRulesHttp(obj.http),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IngressTLS describes the transport layer security associated with an ingress.
 *
 * @schema AccessClaimSpecIngressTemplateTls
 */
export interface AccessClaimSpecIngressTemplateTls {
  /**
   * hosts is a list of hosts included in the TLS certificate. The values in
   * this list must match the name/s used in the tlsSecret. Defaults to the
   * wildcard host setting for the loadbalancer controller fulfilling this
   * Ingress, if left unspecified.
   *
   * @default the
   * @schema AccessClaimSpecIngressTemplateTls#hosts
   */
  readonly hosts?: string[];

  /**
   * secretName is the name of the secret used to terminate TLS traffic on
   * port 443. Field is left optional to allow TLS routing based on SNI
   * hostname alone. If the SNI host in a listener conflicts with the "Host"
   * header field used by an IngressRule, the SNI host is used for termination
   * and value of the "Host" header is used for routing.
   *
   * @schema AccessClaimSpecIngressTemplateTls#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'AccessClaimSpecIngressTemplateTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessClaimSpecIngressTemplateTls(obj: AccessClaimSpecIngressTemplateTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hosts': obj.hosts?.map(y => y),
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServicePort contains information on service's port.
 *
 * @schema AccessClaimSpecServiceTemplatesPorts
 */
export interface AccessClaimSpecServiceTemplatesPorts {
  /**
   * The application protocol for this port.
   * This is used as a hint for implementations to offer richer behavior for protocols that they understand.
   * This field follows standard Kubernetes label syntax.
   * Valid values are either:
   *
   * * Un-prefixed protocol names - reserved for IANA standard service names (as per
   * RFC-6335 and https://www.iana.org/assignments/service-names).
   *
   * * Kubernetes-defined prefixed names:
   * * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
   * * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
   * * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
   *
   * * Other protocols should use implementation-defined prefixed names such as
   * mycompany.com/my-custom-protocol.
   *
   * @schema AccessClaimSpecServiceTemplatesPorts#appProtocol
   */
  readonly appProtocol?: string;

  /**
   * The name of this port within the service. This must be a DNS_LABEL.
   * All ports within a ServiceSpec must have unique names. When considering
   * the endpoints for a Service, this must match the 'name' field in the
   * EndpointPort.
   * Optional if only one ServicePort is defined on this service.
   *
   * @schema AccessClaimSpecServiceTemplatesPorts#name
   */
  readonly name?: string;

  /**
   * The port on each node on which this service is exposed when type is
   * NodePort or LoadBalancer.  Usually assigned by the system. If a value is
   * specified, in-range, and not in use it will be used, otherwise the
   * operation will fail.  If not specified, a port will be allocated if this
   * Service requires one.  If this field is specified when creating a
   * Service which does not need it, creation will fail. This field will be
   * wiped when updating a Service to no longer need it (e.g. changing type
   * from NodePort to ClusterIP).
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
   *
   * @schema AccessClaimSpecServiceTemplatesPorts#nodePort
   */
  readonly nodePort?: number;

  /**
   * The port that will be exposed by this service.
   *
   * @schema AccessClaimSpecServiceTemplatesPorts#port
   */
  readonly port: number;

  /**
   * The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
   * Default is TCP.
   *
   * @default TCP.
   * @schema AccessClaimSpecServiceTemplatesPorts#protocol
   */
  readonly protocol?: string;

  /**
   * Number or name of the port to access on the pods targeted by the service.
   * Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   * If this is a string, it will be looked up as a named port in the
   * target Pod's container ports. If this is not specified, the value
   * of the 'port' field is used (an identity map).
   * This field is ignored for services with clusterIP=None, and should be
   * omitted or set equal to the 'port' field.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
   *
   * @schema AccessClaimSpecServiceTemplatesPorts#targetPort
   */
  readonly targetPort?: AccessClaimSpecServiceTemplatesPortsTargetPort;

}

/**
 * Converts an object of type 'AccessClaimSpecServiceTemplatesPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessClaimSpecServiceTemplatesPorts(obj: AccessClaimSpecServiceTemplatesPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appProtocol': obj.appProtocol,
    'name': obj.name,
    'nodePort': obj.nodePort,
    'port': obj.port,
    'protocol': obj.protocol,
    'targetPort': obj.targetPort?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * sessionAffinityConfig contains the configurations of session affinity.
 *
 * @schema AccessClaimSpecServiceTemplatesSessionAffinityConfig
 */
export interface AccessClaimSpecServiceTemplatesSessionAffinityConfig {
  /**
   * clientIP contains the configurations of Client IP based session affinity.
   *
   * @schema AccessClaimSpecServiceTemplatesSessionAffinityConfig#clientIP
   */
  readonly clientIp?: AccessClaimSpecServiceTemplatesSessionAffinityConfigClientIp;

}

/**
 * Converts an object of type 'AccessClaimSpecServiceTemplatesSessionAffinityConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessClaimSpecServiceTemplatesSessionAffinityConfig(obj: AccessClaimSpecServiceTemplatesSessionAffinityConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientIP': toJson_AccessClaimSpecServiceTemplatesSessionAffinityConfigClientIp(obj.clientIp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * resource is an ObjectRef to another Kubernetes resource in the namespace
 * of the Ingress object. If resource is specified, a service.Name and
 * service.Port must not be specified.
 * This is a mutually exclusive setting with "Service".
 *
 * @schema AccessClaimSpecIngressTemplateDefaultBackendResource
 */
export interface AccessClaimSpecIngressTemplateDefaultBackendResource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema AccessClaimSpecIngressTemplateDefaultBackendResource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema AccessClaimSpecIngressTemplateDefaultBackendResource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema AccessClaimSpecIngressTemplateDefaultBackendResource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AccessClaimSpecIngressTemplateDefaultBackendResource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessClaimSpecIngressTemplateDefaultBackendResource(obj: AccessClaimSpecIngressTemplateDefaultBackendResource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * service references a service as a backend.
 * This is a mutually exclusive setting with "Resource".
 *
 * @schema AccessClaimSpecIngressTemplateDefaultBackendService
 */
export interface AccessClaimSpecIngressTemplateDefaultBackendService {
  /**
   * name is the referenced service. The service must exist in
   * the same namespace as the Ingress object.
   *
   * @schema AccessClaimSpecIngressTemplateDefaultBackendService#name
   */
  readonly name: string;

  /**
   * port of the referenced service. A port name or port number
   * is required for a IngressServiceBackend.
   *
   * @schema AccessClaimSpecIngressTemplateDefaultBackendService#port
   */
  readonly port?: AccessClaimSpecIngressTemplateDefaultBackendServicePort;

}

/**
 * Converts an object of type 'AccessClaimSpecIngressTemplateDefaultBackendService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessClaimSpecIngressTemplateDefaultBackendService(obj: AccessClaimSpecIngressTemplateDefaultBackendService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'port': toJson_AccessClaimSpecIngressTemplateDefaultBackendServicePort(obj.port),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPIngressRuleValue is a list of http selectors pointing to backends.
 * In the example: http://<host>/<path>?<searchpart> -> backend where
 * where parts of the url correspond to RFC 3986, this resource will be used
 * to match against everything after the last '/' and before the first '?'
 * or '#'.
 *
 * @schema AccessClaimSpecIngressTemplateRulesHttp
 */
export interface AccessClaimSpecIngressTemplateRulesHttp {
  /**
   * paths is a collection of paths that map requests to backends.
   *
   * @schema AccessClaimSpecIngressTemplateRulesHttp#paths
   */
  readonly paths: AccessClaimSpecIngressTemplateRulesHttpPaths[];

}

/**
 * Converts an object of type 'AccessClaimSpecIngressTemplateRulesHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessClaimSpecIngressTemplateRulesHttp(obj: AccessClaimSpecIngressTemplateRulesHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'paths': obj.paths?.map(y => toJson_AccessClaimSpecIngressTemplateRulesHttpPaths(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Number or name of the port to access on the pods targeted by the service.
 * Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 * If this is a string, it will be looked up as a named port in the
 * target Pod's container ports. If this is not specified, the value
 * of the 'port' field is used (an identity map).
 * This field is ignored for services with clusterIP=None, and should be
 * omitted or set equal to the 'port' field.
 * More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
 *
 * @schema AccessClaimSpecServiceTemplatesPortsTargetPort
 */
export class AccessClaimSpecServiceTemplatesPortsTargetPort {
  public static fromNumber(value: number): AccessClaimSpecServiceTemplatesPortsTargetPort {
    return new AccessClaimSpecServiceTemplatesPortsTargetPort(value);
  }
  public static fromString(value: string): AccessClaimSpecServiceTemplatesPortsTargetPort {
    return new AccessClaimSpecServiceTemplatesPortsTargetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * clientIP contains the configurations of Client IP based session affinity.
 *
 * @schema AccessClaimSpecServiceTemplatesSessionAffinityConfigClientIp
 */
export interface AccessClaimSpecServiceTemplatesSessionAffinityConfigClientIp {
  /**
   * timeoutSeconds specifies the seconds of ClientIP type session sticky time.
   * The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
   * Default value is 10800(for 3 hours).
   *
   * @schema AccessClaimSpecServiceTemplatesSessionAffinityConfigClientIp#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'AccessClaimSpecServiceTemplatesSessionAffinityConfigClientIp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessClaimSpecServiceTemplatesSessionAffinityConfigClientIp(obj: AccessClaimSpecServiceTemplatesSessionAffinityConfigClientIp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * port of the referenced service. A port name or port number
 * is required for a IngressServiceBackend.
 *
 * @schema AccessClaimSpecIngressTemplateDefaultBackendServicePort
 */
export interface AccessClaimSpecIngressTemplateDefaultBackendServicePort {
  /**
   * name is the name of the port on the Service.
   * This is a mutually exclusive setting with "Number".
   *
   * @schema AccessClaimSpecIngressTemplateDefaultBackendServicePort#name
   */
  readonly name?: string;

  /**
   * number is the numerical port number (e.g. 80) on the Service.
   * This is a mutually exclusive setting with "Name".
   *
   * @schema AccessClaimSpecIngressTemplateDefaultBackendServicePort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'AccessClaimSpecIngressTemplateDefaultBackendServicePort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessClaimSpecIngressTemplateDefaultBackendServicePort(obj: AccessClaimSpecIngressTemplateDefaultBackendServicePort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPIngressPath associates a path with a backend. Incoming urls matching the
 * path are forwarded to the backend.
 *
 * @schema AccessClaimSpecIngressTemplateRulesHttpPaths
 */
export interface AccessClaimSpecIngressTemplateRulesHttpPaths {
  /**
   * backend defines the referenced service endpoint to which the traffic
   * will be forwarded to.
   *
   * @schema AccessClaimSpecIngressTemplateRulesHttpPaths#backend
   */
  readonly backend: AccessClaimSpecIngressTemplateRulesHttpPathsBackend;

  /**
   * path is matched against the path of an incoming request. Currently it can
   * contain characters disallowed from the conventional "path" part of a URL
   * as defined by RFC 3986. Paths must begin with a '/' and must be present
   * when using PathType with value "Exact" or "Prefix".
   *
   * @schema AccessClaimSpecIngressTemplateRulesHttpPaths#path
   */
  readonly path?: string;

  /**
   * pathType determines the interpretation of the path matching. PathType can
   * be one of the following values:
   * * Exact: Matches the URL path exactly.
   * * Prefix: Matches based on a URL path prefix split by '/'. Matching is
   * done on a path element by element basis. A path element refers is the
   * list of labels in the path split by the '/' separator. A request is a
   * match for path p if every p is an element-wise prefix of p of the
   * request path. Note that if the last element of the path is a substring
   * of the last element in request path, it is not a match (e.g. /foo/bar
   * matches /foo/bar/baz, but does not match /foo/barbaz).
   * * ImplementationSpecific: Interpretation of the Path matching is up to
   * the IngressClass. Implementations can treat this as a separate PathType
   * or treat it identically to Prefix or Exact path types.
   * Implementations are required to support all path types.
   *
   * @schema AccessClaimSpecIngressTemplateRulesHttpPaths#pathType
   */
  readonly pathType: string;

}

/**
 * Converts an object of type 'AccessClaimSpecIngressTemplateRulesHttpPaths' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessClaimSpecIngressTemplateRulesHttpPaths(obj: AccessClaimSpecIngressTemplateRulesHttpPaths | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backend': toJson_AccessClaimSpecIngressTemplateRulesHttpPathsBackend(obj.backend),
    'path': obj.path,
    'pathType': obj.pathType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * backend defines the referenced service endpoint to which the traffic
 * will be forwarded to.
 *
 * @schema AccessClaimSpecIngressTemplateRulesHttpPathsBackend
 */
export interface AccessClaimSpecIngressTemplateRulesHttpPathsBackend {
  /**
   * resource is an ObjectRef to another Kubernetes resource in the namespace
   * of the Ingress object. If resource is specified, a service.Name and
   * service.Port must not be specified.
   * This is a mutually exclusive setting with "Service".
   *
   * @schema AccessClaimSpecIngressTemplateRulesHttpPathsBackend#resource
   */
  readonly resource?: AccessClaimSpecIngressTemplateRulesHttpPathsBackendResource;

  /**
   * service references a service as a backend.
   * This is a mutually exclusive setting with "Resource".
   *
   * @schema AccessClaimSpecIngressTemplateRulesHttpPathsBackend#service
   */
  readonly service?: AccessClaimSpecIngressTemplateRulesHttpPathsBackendService;

}

/**
 * Converts an object of type 'AccessClaimSpecIngressTemplateRulesHttpPathsBackend' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessClaimSpecIngressTemplateRulesHttpPathsBackend(obj: AccessClaimSpecIngressTemplateRulesHttpPathsBackend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resource': toJson_AccessClaimSpecIngressTemplateRulesHttpPathsBackendResource(obj.resource),
    'service': toJson_AccessClaimSpecIngressTemplateRulesHttpPathsBackendService(obj.service),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * resource is an ObjectRef to another Kubernetes resource in the namespace
 * of the Ingress object. If resource is specified, a service.Name and
 * service.Port must not be specified.
 * This is a mutually exclusive setting with "Service".
 *
 * @schema AccessClaimSpecIngressTemplateRulesHttpPathsBackendResource
 */
export interface AccessClaimSpecIngressTemplateRulesHttpPathsBackendResource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema AccessClaimSpecIngressTemplateRulesHttpPathsBackendResource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema AccessClaimSpecIngressTemplateRulesHttpPathsBackendResource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema AccessClaimSpecIngressTemplateRulesHttpPathsBackendResource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AccessClaimSpecIngressTemplateRulesHttpPathsBackendResource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessClaimSpecIngressTemplateRulesHttpPathsBackendResource(obj: AccessClaimSpecIngressTemplateRulesHttpPathsBackendResource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * service references a service as a backend.
 * This is a mutually exclusive setting with "Resource".
 *
 * @schema AccessClaimSpecIngressTemplateRulesHttpPathsBackendService
 */
export interface AccessClaimSpecIngressTemplateRulesHttpPathsBackendService {
  /**
   * name is the referenced service. The service must exist in
   * the same namespace as the Ingress object.
   *
   * @schema AccessClaimSpecIngressTemplateRulesHttpPathsBackendService#name
   */
  readonly name: string;

  /**
   * port of the referenced service. A port name or port number
   * is required for a IngressServiceBackend.
   *
   * @schema AccessClaimSpecIngressTemplateRulesHttpPathsBackendService#port
   */
  readonly port?: AccessClaimSpecIngressTemplateRulesHttpPathsBackendServicePort;

}

/**
 * Converts an object of type 'AccessClaimSpecIngressTemplateRulesHttpPathsBackendService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessClaimSpecIngressTemplateRulesHttpPathsBackendService(obj: AccessClaimSpecIngressTemplateRulesHttpPathsBackendService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'port': toJson_AccessClaimSpecIngressTemplateRulesHttpPathsBackendServicePort(obj.port),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * port of the referenced service. A port name or port number
 * is required for a IngressServiceBackend.
 *
 * @schema AccessClaimSpecIngressTemplateRulesHttpPathsBackendServicePort
 */
export interface AccessClaimSpecIngressTemplateRulesHttpPathsBackendServicePort {
  /**
   * name is the name of the port on the Service.
   * This is a mutually exclusive setting with "Number".
   *
   * @schema AccessClaimSpecIngressTemplateRulesHttpPathsBackendServicePort#name
   */
  readonly name?: string;

  /**
   * number is the numerical port number (e.g. 80) on the Service.
   * This is a mutually exclusive setting with "Name".
   *
   * @schema AccessClaimSpecIngressTemplateRulesHttpPathsBackendServicePort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'AccessClaimSpecIngressTemplateRulesHttpPathsBackendServicePort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessClaimSpecIngressTemplateRulesHttpPathsBackendServicePort(obj: AccessClaimSpecIngressTemplateRulesHttpPathsBackendServicePort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

